
           
// http://192.168.178.193/filelist

// http://hf0400e0.local/  

 // g_u_view_switch_ist
 // displayKNXAddress g_u_view_switch_ist

//*************************************************************  
        /*
 -----------------------------------
 - !!!!!!  FEHLER checken   !!!!!! -
 -----------------------------------
        */

 /*
  //--- !! das noch chevken ob auch aktiviert wir und navh 2 mal rest dekatiert wird
  knx_program_mode = false;
  preferences.putBool("p_KNX_ets", knx_program_mode); // KNX Program Mode deaktiviert
  //----------------------
*/


/*
btu_hcif_command_complete_evt   // Bluetooth-Funktionalität   btu_hcif_send_cmd 

// sicherstellen , dass ein Zeiger nicht NULL ist, bevor man auf ihn zugreift
if (pTxCharacteristic != NULL) {
    pTxCharacteristic->setValue(btMessage.c_str());
    pTxCharacteristic->notify();
} else {
    Serial.println("pTxCharacteristic is NULL");
}
*/

// INFOS KNX anpsassen. z.B.  uint8_t multicastAddress[4] = {224, 0, 23, 12};   30808


//  if(currentyear < 2024 || currentyear > 2060){           anpassen auf echtes jahr


// vielleicht noch die option einmbauen das bei >88% speicher ein Restart gemacht wird

//*************************************************************







//pio project config

/*
sdkconfig  schreiben

POWERSHELL
cd C:\Users\Holger\Documents\PlatformIO\Projects\Alphatracer_Home_14
idf.py fullclean
. C:\Espressif\frameworks\esp-idf-v5.3-2\export.ps1
idf.py menuconfig


//---------
https://dl.espressif.com/dl/esp-idf/

Öffnen Sie die Systemsteuerung und navigieren Sie zu “System” > “Erweiterte Systemeinstellungen” > “Umgebungsvariablen”.
Fügen Sie eine neue Systemvariable namens IDF_PATH hinzu und setzen Sie den Wert auf den Pfad zu Ihrem ESP-IDF-Verzeichnis, z.B. C:\Espressif\frameworks\esp-idf-v5.3.
Bearbeiten Sie die Path-Variable und fügen Sie ;%IDF_PATH%\tools am Ende hinzu.

cd C:\Espressif\frameworks\esp-idf-v5.3
install.bat
.\export.bat

setx IDF_PATH "C:\Espressif\frameworks\esp-idf-v5.3"
setx PATH "%PATH%;%IDF_PATH%\tools"

idf_tools.py install-python-env


*/


/*
pio pkg list
pio platform list
*/


/*
SUCHE
pio pkg search "header:Insights.h"
*/


/*
GIT
Öffne dein Termina
cd C:\Users\Holger\Documents\PlatformIO\Projects\Alphatracer_Home_14
git init
git add .
git commit -m "Initial commit"
*/




/*
     cd C:/Users/Holger/Documents/PlatformIO/Projects/Alphatracer_Home_9
     ls -a
     git remote -v
     https://github.com/Trexis5/Alphatracer_Home_9

     //anlegen  und push
     git remote add origin https://github.com/Trexis5/Alphatracer_Home_9.git
     git push -u origin master

*/

/*
   git status
*/


/*
    git add src/main.cpp
    git commit -m "Beschreibung der Änderungen"
    git push
*/


/*

  .mem_block_num = 2,  angepasst ind esp.c in Adafruit Datei 


*/

/*
   WLAN kein Netzwerkname mit  dem  '  Zeichen
   WLAN auf Sicherheit stellen   WPA2-PSK

*/



/*
//WLAN jedesmal disconneten    ausloesenw()
*/





//   C:\Users\Holger\.vscode
//   C:\Users\Holger\.platformio
//   C:\Users\Holger\AppData\Local\Arduino15

//   C:\Users\Holger\.vscode
//   C:\Users\Holger\.platformio
//   C:\Users\Holger\AppData\Local\Arduino15

//   C:\Users\Holger\.platformio\packages\framework-arduinoespressif32\libraries

//******************************************
//**** FW ******
//   OTA_Handler.h   Zeile 175   für %
//   ThingsBoard.h   Zeile 1334  für FW Wait
//**** FW ******
//******************************************

//    //------ WLAN Überwachung ------------------

/*
        currentSec             // akttuell normal RTC
        currentmin             // akttuell normal RTC
        v_currenthour            // akttuell normal RTC
        update_rtc_ready       // 1= RTC OK

        v_currenthour            // ESP Stunden mit Sommer Winter
        rtc_hour               // RTC Stunden mit Sommer Winter

        epochTime_rtc          // RTC Epoch ohne Sommer Winter
        epochTime_esp          // RTC Epoch ohne Sommer Winter

*/


//  https://www.analog.com/en/resources/technical-articles/different-ways-to-use-a-max6369-series-watchdog-timer.html



/*

#include <algorithm> // für std::sort und std::abs
#include <array>     // für std::array

double berechneMittelwertNaechsteWerte(const std::array<uint32_t, 3>& werte) {
    // Kopieren Sie die Werte in ein neues Array zum Sortieren
    std::array<uint32_t, 3> sortierteWerte = werte;
    std::sort(sortierteWerte.begin(), sortierteWerte.end());

    // Berechnen Sie die Differenzen zwischen aufeinanderfolgenden Werten
    uint32_t diff1 = std::abs(static_cast<int>(sortierteWerte[1] - sortierteWerte[0]));
    uint32_t diff2 = std::abs(static_cast<int>(sortierteWerte[2] - sortierteWerte[1]));

    // Geben Sie den Durchschnitt der zwei Werte zurück, die am nächsten beieinander liegen
    if (diff1 < diff2) {
        return (sortierteWerte[0] + sortierteWerte[1]) / 2.0;
    } else {
        return (sortierteWerte[1] + sortierteWerte[2]) / 2.0;
    }
}

int main() {
    std::array<uint32_t, 3> mb_radon_live_32bit = {20, 15, 55};
    //double mittelwert = berechneMittelwertNaechsteWerte(mb_radon_live_32bit);
    // Konvertieren Sie das Ergebnis zu uint32_t
    uint32_t mittelwert_uint32 = static_cast<uint32_t>(mittelwert);
    std::cout << "Der Mittelwert der zwei am nächsten liegenden Werte ist: " << mittelwert << std::endl;
    return 0;
}

In diesem Beispiel wird die Funktion berechneMittelwertNaechsteWerte aufgerufen, 
um den Durchschnitt der zwei am nächsten liegenden Werte in mb_radon_live_32bit zu berechnen. 
Das Ergebnis wird dann auf der Konsole ausgegeben. 
Bitte beachten Sie, dass das Ergebnis als double zurückgegeben wird, da es sich um einen Durchschnitt handelt. 
Wenn Sie das Ergebnis als uint32_t speichern möchten, müssen Sie es entsprechend konvertieren.
*/






//++++++++++++++++++++++++++++++++++++++++++++++++++
//++++++++++++++++++++++++++++++++++++++++++++++++++
 // #define Firmware_backup
//++++++++++++++++++++++++++++++++++++++++++++++++++
//++++++++++++++++++++++++++++++++++++++++++++++++++






//#define myNTP

#define MB_Gateway          // aktiv ist Gateway  0= Server Client

#define httpscloud


//#define Webserver

//#define WebserverCPU1


#define RTC_Clock_DS3231     //Echtzeituhr    northernwidget


#define ea_webserver       //  uint8_t webserver_aktiviert
  // http://192.168.178.186/json  
  // http://192.168.178.186/radon
  // http://192.168.178.186/log


//#define BLEbeacon_space
#define BLEbeacon_new


#define NeoPixel

#define einzel_auswertung




#define j_2_webserver   //geht   /#include <WebServer.h>

//  [SA] Sending Client attributes...         send_client_attribute
//  [SA] Sending Shared attributes...         send_shared_attribute 


//#define RTCDebug
//#define sPACE_DEBUG
//#define WLANDebug




//--------------------------------
// Debug Level Definitionen
#define TB_DEBUG_MIN 1
#define TB_DEBUG_MED 2
#define TB_DEBUG_MAX 3
// Wähle das gewünschte Debug-Level hier
#define TB_DEBUG_LEVEL TB_DEBUG_MIN


// Debug Makros basierend auf dem gewählten Level
#if TB_DEBUG_LEVEL >= TB_DEBUG_MIN
  #define TB_DEBUG_MIN_PRINTLN(x) Serial.println(x)
  #define TB_DEBUG_MIN_PRINT(x) Serial.print(x)
  #define TB_DEBUG_MIN_PRINTF(fmt, ...) Serial.printf((fmt), ##__VA_ARGS__)
#else
  #define TB_DEBUG_MIN_PRINTLN(x)
  #define TB_DEBUG_MIN_PRINT(x)
  #define TB_DEBUG_MIN_PRINTF(fmt, ...)
#endif

#if TB_DEBUG_LEVEL >= TB_DEBUG_MED
  #define TB_DEBUG_MED_PRINTLN(x) Serial.println(x)
  #define TB_DEBUG_MED_PRINT(x) Serial.print(x)
  #define TB_DEBUG_MED_PRINTF(fmt, ...) Serial.printf((fmt), ##__VA_ARGS__)
#else
  #define TB_DEBUG_MED_PRINTLN(x)
  #define TB_DEBUG_MED_PRINT(x)
  #define TB_DEBUG_MED_PRINTF(fmt, ...)
#endif

#if TB_DEBUG_LEVEL >= TB_DEBUG_MAX
  #define TB_DEBUG_MAX_PRINTLN(x) Serial.println(x)
  #define TB_DEBUG_MAX_PRINT(x) Serial.print(x)
  #define TB_DEBUG_MAX_PRINTF(fmt, ...) Serial.printf((fmt), ##__VA_ARGS__)
#else
  #define TB_DEBUG_MAX_PRINTLN(x)
  #define TB_DEBUG_MAX_PRINT(x)
  #define TB_DEBUG_MAX_PRINTF(fmt, ...)
#endif
//--------------------------------



//--------------------------------
// Debug Level Definitionen
#define BT_DEBUG_MIN 1
#define BT_DEBUG_MED 2
#define BT_DEBUG_MAX 3

// Wähle das gewünschte Debug-Level hier
#define BT_DEBUG_LEVEL BT_DEBUG_MIN

// Debug Makros basierend auf dem gewählten Level
#if BT_DEBUG_LEVEL >= BT_DEBUG_MIN
  #define BT_DEBUG_MIN_PRINTLN(x) Serial.println(x)
  #define BT_DEBUG_MIN_PRINT(x) Serial.print(x)
  #define BT_DEBUG_MIN_PRINTF(fmt, ...) Serial.printf((fmt), ##__VA_ARGS__)
#else
  #define BT_DEBUG_MIN_PRINTLN(x)
  #define BT_DEBUG_MIN_PRINT(x)
  #define BT_DEBUG_MIN_PRINTF(fmt, ...)
#endif

#if BT_DEBUG_LEVEL >= BT_DEBUG_MED
  #define BT_DEBUG_MED_PRINTLN(x) Serial.println(x)
  #define BT_DEBUG_MED_PRINT(x) Serial.print(x)
  #define BT_DEBUG_MED_PRINTF(fmt, ...) Serial.printf((fmt), ##__VA_ARGS__)
#else
  #define BT_DEBUG_MED_PRINTLN(x)
  #define BT_DEBUG_MED_PRINT(x)
  #define BT_DEBUG_MED_PRINTF(fmt, ...)
#endif

#if BT_DEBUG_LEVEL >= BT_DEBUG_MAX
  #define BT_DEBUG_MAX_PRINTLN(x) Serial.println(x)
  #define BT_DEBUG_MAX_PRINT(x) Serial.print(x)
  #define BT_DEBUG_MAX_PRINTF(fmt, ...) Serial.printf((fmt), ##__VA_ARGS__)
#else
  #define BT_DEBUG_MAX_PRINTLN(x)
  #define BT_DEBUG_MAX_PRINT(x)
  #define BT_DEBUG_MAX_PRINTF(fmt, ...)
#endif
//--------------------------------








//--------------------------------
//#define NVS_DEBUG
#ifdef NVS_DEBUG
  #define NVS_DEBUG_PRINTLN(x) Serial.println(x)
  #define NVS_DEBUG_PRINT(x) Serial.print(x)
  #define NVS_DEBUG_PRINTF(fmt, ...) Serial.printf((fmt), ##__VA_ARGS__)
#else
  #define NVS_DEBUG_PRINTLN(x)
  #define NVS_DEBUG_PRINT(x)
  #define NVS_DEBUG_PRINTF(fmt, ...)
#endif
//--------------------------------
//--------------------------------
//#define MB_DEBUG
#ifdef MB_DEBUG
  #define MB_DEBUG_PRINTLN(x) Serial.println(x)
  #define MB_DEBUG_PRINT(x) Serial.print(x)
  #define MB_DEBUG_PRINTF(fmt, ...) Serial.printf((fmt), ##__VA_ARGS__)
#else
  #define MB_DEBUG_PRINTLN(x)
  #define MB_DEBUG_PRINT(x)
  #define MB_DEBUG_PRINTF(fmt, ...)
#endif
//--------------------------------
//--------------------------------
//#define MB_DETAIL_DEBUG
#ifdef MB_DETAIL_DEBUG
  #define MB_DETAIL_DEBUG_PRINTLN(x) Serial.println(x)
  #define MB_DETAIL_DEBUG_PRINT(x) Serial.print(x)
  #define MB_DETAIL_DEBUG_PRINTF(fmt, ...) Serial.printf((fmt), ##__VA_ARGS__)
#else
  #define MB_DETAIL_DEBUG_PRINTLN(x)
  #define MB_DETAIL_DEBUG_PRINT(x)
  #define MB_DETAIL_DEBUG_PRINTF(fmt, ...)
#endif
//--------------------------------
//--------------------------------
//#define MB_KAL_DEBUG
#ifdef MB_KAL_DEBUG
  #define MB_KAL_DEBUG_PRINTLN(x) Serial.println(x)
  #define MB_KAL_DEBUG_PRINT(x) Serial.print(x)
  #define MB_KAL_DEBUG_PRINTF(fmt, ...) Serial.printf((fmt), ##__VA_ARGS__)
#else
  #define MB_KAL_DEBUG_PRINTLN(x)
  #define MB_KAL_DEBUG_PRINT(x)
  #define MB_KAL_DEBUG_PRINTF(fmt, ...)
#endif
//--------------------------------
//--------------------------------
#define WLAN_DEBUG
#ifdef WLAN_DEBUG
  #define WLAN_DEBUG_PRINTLN(x) Serial.println(x)
  #define WLAN_DEBUG_PRINT(x) Serial.print(x)
  #define WLAN_DEBUG_PRINTF(fmt, ...) Serial.printf((fmt), ##__VA_ARGS__)
#else
  #define WLAN_DEBUG_PRINTLN(x)
  #define WLAN_DEBUG_PRINT(x)
  #define WLAN_DEBUG_PRINTF(fmt, ...)
#endif
//--------------------------------
//--------------------------------
#define IF_DEBUG
#ifdef IF_DEBUG
  #define IF_DEBUG_PRINTLN(x) Serial.println(x)
  #define IF_DEBUG_PRINT(x) Serial.print(x)
  #define IF_DEBUG_PRINTF(fmt, ...) Serial.printf((fmt), ##__VA_ARGS__)
#else
  #define IF_DEBUG_PRINTLN(x)
  #define IF_DEBUG_PRINT(x)
  #define IF_DEBUG_PRINTF(fmt, ...)
#endif
//--------------------------------


//--------------------------------
// Debug Level Definitionen
#define TM_DEBUG_MIN 1
#define TM_DEBUG_MED 2
#define TM_DEBUG_MAX 3


// Wähle das gewünschte Debug-Level hier
#define TM_DEBUG_LEVEL TM_DEBUG_MIN
// Debug Makros basierend auf dem gewählten Level
#if TM_DEBUG_LEVEL >= TM_DEBUG_MIN
  #define TM_DEBUG_MIN_PRINTLN(x) Serial.println(x)
  #define TM_DEBUG_MIN_PRINT(x) Serial.print(x)
  #define TM_DEBUG_MIN_PRINTF(fmt, ...) Serial.printf((fmt), ##__VA_ARGS__)
#else
  #define TM_DEBUG_MIN_PRINTLN(x)
  #define TM_DEBUG_MIN_PRINT(x)
  #define TM_DEBUG_MIN_PRINTF(fmt, ...)
#endif

#if TM_DEBUG_LEVEL >= TM_DEBUG_MED
  #define TM_DEBUG_MED_PRINTLN(x) Serial.println(x)
  #define TM_DEBUG_MED_PRINT(x) Serial.print(x)
  #define TM_DEBUG_MED_PRINTF(fmt, ...) Serial.printf((fmt), ##__VA_ARGS__)
#else
  #define TM_DEBUG_MED_PRINTLN(x)
  #define TM_DEBUG_MED_PRINT(x)
  #define TM_DEBUG_MED_PRINTF(fmt, ...)
#endif

#if TM_DEBUG_LEVEL >= TM_DEBUG_MAX
  #define TM_DEBUG_MAX_PRINTLN(x) Serial.println(x)
  #define TM_DEBUG_MAX_PRINT(x) Serial.print(x)
  #define TM_DEBUG_MAX_PRINTF(fmt, ...) Serial.printf((fmt), ##__VA_ARGS__)
#else
  #define TM_DEBUG_MAX_PRINTLN(x)
  #define TM_DEBUG_MAX_PRINT(x)
  #define TM_DEBUG_MAX_PRINTF(fmt, ...)
#endif
//--------------------------------


//--------------------------------
// Debug Level Definitionen
#define KNX_DEBUG_MIN 1
#define KNX_DEBUG_MED 2
#define KNX_DEBUG_MAX 3

// Wähle das gewünschte Debug-Level hier
#define KNX_DEBUG_LEVEL KNX_DEBUG_MIN

// Debug Makros basierend auf dem gewählten Level
#if KNX_DEBUG_LEVEL >= KNX_DEBUG_MIN
  #define KNX_DEBUG_MIN_PRINTLN(x) Serial.println(x)
  #define KNX_DEBUG_MIN_PRINT(x) Serial.print(x)
  #define KNX_DEBUG_MIN_PRINTF(fmt, ...) Serial.printf((fmt), ##__VA_ARGS__)
#else
  #define KNX_DEBUG_MIN_PRINTLN(x)
  #define KNX_DEBUG_MIN_PRINT(x)
  #define KNX_DEBUG_MIN_PRINTF(fmt, ...)
#endif

#if KNX_DEBUG_LEVEL >= KNX_DEBUG_MED
  #define KNX_DEBUG_MED_PRINTLN(x) Serial.println(x)
  #define KNX_DEBUG_MED_PRINT(x) Serial.print(x)
  #define KNX_DEBUG_MED_PRINTF(fmt, ...) Serial.printf((fmt), ##__VA_ARGS__)
#else
  #define KNX_DEBUG_MED_PRINTLN(x)
  #define KNX_DEBUG_MED_PRINT(x)
  #define KNX_DEBUG_MED_PRINTF(fmt, ...)
#endif

#if KNX_DEBUG_LEVEL >= KNX_DEBUG_MAX
  #define KNX_DEBUG_MAX_PRINTLN(x) Serial.println(x)
  #define KNX_DEBUG_MAX_PRINT(x) Serial.print(x)
  #define KNX_DEBUG_MAX_PRINTF(fmt, ...) Serial.printf((fmt), ##__VA_ARGS__)
#else
  #define KNX_DEBUG_MAX_PRINTLN(x)
  #define KNX_DEBUG_MAX_PRINT(x)
  #define KNX_DEBUG_MAX_PRINTF(fmt, ...)
#endif
//--------------------------------



//--------------------------------
//#define MQTT_DEBUG
#ifdef MQTT_DEBUG
  #define MQTT_DEBUG_PRINTLN(x) Serial.println(x)
  #define MQTT_DEBUG_PRINT(x) Serial.print(x)
  #define MQTT_DEBUG_PRINTF(fmt, ...) Serial.printf((fmt), ##__VA_ARGS__)
#else
  #define MQTT_DEBUG_PRINTLN(x)
  #define MQTT_DEBUG_PRINT(x)
  #define MQTT_DEBUG_PRINTF(fmt, ...)
#endif
//--------------------------------





//#define LEDDebug
//#define NVS_MQTT_DEBUG
//#define NVS_14_DEBUG
//#define NVS_15_DEBUG
//#define IF_14_15_DEBUG
//#define IF_17_18_DEBUG
//#define NVS_17_DEBUG
//#define NVS_18_DEBUG

//#define MQTT_DEBUG_last
//#define MQTT_DEBUG
//#define NVS_DEBUG
//#define NVS_space_DEBUG

//#define TBDebug

    //   #define RADONCLOUD_DEBUG
   //    #define RADONCLOUD_DEBUG_min


 //#define aktivate_psram_flash

 //#define use_psram_flash
  //#define USE_PSRAM // Kommentiere diese Zeile aus, um normalen RAM zu verwenden

 //  char* allocateHtmlInPSRAM(
  #ifdef USE_PSRAM
  #define MALLOC_CAP MALLOC_CAP_SPIRAM       
  #else
  #define MALLOC_CAP MALLOC_CAP_8BIT
  #endif



#include <Arduino.h>
#include <SPI.h>
#include <Wire.h>
#include <BLEDevice.h>
#include <esp_bt.h>
#include <BLEServer.h>
#include <BLEUtils.h>
#include <BLE2902.h>

bool incomming_connect;

//#include <ArduinoOTA.h>

#include <esp_system.h>
#include <driver/rmt.h>
#include "esp_log.h"
#include "driver/temp_sensor.h"
#include "esp_adc_cal.h"

rmt_config_t config;

#include <regex>

#include "soc/usb_reg.h"
#include "soc/usb_struct.h"
#include "driver/gpio.h"
//#include "esp32/rom/usb/usb.h"

#include <ESP32Ping.h> // Für ESP32 verwenden

#include "BLEBeacon.h"

//#include "Insights.h"

//#include "HomeSpan.h"         // HomeSpan sketches always begin by including the HomeSpan library

#ifdef Ruuvi
  //#include "ArduinoBLE.h"
#endif

#include <iostream>

#include "WiFi.h"
#include "esp_wifi.h"
#include "esp_heap_caps.h"

#ifdef myNTP
const char* ntpServerIP = "192.168.178.94";
#endif

//#include "AsyncTCP.h"
//#include "ESPAsyncWebServer.h"

//#include <Thread.h>
//#include <ThreadController.h>
#ifdef MB_Gateway
#include <ModbusBridgeWiFi.h>
#endif

#include <DNSServer.h>
#include <Preferences.h>
#include <FS.h>           // Include the SPIFFS library
#include <SPIFFS.h>


//#include "time.h"
//#include <sys/time.h>
//  ctime    asctime   diese habe ich aauskokmetiert

#include "timeh.h"

#include <stdio.h>
#include "TCPstub.h"
#include "NTPClient.h"
//#include <NTPClient.h>

//#include <TimeLib.h>



// Modbus server TCP
#ifndef MB_Gateway
#include "ModbusServerTCPasync.h"
#endif

#include <ModbusClientRTU.h>

#include <WiFiClientSecure.h>

#include "Logging.h"
#include <ESPmDNS.h>
#include <ArduinoOTA.h>

#ifdef NeoPixel
#include <Adafruit_NeoPixel.h>
#endif

#include "TCPstub.h"


//#include <Wire.h> // must be included here so that Arduino library object file references work


//#ifdef j_2_webserver
#include <WebServer.h>
#include <WebSocketsServer.h>
//#endif


unsigned long task_previousMillis100ms = 0;
unsigned long task_previousMillis1s = 0;
unsigned long task_previousMillis2s = 0;
unsigned long task_previousMillis30s = 0;
unsigned long task_previousMillis1m = 0;
unsigned long task_previousMillis100s = 0;
unsigned long task_previousMillis60m = 0;
unsigned long task_previousMillis90m = 0;
unsigned long task_previousMillis120m = 0;

const long task_interval100ms = 100;
const long task_interval1s = 1000;
const long task_interval2s = 2000;
const long task_interval30s = 30000;
const long task_interval1m = 60000;
const long task_interval100s = 100000;
const long task_interval60m = 600000;
const long task_interval90m = 900000;
const long task_interval120m = 1200000;

   
unsigned long t_previousMillis = 0;  // Vorherige Zeit, bei der die Nachricht gesendet wurde
const long t_interval = 1000;  // Intervallzeit in Millisekunden (1000 ms = 1 Sekunde)

int failCounter = 0;

#ifdef RTC_Clock_DS3231
#include "AsyncDelay.h"
#include "SoftWire.h"
#include "DS3231.h"
//TwoWire I2CRTC = TwoWire(0);
DS3231 myRTC;
bool ntp_update_start;
bool ntp_min_akualisieren;
unsigned long lastDebugPrintMillis = 0; // Für den 10-Sekunden-Takt

bool alreadyAdjusted = false; // Variable, um sicherzustellen, dass die Umstellung nur einmal erfolgt
bool alreadyAdjustedcheck = false;
bool alreadycheckNTP = false;
unsigned int cachedGSetMesz;
bool cachedAlreadyAdjusted;
bool initializedntp = false;
bool not_write_time;



uint8_t sdaPin = 16; // 
uint8_t sclPin = 15; // 

//SoftWire myWire(sdaPin, sclPin); // Definiere die SDA und SCL Pins für Software I2C
//DS3231 myRTC(myWire);

#else
  //#include <ESPDateTime.h>
#endif

bool loggingEnabled = false;


// Initialisiere das Passwort
char correctPassword[14] = "deinPasswort";
char prev_correctPassword[14] = "            ";


bool programmierModus = false;
// Globale Variablen für die Versuche und die Sperrzeit PW
int attempts = 0;
unsigned long lockoutTime = 0;
// Globale Variablen für die Versuche und die Sperrzeit SPIFFS
int spiffsAttempts = 0;
unsigned long spiffsLockoutTime = 0;

#ifndef Firmware_backup
constexpr char CURRENT_FIRMWARE_VERSION[] PROGMEM = "1.0.3";          // D_FIRMWARE_DATE_KEY
#else
constexpr char CURRENT_FIRMWARE_VERSION[] PROGMEM = "0.0.1";         
#endif
constexpr char FIRMWARE_DATE_TIME[] PROGMEM = "2024-12-18 23:10:00";


bool factoryResetBit = false; 
bool agFW_write = false;

 char U_sw_checksum_read[65]; // 64 Zeichen + 1 für die Nullterminierung
//strcpy(U_sw_checksum_read, "b129edd555fecd6919f919c99f1fd89670deb3af874213f23040768d354bd0d4");

// https://emn178.github.io/online-tools/sha256_checksum.html
 constexpr char spiffs_text[] PROGMEM = "favicon-16x16.png";




// b129edd555fecd6919f919c99f1fd89670deb3af874213f23040768d354bd0d4


#ifndef Firmware_backup
#include "filesystem_daten.h"
#endif

int imageStatus = 0; // 0: rot, 1: gruen, 2: orange  3:weiss  4:grau  5:blau

char prev_firmware_date_time[20] = "";   // Definiere vorheriges Firmware-Datum als reguläres char-Array
bool knx_program_mode = false;
int positiondc = 0;
int directiondc = 1;
int currentPinState_knx_web;
bool g_toggle_knx_prog;
unsigned long startTime_knx = 0;
int currentPinStateknx;

bool isUserOnModbusPage = false;
bool isUserOnKNXPage = false;
bool isUserOnSensorPage = false;
bool lastUserOnSensorPage = true; // Initialisiere den letzten Status
bool isBleOnSensorPage = false;

bool user_on_webside = false;

// Beispielhafte Statusvariablen
bool wifiSStatus = true;
bool ntpStatus = true;
bool unitDEStatus = true;
bool unitENStatus = false;
bool amStatus = true;
bool pmStatus = false;
bool dpStatus = false;
bool lastLEDStatus = false; // Initialisiere letzten LED-Status, z.B. 'true' für an
int lastImageStatus = -1;  // Initialisiere letzten Bildstatus

    unsigned long u_lastPrintTime = 0;
    unsigned long u_printInterval = 5000; // 5 Sekunden


uint32_t mb_radon_live_32bit = 0;
uint32_t save_rad_val;
uint8_t g_getrow0,g_getrow1,g_getrow2,g_getrow3;

uint32_t mb_radon_live_32bitK = 0;
uint32_t mb_radon_live_32bit_m[11];
uint32_t mb_radon_24h_32bit = 0;
uint32_t mb_radon_long_32bit = 0;
uint16_t mb_radon_F3_eintrarge = 0, mb_radon_save_eintrarge = 0;
uint16_t mb_radon_F3_eintr_time = 0;
uint8_t mb_read_byte = 99;
uint32_t mb_radon_live_32bit_arr[7];
uint32_t mb_radon_live_32bit_arr_sum = 0;
uint8_t rad_count;
uint8_t rand_radon_0;


char mb_Seriennummer[23] = "10000000"; // Definiere die Seriennummer als char Array


uint8_t g_Server_ID_mismatch = 0;


uint32_t radon_mittelwert_24h;
uint32_t radon_mittelwert_24_2h;
uint32_t mittelwert_jahr;
uint32_t radon_mittelwert_monat[12];
uint32_t rad_zaehler_24;
uint64_t radon_summe_long;
uint32_t radon_zaehler_long;
uint32_t radon_mittelwert_long ;
uint32_t radon_jahr;

uint32_t freeRAM_s;

uint16_t testcounter = 0;
bool set_g40 = false;
bool set_g41 = false;
bool set_g42 = false;
bool set_g43 = false;

uint8_t set_g40_var = 1; 


char p_uhrzeit[12] = "00:00:00"; // 8 Zeichen + Nullterminator


uint8_t disable_server = 1; //1 = AN
uint8_t disable_bootloop;
uint8_t not_aus_ble;


const char* dateiGr16  = "/things16.txt"; 
// log
String things_list_t_16  = "                                                                                                                                 ";
uint16_t charcount16,charcount16_r,charcount16_w,charcount16_l;
uint16_t charcountweb,charcountweb_r,charcountweb_w,charcountweb_l;


float previousUsedRAM = 0;



float getUsedRAMMB() {
    return (ESP.getHeapSize() - ESP.getFreeHeap()) / (1024.0 * 1024.0);
}




unsigned long f_previousMillis = 0;
const long f_interval = 500; // 500 Millisekunden


//-------------------------------------------------------
#include <knx.h>
#if MASK_VERSION != 0x07B0 && (defined ARDUINO_ARCH_ESP8266 || defined ARDUINO_ARCH_ESP32)
#endif
#define debug_data_o_i
extern uint8_t storedData[512];
#define goRadonlive knx.getGroupObject(1)
#define goRadon24h knx.getGroupObject(2)
#define goRadonlong knx.getGroupObject(3)
#define goRadoneintr knx.getGroupObject(4)
float currentValue = 0;
float maxValue = 0;
float minValue = RAND_MAX;
long lastsend = 0;
uint8_t currentMinute = 1; //  Minute
uint8_t lastMinuteAction = 255;
uint8_t last10MinuteAction = 255;
uint8_t last60MinuteAction = 255;
   

    uint8_t ipAddressKNX[4] = {192, 168, 178, 186};
    uint8_t subnetMaskKNX[4] = {255, 255, 255, 0};
    uint8_t gatewayKNX[4] = {192, 168, 178, 1};
    uint8_t multicastAddress[4] = {224, 0, 23, 12};
   
    uint8_t area = 1; // Bereichsnummer
    uint8_t line = 3; // Liniennummer
    uint8_t device = 7; // Teilnehmernummer
    uint8_t address1[3] = {12, 0, 0};
    uint8_t address2[3] = {12, 0, 1};
    uint8_t address3[3] = {12, 0, 2};
    uint8_t address4[3] = {12, 0, 3};


    // Array von Gruppenadressen
    // Definition der Gruppenadressen
    uint8_t groupAddresses[4][3] = {
        {address1[0], address1[1], address1[2]},
        {address2[0], address2[1], address2[2]},
        {address3[0], address3[1], address3[2]},
        {address4[0], address4[1], address4[2]}
    };

        // Anzahl der Gruppenadressen
    uint8_t numAddresses = 4;
             /*
             uint8_t arraydata1[] = {0x00, 0x01, 0x00, 0xFA, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x13, 0x07, 0x00, 0x01, 0x04, 0x00, 0x01, 0x60, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01};
             uint8_t arraydata2[] = {0x00, 0x00, 0x00, 0x01, 0x01, 0x00, 0x00, 0x00, 0x01, 0xC0, 0xA8, 0xB2, 0xBA, 0x00, 0x01, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x01, 0xC0, 0xA8, 0xB2, 0x01, 0x00, 0x01, 0xE0, 0x00, 0x17};
             uint8_t arraydata3[] = {0x0C, 0x00, 0x01, 0x10, 0x00, 0x1E, 0x52, 0x61, 0x64, 0x6F, 0x6E, 0x73, 0x65, 0x6E, 0x73, 0x6F, 0x72, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
             uint8_t arraydata4[] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFA, 0xAF, 0x00, 0x05, 0x01, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x98, 0x00, 0x08, 0x01, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x00};
             uint8_t arraydata5[] = {0xA0, 0x00, 0x0C, 0x01, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x00, 0xAC, 0x00, 0x0C, 0x01, 0x00, 0x00, 0x00, 0x12, 0x00, 0x00, 0x00, 0xB8, 0x00, 0x14, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF};
             uint8_t arraydata6[] = {0xFF, 0xFF, 0x03, 0x01, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x04, 0x4F, 0x0A, 0x4F, 0x0A, 0x4F, 0x0A, 0x4F, 0x08, 0xFF, 0xFF, 0x00, 0x04, 0x40, 0x00, 0x40, 0x01, 0x40, 0x02};
             uint8_t arraydata7[] = {0x40, 0x03, 0xFF, 0xFF, 0x00, 0x04, 0x00, 0x01, 0x00, 0x01, 0x00, 0x02, 0x00, 0x02, 0x00, 0x03, 0x00, 0x03, 0x00, 0x04, 0x00, 0x04, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF};
            */
// Arrays im PSRAM speichern
 uint8_t arraydata1[] = {0x00, 0x01, 0x00, 0xFA, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x13, 0x07, 0x00, 0x01, 0x04, 0x00, 0x01, 0x60, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01};
 uint8_t arraydata2[] = {0x00, 0x00, 0x00, 0x01, 0x01, 0x00, 0x00, 0x00, 0x01, 0xC0, 0xA8, 0xB2, 0xBA, 0x00, 0x01, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x01, 0xC0, 0xA8, 0xB2, 0x01, 0x00, 0x01, 0xE0, 0x00, 0x17};
 uint8_t arraydata3[] = {0x0C, 0x00, 0x01, 0x10, 0x00, 0x1E, 0x52, 0x61, 0x64, 0x6F, 0x6E, 0x73, 0x65, 0x6E, 0x73, 0x6F, 0x72, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
 uint8_t arraydata4[] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFA, 0xAF, 0x00, 0x05, 0x01, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x98, 0x00, 0x08, 0x01, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x00};
 uint8_t arraydata5[] = {0xA0, 0x00, 0x0C, 0x01, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x00, 0xAC, 0x00, 0x0C, 0x01, 0x00, 0x00, 0x00, 0x12, 0x00, 0x00, 0x00, 0xB8, 0x00, 0x14, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF};
 uint8_t arraydata6[] = {0xFF, 0xFF, 0x03, 0x01, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x04, 0x4F, 0x0A, 0x4F, 0x0A, 0x4F, 0x0A, 0x4F, 0x08, 0xFF, 0xFF, 0x00, 0x04, 0x40, 0x00, 0x40, 0x01, 0x40, 0x02};
 uint8_t arraydata7[] = {0x40, 0x03, 0xFF, 0xFF, 0x00, 0x04, 0x00, 0x01, 0x00, 0x01, 0x00, 0x02, 0x00, 0x02, 0x00, 0x03, 0x00, 0x03, 0x00, 0x04, 0x00, 0x04, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF};



    size_t startOffset = 0; // Veränderbare Variable
    size_t arrayLength = 0;

    int previousPinState = LOW; // Vorheriger Zustand des Pins
    uint8_t v_Colortknx = 0;
    unsigned long lastChangeTime = 0; // Variable, um die Zeit der letzten Zustandsänderung zu speichern





//-----------------------------------------------------------------

void saveDataDirectly() {

    uint32_t flashPos = 0; // Startadresse für saveRestores1

    knx.editMemoryarray(flashPos, arraydata1, sizeof(arraydata1));
    flashPos += sizeof(arraydata1);


    knx.editMemoryarray(flashPos, arraydata2, sizeof(arraydata2));
    flashPos += sizeof(arraydata2);


    knx.editMemoryarray(flashPos, arraydata3, sizeof(arraydata3));
    flashPos += sizeof(arraydata3);

    knx.editMemoryarray(flashPos, arraydata4, sizeof(arraydata4));
    flashPos += sizeof(arraydata4);


    knx.editMemoryarray(flashPos, arraydata5, sizeof(arraydata5));
    flashPos += sizeof(arraydata5);


    knx.editMemoryarray(flashPos, arraydata6, sizeof(arraydata6));
    flashPos += sizeof(arraydata6);

    knx.editMemoryarray(flashPos, arraydata7, sizeof(arraydata7));
    flashPos += sizeof(arraydata7);

}

//-----------------------------------------------------------------


//-----------------------------------------------------------------
void saveGroupAddresses(uint8_t addresses[][3], uint8_t numAddresses) {
    uint32_t flashPos = 172; // Startadresse für die Gruppenadressen
    uint8_t data[2 + numAddresses * 2]; // 1 Startbyte + 1 Anzahl der Paare + 2 Bytes pro Gruppenadresse

    data[0] = 0; // Start- oder Kontrollbyte
    data[1] = numAddresses; // Anzahl der folgenden Datenpaare

    // Debug-Ausgabe vor der Speicherung
    Serial.println(F("[KX] Speichere Gruppenadressen:"));
    Serial.print(F("[KX] Startbyte: "));
    Serial.println(data[0]);
    Serial.print(F("[KX] Anzahl der Paare: "));
    Serial.println(data[1]);


    for (uint8_t i = 0; i < numAddresses; i++) {
        uint8_t mainGroup = addresses[i][0];
        uint8_t middleGroup = addresses[i][1];
        uint8_t subGroup = addresses[i][2];

        // Kodierung der Gruppenadresse in zwei Bytes
        uint8_t highByte = (mainGroup << 3) | (middleGroup >> 3);
        uint8_t lowByte = ((middleGroup & 0x07) << 5) | subGroup;

        data[2 + i * 2] = highByte;
        data[2 + i * 2 + 1] = lowByte;

        // Debug-Ausgabe der kodierten Gruppenadresse
        Serial.print(F("[KX] Gruppenadresse "));
        Serial.print(mainGroup);
        Serial.print(F("/"));
        Serial.print(middleGroup);
        Serial.print(F("/"));
        Serial.print(subGroup);
        Serial.print(F(" kodiert als: "));
        Serial.print(highByte, HEX);
        Serial.print(F(" "));
        Serial.println(lowByte, HEX);

    }

    knx.editMemoryarray(flashPos, data, sizeof(data));

    // Debug-Ausgabe nach der Speicherung
    Serial.println(F("[KX] Gruppenadressen erfolgreich gespeichert."));
}
//-----------------------------------------------------------------


//-----------------------------------------------------------------
void readGroupAddressesFromStoredData() {
   uint32_t flashPos = 172; // Startadresse für die Gruppenadressen
    uint8_t numAddressest;
    uint8_t data[2 + 10 * 2]; // Annahme: maximal 10 Gruppenadressen

    // Daten aus storedData lesen
    for (int i = 0; i < sizeof(data); i++) {
        data[i] = storedData[flashPos + i];
    }

    // Start- oder Kontrollbyte überprüfen
    if (data[0] != 0) {
        Serial.println(F("[KX] Ungültiges Startbyte."));
        return;
    }

    numAddressest = data[1]; // Anzahl der gespeicherten Adressen

    // Debug-Ausgabe vor dem Lesen
     KNX_DEBUG_MED_PRINTLN(F("[KX] Lese Gruppenadressen:"));
     KNX_DEBUG_MED_PRINT(F("[KX] Anzahl der Paare: "));
     KNX_DEBUG_MED_PRINTLN(numAddressest);



    for (uint8_t i = 0; i < numAddressest; i++) {
        uint8_t highByte = data[2 + i * 2];
        uint8_t lowByte = data[2 + i * 2 + 1];

        // Dekodierung der Gruppenadresse
        uint8_t mainGroup = highByte >> 3;
        uint8_t middleGroup = ((highByte & 0x07) << 3) | (lowByte >> 5);
        uint8_t subGroup = lowByte & 0x1F;

        // Debug-Ausgabe der dekodierten Gruppenadresse
        #if KNX_DEBUG_LEVEL >= KNX_DEBUG_MIN
        Serial.print(F("[KX] Gruppenadresse "));
        Serial.print(mainGroup);
        Serial.print(F("/"));
        Serial.print(middleGroup);
        Serial.print(F("/"));
        Serial.println(subGroup);
        #endif
    }

    // Debug-Ausgabe nach dem Lesen
    KNX_DEBUG_MED_PRINTLN(F("Gruppenadressen erfolgreich gelesen"));

}
//-----------------------------------------------------------------


//-----------------------------------------------------------------
void saveKNXAddress(uint8_t areat, uint8_t linet, uint8_t devicet) {
    uint8_t areaLine = (areat << 4) | linet; // Kombiniere Bereichsnummer und Liniennummer
    uint32_t flashPos = 12; // Startadresse für die KNX-Adresse
    knx.editMemoryarray(flashPos, &areaLine, 1);
    knx.editMemoryarray(flashPos + 1, &devicet, 1);
    Serial.print(F("areaLine "));
    Serial.println(areaLine);
    Serial.print(F("device "));
    Serial.println(devicet);

}
//-----------------------------------------------------------------

//-----------------------------------------------------------------
void readKNXAddressFromStoredData() {
    uint32_t flashPos = 12; // Startadresse für die KNX-Adresse
    uint8_t areaLine;
    uint8_t device;

    // Daten aus storedData lesen
    areaLine = storedData[flashPos];
    device = storedData[flashPos + 1];

    // Bereichsnummer und Liniennummer extrahieren
    uint8_t areat = areaLine >> 4;
    uint8_t linet = areaLine & 0x0F;

    // Debug-Ausgabe der gelesenen KNX-Adresse
    Serial.println(F("[KX] Gelesene KNX-Adresse:"));
    Serial.print(F("[KX] Bereich: "));
    Serial.println(areat);
    Serial.print(F("[KX] Linie: "));
    Serial.println(linet);
    Serial.print(F("[KX] Gerät: "));
    Serial.println(device);

}
//-----------------------------------------------------------------



//-----------------------------------------------------------------
// Funktion zum Speichern der IP-Adresse
void saveIPAddress(uint8_t ip[4]) {
    uint32_t flashPos = 39; // Startadresse für die IP-Adresse
    uint8_t data[6]; // 4 Bytes IP-Adresse + 2 Bytes (0 und 1)
    memcpy(data, ip, 4);
    data[4] = 0;
    data[5] = 1;

    // Debug-Ausgabe vor der Speicherung
    Serial.print(F("[KX] Speichere IP-Adresse: "));
    for (int i = 0; i < 4; i++) {
        Serial.print(ip[i]);
        if (i < 3) Serial.print(F("."));
    }
    Serial.println(F(" 0 1"));

    knx.editMemoryarray(flashPos, data, 6);

    // Debug-Ausgabe nach der Speicherung
    Serial.println(F("[KX] IP-Adresse erfolgreich gespeichert."));
}

//-----------------------------------------------------------------

//-----------------------------------------------------------------
void readIPAddressFromStoredData() {
    uint32_t flashPos = 39; // Startadresse für die IP-Adresse
    uint8_t ip[4];
    uint8_t data[6];

    // Daten aus storedData lesen
    for (int i = 0; i < sizeof(data); i++) {
        data[i] = storedData[flashPos + i];
    }

    // IP-Adresse extrahieren
    memcpy(ip, data, 4);

    // Debug-Ausgabe der gelesenen IP-Adresse
    Serial.print(F("[KX] Gelesene IP-Adresse:"));
    for (int i = 0; i < 4; i++) {
        Serial.print(ip[i]);
        if (i < 3) Serial.print(F("."));
    }
    Serial.println(F(""));

    #if KNX_DEBUG_LEVEL >= KNX_DEBUG_MED
    // Überprüfen der Kontrollbytes
    if (data[4] == 0 && data[5] == 1) {
        Serial.println(F("[KX] IP-Adresse erfolgreich gelesen."));
    } else {
        Serial.println(F("[KX] Fehler beim Lesen der IP-Adresse."));
    }
    #endif

}
//-----------------------------------------------------------------


//-----------------------------------------------------------------
// Funktion zum Speichern der Subnetzmaske
void saveSubnetMask(uint8_t subnet[4]) {
    uint32_t flashPos = 45; // Startadresse für die Subnetzmaske
    uint8_t data[6]; // 4 Bytes Subnetzmaske + 2 Bytes (0 und 1)
    memcpy(data, subnet, 4);
    data[4] = 0;
    data[5] = 1;

    // Debug-Ausgabe vor der Speicherung
    Serial.print(F("[KX] Speichere Subnetzmaske: "));
    for (int i = 0; i < 4; i++) {
        Serial.print(subnet[i]);
        if (i < 3) Serial.print(F("."));
    }
    Serial.println(F(" 0 1"));

    knx.editMemoryarray(flashPos, data, 6);

    // Debug-Ausgabe nach der Speicherung
    Serial.println(F("[KX] Subnetzmaske erfolgreich gespeichert."));

}
//-----------------------------------------------------------------

//-----------------------------------------------------------------
void readSubnetMaskFromStoredData() {
    uint32_t flashPos = 45; // Startadresse für die Subnetzmaske
    uint8_t subnet[4];
    uint8_t data[6];

    // Daten aus storedData lesen
    for (int i = 0; i < sizeof(data); i++) {
        data[i] = storedData[flashPos + i];
    }

    // Subnetzmaske extrahieren
    memcpy(subnet, data, 4);

    // Debug-Ausgabe der gelesenen Subnetzmaske
    Serial.print(F("[KX] Gelesene Subnetzmaske: "));
    for (int i = 0; i < 4; i++) {
        Serial.print(subnet[i]);
        if (i < 3) Serial.print(F("."));
    }
    Serial.println();

    #if KNX_DEBUG_LEVEL >= KNX_DEBUG_MED
    // Überprüfen der Kontrollbytes
    if (data[4] == 0 && data[5] == 1) {
        Serial.println(F("[KX] Subnetzmaske erfolgreich gelesen."));
    } else {
        Serial.println(F("[KX] Fehler beim Lesen der Subnetzmaske."));
    }
    #endif

}
//-----------------------------------------------------------------

//-----------------------------------------------------------------
// Funktion zum Speichern des Gateways
void saveGateway(uint8_t gateway[4]) {
    uint32_t flashPos = 51; // Startadresse für das Gateway
    uint8_t data[6]; // 4 Bytes Gateway + 2 Bytes (0 und 1)
    memcpy(data, gateway, 4);
    data[4] = 0;
    data[5] = 1;

    // Debug-Ausgabe vor der Speicherung
    Serial.println(F("Speichere Gateway:"));
    for (int i = 0; i < 4; i++) {
        Serial.print(gateway[i]);
        if (i < 3) Serial.print(F("."));
    }
    Serial.println(F(" 0 1"));

    knx.editMemoryarray(flashPos, data, 6);

    // Debug-Ausgabe nach der Speicherung
    Serial.println(F("Gateway erfolgreich gespeichert."));

}
//-----------------------------------------------------------------


//-----------------------------------------------------------------
void saveParamByte0(uint8_t value) {
    uint32_t flashPos = 152; // Adresse für paramByte(0)
    uint8_t data[1];
    data[0] = value;

    // Debug-Ausgabe vor der Speicherung
    Serial.print(F("Speichere paramByte(0): "));
    Serial.println(value);

    knx.editMemoryarray(flashPos, data, 1);

    // Debug-Ausgabe nach der Speicherung
    Serial.println(F("paramByte(0) erfolgreich gespeichert."));

}
//-----------------------------------------------------------------


//-----------------------------------------------------------------
void saveParamByte1(uint8_t value) {
    uint32_t flashPos = 153; // Adresse für paramByte(1)
    uint8_t data[1];
    data[0] = value;

    // Debug-Ausgabe vor der Speicherung
    Serial.print(F("Speichere paramByte(1): "));
    Serial.println(value);

    knx.editMemoryarray(flashPos, data, 1);

    // Debug-Ausgabe nach der Speicherung
    Serial.println(F("paramByte(1) erfolgreich gespeichert."));
}
//-----------------------------------------------------------------

//-----------------------------------------------------------------
void readGatewayFromStoredData() {
    uint32_t flashPos = 51; // Startadresse für das Gateway
    uint8_t gateway[4];
    uint8_t data[6];

    // Daten aus storedData lesen
    for (int i = 0; i < sizeof(data); i++) {
        data[i] = storedData[flashPos + i];
    }

    // Gateway-Adresse extrahieren
    memcpy(gateway, data, 4);

    // Debug-Ausgabe der gelesenen Gateway-Adresse
    Serial.println(F("Gelesene Gateway-Adresse:"));
    for (int i = 0; i < 4; i++) {
        Serial.print(gateway[i]);
        if (i < 3) Serial.print(F("."));
    }
    Serial.println();

    #if KNX_DEBUG_LEVEL >= KNX_DEBUG_MED
    // Überprüfen der Kontrollbytes
    if (data[4] == 0 && data[5] == 1) {
        Serial.println(F("Gateway-Adresse erfolgreich gelesen."));
    } else {
        Serial.println(F("Fehler beim Lesen der Gateway-Adresse."));
    }
    #endif
}
//-----------------------------------------------------------------

//-----------------------------------------------------------------
// Funktion zum Speichern der Multicast-Adresse
void saveMulticastAddress(uint8_t multicast[4]) {
    uint32_t flashPos = 57; // Startadresse für die Multicast-Adresse
    uint8_t data[6]; // 4 Bytes Multicast-Adresse + 2 Bytes (0 und 1)
    memcpy(data, multicast, 4);
    data[4] = 0;
    data[5] = 1;

    // Debug-Ausgabe vor der Speicherung
    Serial.println(F("Speichere Multicast-Adresse:"));
    for (int i = 0; i < 4; i++) {
        Serial.print(multicast[i]);
        if (i < 3) Serial.print(F("."));
    }
    Serial.println(F(" 0 1"));

    knx.editMemoryarray(flashPos, data, 6);

    // Debug-Ausgabe nach der Speicherung
    Serial.println(F("Multicast-Adresse erfolgreich gespeichert."));
}
//-----------------------------------------------------------------
//-----------------------------------------------------------------
void readMulticastAddressFromStoredData() {
    uint32_t flashPos = 57; // Startadresse für die Multicast-Adresse
    uint8_t multicast[4];
    uint8_t data[6];

    // Daten aus storedData lesen
    for (int i = 0; i < sizeof(data); i++) {
        data[i] = storedData[flashPos + i];
    }

    // Multicast-Adresse extrahieren
    memcpy(multicast, data, 4);

    // Debug-Ausgabe der gelesenen Multicast-Adresse
    Serial.println(F("Gelesene Multicast-Adresse:"));
    for (int i = 0; i < 4; i++) {
        Serial.print(multicast[i]);
        if (i < 3) Serial.print(F("."));
    }
    Serial.println(F(""));

    #if KNX_DEBUG_LEVEL >= KNX_DEBUG_MED
    // Überprüfen der Kontrollbytes
    if (data[4] == 0 && data[5] == 1) {
        Serial.println(F("Multicast-Adresse erfolgreich gelesen."));
    } else {
        Serial.println(F("Fehler beim Lesen der Multicast-Adresse."));
    }
    #endif
}


//---------------------------------------------------------------------------
void send_knx_data()
{

  

      KNX_DEBUG_MIN_PRINTLN(F("[KX] Send KNX Data "));

      // Debug-Ausgaben der Werte
      KNX_DEBUG_MIN_PRINT(F("     Live: "));
      KNX_DEBUG_MIN_PRINTLN(mb_radon_live_32bit);
      KNX_DEBUG_MIN_PRINT(F("     24h: "));
      KNX_DEBUG_MIN_PRINTLN(radon_mittelwert_24h);
      KNX_DEBUG_MIN_PRINT(F("     Long: "));
      KNX_DEBUG_MIN_PRINTLN(radon_mittelwert_long);
      KNX_DEBUG_MIN_PRINT(F("     Einträge: "));
      KNX_DEBUG_MIN_PRINTLN(mb_radon_save_eintrarge);
      KNX_DEBUG_MIN_PRINTLN(F("-----------------------------------------"));


      goRadonlive.value(mb_radon_live_32bit);
      goRadon24h.value(radon_mittelwert_24h);
      goRadonlong.value(radon_mittelwert_long);
      goRadoneintr.value(mb_radon_save_eintrarge);





}

// callback from reset-GO
void resetCallback(GroupObject& go)
{
    if (go.value())
    {
        maxValue = 0;
        minValue = 10000;
    }
}

//-----------------------------------------------------------------



//-------------------------------------------------------


#include <nvs.h>
#include <nvs_flash.h>





bool g_low_data;
bool countdownBeendet = false; // Countdown als beendet markieren

bool calc_diff_timestamp;

int printCounter = 0; // Zähler initialisieren
int printCounter2 = 0; // Zähler initialisieren
bool printCounter_save = true;
uint32_t rest_dl = 0; 

#ifdef RTC_Clock_DS3231

bool century = true;
bool h12Flag;
bool pmFlag;
byte alarmDay, alarmHour, alarmMinute, alarmSecond, alarmBits;
bool alarmDy, alarmH12Flag, alarmPmFlag;
bool alarmDayIsDay;
bool alarmH12;
bool alarmPM;
float rtc_temperatur;
bool rtc_oszi;
// Interrupt signaling byte
volatile byte alarm_tick = 1;

byte rtc_year;
byte rtc_month;
byte rtc_date;
byte rtc_dOW;
byte rtc_hour;
byte rtc_minute;
byte rtc_second;

bool g_h_esp_rtc;

long esp_year_t;    //4 dig
byte esp_year;
byte esp_month;
byte esp_date;
byte esp_dOW;
byte esp_hour;
byte esp_minute;
byte esp_second;

byte s_year;
byte s_month;
byte s_date;
byte s_dOW;
byte s_hour;
byte s_minute;
byte s_second;

bool W_setClockMode;

constexpr time_t tstmp {1660644000UL};

#endif

bool fw_up_to_date;

bool akt_fw_load;
bool g_now_ani_led;


byte encryption;


uint8_t positionts1,positionts2;
uint32_t t_time_ts,t_time_ts_v,t_time_ts_n,t_time_ts_t;
    
 
//------ WLAN Überwachung ------------------------------------------------------------
char statusMessagenight[200]; // Puffer für die Statusnachricht


// Zeitfenster für die Nachtschaltung (z.B. von 21:00 bis 06:00)
int nightStartHour = 22;
int nightEndHour = 5;

    // Beispiel: Ändere die Werte und überprüfe sie
    int newNightStartHour = 22;
    int newNightEndHour = 5;

// Timer-Intervall (in Sekunden)
const unsigned long checkInterval PROGMEM = 900; // 15 Minuten 
unsigned long previousSeconds = 0;
unsigned long restartDelaySeconds = 60; // 60 Sekunden Wartezeit vor Neustart 
unsigned long restartTimer = 0;

unsigned long lastScanTime = millis();
const unsigned long scanInterval PROGMEM = 600000; // Intervall für das Scannen (z.B. 600 Sekunden)

// Letzter bekannter WLAN-Status
bool lastWiFiStatus = false;

// Flag, um die WLAN-Überprüfung zu deaktivieren
bool wifiCheckEnabled = false; // Beim Starten deaktiviert
bool lastWifiCheckEnabled = false;
bool temp_set = false;

// Flag, um den Status der Nachtschaltung zu speichern
bool nightModeActive = false;

// Standard= 20  
uint8_t error_threshold = 20;

// Standard= 5    send_ueberw_counter_t_error 5 größer als 0
uint8_t error_threshold_t = 5;

// gegencounter für error_threshold
uint8_t send_ueberw_counter_alarm;

// gegencounter für error_threshold
uint8_t send_ueberw_counter_t_alarm;

// Erfolgreiche Sendungen
uint16_t successful_sends = 0;

// Anzahl der fehlerhaften Überprüfungen
int maxFailedChecks = 8;   //
int failedCheckCount = 0;

// Zähler für WLAN-Verbindungsversuche
int connectionAttemptCount = 0;

// Zähler für ESP32-Neustarts
int restartCount = 0;

uint8_t init_wifi_counter;
bool g_wlan_check_start = false;

unsigned long startMillissend;  // Startzeit in Millisekunden
const unsigned long periodsend PROGMEM = 15 * 60 * 1000;  // 15 Minuten in Millisekunden

// Variablen zum Speichern des WLAN-Status und der letzten Überprüfungszeit
static wl_status_t cachedWiFiStatus = WL_DISCONNECTED;
static wl_status_t currentStatus = WL_DISCONNECTED;     
static unsigned long lastStatusCheckTime = 0;
//const unsigned long statusCheckInterval = 10000; // Überprüfe den Status alle 10 Sekunden
static int failedStatusCheckCount = 0; // Zähler für fehlgeschlagene Statusüberprüfungen

// Zeit-Zähler für die Dauer der WLAN-Verbindung und Offline-Zeit
unsigned long connectedTime = 0;
unsigned long connectedTime_off = 0;
unsigned long previousConnectedTime = 0; // Neue Variable zum Speichern der vorherigen Verbindungszeit
unsigned long offlineTime = 0;
unsigned long previousofflineTime = 0; // Neue Variable zum Speichern der vorherigen Offlineszeit

// Zähler für die Nachtschaltungserkennung
int nightModeDetectionCount = 0;
const int nightModeDetectionThreshold = 180; // Anzahl der aufeinanderfolgenden Offline-Zeiten zur Erkennung der Nachtschaltung (3 Stunden)
const int stableWiFiThreshold = 1800; // Anzahl der aufeinanderfolgenden Online-Zeiten zur Zurücksetzung der Nachtschaltungserkennung (1 Stunde bei 2sec takt)
int consecutiveFailedChecks = 0; // Zähler für aufeinanderfolgende Fehlversuche

// Variable zum Speichern der Anzahl der gefundenen Netzwerke
int numberOfNetworks = -1;

bool nightCounted = false; // Neues Bit zum Speichern, ob der Zähler hochgezählt wurde

bool restartBit;
uint8_t hourCounter = 0;

// Auswerten
bool start_wlan_auswertung;

// Timer für die Simulation der sekunde_Task
unsigned long lastMillis = 0;

// Globale Variablen für den WLAN-Status und den Nachtschaltungsmodus
bool currentWiFiStatus = false;
bool currentNightMode = false;
bool storedNightModeActive = false;

// Globale Variablen für die letzte Log-Zeit jeder Bedingung
unsigned long lastLogTimeWiFi = 0;
unsigned long lastLogTimeNightModeWindow = 0;
unsigned long lastLogTimeOutsideNightModeWindow = 0;
unsigned long lastLogTimeNightModeActive = 0;
unsigned long lastLogTimeNightModeInactive = 0;
unsigned long lastLogTimeWiFiStatus = 0;
unsigned long lastRTCTimePrint = 0;

// Variablen für die maximale Anzahl der Überprüfungen
const int maxAdditionalFailedChecks = 10; // 10 Versuche zum wiederherstellen, ist ca. 2h
static int additionalFailedCheckCount = 0;

// Variablen für den Tageszähler
int consecutiveNightModeDays = 0;
const int requiredConsecutiveDays = 2; // Anzahl der aufeinanderfolgenden Tage zur Aktivierung der Nachtschaltung

// Variablen für die Tagesmessung
unsigned long lastDayMillis = 0;
const unsigned long dayMillis PROGMEM = 86400000; // 24 Stunden in Millisekunden

// Variable für die Überprüfung der WLAN-Verbindung innerhalb der Nachtzeit
unsigned long nightConnectedTime = 0;
const unsigned long requiredNightConnectedTime PROGMEM = 3600000; // 1 Stunde in Millisekunden
const unsigned long requiredNightConnectedTime2 PROGMEM = 7200000; // 2 Stunde in Millisekunden

unsigned long startMillis;
unsigned long startMillisknx;

const unsigned long waitTime PROGMEM = 30000; // 30 Sekunden

unsigned long rebootStartMillis = 0;
bool rebootScheduled = false;


int previous_wlan_count;       //Anzahl der gefundenen WLANs beim Start abfragen:


unsigned long startMillisb;
unsigned long currentMillisb;
const unsigned long countdownTimeb PROGMEM = 10 * 60 * 1000; // 10 Minuten in Millisekunden

unsigned long lastReconnectAttempt = 0; // Zeitstempel der letzten Ausführung von reconnect()
bool wlanConnected = false; // Variable, um den WLAN-Verbindungsstatus zu verfolgen
unsigned long reconnectInterval = 900000; // Flexibles Intervall für den Reconnect (15 Minuten)

unsigned long ble_startMillis = 0;  // Speichert den Startzeitpunkt
const long ble_delayTime = 15000;   // Verzögerung von 15 Sekunden (in Millisekunden)
bool ble_delayCompleted = false;    // Überprüft, ob die Verzögerung abgeschlossen ist




unsigned long rtc_previousMillis3 = 0;
unsigned long rtc_previousMillis4 = 0;
unsigned long rtc_interval = 3600000; // 1 Stunde in Millisekunden

unsigned long rtc_previousMillis = -rtc_interval; // Setzt initial so, dass Bedingung erfüllt ist
unsigned long rtc_previousMillis2 = -rtc_interval; // Auch hier

uint8_t counterTime = 0;

size_t totalHeapSize;

size_t usedHeapSize;

  void printStatus() {
      Serial.println(F(" "));
      Serial.println(F("--------------------------------- Status der WLAN Auswertung -----------------------------------"));

      // Der Status des Nachtmodus
      Serial.printf("Der Status des Nachtmodus:\t%s\n", nightModeActive ? "Aktiv (WLAN-Verbindung wird nicht überprüft)" : "Nicht aktiv (WLAN-Verbindung wird überprüft)");
      Serial.println(F(" "));
      Serial.printf("Der Status des Nachtmodus:\t%s. Start um %02d:00 Uhr, Ende um %02d:00 Uhr\n", nightModeActive ? "Aktiv (WLAN-Verbindung wird nicht überprüft)" : "Nicht aktiv (WLAN-Verbindung wird überprüft)", nightStartHour, nightEndHour);
      Serial.println(F(" "));

      // Der aktuelle Status der WLAN-Verbindung
      Serial.printf("Der aktuelle Status der WLAN-Verbindung:\t%s\n", currentWiFiStatus ? "Verbunden" : "Nicht verbunden");
      Serial.println(F(" "));

      // Der letzte bekannte Status der WLAN-Verbindung
      Serial.printf("Der letzte bekannte Status der WLAN-Verbindung:\t%s\n", lastWiFiStatus ? "Verbunden" : "Nicht verbunden");
      Serial.println(F("-----------------------------------"));

      // Die Anzahl der fehlgeschlagenen Überprüfungen des WLAN-Status
      Serial.printf("Die Anzahl der fehlgeschlagenen Überprüfungen des WLAN-Status:\t%d\n", failedCheckCount);
      Serial.println(F(" "));

      // Die Anzahl der Versuche, eine WLAN-Verbindung herzustellen
      Serial.printf("Die Anzahl der Versuche, eine WLAN-Verbindung herzustellen:\t%d\n", connectionAttemptCount);
      Serial.println(F("-----------------------------------"));

      // Die Zeit, die das WLAN offline war, in Sekunden
      if (offlineTime < 60) {
          Serial.printf("Die Zeit, die das WLAN offline war, in Sekunden:\t\t%lus\n", offlineTime);
          Serial.println(F(" "));
      } else if (offlineTime < 3600) {
          int minutes = offlineTime / 60;
          int seconds = offlineTime % 60;
          Serial.printf("Die Zeit, die das WLAN offline war seit: %d Minuten und %d Sekunden\n", minutes, seconds);
          Serial.println(F(" "));
      } else {
          int hours = offlineTime / 3600;
          int minutes = (offlineTime % 3600) / 60;
          Serial.printf("Die Zeit, die das WLAN offline war seit: %d Stunden und %d Minuten\n", hours, minutes);
          Serial.println(F(" "));
      }

      // Die Zeit, die das WLAN verbunden war, in Sekunden
      if (connectedTime < 60) {
          Serial.printf("Die Zeit, die das WLAN verbunden ist, in Sekunden:\t\t%lus\n", connectedTime);
          Serial.println(F(" "));
      } else if (connectedTime < 3600) {
          int minutes = connectedTime / 60;
          int seconds = connectedTime % 60;
          Serial.printf("Die Zeit, die das WLAN verbunden ist seit:\t %d Minuten und %d Sekunden\n", minutes, seconds);
          Serial.println(F(" "));
      } else {
          int hours = connectedTime / 3600;
          int minutes = (connectedTime % 3600) / 60;
          Serial.printf("Die Zeit, die das WLAN verbunden ist seit:\t %d Stunden und %d Minuten\n", hours, minutes);
          Serial.println(F(" "));
      }

      // Die Anzahl der Erkennungen der Nachtschaltung
      Serial.printf("Die Anzahl der Erkennungen der Nachtschaltung:\t%d\n", nightModeDetectionCount);
      Serial.printf("Die zusätzliche Anzahl der fehlgeschlagenen Überprüfungen:\t%d\n", additionalFailedCheckCount);
      
      // Die Anzahl der gefundenen WLAN-Netzwerke
      Serial.printf("Die Anzahl der gefundenen WLAN-Netzwerke:\t%d\n", numberOfNetworks);
      
      // Die Anzahl der Neustarts des ESP32
      Serial.printf("Die Anzahl der Neustarts des ESP32:\t%d\n", restartCount);

      Serial.println(F("------------------------------------------------------------------------------------------------"));
  }


/*
typedef enum {
    WIFI_POWER_19_5dBm = 78,// 19.5dBm
    WIFI_POWER_19dBm = 76,// 19dBm
    WIFI_POWER_18_5dBm = 74,// 18.5dBm
    WIFI_POWER_17dBm = 68,// 17dBm
    WIFI_POWER_15dBm = 60,// 15dBm
    WIFI_POWER_13dBm = 52,// 13dBm
    WIFI_POWER_11dBm = 44,// 11dBm
    WIFI_POWER_8_5dBm = 34,// 8.5dBm
    WIFI_POWER_7dBm = 28,// 7dBm
    WIFI_POWER_5dBm = 20,// 5dBm
    WIFI_POWER_2dBm = 8,// 2dBm
    WIFI_POWER_MINUS_1dBm = -4// -1dBm
} wifi_power_t;
*/


bool g_send_end_wlan_aus = false; // Deine Variable
unsigned long startMillisw = 0; // Variable zum Speichern der Startzeit
bool timerStartedw = false; // Variable zum Überprüfen, ob der Timer gestartet wurde



// Dateinamen als char-Variablen
const char* fileName1 = "/data1_24.txt";
const char* fileName2 = "/data2_24.txt";





char attributest[10];


char Headerbuf[1000]; 

char dgrxx_s[10]; // Angenommen, die maximale Länge der Zeichenkette ist 9 + 1 für die Nullterminierung

#define dgrxx_LEN   12
char dgrxx[dgrxx_LEN+1] = "/dgr00.txt";


char chartemp[100]; // Puffer für chartemp, die Länge kannst du anpassen

bool read_seriell;



unsigned long startTime=0;
unsigned long deltaTime=0;





// https://github.com/nayarsystems/posix_tz_db/blob/master/zones.csv
String v_timezone;

          long web_timestamp;
          int web_timezone;
          bool web_dst;
          String web_customZone = "";
          bool web_bit;
          String web_region = "";
          String web_city = "";


uint8_t g_boot_fail = 0;

constexpr char CURRENT_FIRMWARE_TITLE[] PROGMEM = "LivAirHome";

//const char* ntpServer = "pool.ntp.org";
//const char* ntpServer2 = "europe.pool.ntp.org";
//const char* ntpServer3 = "ptbtime1.ptb.de";
const char hostname[] = "LivAirHome";


char g_u_ntp1_ist[32] = "ptbtime1.ptb.de";
char g_u_ntp1_soll[32] = "ptbtime1.ptb.de";
char g_u_ntp2_ist[32] = "europe.pool.ntp.org";
char g_u_ntp2_soll[32] = "europe.pool.ntp.org";
char g_u_ntp3_ist[32] = "pool.ntp.org";
char g_u_ntp3_soll[32] = "pool.ntp.org";

uint32_t  ee_var_01 = 0; 

unsigned long lastPrintTime_Attribute = 0;
unsigned long currentTime_Attribute = 0;
int counter_Attribute = 0;



bool send_bl_status = false;
uint8_t update_ntp_ready;
bool set_manual_time;
bool set_BT_time;
uint8_t update_bl_clock = 0;
bool set_BT_RTC_Time;
uint8_t update_rtc_ready;
bool update_ok_ready;
bool Set_mesz;
uint8_t g_Set_mesz;
uint8_t g_Set_mesz_tmp;
bool set_time_so_wi;
bool g_new_search_ntp;
bool sommerzeit = 0;

bool send_client_attribute_start_send = false;

const long  gmtOffset_sec = 0;
int   daylightOffset_sec = 0;  //0
int   noNTPOffset_sec = 0;    //0

unsigned long epochTime_start = 0;
unsigned long epochTime_diff = 0;
uint8_t p_timeon = 0;

uint8_t rtc_time_valid;

unsigned long epochTime_bl;

unsigned long epochTime_mqtt = 0;
unsigned long epochTime_mqtt_minus = 0;
byte togglebitMqtt = 0;

byte currentSec;
byte currentmin;
byte currenthour;
byte currentdate;
byte currentmonth;
int currentyear;   //4 dig

byte v_currentSec;
byte v_currentmin;
byte v_currenthour;
byte v_currentdate;
byte v_currentmonth;
byte currentYearTwoDigits;   //2 dig

uint8_t t_previousSec = 0; // Variable zum Speichern der vorherigen Sekunde
bool firstRun = true;    // Flag für den ersten Durchlauf
int warningCounter = 0;  // Zähler für die Warnungen

byte currenthour12;
bool currenthourAM_PM;
int previousMin = 255;   // Ein initialer Wert, der ungleich jedem möglichen Minutenwert ist
int previousSec = 255; 
int lastMinute = -1; // Um sicherzustellen, dass das Datum beim ersten Aufruf aktualisiert wird
int lastmin = -1;




int timeDifference;
String timeDifferenceStr;
char timeDifferenceStr_c[10];

unsigned long millissave = millis();
unsigned long  millissave_t;

//unsigned long epochTime = 0;

unsigned long epochTime_rtc = 0;
unsigned long epochTime_save = 0;
unsigned long epochTime_esp = 0;
unsigned long epochTime_esp2 = 0;
unsigned long epochTime_esp3 = 0;
unsigned long epochTime_r_e_diff = 0;
bool g_epochTime_diff;

unsigned long runMillis= millis();
unsigned long allSeconds=millis()/1000;
int runHours= allSeconds/3600;
int secsRemaining=allSeconds%3600;
int runMinutes=secsRemaining/60;
int runSeconds=secsRemaining%60;
 char tbuf[21];
 char uhrzeit_c[21];
 char uhrzeit_t_c[21];
 char p_date_YYMMDD[12] = "00.00.00"; //  "JJ.MM.DD" 

 char p_date_DDMMYY[12] = "00.00.00";  // "DD.MM.JJ" 
 // Ausgabe zur Überprüfung
 char formattedTime[12]; // HH:MM:SS
 char formattedDate[12]; // DD.MM.YY
 char formattedDateYYMMDD[12]; // YY.MM.DD
 char formattedDateHH[5]; // HH
 char formattedDateHHMM[9];
 char current_datetime[50];
 
 
 bool bl_validYear, bl_validMonth, bl_validDay, bl_validHour;
 int bl_lastValidYear = 0, bl_lastValidMonth = 0, bl_lastValidDay = 0, bl_lastValidHour = 0;


byte connectionStatus;
byte second;
byte lastSecond;
byte minute;
byte hour;
byte hour12h;
byte istdst;
byte day;
long year;
long yday;
byte month;
byte weekday;
byte isDST;
byte* current;
float hum;
float temp;
char timeHour12h[3];

uint32_t testzaehler;

byte h_einer;
byte h_zehner;

byte m_einer;
byte m_zehner;
bool tick2 = false;  
bool tick3 = false; 
bool tick4 = false;  
bool tick5 = false;  
bool tick6 = false;  
bool tick20 = false;  
bool tick21 = false;  
bool clock_start = false;  
bool g_time_s;
bool g_set_esp_clock = false;
bool tick_bt = false; 
bool tick_radon = false; 




WiFiUDP ntpUDP;

#define ntp_2_3
#ifdef myNTP
 NTPClient timeClient(ntpUDP, ntpServerIP);
 #else
  //NTPClient timeClient (ntpUDP);
 NTPClient timeClient(ntpUDP, g_u_ntp3_ist);
 #ifdef ntp_2_3
 NTPClient timeClient2(ntpUDP, g_u_ntp2_ist);
 NTPClient timeClient3(ntpUDP, g_u_ntp1_ist);
 #endif
 #endif

bool mQTT_VAR_Send;

bool send_telemetry_data_set;
bool send_client_attribute_set = false;
bool send_client2_attributee_set;

int randomNumber10_20;

bool g_esp_restsrt;
bool g_esp_soft_restart;
unsigned long restartSoftTimer = 0;
bool restartInitiated = false;


 #ifdef __cplusplus
  extern "C" {
 #endif

  //uint8_t temprature_sens_read();

#ifdef __cplusplus
}
#endif

#include <esp_task_wdt.h>
//#include <esp32/rom/rtc.h>
//#include <soc/rtc_wdt.h>
//3 seconds WDT
#define WDT_TIMEOUT 12


  long u_TIME_TB_key_send;
  long u_TIME_TB_key_read;


  uint16_t g_file_start = 0;
  uint16_t g_file_end = 0;
  uint16_t g_file_read = 0;


  bool b_file_read14,b_file_read15;
  bool b_file_read17,b_file_read18;
  bool b_file_delete;
  bool b_file_send;


uint16_t charcount14, charcount14_t,charcount14_w,count14fehlt,g14FileRead,must_transfer4,g14Filewrite;
uint16_t charcount15, charcount15_t,charcount15_w,count15fehlt,g15FileRead,must_transfer5,g15Filewrite;
uint16_t g1415Side,g1415_full,g1415_Sum_Counter,start_counter,arraycounter,resultarrycounter;


int scanResult_n = -1; // Globale Variable für den Scan-Status
bool scanInProgress = false; // Flag, um den Scan-Status zu verfolgen
bool detailedOutput = false; // Flag für detaillierte Ausgabe
unsigned long startTimes; // Variable für die Startzeit des Scans
unsigned long lastCheckTime = 0; // Variable für die letzte Überprüfung
// Statische Arrays für die Ergebnisse
#define wlan_St_LEN     50
 char find_wlan[wlan_St_LEN+1]; //buffer to hold incoming packet
const int maxSSIDs = 30; // Maximale Anzahl der SSIDs, die gespeichert werden können
#define wlan_Ssid_LEN   40
 char wlan_ssids[maxSSIDs][wlan_Ssid_LEN]; // Annahme: maximal 25 Netzwerke, SSID-Länge maximal 40 Zeichen
 char wlan_encryptionType[maxSSIDs][15];   // Annahme: maximal 25 Netzwerke, wencryptionType-Länge maximal 15 Zeichen
    
  #ifdef ea_webserver
    //String stringtime PROGMEM = "labels : ['08.06.24  03:00','','','08.06.24  04:00','','','08.06.24  05:00','','','08.06.24  06:00','','','08.06.24  07:00','','','08.06.24  08:00','','','08.06.24  09:00','','','08.06.24  10:00','','','08.06.24  011:00','','','08.06.24  12:00','','','08.06.24  13:00','','','08.06.24  14:00','','','08.06.24  15:00','','','08.06.24  16:00','','','08.06.24  17:00',],";
    //String stringdata PROGMEM = "data : [11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,],";
    //String chartimexx PROGMEM = "              ";
    /*
    String chartime00 PROGMEM = "00.00.00 00:00";
    String chartime01a PROGMEM = "              ";
    String chartime02b PROGMEM = "              ";
    String chartime04 PROGMEM = "              ";
    String chartime05a PROGMEM = "              ";
    String chartime06b PROGMEM = "              ";
    String chartime08a PROGMEM = "              ";
    String chartime09a PROGMEM = "              ";
    String chartime10b PROGMEM = "              ";
    String chartime12 PROGMEM = "              ";
    String chartime13a PROGMEM = "              ";
    String chartime14b PROGMEM = "              ";
    */
    char chartime00[20]; // Angenommen, 19 Zeichen + 1 für Nullterminierung
    char chartime01a[20];
    char chartime02b[20];
    char chartime04[20];
    char chartime05a[20];
    char chartime06b[20];
    char chartime08a[20];
    char chartime09a[20];
    char chartime10b[20];
    char chartime12[20];
    char chartime13a[20];
    char chartime14b[20];
    char chartime16[20];



  #endif 
    //String chartime16 = "              ";
    //String chartime16a  = "              ";
    //String chartime16b  = "              ";


    uint16_t charInts[49];

    uint8_t chartime;

 


   
   
    String answer_s = "                                                                                                                                                                                             ";
  

    uint16_t charcount17_t,count17fehlt,g17FileRead,g17Filewrite;
    uint16_t charcount18_t,count18fehlt,g18FileRead,g18Filewrite;
    uint16_t g1718Side,g1718_full,g1718_Sum_Counter;

    uint16_t gFilewrite,g_full;
    uint16_t gFileread=1;
    bool new_entr_log;
    bool entr_log;
    int leszaehler;

    const char* dateiGr17 = "/things17.txt"; 
    String things_list_t_17 = "                                                                                                                                 ";
    const char* dateiGr18 = "/things18.txt"; 
    String things_list_t_18 = "                                                                                                                                 ";
    
    const uint16_t v_count_gh1718 = 100; 

    uint8_t write_to_file17_count;

    uint16_t charcount17,charcount17_r,charcount17_l,charcount17_w;
    uint16_t charcount18,charcount18_r,charcount18_l,charcount18_w;

    //  String list_t_18[4] = {"", "", "", ""};


 #ifdef ea_webserver


     /*
    void datei_w_graph()  
    {
        esp_task_wdt_reset();
        dgrxx_s.toCharArray(dgrxx, dgrxx_LEN);
        File file = SPIFFS.open(dgrxx, FILE_WRITE);
      
        if(!file){
          Serial.println("Fehler beim Öffnen der Datei zum Schreiben.");
          File file = SPIFFS.open(dgrxx, FILE_WRITE);
          file.print(" ");
          file.close();
        }else{
          file.print(chartemp + "\n"); 
          file.close();       
        }
        Serial.println("Schreiben abgeschlossen.");

    }


    void datei_r_graph() {

        dgrxx_s.toCharArray(dgrxx, dgrxx_LEN);
        uint16_t zeilenZaehler = 0;
        int i = 0;
        File file = SPIFFS.open(dgrxx, "r");
        if (!file) {
            if (read_seriell == true) {
                read_seriell = false;
                Serial.print(dgrxx);
                Serial.print(" ");
                Serial.println("new");
            }
            File file = SPIFFS.open(dgrxx, FILE_WRITE);
            file.print(" ");
            file.close();
            file = SPIFFS.open(dgrxx, "r");
        }
        while (file.available() && i < 60) {
            chartemp = file.readStringUntil('\n'); // lesen bis Zeilenumbruch...
            // if(read_seriell == true){
            // read_seriell = false;
            // Serial.print(dgrxx);Serial.print(" ");Serial.println(chartemp);
            // }
            i++;
            zeilenZaehler++;
            Serial.println("Zeile gelesen: " + chartemp);
            esp_task_wdt_reset();
        }
        file.close();
        Serial.println("Lesen abgeschlossen.");
    }
    */



    void updateNTPServer(String ntpServer) {
      timeClient.end(); // Stoppe den aktuellen NTPClient
      timeClient = NTPClient(ntpUDP, ntpServer.c_str()); // Erstelle einen neuen NTPClient mit dem neuen Server
      timeClient.begin(); // Starte den NTPClient
    }

    void startNTPServer(String ntpServer) {
      timeClient = NTPClient(ntpUDP, ntpServer.c_str()); // Erstelle einen neuen NTPClient mit dem neuen Server
      timeClient.begin(); // Starte den NTPClient
    }


    




      //-----------------------------------------------------------------------------------------------------------------------------
        void datei_schreiben17()   // FILE_APPEND
        {

        File file = SPIFFS.open(dateiGr17, FILE_APPEND);


          if(!file){
              // Die Datei ist nicht vorhanden
              #ifdef NVS_17_DEBUG
                Serial.println("[FI] Die Datei " + String(dateiGr17) + " existiert nicht!");
              #endif 
              // Datei mit Schreibrechten öffnen, wird erstellt wenn nicht vorhanden
              File file = SPIFFS.open(dateiGr17, FILE_WRITE);
              #ifdef NVS_17_DEBUG
                Serial.println("[FI] Datei " + String(dateiGr17) + " wurde erstellt!");
              #endif
              // Daten in die Datei schreiben
              file.print("");
              // Schließen der Datei
              file.close();
            }else{
                // Die Datei ist vorhanden
                file.print(things_list_t_17 + "\n"); 
                // !! hier BL Ausgabe
                  #ifdef NVS_17_DEBUG
                      Serial.println("Datei17 w Zeile : " + String(things_list_t_17));  

                  #endif
                  charcount17_w ++;
                file.close();       
            }


        }
      //-----------------------------------------------------------------------------------------------------------------------------


      //-----------------------------------------------------------------------------------------------------------------------------
        void datei_schreiben18()   // FILE_APPEND
        {

        File file = SPIFFS.open(dateiGr18, FILE_APPEND);

          if(!file){
              // Die Datei ist nicht vorhanden
              #ifdef NVS_18_DEBUG
                Serial.println("[FI] Die Datei " + String(dateiGr18) + " existiert nicht!");
              #endif 
              // Datei mit Schreibrechten öffnen, wird erstellt wenn nicht vorhanden
              File file = SPIFFS.open(dateiGr18, FILE_WRITE);
              #ifdef NVS_18_DEBUG
                Serial.println("[FI] Datei " + String(dateiGr18) + " wurde erstellt!");
              #endif
              // Daten in die Datei schreiben
              file.print("");
              // Schließen der Datei
              file.close();
            }else{
                // Die Datei ist vorhanden
                file.print(things_list_t_18 + "\n"); 
                // !! hier BL Ausgabe
                  #ifdef NVS_18_DEBUG
                      Serial.println("Datei18 w Zeile : " + String(things_list_t_18));  

                  #endif
                  charcount18_w ++;
                file.close();       
            }


        }
      //-----------------------------------------------------------------------------------------------------------------------------


    //-----------------------------------------------------------------------------------------------------------------------------
      void datei_lesen_line17()
      {
          String data;
          uint16_t zeilenZaehler = 0;
          int i = 0;
          File file = SPIFFS.open(dateiGr17, "r");

          if(!file){
              // Die Datei ist nicht vorhanden
              #ifdef NVS_17_DEBUG
                Serial.println("[FI] Die Datei " + String(dateiGr17) + " existiert nicht!");
              #endif 
              // Datei mit Schreibrechten öffnen, wird erstellt wenn nicht vorhanden
              File file = SPIFFS.open(dateiGr17, FILE_WRITE);
              #ifdef NVS_17_DEBUG
                Serial.println("[FI] Datei " + String(dateiGr17) + " wurde erstellt!");
              #endif
              // Daten in die Datei schreiben
              file.print("0");
              // Schließen der Datei
              file.close();

              // erneut öffnen für lesen 
              file = SPIFFS.open(dateiGr17, "r");
          }

          #ifdef NVS_17_DEBUG
            Serial.println("[FI] Lese Daten aus Log Datei 17:");
          #endif

          tick21 = false;
          while(file.available()) {
            data = file.readStringUntil('\n'); // lesen bis Zeilenumbruch...
            
            if(zeilenZaehler == charcount17_l){ 
              answer_s = data; 
              tick21 = true;
                #ifdef NVS_17_DEBUG
                  Serial.print("[FI] -> Zeile ");
                  Serial.print(zeilenZaehler);
                  Serial.print(": ");
                  Serial.println(data);           // ... und wieder ausgegeben
                #endif
            } else{
                #ifdef NVS_17_DEBUG
                  //Serial.print("[FI] r Zeile ");
                  //Serial.print(zeilenZaehler);
                  //Serial.print(": ");
                  //Serial.println(data);           // ... und wieder ausgegeben
                #endif
            }  
            i++;
            zeilenZaehler++;
          } 

              charcount17 = zeilenZaehler;
              charcount17_r = zeilenZaehler;
          
          #ifdef NVS_17_DEBUG
          Serial.println("[FI] Aktueller Log 17 read Zeilen Zähler: " + String(charcount17_r)); 
          #endif

          file.close();
      }
    //-----------------------------------------------------------------------------------------------------------------------------

    //-----------------------------------------------------------------------------------------------------------------------------
      void datei_lesen_line18()
      {
          String data;
          uint16_t zeilenZaehler = 0;
          int i = 0;
          File file = SPIFFS.open(dateiGr18, "r");

          if(!file){
              // Die Datei ist nicht vorhanden
              #ifdef NVS_18_DEBUG
                Serial.println("[FI] Die Datei " + String(dateiGr18) + " existiert nicht!");
              #endif 
              // Datei mit Schreibrechten öffnen, wird erstellt wenn nicht vorhanden
              File file = SPIFFS.open(dateiGr18, FILE_WRITE);
              #ifdef NVS_18_DEBUG
                Serial.println("[FI] Datei " + String(dateiGr18) + " wurde erstellt!");
              #endif
              // Daten in die Datei schreiben
              file.print("0");
              // Schließen der Datei
              file.close();

              // erneut öffnen für lesen 
              file = SPIFFS.open(dateiGr18, "r");
          }

          #ifdef NVS_18_DEBUG
            Serial.println("[FI] Lese Daten aus Log Datei 18:");
          #endif

          tick21 = false;
          while(file.available()) {
            data = file.readStringUntil('\n'); // lesen bis Zeilenumbruch...
            
            if(zeilenZaehler == charcount18_l){ 
              answer_s = data; 
              tick21 = true;
                #ifdef NVS_18_DEBUG
                  Serial.print("[FI] -> Zeile ");
                  Serial.print(zeilenZaehler);
                  Serial.print(": ");
                  Serial.println(data);           // ... und wieder ausgegeben
                #endif
            } else{
                #ifdef NVS_18_DEBUG
                  //Serial.print("[FI] r Zeile ");
                  //Serial.print(zeilenZaehler);
                  //Serial.print(": ");
                  //Serial.println(data);           // ... und wieder ausgegeben
                #endif
            }  
            i++;
            zeilenZaehler++;
          } 

              charcount18 = zeilenZaehler;
              charcount18_r = zeilenZaehler;
          
          #ifdef NVS_18_DEBUG
          Serial.println("[FI] Aktueller Log read Zeilen Zähler: " + String(charcount18_r)); 
          #endif

          file.close();
      }
    //-----------------------------------------------------------------------------------------------------------------------------







//-----------------------------------------------------------------------------------------------------------------------------
  void datei_log16()   // FILE_APPEND
  {



  File file = SPIFFS.open(dateiGr16, FILE_APPEND);
     
    if(!file){
        // Die Datei ist nicht vorhanden
        #ifdef NVS_16_DEBUG
          Serial.println("[FI] Die Datei " + String(dateiGr16) + " existiert nicht!");
        #endif 
        // Datei mit Schreibrechten öffnen, wird erstellt wenn nicht vorhanden
        File file = SPIFFS.open(dateiGr16, FILE_WRITE);
        #ifdef NVS_16_DEBUG
          Serial.println("[FI] Datei " + String(dateiGr16) + " wurde erstellt!");
        #endif
        // Daten in die Datei schreiben
        file.print("");
        // Schließen der Datei
        file.close();
      }else{
          // Die Datei ist vorhanden
           file.print(things_list_t_16 + "\n"); 
           // !! hier BL Ausgabe
             #ifdef NVS_16_DEBUG
                Serial.println("Datei16 w Zeile : " + String(things_list_t_16));  
                //Serial.println(things_list_t_15);           // ... und ausgegeben 
             #endif
             //charcount16_w ++;
          file.close();       
      }




  }
//-----------------------------------------------------------------------------------------------------------------------------





//-----------------------------------------------------------------------------------------------------------------------------


  void datei_lesen_line16()
  {
      String data;
      uint16_t zeilenZaehler = 0;
      int i = 0;
      File file = SPIFFS.open(dateiGr16, "r");
      

      if(!file){

          // Die Datei ist nicht vorhanden
          #ifdef NVS_16_DEBUG
            Serial.println("[FI] Die Datei " + String(dateiGr16) + " existiert nicht!");
          #endif 
          // Datei mit Schreibrechten öffnen, wird erstellt wenn nicht vorhanden
          File file = SPIFFS.open(dateiGr16, FILE_WRITE);
          #ifdef NVS_16_DEBUG
            Serial.println("[FI] Datei " + String(dateiGr16) + " wurde erstellt!");
          #endif
          // Daten in die Datei schreiben
          file.print("0");
          // Schließen der Datei
          file.close();

          // erneut öffnen für lesen 
          file = SPIFFS.open(dateiGr16, "r");
        
      }



      #ifdef NVS_16_DEBUG
        Serial.println("[FI] Lese Daten aus Log Datei:");
      #endif

      tick21 = false;
      while(file.available()) {
        
        if(i == leszaehler){

            things_list_t_16 = file.readStringUntil('\n'); // lesen bis Zeilenumbruch...
            
                #ifdef NVS_16_DEBUG
                  Serial.print("[FI] -> Zeile ");
                  Serial.print(zeilenZaehler);
                  Serial.print(": ");
                  Serial.println(data);           // ... und wieder ausgegeben
                #endif
           zeilenZaehler++;  
        }     
            i++;
                
      } 

          charcount16 = zeilenZaehler;
          charcount16_r = i;
      
      #ifdef NVS_16_DEBUG
      Serial.println("[FI] Aktueller Log read Zeilen Zähler: " + String(charcount16_r)); 
      #endif

      file.close();
      #ifdef NVS_cloud_DEBUG
        //Serial.println(F(" "));
      #endif

  }
//-----------------------------------------------------------------------------------------------------------------------------



 uint8_t webserver_aktiviert = 1;     //1 = AN


        /*
        // bei entfernen der liste
        gFileread = 0;
        g_full = 0;
        list_t_18[0] = ""; 
        list_t_18[1] = ""; 
        */

#include <vector>

//const char* logFileName = "/log.txt";
const char* logFileName1 = "/log1.txt";
const char* logFileName2 = "/log2.txt";
const int maxLogs = 20;
std::vector<String> logBuffer;
//Preferences preferences;
size_t filePos = 0;
int logCount_sum, fileEntr,global_logCount;
int logCount = 0; // Globale Variable deklarieren
int currentLogIndex = 0; // Globale Variable für den aktuellen Log-Index
uint16_t currentEntryIndex;
String currentLogFile;
bool isLogFull = false; // Variable um zu wissen, ob die maxLogs erreicht wurden
int globalLogIndex = 0; 
int totalEntries,totalEntriesFile1t;

int currentIndex1 = 0;
int currentIndex2 = 0;
bool useFirstLog = false;




/*
// Funktion zum Lesen von Preferences
void datei_r_graph(String key) {
    Preferences preferences;
    preferences.begin("eenvs", false);
    chartemp = preferences.getString(key.c_str(), ""); // key in const char* umwandeln
    //Serial.println("Gelesen von " + key + ": " + chartemp);
    preferences.end(); 
}

// Funktion zum Schreiben in Preferences
void datei_w_graph(String key, String value) {
    Preferences preferences;
    preferences.begin("eenvs", false);
    preferences.putString(key.c_str(), value); // key in const char* umwandeln
    //Serial.println("Geschrieben zu " + key + ": " + value);
    preferences.end(); 
}
*/
// Funktion zum Lesen von Preferences
void datei_r_graph(const char* key) {
    Preferences preferences;
    preferences.begin("eenvs", false);
    preferences.getBytes(key, chartemp, sizeof(chartemp)); // key in const char* umwandeln
    preferences.end(); 
}

// Funktion zum Schreiben in Preferences
void datei_w_graph(const char* key, const char* value) {
    Preferences preferences;
    preferences.begin("eenvs", false);
    preferences.putBytes(key, value, strlen(value) + 1); // key in const char* umwandeln
    preferences.end(); 
}




#define KEY_LEN 10
#define TEMP_SIZE 128
char chartemp2[TEMP_SIZE]; // Puffer für die gelesenen Werte
char chartime002[TEMP_SIZE]; // Zusätzlicher Puffer

// Funktion zum Lesen von Preferences
void datei_r_graph2(const char* key) {
    Preferences preferences;
    preferences.begin("eenvs", false);
    String temp = preferences.getString(key, ""); // key verwenden und in temp speichern
    temp.toCharArray(chartemp2, TEMP_SIZE); // In chartemp kopieren
    preferences.end(); 
}

// Funktion zum Schreiben in Preferences
void datei_w_graph2(const char* key, const char* value) {
    Preferences preferences;
    preferences.begin("eenvs", false);
    preferences.putString(key, value); // key und value verwenden
    preferences.end(); 
}





//-------------------------------------------------------

void trim_log_file() {
    Preferences preferences;
    preferences.begin("eenvs", false);
      currentLogFile = preferences.getString("cLogFile", logFileName1);
    currentLogFile = logFileName1;
      String nextLogFile = (currentLogFile == logFileName1) ? logFileName2 : logFileName1;
    nextLogFile = logFileName2;

    
    isLogFull = true; // Setze die Variable auf true, da maxLogs erreicht wurden
    preferences.putBool("isLogFull", isLogFull); // Speichere die Variable in den Preferences


    Serial.println("Trimming log file...");
    Serial.println("Current Log File: " + currentLogFile);
    Serial.println("Next Log File: " + nextLogFile);

    File readFile = SPIFFS.open(currentLogFile.c_str(), "r");
    if (!readFile) {
        Serial.println("Failed to open log file for reading");
        return;
    }

    String allLogs = "";
    int logCount = 0;
    int logCount2 = 0;

    // logFileName1
    while (readFile.available() > 0 && logCount < maxLogs) {
        String line = readFile.readStringUntil('\n');
        Serial.println("Reading line: " + line);
            logCount2++;
            if (logCount2 >= maxLogs+4) { // Abbruchbedingung
                Serial.println("Maximale Anzahl von Logs erreicht.");
                break; // Schleife abbrechen
            }
        esp_task_wdt_reset();
        if (line.length() > 0) { // Nur nicht-leere Zeilen speichern
            allLogs += line + "\n"; // Füge Zeilenumbruch hinzu
            //allLogs += line; 
            logCount++;
        }
    }
    readFile.close();

    // Debugging-Statement
    Serial.println("All Logs Counts: " + logCount);
    Serial.println("All Logs to transfer: " + allLogs);
    Serial.println("Length of allLogs: " + String(allLogs.length())); // Debugging-Statement


    //-------------------------------------------------------------

    // Schreibe in die nächste Datei
    File writeFile = SPIFFS.open(nextLogFile.c_str(), FILE_WRITE);
    if (!writeFile) {
        Serial.println("Failed to open log file for writing");
        return;
    }
    //writeFile.print(allLogs + "\n");
    writeFile.print(allLogs);
    writeFile.close();
    Serial.println("Written logs to new file.");

    // Alte Datei löschen und neu anlegen
    if (SPIFFS.remove(currentLogFile.c_str())) {
        Serial.println("Old log file deleted: " + currentLogFile);
    } else {
        Serial.println("Failed to delete old log file: " + currentLogFile);
    }
    writeFile = SPIFFS.open(currentLogFile.c_str(), FILE_WRITE);
    if (!writeFile) {
        Serial.println("Failed to create new log file for writing");
        return;
    }
    writeFile.print("");
    writeFile.close();
    Serial.println("Deleted log file new created: " + currentLogFile);
    esp_task_wdt_reset();
}







void write_to_log(const String& logEntry) {
   
  if (loggingEnabled){

    esp_task_wdt_reset();
    Preferences preferences;
    preferences.begin("eenvs", false);
    currentLogFile = preferences.getString("cLogFile", logFileName1);
    currentEntryIndex = preferences.getUInt("cEntryIndex", 0);


    // Log-Eintrag schreiben
    File logFile = SPIFFS.open(currentLogFile.c_str(), FILE_APPEND);
    if (!logFile) {
        Serial.println("Failed to open log file for writing");
        return;
    }

    // Füge den globalen Zähler in den Log-Eintrag ein
    //String logEntryWithCounter = logEntry + " | Global Counter: " + String(global_logCount);
    String logEntryWithCounter = logEntry;
    global_logCount++;
    //logFile.print(logEntryWithCounter + "\n"); // Verwende print und füge Zeilenumbruch manuell hinzu
    logFile.println(logEntryWithCounter);
    logFile.close();

    // Eintragsindex erhöhen und prüfen
    currentEntryIndex++;
    logCount_sum++;
    Serial.println("Current Entry Index: " + String(currentEntryIndex));  // Debug-Ausgabe
    Serial.println("Current Log File: " + currentLogFile);  // Debug-Ausgabe
    Serial.println("Log Entry: " + logEntryWithCounter);  // Debug-Ausgabe
    Serial.println("Total Log Count: " + String(logCount_sum));  // Debug-Ausgabe

    if (currentEntryIndex >= maxLogs) {
        // Wechsle zur anderen Datei und setze den Index zurück
        trim_log_file();
        currentEntryIndex = 0;
        esp_task_wdt_reset();      

    }

    currentLogFile = logFileName1;
    // Index und isLogFull speichern
    preferences.begin("eenvs", false);
    preferences.putUInt("cEntryIndex", currentEntryIndex);
    preferences.putBool("isLogFull", isLogFull); // Speichere die Variable in den Preferences
    preferences.putString("cLogFile", currentLogFile); // Speichere die aktuelle Logdatei in den Preferences
    preferences.end();

  }

}







String read_file_content(const char* logFileName) {
    File readFile = SPIFFS.open(logFileName, "r");
    if (!readFile) {
        Serial.println("Failed to open log file for reading: " + String(logFileName));
        return "";
    }

    String fileContent = "";
    while (readFile.available() > 0) {
        fileContent += readFile.readStringUntil('\n') + "\n";
    }
    readFile.close();
    return fileContent;
}


String get_log_entry_from_file(const char* logFileName, int index) {
    File readFile = SPIFFS.open(logFileName, "r");
    if (!readFile) {
        Serial.println("Failed to open log file for reading: " + String(logFileName));
        return "";
    }

    String line;
    int currentIndex = 0;
    while (readFile.available() > 0) {
        line = readFile.readStringUntil('\n');
        esp_task_wdt_reset();
        if (currentIndex == index) {
            readFile.close();
            return line;
        }
        currentIndex++;
    }
    readFile.close();
    return "";
}




int count_log_entries(const char* logFileName) {
    File readFile = SPIFFS.open(logFileName, "r");
    if (!readFile) {
        Serial.println("Failed to open log file for reading: " + String(logFileName));
        return 0;
    }

    int tempLogCount = 0;
    while (readFile.available() > 0) {
        String line = readFile.readStringUntil('\n');
        line.trim();  // Entferne Leerzeichen
        if (line.length() > 0) {  // Prüfe, ob die Zeile leer ist
            tempLogCount++;
        }
        esp_task_wdt_reset();
    }
    readFile.close();
    return tempLogCount;
}

String read_log_entry_by_index2(int index, int maxAttempts = 3) {
    Preferences preferences;
    preferences.begin("eenvs", false);
    String currentLogFile;

    if (useFirstLog == true) {
        currentLogFile = logFileName1;
        currentIndex1 = index;
        Serial.println("currentIndex1"); // Debug
    } else {
        currentLogFile = logFileName2;
        currentIndex2 = index;
        Serial.println("currentIndex2"); // Debug
    }

    // preferences.end();
    const char* logFileChar = currentLogFile.c_str(); // String zu const char* umwandeln
    Serial.println("Lese Log-Datei: " + currentLogFile + ", Index: " + String(index)); // Debug

    String logEntry = get_log_entry_from_file(logFileChar, index);
    if (logEntry == "" && totalEntriesFile1t > 0) {
        // Wechsel zur nächsten Datei, wenn die aktuelle Datei leer ist
        Serial.println("Log-Datei leer, wechsle zur nächsten Datei."); // Debug
        useFirstLog = !useFirstLog;
        useFirstLog = true;
        if (useFirstLog) {
            currentIndex1 = 1; // Start bei 1
        } else {
            currentIndex2 = 1; // Start bei 1
        }

        if (maxAttempts > 0) {
            return read_log_entry_by_index2(1, maxAttempts - 1); // Rekursiver Aufruf mit reduziertem maxAttempts
        } else {
            Serial.println("Maximale Anzahl von Versuchen erreicht, keine Log-Einträge gefunden."); // Debug
            return ""; // Rückgabe eines leeren Strings, wenn die maximale Anzahl von Versuchen erreicht ist
        }
    } else {
        Serial.println("Gelesener Log-Eintrag: " + logEntry); // Debug
        return logEntry;
    }
}






String read_log_entry_by_index1(int index) {
    esp_task_wdt_reset();
    Preferences preferences;
    preferences.begin("eenvs", false);
    String currentLogFile = preferences.getString("cLogFile", logFileName1);
    currentEntryIndex = preferences.getUInt("cEntryIndex", 0);
    bool isLogFull = preferences.getBool("isLogFull", false);


    // Berechnen Sie den tatsächlichen Index unter Berücksichtigung der aktuellen Position
    int totalEntriesFile1 = count_log_entries(logFileName1);
    totalEntriesFile1t = totalEntriesFile1;
    int totalEntriesFile2 = count_log_entries(logFileName2);
    Serial.println("Total Entries Logfile 1: " + String(totalEntriesFile1));
    Serial.println("Total Entries Logfile 2: " + String(totalEntriesFile2));
    totalEntries = totalEntriesFile1 + (isLogFull ? totalEntriesFile2 : 0);
    Serial.println("Total Entries: " + String(totalEntries));
    int adjustedIndex = set_g40_var % totalEntries;

    int actualIndex = (currentEntryIndex + adjustedIndex) % totalEntries; 
    Serial.println("Reading entry at index: " + String(index));
    Serial.println("Reading adjustedIndex: " + String(adjustedIndex));
    Serial.println("Actual index to read: " + String(actualIndex));
    Serial.println("Current log file: " + currentLogFile);
    Serial.println("Current entry index: " + String(currentEntryIndex));
    Serial.println("Global log index: " + String(globalLogIndex));

    String logEntry = "";

    if (actualIndex < totalEntriesFile2) {
        logEntry = get_log_entry_from_file(logFileName2, actualIndex);
    } else {
        logEntry = get_log_entry_from_file(logFileName1, actualIndex - totalEntriesFile2);
    }

    globalLogIndex++; // Aktualisieren Sie die globale Zählvariable

    Serial.println("Returning log entry: ");
    Serial.println(logEntry);
    return logEntry;
}



String read_log_entry_by_index(int index) {
    esp_task_wdt_reset();
    Preferences preferences;
    preferences.begin("eenvs", false);
    String currentLogFile = preferences.getString("cLogFile", logFileName1);
    currentEntryIndex = preferences.getUInt("cEntryIndex", 0);
    preferences.end();

    // Berechnen Sie den tatsächlichen Index unter Berücksichtigung der aktuellen Position
    totalEntries = count_log_entries(logFileName1) + count_log_entries(logFileName2);
    int actualIndex = (currentEntryIndex + index) % totalEntries;
    Serial.println("Reading entry at index: " + String(index));
    Serial.println("Total Entries: " + String(totalEntries));
    Serial.println("Actual index to read: " + String(actualIndex));
    Serial.println("Current log file: " + currentLogFile);
    Serial.println("Current entry index: " + String(currentEntryIndex));

    String logEntry = "";

    if (currentLogFile == logFileName1) {
        logEntry = get_log_entry_from_file(logFileName1, actualIndex);
    } else {
        logEntry = get_log_entry_from_file(logFileName2, actualIndex);
    }

    Serial.println("Returning log entry: " + logEntry);
    return logEntry;
}





void print_log_info() {
    Preferences preferences;
    preferences.begin("eenvs", false);
    String currentLogFile = preferences.getString("cLogFile", logFileName1);
    int currentEntryIndex = preferences.getUInt("cEntryIndex", 0);
    bool isLogFull = preferences.getBool("isLogFull", false);
    preferences.end();

    int totalEntriesFile1 = count_log_entries(logFileName1);
    totalEntriesFile1t = totalEntriesFile1;
    int totalEntriesFile2 = count_log_entries(logFileName2);
    totalEntries = totalEntriesFile1 + totalEntriesFile2;

    Serial.println("Aktuelle Log-Datei: " + currentLogFile);
    Serial.println("Aktueller Eintrag Index: " + String(currentEntryIndex));
    Serial.println("Gesamteinträge in Datei 1: " + String(totalEntriesFile1));
    Serial.println("Gesamteinträge in Datei 2: " + String(totalEntriesFile2));
    Serial.println("Gesamteinträge: " + String(totalEntries));
    Serial.println("Log ist voll: " + String(isLogFull));
}





void debug_log_files() {
    Preferences preferences;
    preferences.begin("eenvs", false);
    String currentLogFile = preferences.getString("cLogFile", logFileName1);
    unsigned int currentEntryIndex = preferences.getUInt("cEntryIndex", 0);
    bool isLogFull = preferences.getBool("isLogFull", false);
    preferences.end();

    Serial.println("Debugging Log Files...");
    Serial.println("Current Log File: " + currentLogFile);
    Serial.println("Current Entry Index: " + String(currentEntryIndex));
    Serial.println("Is Log Full: " + String(isLogFull));

    // Lese den Inhalt der ersten Logdatei
    Serial.println("Reading Log File 1: " + String(logFileName1));
    String logFile1Content = read_file_content(logFileName1);
    Serial.println("Log File 1 Content:");
    Serial.println(logFile1Content);

    // Lese den Inhalt der zweiten Logdatei
    Serial.println("Reading Log File 2: " + String(logFileName2));
    String logFile2Content = read_file_content(logFileName2);
    Serial.println("Log File 2 Content:");
    Serial.println(logFile2Content);
}




void executeRestart() {

}






void removeCarriageReturnAndNewline(char* buffer) {
    size_t len = strlen(buffer);
    char* p = buffer;
    for (size_t i = 0; i < len; i++) {
        if (buffer[i] != '\r' && buffer[i] != '\n') {
            *p++ = buffer[i];
        }
    }
    *p = '\0'; // Null-terminieren
}

void removeTrailingNewline(char* buffer) {
    size_t len = strlen(buffer);
    if (len > 0 && buffer[len - 1] == '\n') {
        buffer[len - 1] = '\0';
    }
}







     //-------------------------------------------------------------------------------------------------------
     void read_from_log() 
     {
          
    

         //answer_s = things_list_t_16;


          //---------------- länge -------------------------
          String tempstr = "";
      
          if(g1718_full == 1){
            g1718_Sum_Counter = v_count_gh1718;
          }else{
            g1718_Sum_Counter = g17Filewrite;
          }
          //---------------------------------------------
            

            //#ifdef IF_17_18_DEBUG
              //Serial.println("[GR] Lese Daten aus Dateien für LOG");
              //Serial.print("[GR] LOG Aufzeichnungen ");Serial.print(g1718_Sum_Counter);Serial.print(" | Seite voll ");Serial.print(g1718_full);Serial.print(" | Seite ");Serial.println(g1718Side); 
            //#endif
              #ifdef IF_17_18_DEBUG
              Serial.println("  ");
              Serial.println("---------------------------------------------------------");
             #endif

          if(g1718_full != 0){ // ein Jahr voll

             if(g1718Side == 0){
               g1718_Sum_Counter = g18Filewrite-g17Filewrite;
               start_counter = g1718_Sum_Counter;

               // alles aus der neuen Datei
               datei_lesen_line18();
                if(g1718Side == 0){ 
                  #ifdef IF_17_18_DEBUG
                    start_counter ++;
                    Serial.print("[GR] Lese Daten aus Datei Nr.18b ab zeile "); Serial.println(start_counter);   //start_counter = g14Filewrite;
                    start_counter --;
                    Serial.print("[GR] LOG Aufzeichnungen ");Serial.print(g1718_Sum_Counter);Serial.print(" | g1718_full ");Serial.print(g1718_full);Serial.print(" | g1718Side ");Serial.println(g1718Side); 
                  #endif
                }else{
                  #ifdef IF_17_18_DEBUG
                  Serial.print("[GR] Lese alle Daten aus Datei Nr.18b    Aufzeichnungen vorhanden: "); Serial.println(g18Filewrite); 
                  Serial.print("[GR] g1718_full ");Serial.print(g1718_full);Serial.print(" | g1718Side ");Serial.println(g1718Side);  
                  #endif
                } 
                //-------------------------------------------------- 
              
               //--------------------------------------------------
                // alles aus der neuen Datei
               datei_lesen_line17();
                if(g1718Side != 0){ 
                  #ifdef IF_17_18_DEBUG
                      start_counter ++;
                      Serial.print("[GR] Lese Daten aus Datei Nr.17 ab zeile "); Serial.println(start_counter);   
                      start_counter --;
                      Serial.print("[GR] LOG Aufzeichnungen ");Serial.print(g1718_Sum_Counter);Serial.print(" | g1718_full ");Serial.print(g1718_full);Serial.print(" | g1718Side ");Serial.println(g1718Side);  
                  #endif
                }else{
                  start_counter = 0;
                  #ifdef IF_17_18_DEBUG
                    Serial.print("[GR] Lese alle Daten aus Datei Nr.17    Aufzeichnungen vorhanden: "); Serial.println(g17Filewrite); 
                    Serial.print("[GR] g1718_full ");Serial.print(g1718_full);Serial.print(" | g1718Side ");Serial.println(g1718Side);  
                  #endif
                }   
               //--------------------------------------------------

             }else{

               g1718_Sum_Counter = g17Filewrite-g18Filewrite;
               start_counter = g1718_Sum_Counter;
               //Serial.print("start_counter log ");Serial.print(start_counter);Serial.print(" ");Serial.print(g17Filewrite);Serial.print(" ");Serial.println(g18Filewrite);
               // lese ab g1718_Sum_Counter bis ende
               start_counter = g18Filewrite;
               
               //--------------------------------------------------
               datei_lesen_line17();
                if(g1718Side != 0){ 
                  #ifdef IF_17_18_DEBUG
                      start_counter ++;
                      Serial.print("[GR] Lese Daten aus Datei Nr.17 ab zeile "); Serial.println(start_counter);  
                      start_counter --;
                      Serial.print("[GR] LOG Aufzeichnungen ");Serial.print(g1718_Sum_Counter);Serial.print(" | g1718_full ");Serial.print(g1718_full);Serial.print(" | g1718Side ");Serial.println(g1718Side);  
                  #endif
                }else{
                  start_counter = 0;
                  #ifdef IF_17_18_DEBUG
                    Serial.print("[[GR] Lese alle Daten aus Datei Nr.17    Aufzeichnungen vorhanden: "); Serial.println(g17Filewrite); 
                    Serial.print("[GR] g1718_full ");Serial.print(g1718_full);Serial.print(" | g1718Side ");Serial.println(g1718Side);  
                  #endif
                }   
               //--------------------------------------------------

               //--------------------------------------------------
               // alles aus der neuen Datei

               // if(zeilenZaehler == charcount18_l){ 
               datei_lesen_line18();
                if(g1718Side == 0){ 
                  #ifdef IF_17_18_DEBUG
                    start_counter ++;
                    Serial.print("[GR] Lese Daten aus Datei Nr.18 ab zeile "); Serial.println(start_counter);  
                    start_counter --;
                    Serial.print("[GR] LOG Aufzeichnungen ");Serial.print(g1718_Sum_Counter);Serial.print(" | g1718_full ");Serial.print(g1718_full);Serial.print(" | g1718Side ");Serial.println(g1718Side); 
                  #endif
                }else{
                  #ifdef IF_17_18_DEBUG
                  Serial.print("[GR] Lese alle Daten aus Datei Nr.18    Aufzeichnungen vorhanden: "); Serial.println(g18Filewrite); 
                  Serial.print("[GR] g1718_full ");Serial.print(g1718_full);Serial.print(" | g1718Side ");Serial.println(g1718Side);  
                  #endif
                } 
                //-------------------------------------------------- 

             }




          }else{

              start_counter = 0;
 
                datei_lesen_line17();

                g1718_Sum_Counter = charcount17_r; 


          }
              
       
        
 
               


     }
     //-------------------------------------------------------------------------------------------------------


 #endif  //webserver





void handleTimeUnit(uint8_t currentMinute, uint8_t timeUnit) {
    switch (timeUnit) {
        case 0:
            //Serial.println(F("Timer deaktiviert"));
            break;
        case 1:
            if (currentMinute != lastMinuteAction) {
                Serial.println(F("-----------------------------------------")); 
                Serial.println(F("[KX] Aktion fuer 1 Minute"));
                send_knx_data();
                if(disable_server >= 1) { 
                  if (loggingEnabled) {
                          //strcpy(things_list_t_16, p_uhrzeit); // Kopiert p_uhrzeit in things_list_t_16
                          //strcat(things_list_t_16, "  [KX] KNX-Daten gesendet"); // Hängt den Text an
                          write_to_log(things_list_t_16);
                  }
                }
                lastMinuteAction = currentMinute;
            }
            break;
        case 2:
            if (currentMinute % 10 == 0 && currentMinute != last10MinuteAction) {
                Serial.println(F("-----------------------------------------")); 
                Serial.println(F("[KX] Aktion fuer 10 Minuten"));
                send_knx_data();
                if(disable_server >= 1) { 
                  if (loggingEnabled) {
                      //things_list_t_16 = p_uhrzeit + "  [KX] KNX-Daten gesendet"; 

                          write_to_log(things_list_t_16);
                    
                  }
                }
                last10MinuteAction = currentMinute;
            }
            break;
        case 3:
            if (currentMinute % 60 == 0 && currentMinute != last60MinuteAction) {
                Serial.println(F("-----------------------------------------")); 
                Serial.println(F("[KX] Aktion fuer 60 Minuten"));
                send_knx_data();
                if(disable_server >= 1) { 
                  if (loggingEnabled) {
                      //things_list_t_16 = p_uhrzeit + "  [KX] KNX-Daten gesendet"; 

                          write_to_log(things_list_t_16);
               
                  }
                }
                last60MinuteAction = currentMinute;
            }
            break;
        default:
            //Serial.println(F("Ungültige Zeiteinheit"));
            break;
    }
}


//-----------------------------------------------------------------








double temp_esp;
uint16_t temp_esp_int;
uint32_t minimum_free_heap_size;

uint32_t tempuint32_t;

String time_str;

uint8_t count_ntp_fail = 0;
uint8_t ntp_change_web;


    //------------------------------------------------
    String printLocalTimezone(){

                  struct tm timeinfo;
                  time_t now;

              if (WiFi.status() == WL_CONNECTED) {
                if (!getLocalTime(&timeinfo)) {
                  #if TM_DEBUG_LEVEL >= TM_DEBUG_MAX
                    Serial.println("[TM] Failed to obtain time");
                  #endif
                }else{
                  Serial.print(F("[TM] 4: "));
                  Serial.println(&timeinfo, "%A, %B %d %Y %H:%M:%S");
                }
              } else {
                #if TM_DEBUG_LEVEL  == TM_DEBUG_MAX
                  Serial.println("[TM] WiFi nicht verbunden. Zeit wird vom ESP abgerufen.");
                #endif
                time(&now);
                localtime_r(&now, &timeinfo);
              }


      //Serial.print("[TM] ");Serial.println(&timeinfo, "%A, %B %d %Y %H:%M:%S");
      //Serial.print("[TM] Epoch: ");Serial.println(timeClient.getEpochTime());
      //time_t now;
      //Serial.print("[TM] Time : ");Serial.println(time(&now));     // Zeit mit Zeitzone und Sommer Winter Offset

      //See http://www.cplusplus.com/reference/ctime/strftime/
      char output[80];
      strftime(output, 80, "%d-%b-%y, %H:%M:%S", &timeinfo);
      time_str = String(output);
      return String(output);
    }
    //------------------------------------------------


    //------------------------------------------------
    // https://github.com/nayarsystems/posix_tz_db/blob/master/zones.csv
    void setTimezone(String timezone){
      
      #if TM_DEBUG_LEVEL  >= TM_DEBUG_MED
        Serial.printf("[TM] Timezone to: %s\n",timezone.c_str());
        //Serial.println(F(" "));
      
      Serial.print(F("[TM] Timezone = "));
      Serial.println(printLocalTimezone());
      Serial.println(F("[TM] Timezone SET..."));
      #endif
                            // 0= 20 uhr 
                            // 1= 21 uhr
      setenv("TZ",timezone.c_str(),1);  //  Now adjust the TZ.  Clock settings are adjusted to show the new local time
      //setenv("TZ",timezone.c_str(),g_Set_mesz);  //  Now adjust the TZ.  Clock settings are adjusted to show the new local time
      tzset();

      #ifdef ea_webserver
      #ifdef j_2_webserver
        if(disable_server >= 1) {
        if (loggingEnabled) {
          //things_list_t_16 =  p_uhrzeit + "  [TM] Timezone = " + printLocalTimezone(); 
          write_to_log(things_list_t_16);
        }
      }

      #endif
      #endif

      

    }
    //------------------------------------------------
  // https://github.com/nayarsystems/posix_tz_db/blob/master/zones.csv
  //See: https://www.gnu.org/software/libc/manual/html_node/TZ-Variable.html
  // CET-1CEST,M3.5.0,M10.5.0/3
  // CST6CDT, M3.2.0/2:00:00, M11.1.0/2:00:00
  // CST6CDT is the name of the time zone
  // CST is the abbreviation used when DST is off
  // 6 hours is the time difference from GMT
  // CDT is the abbreviation used when DST is on
  // ,M3 is the third month
  // .2 is the second occurrence of the day in the month
  // .0 is Sunday
  // /2:00:00 is the time
  // ,M11 is the eleventh month
  // .1 is the first occurrence of the day in the month
  // .0 is Sunday
  // 2:00:00 is the time

//  setTime(2021,10,31,0,59,50,0);    // Set it to 1 minute before daylight savings comes in.
  


//uint8_t temprature_sens_read();
//uint8_t temp_farenheit = temprature_sens_read();
float ESP32temp;
int hall_measurement;
//ESP32temp = ( temp_farenheit - 32 ) / 1.8;


uint8_t count_reconn = 0;
 uint8_t dot_pos;

//TB#*****
String TB_currFwVersion;
//String TB_currFwVersion_view;
bool g_end_boot;
uint8_t g_end_boot_time = 10;
uint32_t BLEvalue = 0;
bool g_sperre1,g_sperre2;

// Zähler nicht erfolgreicher datentransfer
uint16_t send_ueberw_counter;
uint16_t send_ueberw_counter_error_[40];

// Zähler erfolgreicher datentransfer
uint16_t send_ueberw_counter_success;
uint16_t send_ueberw_counter_success_[40];

// Zähler für aktivierung von datentransfer
uint16_t send_ueberw_counter_start;
uint16_t send_ueberw_counter_start_[40];


uint16_t send_ueberw_counter_alarm_[40];

bool restartPending = false; // Variable, um den Neustart zu verfolgen

// Zähler nicht erfolgreicher datentransfer
uint16_t send_ueberw_counter_t_error;

// Zähler erfolgreicher datentransfer
uint16_t send_ueberw_counter_t_success;

// Zähler für aktivierung von datentransfer
uint16_t send_ueberw_counter_t_start;



bool g_check_send_ueberwachung;

 bool sendTelemetryJson_ok = false;
 bool sendTelemetryJson2_ok = false;

 bool sendAttributes11_ok = true;
 bool sendAttributes12_ok = true;
 bool sendAttributes13_ok = true;
 bool sendAttributes14_ok = true;
 bool sendAttributes15_ok = true;
 bool sendAttributes16_ok = true;
 bool sendAttributes17_ok = true;
 bool sendAttributes19_ok = true;

 bool sendAttributes25_ok = false;
 bool sendAttributes26_ok = false;
 bool sendAttributes27_ok = false;
 bool sendAttributes28_ok = false;
 bool sendAttributes29_ok = false;
 bool sendAttributes30_ok = false;
 bool sendAttributes31_ok = false;
 bool sendAttributes32_ok = false;
 bool sendAttributes33_ok = false;

 bool sendRequestedShared0_ok = false;
 bool sendRequestedShared1_ok = false;
 bool sendRequestedShared2_ok = false;
 bool sendRequestedShared3_ok = false;
 bool sendRequestedShared4_ok = false;
 //bool sendRequestedShared5_ok = false;
 bool sendRequestedShared6_ok = false;
 bool sendRequestedShared7_ok = false;
 bool sendRequestedShared8_ok = false;
 bool sendRequestedShared9_ok = false;
  bool sendRequestedSharedt_ok = false;

  bool Sending_Client_attributes_2 = true;
  bool Sending_Telemetry_Data_2 = true;
  bool Sending_Telemetry_Data_3 = true;
  bool Sending_Telemetry_Data_4 = true;
  bool Sending_data_2 = false;
  byte loopCount = 0;       // Zähler für die Anzahl der Schleifendurchläufe
  byte loopCount_vorgabe = 3; 


 String json = "                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       ";


String TB_newFwVersion;
bool TB_new_FW_available;
bool TB_FW_up_to_date;
bool TB_FW_up_to_date_info = true;
uint8_t gFW_Update_start = 0;
uint8_t count_fw;
uint8_t gFW_counter = 0;
bool gFW_write;
bool schreib_sperre;
bool g_set_new_FW = false;
uint8_t g_set_new_FW_time;

uint8_t verzoegerung_fw_update = 0;
bool g_bit_fw_load;
uint8_t wait_counter_fw_failbit;


#include <array>
// Definieren Sie ein Array, um die Messwerte zu speichern
#ifdef einzel_auswertung
  //std::array<uint32_t, 144> messwerte; // 144 Messwerte für 24 Stunden (ein Messwert alle 10 Minuten)
#endif

//uint32_t aufrufZaehler = 0;
uint8_t previousMonth = 255; // Ungültiger Monat, um den ersten Durchlauf zu erzwingen
bool save_long_24h_values = false;
bool save_long_24h_values2 = false;
bool fertig_uebertragen = false;
bool alles_senden_fertig = false;
bool internetTransferComplete = false; // Flag-Variable
unsigned long transferCompleteTime = 0; // Zeitstempel für den Abschluss der Übertragungen
bool ble_start_aktivieren;
bool boot_fertig = true;
bool BLE_enabled;
bool BLE_Server_enabled;
bool BLE_Beacon_enabled;
bool git_startBeacon2;
bool git_stopBeacon2;
uint8_t KNX_enabled = 0;
unsigned long debugTimer = 0;


int pre_ble_counter = 0;
bool pre_ble_counterDisabled = false;
unsigned long pre_ble_timer = 0;


//#define THINGSBOARD_ENABLE_DYNAMIC 1

bool startFirmwareUpdate = false;
bool dataFirmwareUpdate = false;
unsigned long randomDelay = 0;
unsigned long delayStartTime = 0;
unsigned long actualDelay = 0;

#include <ThingsBoard.h>
#include <ESP32_Updater.h>
//TB#*****

/*
// Globale Variablen für Firmware-Update
const OTA_Update_Callback *m_fw_callback;
size_t fw_size;
std::string fw_algorithm;
std::string fw_checksum;
mbedtls_md_type_t fw_checksum_algorithm;
//ThingsBoard tb; // Deklariere tb als globale Variable

// Lokale Variablen
const OTA_Update_Callback *local_fw_callback;
size_t local_fw_size;
std::string local_fw_algorithm;
std::string local_fw_checksum;
mbedtls_md_type_t local_fw_checksum_algorithm;
*/


//int attribute_items_temp = 1;



WiFiClient espClient2;
PubSubClient mqttClient(espClient2); // Eigene Instanz


#define MQTT_CLIENTID_LEN   48
#define MQTT_SERVER_LEN     40
#define MQTT_PORT_LEN        4
#define MQTT_USER_LEN       40
#define MQTT_PASS_LEN       40
#define MQTT_TOPIC          50

bool g_SUBSCRIBE_TOPIC;
bool p_mqonoff = false;

String p_inputmqclient = "";
char p_inputmqclientc[MQTT_CLIENTID_LEN+1] = "";

String p_inputmqserver = "io.adafruit.com";
char p_inputmqserverc[MQTT_SERVER_LEN+1] = "io.adafruit.com"; 

String p_inputmquser = "radonvalue"; //TOKEN
char p_inputmquserc[MQTT_USER_LEN+1] = "radonvalue";

String p_inputmqpass = "4056e40b03b14156ab1d707f5104255e";                 // 0056e40b03b14156ab7d707f5104256e
char p_inputmqpassc[MQTT_PASS_LEN+1] = "4056e40b03b14156ab7d701f5104255e"; // 0056e40b03b14156ab7d707f5104256e

String p_inputmqtopic = "radonvalue/feeds/radon.radon";      
char p_inputmqtopicc[MQTT_TOPIC+1] = "radonvalue/feeds/radon.radon";


String p_inputmqoptions = "0";    //0 = Adafruit [user/pwd]    
String p_inputmqoptionst;
uint8_t p_inputmqoptionsi = 1;

String p_inputmqport = "1883";
uint16_t p_inputmqporti = 1883;


unsigned long mqtt_previousMillis = 0;
const long mqtt_interval = 600000; // 10 Minuten in Millisekunden

//------------------------------------
void reconnectmqtt() {
  int attempt = 0;
  const int maxAttempts = 3;

  p_inputmqpass.toCharArray(p_inputmqpassc, 40);
  p_inputmquser.toCharArray(p_inputmquserc, 48);
  p_inputmqclient.toCharArray(p_inputmqclientc, 40);

  Serial.println(F("-----------------------------------------")); 
  while (!mqttClient.connected() && attempt < maxAttempts) {
    MQTT_DEBUG_PRINTLN(F("[MQ] Versuche MQTT-Verbindung..."));

    esp_task_wdt_reset(); // Watchdog-Timer zurücksetzen
    if (mqttClient.connect(p_inputmqclientc, p_inputmquserc, p_inputmqpassc)){
      MQTT_DEBUG_PRINTLN(F("[MQ] verbunden"));
      mqttClient.subscribe(p_inputmqtopicc);
      if(disable_server >= 1) { 
        if (loggingEnabled) {
          //things_list_t_16 = p_uhrzeit + "  [MQ] MQTT-Verbindung erfolgreich"; 

            write_to_log(things_list_t_16);

        }
      }
     } else {
          int state = mqttClient.state();
          MQTT_DEBUG_PRINT(F("[MQ] Fehler, rc="));
          esp_task_wdt_reset(); // Watchdog-Timer zurücksetzen

          switch (state) {
              case -4:
                  MQTT_DEBUG_PRINTLN(F("MQTT_CONNECTION_TIMEOUT"));
                  break;
              case -3:
                  MQTT_DEBUG_PRINTLN(F("MQTT_CONNECTION_LOST"));
                  break;
              case -2:
                  MQTT_DEBUG_PRINTLN(F("MQTT_CONNECT_FAILED"));
                  break;
              case -1:
                  MQTT_DEBUG_PRINTLN(F("MQTT_DISCONNECTED"));
                  break;
              case 0:
                  MQTT_DEBUG_PRINTLN(F("MQTT_CONNECTED"));
                  break;
              case 1:
                  MQTT_DEBUG_PRINTLN(F("MQTT_CONNECT_BAD_PROTOCOL"));
                  break;
              case 2:
                  MQTT_DEBUG_PRINTLN(F("MQTT_CONNECT_BAD_CLIENT_ID"));
                  break;
              case 3:
                  MQTT_DEBUG_PRINTLN(F("MQTT_CONNECT_UNAVAILABLE"));
                  break;
              case 4:
                  MQTT_DEBUG_PRINTLN(F("MQTT_CONNECT_BAD_CREDENTIALS"));
                  break;
              case 5:
                  MQTT_DEBUG_PRINTLN(F("MQTT_CONNECT_UNAUTHORIZED"));
                  break;
              default:
                  MQTT_DEBUG_PRINTLN(F("UNKNOWN_STATE"));
                  break;
          }

          MQTT_DEBUG_PRINTLN(F(" versuche es in 2 Sekunden erneut"));
          delay(2000);
          attempt++;


    }
  }

  if (attempt == maxAttempts) {
    MQTT_DEBUG_PRINTLN(F("Maximale Anzahl an Verbindungsversuchen erreicht. Abbruch."));
    esp_task_wdt_reset(); // Watchdog-Timer zurücksetzen
    if(disable_server >= 1) { 
      if (loggingEnabled) {
        //things_list_t_16 = p_uhrzeit + "  [MQ] MQTT-Verbindung nicht erfolgreich!"; 
          write_to_log(things_list_t_16);
   
      }
    }
  }
}

//------------------------------------

void mqtt_callback(char* topic, byte* message, unsigned int length) {
  MQTT_DEBUG_PRINT(F("[MQ] Message arrived on topic: "));
  MQTT_DEBUG_PRINT(topic);
  MQTT_DEBUG_PRINT(F(". Message: "));

  String messageTemp;
  
  for (int i = 0; i < length; i++) {
    Serial.print((char)message[i]);
    messageTemp += (char)message[i];
  }
  Serial.println();

  // Feel free to add more if statements to control more GPIOs with MQTT

  // If a message is received on the topic esp32/output, you check if the message is either "on" or "off". 
  // Changes the output state according to the message
  if (String(topic) == p_inputmqtopicc) {
    //Serial.println(F("Changing Topic "));
    if(messageTemp == "on"){
      //Serial.println(F("on"));
      //digitalWrite(ledPin, HIGH);
    } else if(messageTemp == "off"){
      //Serial.println(F("off"));
      //digitalWrite(ledPin, LOW);
    }
  }
  MQTT_DEBUG_PRINTLN(F("-----------------------------------------"));

}

//------------------------------------



//------------------------------------
      bool isPasswordValid(const String& password) {
          if (password.length() < 5) {
            return false;
          }
          std::regex re("^(?=.*[A-Za-z])(?=.*\\d)[A-Za-z\\d]{5,}$");
          return std::regex_match(password.c_str(), re);
      }
//------------------------------------



    //------------------------------------  void InitWiFi()
    // Definiere die Optionen
     //#define g_PSRAM_aktiv
    // #define g_PROGMEM_aktiv

    #ifdef g_PROGMEM_aktiv
      #include <pgmspace.h>  // Für PROGMEM
    #endif

    #ifdef g_PSRAM_aktiv
      //#include <esp_heap_caps.h>  // Für PSRAM
    #endif

    #if defined(g_PROGMEM_aktiv)
      // PROGMEM-Option
      #define APname_LEN   28
      const char p_APname_c[APname_LEN + 1] PROGMEM = "Radon Home Tracer";
      char ram_p_APname_c[APname_LEN + 1]; // Speicher im RAM für die Bearbeitung
      const char device_id[9] PROGMEM = "00000000";
      char ram_device_id[9]; // Speicher im RAM für die Bearbeitung
      String p_APname_p = "Radon Home Tracer         ";
      String read_SSID_String;   //String 
      String device_id_s = "00000000";
      #define DeviceID_LEN   9
      char device_id[DeviceID_LEN + 1];
      String device_id_s = "00000000";

    #elif defined(g_PSRAM_aktiv)
      // PSRAM-Option     macht noch probleme bei device_id Generation
      #define APname_LEN   28
      char *p_APname_c = (char *)ps_malloc((APname_LEN + 1) * sizeof(char));
      String p_APname_p = "Radon Home Tracer         ";
      String read_SSID_String;   //String 
 
      #define DeviceID_LEN   9
      char *device_id = (char *)ps_malloc((DeviceID_LEN + 1) * sizeof(char));
      String device_id_s = "00000000";
    #else
      // Normaler RAM-Option
      #define APname_LEN   28
      char p_APname_c[APname_LEN + 1] = "Radon Home Tracer";
      String p_APname_p = "Radon Home Tracer         ";
      String read_SSID_String;   //String 

      #define DeviceID_LEN   9
      char device_id_c[DeviceID_LEN + 1] = "00000000";
      char device_id[DeviceID_LEN + 1] = "00000000";
      //String device_id_s = "00000000";
    #endif
    //------------------------------------




    //const int numMeasurements = 144;  // Anzahl der Messungen
    //unsigned long times1[numMeasurements];  // Array zum Speichern der Zeiten für die erste Funktion
    //unsigned long times2[numMeasurements];  // Array zum Speichern der Zeiten für die zweite Funktion
    //int numMeasurements_i = 0;  // Variable zur Verfolgung der aktuellen Anzahl der Messungen
    unsigned long previousDuration1 = 0;
    unsigned long previousDuration2 = 0; 

    unsigned long minDuration1 = ULONG_MAX;
    unsigned long maxDuration1 = 0;
    unsigned long minDuration2 = ULONG_MAX;
    unsigned long maxDuration2 = 0;








  int checkFileSystemAndPreferences() {
  
      //bool error = false;
      Preferences preferences;
      preferences.begin("eenvs", false);


      esp_err_t err = preferences.begin("eenvs", false);
      if (err == ESP_ERR_NVS_NO_FREE_PAGES || err == ESP_ERR_NVS_NEW_VERSION_FOUND) {
          Serial.println("[KY] NVS error: No free pages or new version found");
          preferences.end();
        return 1; // Fehler 1: NVS nicht verfügbar oder ein Versionsfehler
      }
    

      if (!preferences.isKey("p_device_id") || !preferences.isKey("p_client_id") || !preferences.isKey("p_username") || !preferences.isKey("p_password")) {
         // error = true;
          Serial.println("[KY] Error: KEY's is missing or set to default value.");
           return 2; // Fehler 2: NVS KEY's nicht verfügbar
      }else{
           return 6; // Kein Fehler
      }

      if (!preferences.isKey("countNVS")) {
          Serial.println("[KY] NVS error: Start KEY's not found");
          preferences.end();
          return 3; // Fehler 3: NVS Start KEY nicht verfügbar
      }else{
          return 7; // Kein Fehler
      }
     
      if (preferences.isKey("errorNVS")) {
          Serial.println("[KY] NVS error: KEY not found");
          preferences.end();
          return 4; // Fehler 4: NVS KEY verfügbar
      }{
          return 8; // Kein Fehler
      }


      return 9; // Kein Fehler
  }



/*
#define WIFI_SSID_LEN   50
char wIFI_SSID_c[WIFI_SSID_LEN+1] = "FRITZ!Box 6490 Holger";
String wIFI_SSID_s = "FRITZ!Box 6490 Holger";

#define WIFI_PWD_LEN   50
char wIFI_PASSWORD_c[WIFI_PWD_LEN+1] = "15400240614617116002";
String wIFI_PASSWORD_s = "15400240614617116002";
*/

#define WIFI_SSID_LEN   50
#define WIFI_PWD_LEN   50
#define ENCRYPTION_LEN 10
char wIFI_SSID_c[WIFI_SSID_LEN+1] = "FRITZ!Box 6490 Holger";
char wIFI_PASSWORD_c[WIFI_PWD_LEN+1] = "15400240614617116002";
char wIFI_encryptionType_c[ENCRYPTION_LEN + 1];

// String wIFI_SSID_s = "FRITZ!Box 6490 Holger";
// String wIFI_PASSWORD_s = "15400240614617116002";





const char* dateiGrSP = "/pref_bu.txt";//                                dateiGr12  

void savePreferencesToSPIFFS() {

      Preferences preferences;
      preferences.begin("eenvs", false);  
    
    File file = SPIFFS.open(dateiGrSP, FILE_WRITE);
    if(!file){
        Serial.println("[KY] Die Datei " + String(dateiGrSP) + " existiert nicht!");
        File file = SPIFFS.open(dateiGrSP, FILE_WRITE);
        file.print("");
        file.close();
      }else{

        file.printf("eprovision:UInt:%u\n", preferences.getUInt("eprovision", 0));
        file.printf("p_client_id:String:%s\n", preferences.getString("p_client_id", "").c_str());
        file.printf("p_username:String:%s\n", preferences.getString("p_username", "").c_str());
        file.printf("p_password:String:%s\n", preferences.getString("p_password", "").c_str());
        file.printf("fw_success:UChar:%u\n", preferences.getUChar("fw_success", 0));
        //file.printf("p_device_id:String:%s\n", preferences.getString("p_device_id", "00000000").c_str());

        // Gerätedaten aus den Preferences lesen und in device_id_c kopieren
        preferences.getBytes("p_device_id", device_id_c, DeviceID_LEN);
        device_id_c[DeviceID_LEN] = '\0'; // Sicherstellen, dass die Zeichenkette nullterminiert ist
        // Verwende das char-Array device_id_c in der printf-Ausgabe
        file.printf("p_device_id:Char:%s\n", device_id_c);

        file.printf("epochstart:ULong64:%llu\n", preferences.getULong64("epochstart", 0));
        file.printf("ee_var_01:UInt:%u\n", preferences.getUInt("ee_var_01", 0));

        //file.printf("wISSID_s:String:%s\n", preferences.getString("wISSID_s", "FRITZ!Box 6490 Holger").c_str());
        //file.printf("wPWD_s:String:%s\n", preferences.getString("wPWD_s", "15400240614617116002").c_str());
        preferences.getBytes("wSSID_s", wIFI_SSID_c, sizeof(wIFI_SSID_c));
        preferences.getBytes("wPWD_s", wIFI_PASSWORD_c, sizeof(wIFI_PASSWORD_c));
        //preferences.getBytes("encryption", wIFI_encryptionType_c, sizeof(wIFI_encryptionType_c));
        file.printf("wISSID_s:String:%s\n", wIFI_SSID_c);
        file.printf("wPWD_s:String:%s\n", wIFI_PASSWORD_c);

        file.printf("g_u_timezone:String:%s\n", preferences.getString("g_u_timezone", "CET-1CEST,M3.5.0,M10.5.0/3").c_str());
        file.printf("t_fw_version:String:%s\n", preferences.getString("t_fw_version", CURRENT_FIRMWARE_VERSION).c_str());
        file.printf("s_kalibriert:UChar:%u\n", preferences.getUChar("s_kalibriert", 0));
        file.printf("s_checked:UChar:%u\n", preferences.getUChar("s_checked", 0));
        file.printf("g_cloud_ea:UChar:%u\n", preferences.getUChar("g_cloud_ea", 0));
        file.printf("p_clon:String:%s\n", preferences.getString("p_clon", "0").c_str());
        file.printf("p_clserv:String:%s\n", preferences.getString("p_clserv", "radoncloud.com").c_str());
        file.printf("p_clpage:String:%s\n", preferences.getString("p_clpage", "LoRaWAN-Live-Link-K1-W33rt22bd11np00L/lora_radon.php").c_str());
        file.printf("p_clpre:String:%s\n", preferences.getString("p_clpre", "submit=Daten").c_str());
        file.printf("p_clport:Short:%d\n", preferences.getShort("p_clport", 80));
        file.printf("p_clchain:String:%s\n", preferences.getString("p_clchain", "&p").c_str());
         
        //uint8_t byteData[] = {0x01, 0x02, 0x03, 0x04};
        //preferences.putBytes("byteData", byteData, sizeof(byteData));

      file.close();
      Serial.println("[KY] Key Preferences saved to SPIFFS");
   }

   preferences.end();

}


    void restorePreferencesFromSPIFFS(bool restore) {
      File file = SPIFFS.open(dateiGrSP, "r");
      if (!file) {
        file = SPIFFS.open(dateiGrSP, FILE_WRITE);
        file.print("0");
        file.close();
        file = SPIFFS.open(dateiGrSP, "r");
      }

      Preferences preferences;
      if (restore) {
        preferences.begin("eenvs", false);
      }

    while (file.available()) {
        String line = file.readStringUntil('\n');
        int firstSeparatorIndex = line.indexOf(':');
        int secondSeparatorIndex = line.indexOf(':', firstSeparatorIndex + 1);
        String key = line.substring(0, firstSeparatorIndex);
        String type = line.substring(firstSeparatorIndex + 1, secondSeparatorIndex);
        String value = line.substring(secondSeparatorIndex + 1);

        if (type == "String") {
            if (restore) {
                preferences.putString(key.c_str(), value.c_str());
                Serial.printf("[KY] Restored: %s: %s\n", key.c_str(), value.c_str());
            } else {
                //Serial.printf("[KY] Read: %s: %s\n", key.c_str(), value.c_str());
            }
            //Serial.println(F(" "));
        } else if (type == "UInt") {
            if (restore) {
                preferences.putUInt(key.c_str(), value.toInt());
                Serial.printf("[KY] Restored: %s: %u\n", key.c_str(), (unsigned int)value.toInt());
            } else {
                //Serial.printf("[KY] Read: %s: %u\n", key.c_str(), (unsigned int)value.toInt());
            }
            //Serial.println(F(" "));
        } else if (type == "UChar") {
            if (restore) {
                preferences.putUChar(key.c_str(), value.toInt());
                Serial.printf("[KY] Restored: %s: %u\n", key.c_str(), (unsigned int)value.toInt());
            } else {
                //Serial.printf("[KY] Read: %s: %u\n", key.c_str(), (unsigned int)value.toInt());
            }
            //Serial.println(F(" "));
        } else if (type == "Bool") {
            if (restore) {
                preferences.putBool(key.c_str(), value.toInt());
                Serial.printf("[KY] Restored: %s: %d\n", key.c_str(), (int)value.toInt());
            } else {
                //Serial.printf("[KY] Read: %s: %d\n", key.c_str(), (int)value.toInt());
            }
            //Serial.println(F(" "));
        } else if (type == "UShort") {
            if (restore) {
                preferences.putUShort(key.c_str(), value.toInt());
                Serial.printf("[KY] Restored: %s: %u\n", key.c_str(), (unsigned int)value.toInt());
            } else {
                //Serial.printf("[KY] Read: %s: %u\n", key.c_str(), (unsigned int)value.toInt());
            }
            //Serial.println(F(" "));
        } else if (type == "ULong64") {
            if (restore) {
                preferences.putULong64(key.c_str(), value.toInt());
                Serial.printf("[KY] Restored: %s: %llu\n", key.c_str(), (unsigned long long)value.toInt());
            } else {
                //Serial.printf("[KY] Read: %s: %llu\n", key.c_str(), (unsigned long long)value.toInt());
            }
            //Serial.println(F(" "));
        } else if (type == "Char") {
            if (restore) {
                preferences.putChar(key.c_str(), value.toInt());
                Serial.printf("[KY] Restored: %s: %d\n", key.c_str(), (int)value.toInt());
            } else {
                //Serial.printf("[KY] Read: %s: %d\n", key.c_str(), (int)value.toInt());
            }
            //Serial.println(F(" "));
        } else if (type == "Short") {
            if (restore) {
                preferences.putShort(key.c_str(), value.toInt());
                Serial.printf("[KY] Restored: %s: %d\n", key.c_str(), (int)value.toInt());
            } else {
                //Serial.printf("[KY] Read: %s: %d\n", key.c_str(), (int)value.toInt());
            }
            //Serial.println(F(" "));
        } else if (type == "Int") {
            if (restore) {
                preferences.putInt(key.c_str(), value.toInt());
                Serial.printf("[KY] Restored: %s: %d\n", key.c_str(), (int)value.toInt());
            } else {
                //Serial.printf("[KY] Read: %s: %d\n", key.c_str(), (int)value.toInt());
            }
            //Serial.println(F(" "));
        } else if (type == "Long") {
            if (restore) {
                preferences.putLong(key.c_str(), value.toInt());
                Serial.printf("[KY] Restored: %s: %ld\n", key.c_str(), (long)value.toInt());
            } else {
                //Serial.printf("[KY] Read: %s: %ld\n", key.c_str(), (long)value.toInt());
            }
            //Serial.println(F(" "));
        } else if (type == "ULong") {
            if (restore) {
                preferences.putULong(key.c_str(), value.toInt());
                Serial.printf("[KY] Restored: %s: %lu\n", key.c_str(), (unsigned long)value.toInt());
            } else {
                //Serial.printf("[KY] Read: %s: %lu\n", key.c_str(), (unsigned long)value.toInt());
            }
            //Serial.println(F(" "));
        } else if (type == "Long64") {
            if (restore) {
                preferences.putLong64(key.c_str(), value.toInt());
                Serial.printf("[KY] Restored: %s: %lld\n", key.c_str(), (long long)value.toInt());
            } else {
                //Serial.printf("[KY] Read: %s: %lld\n", key.c_str(), (long long)value.toInt());
            }
            //Serial.println(F(" "));
        } else if (type == "Float") {
            if (restore) {
                preferences.putFloat(key.c_str(), value.toFloat());
                Serial.printf("[KY] Restored: %s: %f\n", key.c_str(), value.toFloat());
            } else {
                //Serial.printf("[KY] Read: %s: %f\n", key.c_str(), value.toFloat());
            }
            //Serial.println(F(" "));
        } else if (type == "Double") {
            if (restore) {
                preferences.putDouble(key.c_str(), value.toDouble());
                Serial.printf("[KY] Restored: %s: %f\n", key.c_str(), value.toDouble());
            } else {
                //Serial.printf("[KY] Read: %s: %f\n", key.c_str(), value.toDouble());
            }
            //Serial.println(F(" "));
        } else if (type == "Bytes") {
            // Hier müsstest du die Bytes entsprechend verarbeiten
            // uint8_t byteData[4];
            // for (int i = 0; i < 4; i++) {
            //   byteData[i] = strtol(value.substring(i * 2, i * 2 + 2).c_str(), NULL, 16);
            // }
            // if (restore) {
            //   preferences.putBytes(key.c_str(), byteData, sizeof(byteData));
            // }
            if (restore) {
                Serial.printf("[KY] Restored: %s: %s\n", key.c_str(), value.c_str());
            } else {
                //Serial.printf("[KY] Read: %s: %s\n", key.c_str(), value.c_str());
            }
            //Serial.println(F(" "));
        }
    }

      file.close();
      //Serial.println(F(" "));
            if (restore) {
                Serial.println("[KY] Preferences restored from SPIFFS");
            } else {
                Serial.println("[KY] Preferences gelesen aus SPIFFS");
            }

      if (restore) {
        preferences.end();
      }
    }


      const uint8_t ledPin20 = 20;   //   GPIO20 Reserve

      // -------   PWM   -------
      // the number of the LED pin
      const uint8_t ledPin   =  4;  //   GPIO04  DP
      const uint8_t ledPin2  = 21;  //   GPIO02  Bq/m³
      const uint8_t ledPin15 = 14;  //   GPIO15  PcI/L
      const uint8_t ledPin27 = 5;  //   GPIO27  AM
      const uint8_t ledPin25 = 1;   //   GPIO25  PM
      const uint8_t ledPin26 = 38;   //   GPIO26  NTP
      const uint8_t ledPin14 = 2;   //   GPIO14  WLAN
      int buzzerPin = 3;            //   GPIO13  Summer
      #define PINn 48               //   GPIO32  NEOPixel  

      #define I2C_SCL 15
      #define I2C_SDA 16

      // SPI
      #define MOSI 40        //GPIO 40
      #define DIN 41         //GPIO 41
      #define CLK 39         //GPIO 39
      #define CS 42          //GPIO 42
      //Die CS Pins für die einzelnen Zeilen
      #define CS_BOTTOM 42  //GPIO 42
      //#define CS_TOP XX  // GPIO xx

      // neue platine 11 10
      #define Serial1_RXPIN 18             //GPIO 11 receive   UART2    gelb  
      #define Serial1_TXPIN 17             //GPIO 10 transmit  UART2    grün   

      const uint8_t WTD_toggle = 19;   //   GPIO33 Watchdog Toggle
      const uint8_t WTD_Set = 47;      //   GPIO12 Watchdog Set      0 = Disable   1 = Enable
      bool WTD_tick = false; 
      bool FW_tick = false;  

      uint8_t ledPin26c;
      uint8_t ledPin27c;



      // setting PWM properties
      const int freq = 5000;
      const uint8_t ledChannel   = 0;  //   dp
      const uint8_t ledChannel2  = 1;  //   GPIO02  Bq/m³
      const uint8_t ledChannel15 = 2;  //   GPIO15  PcI/L
      const uint8_t ledChannel27 = 3;  //   GPIO27  AM
      const uint8_t ledChannel25 = 4;  //   GPIO25  PM
      const uint8_t ledChannel26 = 5;  //   GPIO26  NTP
      const uint8_t ledChannel14 = 6;  //   GPIO14  WLAN
      const uint8_t Channel13 = 7;  //   GPIO13  Buzzer



 


      /**
       * Play a simple melody hard-coded in the sketch.
       *
       * You can observe the difference between the blocking play(..),
       * which blocks the sketch for the entire duration of the melody, and
       * playAsync(..) which returns immediately.
       */
      #include <melody_player.h>
      #include <melody_factory.h>

      
      bool startplayer = false;

      // specify the buzzer's pin and the standby voltage level
      MelodyPlayer player(buzzerPin, Channel13, HIGH);

     int timeUnit0 = 200;
     const int nNotes0 = 3;

      unsigned long startPlay = millis();
      int statep = 0;
      bool alarm_sound;
      bool alarm_sound_sperre = true; //erstmal aus





      const int resolution = 8;
      byte dutyCycle = 150;
      byte dutyCycle_dp = 150;
      byte dutyCycle_t = 0;
      byte dutyCycle_t215 = 150;
      byte dutyCycle_t215_temp;
      // -------   PWM   -------


      bool wlan_led_hell_calc;






        const char* dateiGr13 = "/things13.txt";  //     dateiGr13  
        String things_list_t = "                                                                                                   ";
        uint16_t charcount13, charcount13_t,charcount13_w,count13fehlt,g13FileRead,must_transfer3;
        bool gcharcount13read = true;
        bool gLostvaluesFlag = false;
        bool gLostuploadlag = false;


        const char* dateiGr14 = "/things14.txt"; 
        //String things_list_t_14 = "                                                                                                   ";
        char things_list_t_14[50]; // Puffer für das formattierte Datum, Uhrzeit und Radon-Wert
        const char* dateiGr15 = "/things15.txt"; 
        //String things_list_t_15 = "                                                                                                   ";
        char things_list_t_15[50]; // Puffer für die Kopie, gleiche Größe wie things_list_t_14

        char things_list_web[18]; // "00.00.00 00:00" + Nullterminator = 18 Zeichen

        const uint16_t v_count_gh = 365*24; 




              void setLedPins(uint8_t newLedPin26, uint8_t newLedPin27) {
                /*
                Preferences preferences;
                preferences.begin("eenvs", false);
                preferences.putUChar("ledPin26", newLedPin26);
                preferences.putUChar("ledPin27", newLedPin27);
                delay(50);
                // Lade die neuen Pin-Nummern
                ledPin26c = preferences.getUChar("ledPin26", 27); 
                ledPin27c = preferences.getUChar("ledPin27", 26); 
                preferences.end();

                // Konfiguriere LED PWM Funktionalitäten
                ledcSetup(ledChannel26, freq, resolution);
                ledcSetup(ledChannel27, freq, resolution);

                // Verbinde die Kanäle mit den GPIOs
                ledcAttachPin(ledPin26c, ledChannel26);
                ledcAttachPin(ledPin27c, ledChannel27);

                int dutyCycle = 0;
                ledcWrite(ledChannel26, dutyCycle);
                ledcWrite(ledChannel27, dutyCycle);
                */
              }




     //**************************************************************************
/*
        const char *root_cert =
        "-----BEGIN CERTIFICATE-----\n"
        "MIIFWjCCA0KgAwIBAgIQbkepxlqz5yDFMJo/aFLybzANBgkqhkiG9w0BAQwFADBH\n"
        "MQswCQYDVQQGEwJVUzEiMCAGA1UEChMZR29vZ2xlIFRydXN0IFNlcnZpY2VzIExM\n"
        "QzEUMBIGA1UEAxMLR1RTIFJvb3QgUjIwHhcNMTYwNjIyMDAwMDAwWhcNMzYwNjIy\n"
        "MDAwMDAwWjBHMQswCQYDVQQGEwJVUzEiMCAGA1UEChMZR29vZ2xlIFRydXN0IFNl\n"
        "cnZpY2VzIExMQzEUMBIGA1UEAxMLR1RTIFJvb3QgUjIwggIiMA0GCSqGSIb3DQEB\n"
        "AQUAA4ICDwAwggIKAoICAQDO3v2m++zsFDQ8BwZabFn3GTXd98GdVarTzTukk3Lv\n"
        "CvptnfbwhYBboUhSnznFt+4orO/LdmgUud+tAWyZH8QiHZ/+cnfgLFuv5AS/T3Kg\n"
        "GjSY6Dlo7JUle3ah5mm5hRm9iYz+re026nO8/4Piy33B0s5Ks40FnotJk9/BW9Bu\n"
        "XvAuMC6C/Pq8tBcKSOWIm8Wba96wyrQD8Nr0kLhlZPdcTK3ofmZemde4wj7I0BOd\n"
        "re7kRXuJVfeKH2JShBKzwkCX44ofR5GmdFrS+LFjKBC4swm4VndAoiaYecb+3yXu\n"
        "PuWgf9RhD1FLPD+M2uFwdNjCaKH5wQzpoeJ/u1U8dgbuak7MkogwTZq9TwtImoS1\n"
        "mKPV+3PBV2HdKFZ1E66HjucMUQkQdYhMvI35ezzUIkgfKtzra7tEscszcTJGr61K\n"
        "8YzodDqs5xoic4DSMPclQsciOzsSrZYuxsN2B6ogtzVJV+mSSeh2FnIxZyuWfoqj\n"
        "x5RWIr9qS34BIbIjMt/kmkRtWVtd9QCgHJvGeJeNkP+byKq0rxFROV7Z+2et1VsR\n"
        "nTKaG73VululycslaVNVJ1zgyjbLiGH7HrfQy+4W+9OmTN6SpdTi3/UGVN4unUu0\n"
        "kzCqgc7dGtxRcw1PcOnlthYhGXmy5okLdWTK1au8CcEYof/UVKGFPP0UJAOyh9Ok\n"
        "twIDAQABo0IwQDAOBgNVHQ8BAf8EBAMCAQYwDwYDVR0TAQH/BAUwAwEB/zAdBgNV\n"
        "HQ4EFgQUu//KjiOfT5nK2+JopqUVJxce2Q4wDQYJKoZIhvcNAQEMBQADggIBALZp\n"
        "8KZ3/p7uC4Gt4cCpx/k1HUCCq+YEtN/L9x0Pg/B+E02NjO7jMyLDOfxA325BS0JT\n"
        "vhaI8dI4XsRomRyYUpOM52jtG2pzegVATX9lO9ZY8c6DR2Dj/5epnGB3GFW1fgiT\n"
        "z9D2PGcDFWEJ+YF59exTpJ/JjwGLc8R3dtyDovUMSRqodt6Sm2T4syzFJ9MHwAiA\n"
        "pJiS4wGWAqoC7o87xdFtCjMwc3i5T1QWvwsHoaRc5svJXISPD+AVdyx+Jn7axEvb\n"
        "pxZ3B7DNdehyQtaVhJ2Gg/LkkM0JR9SLA3DaWsYDQvTtN6LwG1BUSw7YhN4ZKJmB\n"
        "R64JGz9I0cNv4rBgF/XuIwKl2gBbbZCr7qLpGzvpx0QnRY5rn/WkhLx3+WuXrD5R\n"
        "RaIRpsyF7gpo8j5QOHokYh4XIDdtak23CZvJ/KRY9bb7nE4Yu5UC56GtmwfuNmsk\n"
        "0jmGwZODUNKBRqhfYlcsu2xkiAhu7xNUX90txGdj08+JN7+dIPT7eoOboB6BAFDC\n"
        "5AwiWVIQ7UNWhwD4FFKnHYuTjKJNRn8nxnGbJN7k2oaLDX5rIMHAnuFl2GqjpuiF\n"
        "izoHCBy69Y9Vmhh1fuXsgWbRIXOhNUQLgD1bnF5vKheW0YMjiGZt5obicDIvUiLn\n"
        "yOd/xCxgXS/Dr55FBcOEArf9LAhST4Ldo/DUhgkC\n"
        "-----END CERTIFICATE-----\n";
*/



      #ifdef httpscloud
        //#include "WiFiClientSecure.h"
      #endif

     const char* dateiGr12 = "/cloud12.txt";//                                dateiGr12  

      String p_cloudonoff = "off";


      //#define CLOUD_USER_LEN     20
      //String p_inputclouduser = "user";
      //char p_inputclouduserc[CLOUD_USER_LEN+1] = "user";

      //#define CLOUD_DEVICE_LEN     5
      //String p_inputclouddevice = "5487";
      //char p_inputclouddevicec[CLOUD_DEVICE_LEN+1] = "5487";

      //#define CLOUD_KEY_LEN     40
      //String p_inputcloudkey = "3as44643euW";
      //char p_inputcloudkeyc[CLOUD_KEY_LEN+1] = "3as44643euW";

      //#define CLOUD_inter_LEN     2
      //String p_inputcloudinter = "15";
      //char p_inputcloudinterc[CLOUD_inter_LEN+1] = "15";
      //uint16_t p_inputcloudinteri = 15; 


      char wlanstatusMessage[100]; // Puffer für die Statusnachricht


      //-------------------
      uint8_t g_Cloud_ea_ist;  // 0=Standard   Cloud Ein Aus
      uint8_t g_Cloud_ea_soll;  // 0=Standard   Cloud Ein Aus
      uint8_t lora_change_bt;
      uint8_t json_aktiv = 1;
      uint8_t xml_aktiv  = 1;
     
      #define CLOUD_SERVER_LEN     40
      String p_inputcloudserver = "radoncloud.com";
      char p_inputcloudserverc[CLOUD_SERVER_LEN+1] = "radoncloud.com";

      #define DB_PAGE_LEN 80
      String p_inputcloudpage = "LoRaWAN-Live-Link-K1-W33rt22bd11np00L/lora_radon.php";
      //char p_inputcloudpagec[DB_PAGE_LEN+1] = "LoRaWAN-Live-Link-K1-W64rt39bd41np75L/lora_radon_alphatracer_1.php";  

      #define DB_PRE_LEN 40
      //String p_inputcloudpre = "submit=Daten";
      char p_inputcloudprec[DB_PRE_LEN+1] = "submit=Daten";  

      #define DB_CHAIN_LEN 6
      String p_inputcloudchain = "&p";
      //char p_inputcloudchainc[DB_CHAIN_LEN+1] = "&p"; 

      //#define DB_PORT_LEN 4
      //String p_inputcloudport = "80";
      //char p_inputcloudportc[DB_PORT_LEN+1] = "80"; 
      //-------------------

      int16_t p_inputcloudporti = 80;

      //                     http://loragate2.de/LoRaWAN-Live-Link-K1-W64rt39bd41np75L/lora_radon_alphatracer_1.php?submit=Daten&p0=1721485815&p1=5&p2=74:42:7F:4A:A5:4B&p3=HB0798E0&p4=11&p5=11&p6=156 
      //                     https://loragate2.de/LoRaWAN-Live-Link-K1-W64rt39bd41np75L/lora_radon_alphatracer_1.php
      String cloud_result = "https://loragate2.de/LoRaWAN-Live-Link-K1-W64rt39bd41np75L/lora_radon_alphatracer_1.php?submit=Daten&p0=1680496727&p1=127&p2=74:42:7F:4A:A5:4B&p3=TD474968&p4=121&p5=123&p6=2880";


        uint8_t cloud_list_count = 1;   //start bei 1
        bool g_save_cloudlist = false;
        bool g_write_cloudlist = false;   // gerade wird angefangen schreiben in cloud
        bool g_abort_cloudlist_2 = false; // abbruch beim schreiben
        uint8_t i_secure;
        bool g_i_secure = false;
        uint16_t must_transferC;

        bool gcharcount12Del = false;
        uint16_t charcount12, charcount12_t,charcount12_w,count12fehlt,g12FileRead;
        uint16_t cloud_connect_error_count = 0;
        
        String sendValueStr2 = "                                                                                                   ";
        // Definiere sendValueStr2b im PSRAM
        //String* sendValueStr2b;
        
        uint8_t gReboot_TOKENFlag = 0;    // nur neu Speichern wenn Zeit abgelaufen ist







 //*******************************************************************************
  void datei_lesen_line12()
  {
      String data;
      uint16_t zeilenZaehler = 0;
      int i = 0;
      File file = SPIFFS.open(dateiGr12, "r");
      

      if(!file){

          // Die Datei ist nicht vorhanden
          #ifdef NVS_cloud_DEBUG
            Serial.println("Die Datei " + String(dateiGr12) + " existiert nicht!");
          #endif 
          // Datei mit Schreibrechten öffnen, wird erstellt wenn nicht vorhanden
          File file = SPIFFS.open(dateiGr12, FILE_WRITE);
          #ifdef NVS_cloud_DEBUG
            Serial.println("Datei " + String(dateiGr12) + " wurde erstellt!");
          #endif
          // Daten in die Datei schreiben
          file.print("0");
          // Schließen der Datei
          file.close();

          // erneut öffnen für lesen 
          file = SPIFFS.open(dateiGr12, "r");
        
      }



      #ifdef NVS_cloud_DEBUG
        Serial.println("Lese Daten aus Cloud Datei:");
      #endif

      while(file.available()) {
        data = file.readStringUntil('\n'); // lesen bis Zeilenumbruch...
        #ifdef NVS_cloud_DEBUG
          Serial.print("r Zeile ");
          Serial.print(zeilenZaehler);
          Serial.print(": ");
          Serial.println(data);           // ... und wieder ausgegeben
        #endif
        //cloud_list[i] = data;      
        i++;
        zeilenZaehler++;
      } 

          charcount12 = zeilenZaehler;
          charcount12_t = charcount12;

      //cloud_list_count = cloud_list[0].toInt();
      
      #ifdef NVS_cloud_DEBUG
      // Ausgabe der Nachricht
      Serial.print("--> ");
      Serial.print(p_uhrzeit);
      Serial.print(" | Aktueller Cloud read Zeilen Zähler: ");
      Serial.println(charcount12);

      #endif

      file.close();
      #ifdef NVS_cloud_DEBUG
        //Serial.println(F(" "));
      #endif

  }




  void datei_schreiben12()   // FILE_APPEND
  {
    File file = SPIFFS.open(dateiGr12, FILE_APPEND);
    
    //Serial.println("[IF] Speichere Daten in Cloud Datei: " + sendValueStr2); 
     
    if(!file){
        // Die Datei ist nicht vorhanden
        #ifdef NVS_cloud_DEBUG
          Serial.println("Die Datei " + String(dateiGr12) + " existiert nicht!");
        #endif 
        // Datei mit Schreibrechten öffnen, wird erstellt wenn nicht vorhanden
        File file = SPIFFS.open(dateiGr12, FILE_WRITE);
        #ifdef NVS_cloud_DEBUG
          Serial.println("Datei " + String(dateiGr12) + " wurde erstellt!");
        #endif
        // Daten in die Datei schreiben
        file.print("");
        // Schließen der Datei
        file.close();
      }else{
          // Die Datei ist vorhanden


            file.print(sendValueStr2 + "\n"); 
    
             #ifdef NVS_cloud_DEBUG
                //Serial.println("Cloud w Zeile  : " + cloud_list_t);           // ... und ausgegeben 
             #endif


          file.close();       
      }
  }






   //-------------------------------------------------------------------------------------------
      void loescheDateiFuerNeuenMonat(uint8_t monat) {
          String dateiName = "/data_" + String(monat) + ".txt";
          if (SPIFFS.exists(dateiName)) {
              SPIFFS.remove(dateiName);
              Serial.println("Datei entfernt: " + dateiName);
          }
      }
   //-------------------------------------------------------------------------------------------



   //-------------------------------------------------------------------------------------------
      #define MAX_SAMPLES_m 4320 // Anzahl der Messungen pro Monat (10 Minuten Auflösung)
      #define MONTHS 12 // Anzahl der Monate im Jahr
      #define BUFFER_SIZEm 512 // Größe des Puffers

      void aktualisiereMesswertemonate(uint32_t neuerMesswert, uint8_t monat) {
          Preferences preferences;
          preferences.begin("eenvs", false); // Ordner eenvs anlegen/verwenden


          // Laden des vorherigen Monats aus den Präferenzen
          previousMonth = preferences.getUInt("previousMonth", 255); // 255 als ungültiger Monat

          // Überprüfen, ob der Monat gewechselt hat
          if (monat != previousMonth) {
              loescheDateiFuerNeuenMonat(monat);
              previousMonth = monat;
              preferences.putUInt("previousMonth", previousMonth); // Speichern des neuen Monats
          }

          // Fügen Sie den neuen Messwert zum Puffer hinzu
          uint32_t bufferIndexm = preferences.getUInt("bufferIndexm", 0);
          preferences.putUInt(("buffer_" + String(bufferIndexm)).c_str(), neuerMesswert);
          ++bufferIndexm;

          // Debug-Ausgabe
          //Serial.println("Aktueller Pufferindex: " + String(bufferIndexm));
          //Serial.println("Neuer Messwert: " + String(neuerMesswert));

          // Wenn der Puffer voll ist, schreiben Sie ihn in eine Datei
          if (bufferIndexm >= MAX_SAMPLES_m) {
              File dataFile = SPIFFS.open("/data_" + String(monat) + ".txt", FILE_APPEND);
              //Serial.println("Daten in Datei schreiben: /data_" + String(monat) + ".txt");
              esp_task_wdt_reset();
              if (dataFile) {
                  for (uint32_t i = 0; i < BUFFER_SIZEm; ++i) {
                      uint32_t messwert = preferences.getUInt(("buffer_" + String(i)).c_str(), 0);
                      dataFile.println(messwert);

                      // Debug-Ausgabe
                      //Serial.println("Geschriebener Messwert: " + String(messwert));
                  }
                  dataFile.close();
              }
              bufferIndexm = 0;
          }
          preferences.putUInt("bufferIndexm", bufferIndexm);

          // Berechnen Sie den gleitenden Monatsmittelwert
          uint64_t summe = 0;
          uint32_t zaehler = 0;

          // Fügen Sie die Werte aus dem Puffer hinzu
          for (uint32_t i = 0; i < bufferIndexm; ++i) {
              uint32_t messwert = preferences.getUInt(("buffer_" + String(i)).c_str(), 0);
              summe += messwert;
              ++zaehler;
              esp_task_wdt_reset();

              // Debug-Ausgabe
              //Serial.println("Puffer Messwert: " + String(messwert));
          }

          // Fügen Sie die Werte aus der Datei hinzu
          File dataFile = SPIFFS.open("/data_" + String(monat) + ".txt", "r");
          if (dataFile) {
              while (dataFile.available()) {
                  uint32_t messwert = dataFile.parseInt();
                  summe += messwert;
                  ++zaehler;
                  esp_task_wdt_reset();

                  // Debug-Ausgabe
                  //Serial.println("Gelesener Messwert: " + String(messwert));
              }
              dataFile.close();
          }

          uint32_t mittelwert_monat = zaehler > 0 ? summe / zaehler : 0;
          preferences.putUInt(("mittelwert_" + String(monat)).c_str(), mittelwert_monat);

          // Debug-Ausgabe
          //Serial.println("Gleitender Monatsmittelwert: " + String(mittelwert_monat));

          // Berechnen Sie den Jahresmittelwert aus den Monatsmittelwerten
          summe = 0;
          uint8_t zaehler_monate = 0;
          for (uint8_t i = 0; i < MONTHS; ++i) {
              //Serial.println("mittelwert_ " + String(i));
              uint32_t mittelwert_monat = preferences.getUInt(("mittelwert_" + String(i)).c_str(), 0);
              esp_task_wdt_reset();
              if (mittelwert_monat > 0) { // Überprüfen Sie, ob für diesen Monat Messwerte vorhanden sind
                  summe += mittelwert_monat;
                  ++zaehler_monate;
              }
          }
          mittelwert_jahr = zaehler_monate > 0 ? summe / zaehler_monate : 0;
          preferences.putUInt("mittelwert_jahr", mittelwert_jahr);

          preferences.end();

          // Debug-Ausgabe
          //Serial.println("Gleitender Jahresmittelwert von Monate: " + String(mittelwert_jahr));
      }


    //-------------------------------------------------------------------------------------------




    //----------------------------------------  
      
    void leseMittelwerteMonate() {
        // Array mit Monatsnamen
        //const char* monatsnamen[] = {"Januar", "Februar", "März", "April", "Mai", "Juni", "Juli", "August", "September", "Oktober", "November", "Dezember"};
        
        Preferences preferences;
        preferences.begin("eenvs", false); // Ordner eenvs anlegen/verwenden

        for (uint8_t monat = 0; monat < 12; ++monat) {
            radon_mittelwert_monat[monat] = preferences.getUInt(("mittelwert_" + String(monat)).c_str(), 0);
            // Debug-Ausgabe
            //Serial.println("[IF] Mittelwert für Monat " + String(monat + 1) + " (" + String(monatsnamen[monat]) + "): " + String(radon_mittelwert_monat[monat]));
        }
        preferences.end();
    }

    //------------------------------------------





    //-------------------------------------------------------------------------------------------
    #define MAX_SAMPLES_j 51840 // Anzahl der Messungen pro Jahr
    #define BUFFER_SIZE 512 // Größe des Puffers

    void aktualisiereMesswertejahr(uint32_t neuerMesswert, bool aktualisieren) {
        Preferences preferences;
        preferences.begin("eenvs", false); // Ordner eenvs anlegen/verwenden

        uint32_t bufferIndex = preferences.getUInt("bufferIndex", 0);

        if (aktualisieren) {
            // Fügen Sie den neuen Messwert zum Puffer hinzu
            preferences.putUInt(("buffer_" + String(bufferIndex)).c_str(), neuerMesswert);
            ++bufferIndex;

            // Debug-Ausgabe
            //Serial.println("Aktueller Pufferindex: " + String(bufferIndex));
            //Serial.println("Neuer Messwert: " + String(neuerMesswert));

            // Wenn der Puffer voll ist, schreiben Sie ihn in eine Datei
            if (bufferIndex >= BUFFER_SIZE) {
                File dataFile = SPIFFS.open("/data.txt", FILE_APPEND);
                if (dataFile) {
                    for (uint32_t i = 0; i < BUFFER_SIZE; ++i) {
                        uint32_t messwert = preferences.getUInt(("buffer_" + String(i)).c_str(), 0);
                        dataFile.println(messwert);

                        // Debug-Ausgabe
                        //Serial.println("Geschriebener Messwert: " + String(messwert));
                        esp_task_wdt_reset();
                    }
                    dataFile.close();
                }
                bufferIndex = 0;
            }
            preferences.putUInt("bufferIndex", bufferIndex);
        }

        // Berechnen Sie den gleitenden Jahresmittelwert
        uint64_t summe = 0;
        uint32_t zaehler = 0;

        // Zuerst die Daten aus der Datei hinzufügen
        File dataFile = SPIFFS.open("/data.txt", "r");
        if (dataFile) {
            while (dataFile.available()) {
                uint32_t messwert = dataFile.parseInt();
                summe += messwert;
                ++zaehler;

                // Debug-Ausgabe
                //Serial.println("Gelesener Messwert: " + String(messwert));
                esp_task_wdt_reset();
            }
            dataFile.close();
        }

        // Dann die Daten aus dem Puffer hinzufügen
        for (uint32_t i = 0; i < bufferIndex; ++i) {
            uint32_t messwert = preferences.getUInt(("buffer_" + String(i)).c_str(), 0);
            summe += messwert;
            ++zaehler;
            esp_task_wdt_reset();

            // Debug-Ausgabe
            //Serial.println("Puffer Messwert: " + String(messwert));
        }

        //hier wird die Division nur durchgeführt, wenn zaehler_monate größer als 0 ist. Andernfalls wird mittelwert_jahr auf 0 gesetzt.
        radon_jahr = zaehler > 0 ? summe / zaehler : 0;
        //preferences.putUInt("radon_jahr", radon_jahr);

        // Debug-Ausgabe
        //Serial.println("Gleitender Jahresmittelwert: " + String(radon_jahr));

        // Hier können Sie den Mittelwert verwenden
        // ...
        preferences.end();
    }
    //-------------------------------------------------------------------------------------------

















      void loeschePreferences() {
          
          Preferences preferences;
          preferences.begin("eenvs", false); // Preferences initialisieren

          // Überprüfe, ob "messwert_0" vorhanden ist
          if (!preferences.isKey("messwert_0")) {
              preferences.end(); // Preferences schließen
              Serial.println("Preferences Aufzeichnungen entfernt.");
              return; // Funktion beenden, wenn "messwert_0" nicht vorhanden ist
          }

          // Überprüfe und lösche die Aufzeichnungen "messwert_0" bis "messwert_MAX_SAMPLES_241-1"
          for (uint32_t i = 0; i < 144; ++i) {
              String key = "messwert_" + String(i);
              if (preferences.isKey(key.c_str())) {
                  preferences.remove(key.c_str());
              }
          }

          // Überprüfe und lösche den Eintrag "rad_zaehler_24"
          if (preferences.isKey("rad_zaehler_24")) {
              preferences.remove("rad_zaehler_24");
          }


          preferences.end(); // Preferences schließen

          // Debug-Ausgabe
          Serial.println("Preferences Aufzeichnungen entfernt.");

      }





    //-------------------------------------------------------------------------------------------

      #define MAX_SAMPLES_24 144 // Anzahl der Messungen pro Tag

      void aktualisiereMesswerte24(uint32_t neuerMesswert, bool aktualisieren) {
          esp_task_wdt_reset();
          Preferences preferences;
          preferences.begin("eenvs", false); // Ordner eenvs anlegen/verwenden

          if (aktualisieren) {
              // Erhöhen Sie den Zähler
              rad_zaehler_24 = preferences.getUInt("rad_zaehler_24", 0);
              ++rad_zaehler_24;
              if (rad_zaehler_24 > MAX_SAMPLES_24) {
                  rad_zaehler_24 = MAX_SAMPLES_24;
              }
              preferences.putUInt("rad_zaehler_24", rad_zaehler_24);


                  for (uint8_t i = rad_zaehler_24 - 1; i > 0; --i) {
                      uint32_t messwert = preferences.getUInt(("messwert_" + String(i - 1)).c_str(), 0);
                      preferences.putUInt(("messwert_" + String(i)).c_str(), messwert);
                      esp_task_wdt_reset();
                  }


              // Fügen Sie den neuen Messwert am Anfang des Arrays hinzu
              preferences.putUInt("messwert_0", neuerMesswert);
          }

          // Berechnen Sie den neuen 24-Stunden-Mittelwert
          uint32_t summe = 0;
          for (uint32_t i = 0; i < rad_zaehler_24; ++i) {
              uint32_t messwert = preferences.getUInt(("messwert_" + String(i)).c_str(), 0);
              summe += messwert;
              // Debug-Ausgabe für jeden Messwert
              //Serial.print("Messwert["); Serial.print(i); Serial.print("]: "); Serial.println(messwert);
          }

    

              // Das bedeutet, dass radon_mittelwert_24h nur berechnet wird, wenn rad_zaehler_24 größer als 0 ist. Andernfalls wird radon_mittelwert_24h auf 0 gesetzt
              radon_mittelwert_24h = rad_zaehler_24 > 0 ? summe / rad_zaehler_24 : 0;

              // Debug-Ausgabe für den 24-Stunden-Mittelwert
              Serial.print("24-Stunden-Mittelwert: ");
              Serial.println(radon_mittelwert_24h);

              // Debug-Ausgabe für den Zähler
               Serial.print("Zähler: ");
               Serial.println(rad_zaehler_24);

              // Debug-Ausgabe für den Zähler
              //Serial.print("Zähler: "); Serial.println(rad_zaehler_24);

              preferences.end();
      }


    //-------------------------------------------------------------------------------------------



    //-------------------------------------------------------------------------------------------
      void aktualisiereMesswertelong(uint32_t neuerMesswert, bool aktualisieren) {
          // Fügen Sie den neuen Messwert zur laufenden Summe hinzu
          esp_task_wdt_reset();
          Preferences preferences;
          preferences.begin("eenvs", false); // Ordner eenvs anlegen/verwenden

          radon_zaehler_long  = preferences.getUInt("zaeradonlong", 0);
          radon_summe_long  = preferences.getULong64("summeradonlong", 0);
        
        
        if (aktualisieren) {

          radon_summe_long += neuerMesswert;

          // Debug-Ausgaben
          //Serial.println("Neuer Messwert: " + String(neuerMesswert));
          //Serial.println("Aktuelle Summe: " + String((unsigned long)radon_summe_long));


          // Erhöhen Sie den Zähler
          ++radon_zaehler_long;

          // Debug-Ausgabe
          //Serial.println("Aktueller Zähler: " + String(radon_zaehler_long));

          // Speichern Sie die aktualisierten Werte von 'radon_summe_long' und 'radon_zaehler_long'
          preferences.putULong64("summeradonlong", radon_summe_long);
          preferences.putUInt("zaeradonlong", radon_zaehler_long);
        }


          // Berechnen Sie den neuen Mittelwert

              //Das bedeutet, dass radon_mittelwert_long nur berechnet wird, wenn radon_zaehler_long größer als 0 ist. Andernfalls wird radon_mittelwert_long auf 0 gesetzt
              radon_mittelwert_long = radon_zaehler_long > 0 ? radon_summe_long / radon_zaehler_long : 0;


              // Debug-Ausgabe für den Mittelwert
              //Serial.print("Mittelwert Long: "); Serial.println(radon_mittelwert_long);


          // Debug-Ausgabe
          //Serial.println("Gleitender Mittelwert Long: " + String(radon_mittelwert_long));

          // Hier können Sie den Mittelwert verwenden
          // ...

          preferences.end();
      }

    //-------------------------------------------------------------------------------------------



    //-------------------------------------------------------------------------------------------
    void zuruecksetzen() {
      
        Preferences preferences;
        preferences.begin("eenvs", false);                         //Ordner eenvs anlegen/verwenden


        //-------------------------------
        // Setzen Sie alle Werte in 'messwerte' und 'mittelwert_24h' auf 0
        for (int i = 0; i < 144; ++i) {
            preferences.putUInt(("messwert_" + String(i < 10 ? "0" : "") + String(i)).c_str(), 0);
        }
        preferences.putUInt("mittelwert_24h", 0);
        preferences.putUInt("rad_zaehler_24", 0);
        preferences.putULong64("summeradonlong", 0);
        preferences.putUInt("zaeradonlong", 0);
        preferences.putUInt("bufferIndex", 0);
        preferences.putUInt("bufferIndexm", 0);
        preferences.putUShort("r_eintrarge", 0); 
        preferences.putUInt("previousMonth", 255); // Speichern des neuen Monats
       
        // Zeiger und Zähler in den Preferences zurücksetzen
        preferences.putBool("useFirstFile", true);
        preferences.putUInt("countFile1", 0);
        preferences.putUInt("countFile2", 0);

        ee_var_01 = 0;
        preferences.putUInt("ee_var_01", ee_var_01);  
     
       //-------------------------------


       //-------------------------------
        // Setzen Sie alle Werte in 'charInts' auf 0
        /*
        for (int i = 0; i < 49; ++i) {
            preferences.putUInt(("int" + String(i < 10 ? "0" : "") + String(i)).c_str(), 0);
        }
        */
       //-------------------------------
      

       //-------------------------------
        // Liste der Dateinamen
        //                                                                                                   dateiGr17, dateiGr18,
        //     dateiGr13 = Telemetry Data 2
        const char* dateiNamen[] = {dateiGr16, dateiGr17, dateiGr18, dateiGr12, dateiGr13, dateiGr14, dateiGr15, fileName1 , fileName2 , logFileName1 , logFileName2};

        // Berechnen Sie die Größe des Arrays
        int arraySize = sizeof(dateiNamen) / sizeof(dateiNamen[0]);

        for(int i = 0; i < arraySize; i++) {
            // Öffnen Sie die Datei im Schreibmodus
            File file = SPIFFS.open(dateiNamen[i], FILE_WRITE);
            if (!file) {
                // Fehler beim Öffnen der Datei
                Serial.println("Fehler beim Öffnen der Datei " + String(dateiNamen[i]) + " zum entfernen");
                continue;
            }
            // Schließen Sie die Datei sofort
            file.close();
        }
       //-------------------------------
           // File filew2 = SPIFFS.open(dateiGr15, FILE_WRITE);
           // filew2.close(); 



       //-------------------------------
        // Liste der Dateinamen  Grafik Webserver
        std::array<String, 16> dateinamen = {
            "00", "01", "02", "03", "04", "05", "06", "07", "08", "09", "10", "11", "12", "13", "14", "15"
        };

        // Schleife durch die Liste der Dateinamen
        for (const auto& dateiname : dateinamen) {
            // entfernen Sie jede Datei und ihre Varianten (a, b)
            preferences.putUInt(("/dgr" + dateiname + "a.txt").c_str(), 0);
            preferences.putUInt(("/dgr" + dateiname + ".txt").c_str(), 0);
            preferences.putUInt(("/dgr" + dateiname + "b.txt").c_str(), 0);
        }
       //-------------------------------



       //-------------------------------
        for (uint8_t monat = 0; monat < 12; ++monat) {
            // Setzen Sie den gespeicherten Wert auf 0
            preferences.putUInt(("mittelwert_" + String(monat)).c_str(), 0);
        }
       //-------------------------------


         Serial.println("Daten und Zähler wurden zurückgesetzt");

        preferences.end();


    }
    //-------------------------------------------------------------------------------------------










        #define MAX_SAMPLES_24_2 144 // Anzahl der Messungen pro Tag

       void aktualisiereMesswerte24_2(uint32_t neuerMesswert, bool aktualisieren) {
         
          esp_task_wdt_reset();

          Preferences preferences;
          preferences.begin("eenvs", false); // Preferences initialisieren
          
          // Zeiger aus den Preferences lesen
          bool useFirstFile = preferences.getBool("useFirstFile", true);
          uint32_t countFile1 = preferences.getUInt("countFile1", 0);
          uint32_t countFile2 = preferences.getUInt("countFile2", 0);

          if (aktualisieren) {
            // Öffnen Sie die entsprechende Datei im Anhängemodus
            const char* fileName = useFirstFile ? fileName1 : fileName2;
            File dataFile = SPIFFS.open(fileName, FILE_APPEND);
            if (dataFile) {
              dataFile.println(neuerMesswert);
              dataFile.close();
            } else {
              Serial.println("Failed to open file for appending");
            }

            // Aktualisieren Sie die Anzahl der Messwerte
            if (useFirstFile) {
              countFile1++;
              preferences.putUInt("countFile1", countFile1);
            } else {
              countFile2++;
              preferences.putUInt("countFile2", countFile2);
            }

            // Wechseln Sie die Datei, wenn die maximale Anzahl überschritten wurde
            if ((useFirstFile && countFile1 >= MAX_SAMPLES_24_2) || (!useFirstFile && countFile2 >= MAX_SAMPLES_24_2)) {
              useFirstFile = !useFirstFile;
              preferences.putBool("useFirstFile", useFirstFile);

              // Setzen Sie den Zähler der aktuellen Datei zurück und leeren Sie die Datei
              if (useFirstFile) {
                countFile2 = 0;
                preferences.putUInt("countFile2", countFile2);
                File dataFile2 = SPIFFS.open(fileName2, FILE_WRITE);
                dataFile2.close();
              } else {
                countFile1 = 0;
                preferences.putUInt("countFile1", countFile1);
                File dataFile1 = SPIFFS.open(fileName1, FILE_WRITE);
                dataFile1.close();
              }
            }
          }

          // Berechnen Sie den neuen 24_2-Stunden-Mittelwert
          uint32_t summe = 0;
          uint32_t zaehler = 0;

          // Lesen Sie die Daten aus der ersten Datei
          File dataFile1 = SPIFFS.open(fileName1, "r");
          if (dataFile1) {
            while (dataFile1.available()) {
              uint32_t messwert = dataFile1.readStringUntil('\n').toInt();
              summe += messwert;
              zaehler++;
              esp_task_wdt_reset();
            }
            dataFile1.close();
          }

          // Lesen Sie die restlichen Daten aus der zweiten Datei, falls erforderlich
          if (zaehler < MAX_SAMPLES_24_2) {
            File dataFile2 = SPIFFS.open(fileName2, "r");
            if (dataFile2) {
              while (dataFile2.available() && zaehler < MAX_SAMPLES_24_2) {
                uint32_t messwert = dataFile2.readStringUntil('\n').toInt();
                summe += messwert;
                zaehler++;
                esp_task_wdt_reset();
              }
              dataFile2.close();
            }
          }

          radon_mittelwert_24_2h = zaehler > 0 ? summe / zaehler : 0;
          radon_mittelwert_24h = radon_mittelwert_24_2h; 

          // Debug-Ausgabe für den 24_2-Stunden-Mittelwert
          //Serial.print("24_2-Stunden-Mittelwert: ");
          //Serial.println(radon_mittelwert_24_2h);

          // Debug-Ausgabe für den Zähler
          //Serial.print("Zähler: ");
         //Serial.println(zaehler);

         preferences.end();

     
        }











  //**************************************************************************
/*
void lesen_next_cloud() {
    *sendValueStr2b = p_inputcloudpre;

    *sendValueStr2b += p_inputcloudchain;
    *sendValueStr2b += "0=";
    // Date
    *sendValueStr2b += String(epochTime_mqtt);
    // Radon value
    *sendValueStr2b += p_inputcloudchain;
    *sendValueStr2b += "1=";
    *sendValueStr2b += String(mb_radon_live_32bit);
    
    // MAC
    *sendValueStr2b += p_inputcloudchain;
    *sendValueStr2b += "2=";
    *sendValueStr2b += WiFi.macAddress();

    // Tracer ID value
    *sendValueStr2b += p_inputcloudchain;
    *sendValueStr2b += "3=";
    *sendValueStr2b += String(device_id_c);

    // Radon value
    *sendValueStr2b += p_inputcloudchain;
    *sendValueStr2b += "4=";
    *sendValueStr2b += String(radon_mittelwert_24h);

    // Radon value
    *sendValueStr2b += p_inputcloudchain;
    *sendValueStr2b += "5=";
    *sendValueStr2b += String(radon_mittelwert_long);

    // Radon value
    *sendValueStr2b += p_inputcloudchain;
    *sendValueStr2b += "6=";
    *sendValueStr2b += String(mb_radon_save_eintrarge);

    //cloud_list_t = *sendValueStr2;
}
*/
 
 void lesen_next_cloud(){

    //String sendValueStr2;

      //sendValueStr2 = p_inputcloudpre;
      sendValueStr2 = String(p_inputcloudprec);


      sendValueStr2 += p_inputcloudchain;
      sendValueStr2 += "0=";
      //Date
      sendValueStr2 += String(epochTime_mqtt);  
      //Radon value
      sendValueStr2 += p_inputcloudchain;
      sendValueStr2 += "1=";
      sendValueStr2 += String(mb_radon_live_32bit);
      
      //MAC
      sendValueStr2 += p_inputcloudchain;
      sendValueStr2 += "2=";
      sendValueStr2 += WiFi.macAddress();

      //Tracer ID value
      sendValueStr2 += p_inputcloudchain;
      sendValueStr2 += "3=";
      sendValueStr2 += String(device_id_c);

      //Radon value
      sendValueStr2 += p_inputcloudchain;
      sendValueStr2 += "4=";
      sendValueStr2 += String(radon_mittelwert_24h);

      //Radon value
      sendValueStr2 += p_inputcloudchain;
      sendValueStr2 += "5=";
      sendValueStr2 += String(radon_mittelwert_long);  

      //Radon value
      sendValueStr2 += p_inputcloudchain;
      sendValueStr2 += "6=";
      sendValueStr2 += String(mb_radon_save_eintrarge);

      //cloud_list_t = sendValueStr2;


 }
 
  //**************************************************************************


   WiFiClient radonClient1;


          // Funktion zum Lesen einer Zeile mit Timeout
            String readLineWithTimeout(Client& client, unsigned long timeout, bool &success) {
                String line = "";
                unsigned long startTime = millis();
                success = false; // Standardmäßig auf false setzen
                while (millis() - startTime < timeout) {
                    while (client.available()) {
                        char c = client.read();
                        if (c == '\n') {
                            success = true; // Zeile erfolgreich gelesen
                            return line;
                        }
                        line += c;
                    }
                    delay(1); // Kleine Verzögerung, um den Watchdog nicht zu triggern
                    esp_task_wdt_reset(); // Watchdog zurücksetzen
                }
                // Timeout erreicht
                return "";
            }





        //--------------------
        void SendCloudData()
        {
              
                #ifdef RADONCLOUD_DEBUG
                    Serial.println(F("[CL] Start Cloud Datatransfer"));
                #endif

                datei_lesen_line12();
                charcount12_w = charcount12;

                // ??????????????????????
                if (gReboot_TOKENFlag == 1) {  // nur neu Speichern wenn Zeit abgelaufen ist
                    lesen_next_cloud();
                    datei_schreiben12();  // FILE_APPEND
                    charcount12_w = charcount12 + 1; // aktuell in der Datei
                    
                    #ifdef RADONCLOUD_DEBUG
                        Serial.print(F(" >| Aktueller write Zeilen Zähler: "));
                        Serial.println(charcount12_w); 
                    #endif

                    gReboot_TOKENFlag = 0;
                    Preferences preferences;
                    preferences.begin("eenvs", false);  // Ordner eenvs anlegen/verwenden
                    preferences.putUChar("p_crebbot", gReboot_TOKENFlag);      
                    preferences.end();       
                }


              


              g_write_cloudlist = false;   //gerade wird angefangen zu schreiben in cloud

              must_transferC = charcount12_w;
              cloud_connect_error_count ++;
    
                #ifdef RADONCLOUD_DEBUG
                    Serial.print(F(" >| "));
                    Serial.print(must_transferC);
                    Serial.println(F(" Zeilen gespeichert."));
                #endif

                Preferences preferences;
                preferences.begin("eenvs", false);  // Ordner eenvs anlegen/verwenden
                g12FileRead = preferences.getUShort("p_12file", 0);  // in Datei gespeicherte Zeilen lesen
                preferences.end(); 
                must_transferC = must_transferC - g12FileRead;

                #ifdef RADONCLOUD_DEBUG
                    Serial.print(F(" >| ab der Zeile "));
                    Serial.print(g12FileRead);
                    Serial.println(F(" lesen."));  
                    Serial.print(F(" >| lese "));
                    Serial.print(must_transferC);
                    Serial.println(F(" Zeilen."));  
                #endif        

                // esp_get_minimum_free_heap_size()
                if (cloud_connect_error_count > 20) {
                    cloud_connect_error_count = 0; 
                    Serial.print(F(" >| cloud_connect_error_count "));
                    Serial.print(cloud_connect_error_count);
                    Serial.println(F(" ."));                   
                    g_esp_soft_restart = true;
                }

                #ifdef RADONCLOUD_DEBUG
                if (cloud_connect_error_count > 0) {
                    Serial.print(F(" >| cloud_connect_error_count "));
                    Serial.print(cloud_connect_error_count);
                    Serial.println(F(" ."));  
                }
                #endif






                  
            //==================================            
              String data;
              uint16_t zeilenZaehler = 0;
              int ir12 = 0;
              File file = SPIFFS.open(dateiGr12, "r");



          while(file.available()) {


            data = file.readStringUntil('\n'); // lesen bis Zeilenumbruch...

            if(ir12 >= g12FileRead){

                //=======================================================  
                  //WiFiClientSecure radonClient1;
                  // radonClient1.setInsecure();  // ESP32-HTTPS-Anfragen ohne Zertifikat           
                  //radonClient1.setCACert(root_cert);          // Setze Google Fingerprint


                  //WiFiClient radonClient1;

                 
                 
                 
                  #ifdef RADONCLOUD_DEBUG
                      //Serial.println(F("-->  ") + p_uhrzeit + F(" | set Secure."));
                  #endif

                  #ifdef RADONCLOUD_DEBUG_min
                      Serial.print(F("-->  "));
                      Serial.print(p_uhrzeit);
                      Serial.print(F(" | Starting connection to server...: http= "));
                      Serial.print(p_inputcloudserverc);
                      Serial.print(F(" | Port: "));
                      Serial.println(p_inputcloudporti);
                  #endif
          
              
                //p_inputcloudporti = 80;
                if (!radonClient1.connect(p_inputcloudserverc, p_inputcloudporti)){
                    

                      g_save_cloudlist = false; //bit entfernen
          
                      g_i_secure = true;  //fehler
                      i_secure ++;

                      g_abort_cloudlist_2 = true; // abbruch beim schreiben
                      

                      #ifdef RADONCLOUD_DEBUG_min
                          Serial.print(F("-->  "));
                          Serial.print(p_uhrzeit);
                          Serial.println(F(" | Server connection failed!"));
                          Serial.print(F("-->  "));
                          Serial.print(p_uhrzeit);
                          Serial.println(F(" | Error: "));
                      #endif

                        
                         /*
                        char err_bufc[100];
                        String err_buf;
                       
                        if (radonClient1.lastError(err_bufc, 100) < 0) {
                            
                            err_buf = String(err_bufc);
                            #ifdef RADONCLOUD_DEBUG
                            Serial.println(err_buf);
                            #endif

                            // UNKNOWN ERROR CODE (0001)        bei falschem server
                            // BIGNUM - Memory allocation failed      bei server ok
                            // RSA - The public key operation failed : BIGNUM - Memory allocation failed      bei server ok
                            // X509 - The CRT/CRL/CSR format is invalid, e.g. different type expected    ohne setInsecure();

                        } else {
                          #ifdef RADONCLOUD_DEBUG
                            Serial.println("Connection error!");
                          #endif
                        }

                        int Suche = err_buf.indexOf("BIGNUM - Memory allocation failed"); 
                        if(Suche > 0 ){
                            Serial.println("---------------");
                            Serial.println("- ESP.restart -");
                            Serial.println("---------------");

                         
                        }

                        */

                        break;

                }else{
                            
                        cloud_connect_error_count = 0;

                        
                        g_i_secure = false;
                
                        #ifdef RADONCLOUD_DEBUG
                            Serial.print(F("-->  "));
                            Serial.print(p_uhrzeit);
                            Serial.println(F(" | Connected to Server erfolgreich."));
                        #endif

                        // Make a HTTP request:


                        // g12FileRead   das muss noch eingebunden werden wenn > 0
                        String client_send_str2 = "GET /" + p_inputcloudpage + "?" + data + " HTTP/1.1\r\n" + 
                                          "Host: " + p_inputcloudserver + "\r\n" + "Connection: close\r\n\r\n";
                          // Send the sensor data to the mysql server
                          #ifdef RADONCLOUD_DEBUG
                            Serial.println(client_send_str2);
                          #endif
                          radonClient1.print(client_send_str2);
                          esp_task_wdt_reset();
                          g_save_cloudlist = false; //bit entfernen
                  
                  
                            //----------------------------------------------------
                                
                                //char line[256];
                                //int index = 0;
                     
                                  String line_t = ""; 
                                  unsigned long lasttime = millis();
                                  //while (!radonClient1.available() && millis() - lasttime < 3000) {
                                      //delay(1);
                                      //esp_task_wdt_reset();
                                 // }   // wait max 3s for data

                                  unsigned long timeout = 5000; // 3 Sekunden Timeout
                                  bool success;
                                  bool exitLoop = false; // Variable zum Beenden der äußeren Schleife
                                  bool ohne_response = true;

                                  //-----------------------------
                                      while (millis() - lasttime < timeout && !exitLoop) {
                                          while (radonClient1.available()) {
                                              esp_task_wdt_reset();
                                              String line = readLineWithTimeout(radonClient1, timeout, success);
                                              if (success) {
                                                  //Serial.println("=> ") + line;
                                                  #ifdef RADONCLOUD_DEBUG
                                                  // Serial.println(line);
                                                  #endif
                                              } else {
                                                  Serial.println(F("Timeout erreicht, keine vollständige Zeile empfangen."));
                                                  //-- NICHT OPTIMAL !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
                                                  // g_save_cloudlist = true; // erfolgreich gesendet
                                                  exitLoop = true; // Äußere Schleife beenden
                                                  break; // Innere Schleife beenden
                                              }

                                              int Suche1 = line.indexOf("--OK!--"); 
                                              if (Suche1 > 0) {
                                                  g_save_cloudlist = true; // erfolgreich gesendet
                                                  exitLoop = true; // Äußere Schleife beenden
                                                  break; // Innere Schleife beenden
                                              }
                                              int Suche2 = line.indexOf("--ERROR!--"); 
                                              if (Suche2 > 0) {
                                                  // g_save_cloudlist = true; // erfolgreich gesendet
                                                  Serial.println(F("ERROR empfangen"));
                                                  exitLoop = true; // Äußere Schleife beenden
                                                  break; // Innere Schleife beenden
                                              }
                                          }
                                      }

                                  //-----------------------------

                                  if(ohne_response == true){
                                    g_save_cloudlist = true; // erfolgreich gesendet
                                  }
  

                            //----------------------------------------------------
                                              
                              if (g_save_cloudlist == true) {
                                  must_transferC--;
                                  g_write_cloudlist = true;   // gerade wird angefangen zu schreiben in cloud
                                  cloud_connect_error_count = 0;
                                  
                                  // Update the preferences only if data was successfully sent
                                  g12FileRead++;
                                  Preferences preferences;
                                  preferences.begin("eenvs", false);                         // Ordner eenvs anlegen/verwenden
                                  preferences.putUShort("p_12file", g12FileRead);            // schreibe ab dieser Zeile lesen
                                  preferences.end();
                                  
                                  #ifdef RADONCLOUD_DEBUG_min
                                      String debugMessage = String(F("-->  ")) + p_uhrzeit + String(F(" | Cloud send success, save Zeiger"));
                                      Serial.println(debugMessage); 
                                  #endif
                                  } else {
                                      if (data == "") {
                                          must_transferC--;
                                          g_write_cloudlist = true;  // gerade wird angefangen zu schreiben in cloud
                                      } // Wenn Zeile leer ist, auch abziehen.
                                      
                                      #ifdef RADONCLOUD_DEBUG_min
                                          String debugMessage = String(F("-->  ")) + p_uhrzeit + String(F(" | Cloud no reply from server! | ")) + line_t;
                                          Serial.println(debugMessage); 
                                      #endif

                              }

                  
                  
                        #ifdef RADONCLOUD_DEBUG
                          //Serial.print("RadonCloud = "); Serial.println(client_send_str2);
                        #endif

            

                      radonClient1.stop();   
                  
                  }  //radonClient1.connect              
                  
                  
           
                  esp_task_wdt_reset();              

              //======================================================= 

            }   // if(ir12 >= g12FileRead)

            ir12++;
            zeilenZaehler++;
            
          }  //while(file.available()) 


                #ifdef RADONCLOUD_DEBUG
                    Serial.print(F("-->  "));
                    Serial.print(p_uhrzeit);
                    Serial.println(F(" | File close!")); 
                #endif 

                file.close();   

                #ifdef RADONCLOUD_DEBUG
                    Serial.print(F("-->  | "));
                    Serial.print(g12FileRead);
                    Serial.print(F(" | "));
                    Serial.print(must_transferC);
                    Serial.print(F(" | "));
                    Serial.println(charcount12_w);  
                #endif

              
                
              // ist     must_transfer
              // soll    charcount12_w
                
              if(must_transferC <= 0 || g_save_cloudlist == true){
                  // alles gesendet
                  gcharcount12Del = true;        //alles aus der Datei entfernen
                  g_abort_cloudlist_2 = false;   // kein abbruch beim schreiben
                  g_write_cloudlist = false;      //schreiben ist beendet
              
                  File filew = SPIFFS.open(dateiGr12, FILE_WRITE);
                  #ifdef RADONCLOUD_DEBUG
                      Serial.print(F("Datei "));
                      Serial.print(dateiGr12);
                      Serial.println(F(" entfernen. Alles gesendet."));
                  #endif

                  cloud_connect_error_count = 0;
                  filew.close(); 

                      g12FileRead = 0; 
                      count12fehlt = 0; 
                      must_transferC = 0; 
                      charcount12_w = 0; 
                      if(g12FileRead >500){g12FileRead=500;}
                      Preferences preferences;
                      preferences.begin("eenvs", false);                         //Ordner eenvs anlegen/verwenden
                      preferences.putUShort("p_12file", g12FileRead);            //schreibe      ab dieser zeile lesen
                      preferences.end();  

              }else{
                // charcount12_w=7    must_transferC=7
                // einiges fehlt, hier z.B. nur 3 zeilen gesendet
                // 0
                // 1
                // 2

                // 3
                // 4
                // 5
                // 6

                //   3             7               7-3=4
                count12fehlt = charcount12_w - must_transferC;
                // ab Zeile 4 dann gesendet
                count12fehlt ++; 

                gcharcount12Del = false;      // nicht alles aus der Datei entfernen
                g_abort_cloudlist_2 = true;   // abbruch beim schreiben
                g_write_cloudlist = false;     //schreiben ist beendet
              
                  //-------------------------------------------

                  // hier den wert speichern um später dort zu starten
                  g12FileRead = count12fehlt-1;
                  if(g12FileRead >500){g12FileRead=500;}
                  Preferences preferences;
                  preferences.begin("eenvs", false);                         //Ordner eenvs anlegen/verwenden
                  preferences.putUShort("p_12file", g12FileRead);            //lese ab dieser zeile 
                  preferences.end();  


                  #ifdef RADONCLOUD_DEBUG
                      Serial.print(F("-->  "));
                      Serial.print(p_uhrzeit);
                      Serial.print(F(" | ENDE: ab Zeile "));
                      Serial.print(g12FileRead);
                      Serial.println(F(" muss gelesen werden."));
                  #endif
  
          

                  //-------------------------------------------
              }  
          
      
          
          
              #ifdef RADONCLOUD_DEBUG
                //Serial.println("-->  [APP] min Free memory  : " + String(esp_get_minimum_free_heap_size()) + " bytes");
                Serial.println(F("---------------------------------------------"));
                //Serial.printf("$%d %d %d;", tmp.length(), ESP.getFreeHeap(), ESP.getMaxAllocHeap());
              #endif




        }
        //--------------------




  

     //**************************************************************************





      // 02 DEC TO HEXA CONVERT
    void decToHexa(byte &num) {
        char hexString[3]; // 2 Zeichen für Hex + 1 für Nullterminator
        sprintf(hexString, "%02X", num); // In Hex umwandeln und in hexString speichern
        num = (byte)strtol(hexString, NULL, 16); // hexString zurück in Byte umwandeln
    }





     //---------------------------------------------------------------------------------

      #define GPIO_DEEP_SLEEP_DURATION 10     // sleep x seconds and then wake up
      #define GAP_ADTYPE_ADV_SCAN_IND   0x02

      //RTC_DATA_ATTR static uint32_t bootcount; // remember number of boots in RTC Memory
      //RTC_DATA_ATTR static time_t last;        // remember last boot in RTC Memory

      // See the following for generating UUIDs:
      // https://www.uuidgenerator.net/
      BLEAdvertising *pAdvertising;
      struct timeval nowTimeStruct;
      #define DEBUG

      time_t lastTenth;

      //#define BEACON_UUID  "8ec76ea3-6668-48da-9866-75be8bc86f4d" // UUID 1 128-Bit (may use linux tool uuidgen or random numbers via https://www.uuidgenerator.net/)
      #define BEACON_UUID "e32a0eee-21a2-11ee-be56-0242ac120002" // UUID 1 128-Bit (may use linux tool uuidgen or random numbers via https://www.uuidgenerator.net/)

      //#define SERVICE_UUID           0x1801
      //#define SERVICE_UUID1          0x1802
      //#define SERVICE_UUID2          0x1803

        long end_pAdvertising;
        bool g_end_pAdvertising;
      //---------------------------------------------------------------------------------



  #ifdef BLEbeacon_space


        void setBeacon_tracer() {

        char beacon_data[27];
            
            // Define the manufacturer ID for Ruuvi
            //#define TRACER_ID 0x0697

            // Define the data format byte for RuuviTag Payload Dataformat 5
            

            // Define the bitmask byte for RuuviTag Payload Dataformat 5
            // Set the bits for temperature, humidity and measurement sequence number
            //#define TRACER_BITMASK 0xC3

            // Define a custom data byte for RuuviTag Payload Dataformat 5
            //#define TRACER_CUSTOM 0x42
                  
            
            //uint16_t beconUUID = RUUVI_ID;

            //int num1 = 0;
            //int temp_raw = (int)(ESP32temp * 256); 

            //float tempFloat = random(2000, 3100) / 100.0f;

            //int hum_raw = (int)(tempFloat * 256); 



            //uint32_t mb_radon_temp = mb_radon_live_32bit;


            BLEAdvertisementData oAdvertisementData = BLEAdvertisementData();
            BLEAdvertisementData oScanResponseData  = BLEAdvertisementData();

            /*
            #define ESP_BLE_ADV_FLAG_LIMIT_DISC         (0x01 << 0)
            #define ESP_BLE_ADV_FLAG_GEN_DISC           (0x01 << 1)
            #define ESP_BLE_ADV_FLAG_BREDR_NOT_SPT      (0x01 << 2)
            #define ESP_BLE_ADV_FLAG_DMT_CONTROLLER_SPT (0x01 << 3)
            #define ESP_BLE_ADV_FLAG_DMT_HOST_SPT       (0x01 << 4)
            #define ESP_BLE_ADV_FLAG_NON_LIMIT_DISC     (0x00 )
            */

            #define TRACER_FORMAT 0xD5

            oAdvertisementData.setFlags(0x06); // GENERAL_DISC_MODE 0x02 | BR_EDR_NOT_SUPPORTED 0x04
            //oAdvertisementData.setCompleteServices(BLEUUID(beconUUID));

              // https://github.com/google/eddystone/tree/master/eddystone-url
              
            // byte mac[6]; 
              //WiFi.macAddress(mac);

              // ende 0x0CBD    https://btprodspecificationrefs.blob.core.windows.net/assigned-numbers/Assigned%20Number%20Types/Assigned_Numbers.pdf
              beacon_data[0]  = 0xAF;          
              beacon_data[1]  = 0x0D; 
            
              beacon_data[2]  = TRACER_FORMAT;  //D5     Eddystone Frame Type (Eddystone-UID)

                  // uint32_t mb_radon_live_32bit;
                  byte* bytes=(byte*) &mb_radon_live_32bit;
                  decToHexa (bytes[0]);
                  beacon_data[3] = bytes[0]; 

                  decToHexa (bytes[1]);
                  beacon_data[4] = bytes[1]; 

                  decToHexa (bytes[2]);
                  beacon_data[5] = bytes[2];  

                  decToHexa (bytes[3]);
                  beacon_data[6] = bytes[3];  



                  byte* bytes1=(byte*) &radon_mittelwert_24h;
                  decToHexa (bytes1[0]);
                  beacon_data[7] = bytes1[0]; 

                  decToHexa (bytes1[1]);
                  beacon_data[8] = bytes1[1]; 

                  decToHexa (bytes1[2]);
                  beacon_data[9] = bytes1[2];  

                  decToHexa (bytes1[3]);
                  beacon_data[10] = bytes1[3];  


                  byte* bytes2=(byte*) &radon_mittelwert_long;
                  decToHexa (bytes2[0]);
                  beacon_data[11] = bytes2[0]; 

                  decToHexa (bytes2[1]);
                  beacon_data[12] = bytes2[1]; 

                  decToHexa (bytes2[2]);
                  beacon_data[13] = bytes2[2];  

                  decToHexa (bytes2[3]);
                  beacon_data[14] = bytes2[3]; 
  
            
                  byte* bytes3=(byte*) &mb_radon_save_eintrarge;                
                  decToHexa (bytes[0]);
                  beacon_data[15] = bytes3[0]; 

                  decToHexa (bytes[1]);
                  beacon_data[16] = bytes3[1]; 


              int str_len = device_id_s.length() + 1; 
              char char_array[str_len];
              device_id_s.toCharArray(char_array, str_len);

              beacon_data[17] = char_array[0]; 
              beacon_data[18] = char_array[1]; 
              beacon_data[19] = char_array[2];
              beacon_data[20] = char_array[3];           
              beacon_data[21] = char_array[4];   
              beacon_data[22] = char_array[5];         
              beacon_data[23] = char_array[6]; 
              beacon_data[24] = char_array[7];   






              //mac_s = mac[0],HEX;

              //w_macAddress_s = String(mac[0],HEX);

            
            //oAdvertisementData.setServiceData(BLEUUID(beconUUID), std::string(beacon_data, 20));
            //2  06
            //3  9904
            //23 990405C3........
            //27 5261
            //2  03

          
                //pAdvertising->setScanResponseData(oAdvertisementData);
                //oScanResponseData.setName(p_APname_c);
                // oScanResponseData.setShortName


            oAdvertisementData.setManufacturerData(std::string(beacon_data, 26));
            //2  06
            //3  9904
            //21 05C3
            //27 5261...
            //2  03

            


            pAdvertising->setAdvertisementData(oAdvertisementData);

            //pAdvertising->setAdvertisementType(ADV_TYPE_IND);


            pAdvertising->start();


        }


#endif
//---------------------------------------------------------------------------------


unsigned long ms2 = millis();
unsigned long msshared = millis();




bool g_InitWiFi = true;
bool g_MB_abfrage_boot = true;
uint8_t count_InitWiFi = 0;
uint8_t count_InitTB = 0;
uint8_t count_subscribedSHARED = 0;
uint8_t count_subscribedSHARED2 = 0;
uint8_t count_subscribedSHARED3 = 0;
uint8_t count_subscribedSHARED4 = 0;
uint8_t count_subscribedSHARED5 = 0;

String r0_val1 ="";
String r0_val2 ="";
String r0_val3 ="";

unsigned long esp32_uptime = 0;
//String p_uptime2 = "--------";
String val3_color = "0, 0, 0, 0.3";



String bgcolor_g ="bgcolor='#009513'";
String bgcolor_o ="bgcolor='#FF8A3C'";
String bgcolor_r ="bgcolor='#FF0000'";
String bgcolor_vorgabe = "bgcolor='#009513'";

String bgcolor_vorgabeg = "bgcolor='#9F9F9F'"; //grau
String bgcolor_vorgaber = "bgcolor='#FFB3B3'"; // lell rot

uint16_t var_led_t = 9987;
uint16_t mb_radon_F3_eintrarge_last = 0;
uint16_t mb_radon_F3_Version;

String fw_myString = "0.0.0";
char fw_daten[3][2] = {"\0", "\0", "\0"};


uint16_t ledgammaVal = 200;

bool kal_vars_read;
uint8_t g_start_kalibireung = 0;  //1-12
uint8_t g_kalibrieren = 0;
uint8_t g_checken = 0;
uint8_t g_kal_write = 0;

uint8_t g_kalibriert = 0;
uint8_t g_checked = 0;


// Globale Variablen für die vorherigen Werte
char prev_tMember[20];
char prev_d_AvailableKeys[10];
uint8_t prev_g_kalibrieren;
uint8_t prev_g_checken;
uint8_t prev_g_kal_write;
bool attributesChangedFlag25;


// Globale Variablen für die vorherigen Werte
uint16_t prev_g_unit_ist;
uint16_t prev_g_LEDT_T_ist;
uint16_t prev_g_LEDT_F_ist;
uint16_t prev_g_LEDT_FB_ist;
uint16_t prev_g_LEDT_TB_ist;
bool attributesChangedFlag26;




// Globale Variablen für die vorherigen Werte
uint16_t prev_g_Range_T_ist;
uint16_t prev_g_Range_M_ist;
uint16_t prev_g_Range_U_ist;
uint16_t prev_g_u_beacon_ist;
uint16_t prev_g_u_identify_ist;
bool attributesChangedFlag27;


// Globale Variablen für die vorherigen Werte
char prev_t_strc[5];
char prev_rssi_strc[5];
char prev_t_str2c[16];
char prev_t_str3c[18];
char prev_t_str4c[18];
char prev_t_channelc[4];
bool attributesChangedFlag28;

bool g_dp_fast = false;

// Globale Variablen für die vorherigen Werte
char prev_read_SSID_String[50]; // Annahme: Maximale Länge des SSID-Strings ist 32
char prev_t_str[5];
char prev_v_timezone[32];
uint16_t prev_g_u_clock_ist;
uint16_t prev_g_u_view_switch_ist;
bool attributesChangedFlag29;



// Globale Variablen für die vorherigen Werte
char prev_fw_state_i[25]; // Annahme: Maximale Länge des fw_state_i-Strings ist 32
uint16_t prev_g_Buzzer_ist;
uint16_t prev_g_u_buzzer_ea;
bool attributesChangedFlag30;



// Globale Variablen für die vorherigen Werte
char prev_mb_Seriennummer[23]; // Annahme: Maximale Länge des Seriennummer-Strings ist 32
uint8_t prev_g_checked;
uint8_t prev_g_kalibriert;
uint32_t prev_radon_2h_ist;
uint16_t prev_g_KNX_S_ist;
bool attributesChangedFlag31;



// Globale Variablen für die vorherigen Werte
char prev_g_u_ntp1_ist[32]; // Annahme: Maximale Länge des NTP-Strings ist 32
char prev_g_u_ntp2_ist[32];
char prev_g_u_ntp3_ist[32];
bool attributesChangedFlag32;


  // Globale Variablen für die vorherigen Werte
uint8_t prev_g_Cloud_ea_ist;
char prev_p_inputcloudserver[CLOUD_SERVER_LEN+1]; // Annahme: Maximale Länge des Server-Strings ist 64
char prev_p_inputcloudpage[DB_PAGE_LEN+1]; // Annahme: Maximale Länge des Page-Strings ist 128
char prev_p_inputcloudpre[DB_PRE_LEN+1]; // Annahme: Maximale Länge des Pre-Strings ist 32
uint16_t prev_p_inputcloudporti;
char prev_p_inputcloudchain[DB_CHAIN_LEN+1]; // Annahme: Maximale Länge des Chain-Strings ist 32
bool attributesChangedFlag33;



// Globale Variable für den vorherigen Wert
uint16_t prev_mb_radon_F3_Version; // Neue Variable für das neue Attribut
bool attributesChangedFlag11;



bool attributesChangedFlag19;
// Globale Variable für den vorherigen Wert
char prev_fw_state[32]; // Annahme: Maximale Länge des fw_state-Strings ist 32



// Globale Variable für den vorherigen Wert
//char prev_d_AvailableKeys[10]; // Annahme: Maximale Länge des d_AvailableKeys-Strings ist 10
bool attributesChangedFlag12;



// Globale Variable für den vorherigen Wert
//uint8_t prev_g_checked; // Variable für das Attribut g_checked
bool attributesChangedFlag13;


// Globale Variable für den vorherigen Wert
//uint8_t prev_g_kalibriert; // Variable für das Attribut g_kalibriert
bool attributesChangedFlag14;



// Globale Variable für den vorherigen Wert
//uint32_t prev_radon_2h_ist; // Variable für das Attribut radon_2h_ist
bool attributesChangedFlag15;










// 888b    888                   8888888b.  d8b                   888 
// 8888b   888                   888   Y88b Y8P                   888 
// 88888b  888                   888    888                       888 
// 888Y88b 888  .d88b.   .d88b.  888   d88P 888 888  888  .d88b.  888 
// 888 Y88b888 d8P  Y8b d88""88b 8888888P"  888 `Y8bd8P' d8P  Y8b 888 
// 888  Y88888 88888888 888  888 888        888   X88K   88888888 888 
// 888   Y8888 Y8b.     Y88..88P 888        888 .d8""8b. Y8b.     888 
// 888    Y888  "Y8888   "Y88P"  888        888 888  888  "Y8888  888 
//******************** N E O P I X E L *******************************
#ifdef NeoPixel
  unsigned long ms1 = millis();
  unsigned long ms1v = 1000;

    // OUTPUT PIN AND NUMBER OF PIXELS
    //#define PINn 32
    #define NUM_PIXELS  4
    #define CNT 4
    Adafruit_NeoPixel strip = Adafruit_NeoPixel(NUM_PIXELS, PINn, NEO_GRB + NEO_KHZ800);
    int delayval = 500;
    uint8_t v_Brightness = 100; // Thingsboard
    uint8_t s_Brightness = 50;  // umlade VAR
    uint8_t s_Color = 4;  // 0=aus  1=rot  2=grün  3=blau  4=weiss  5=orange  6=lila 
    uint8_t old_Color = 4;

    //                       aus          rot         grün        blau           weiss           orange          lila       
    byte m_color[7][3] = {{0, 0, 0} ,{255, 0, 0}, {0, 255, 0}, {0, 0, 255}, {255, 255, 255}, {255, 90, 0}, {92, 10, 185} };

    uint8_t v_flamme = 4;

   bool g_showani = true;  // LED Animation aktivieren
      bool ani_segment_finish = false;
   bool boot_ani_off = false; 
   bool boot_ani_off2 = false;    // false = led pulsen
    uint8_t led_farbe = 0;
    uint8_t led_flame= 80;

   uint32_t reloadcounter;


    // Input a value 0 to 255 to get a color value.
    // The colours are a transition r - g - b - back to r.
    uint32_t Wheel(byte WheelPos) {
      WheelPos = 255 - WheelPos;
      if(WheelPos < 85) {
        return strip.Color(255 - WheelPos * 3, 0, WheelPos * 3);
      }
      if(WheelPos < 170) {
        WheelPos -= 85;
        return strip.Color(0, WheelPos * 3, 255 - WheelPos * 3);
      }
      WheelPos -= 170;
      return strip.Color(WheelPos * 3, 255 - WheelPos * 3, 0);
    }



    // Fill the dots one after the other with a color
    void colorWipe(uint32_t c, uint8_t wait) {
      for(uint16_t i=0; i<strip.numPixels(); i++) {
        strip.setPixelColor(i, c);
        strip.show();
        delay(wait);
      }
    }



    // alles ein mit vorgabe helligkeit
    void colorWipe2b(uint32_t c, uint8_t bright) {
      for(uint16_t i=0; i<strip.numPixels(); i++) {
        strip.setBrightness(bright);
        strip.setPixelColor(i, c);
        strip.show();
      }
    }

    void colorWipe2c(uint32_t c, uint8_t bright) {
      
        byte c0,c1,c2;
        uint32_t combined = 0; // clear it out  
        
        byte test0;     //send((byte) (theValue>>8));
        byte test1;  
        byte test2;  


          test2 = c & 0xFF;
          test1 = c >> 8 & 0xFF;
          test0 = c >> 16 & 0xFF;


        //Serial.println("a " + String(test0));  
        //Serial.println("b " + String(test1));  
        //Serial.println("c " + String(test2)); 


        //Serial.println("a " + String(c)); 
          c0 = test0;
          c1 = test1;
          c2 = test2;
        if(test0>=100){
          c0 = random(bright,test0);
        }else if(test1 >= 100) {
          c1 = random(bright,test1);
        }else if(test2 >= 100) {
          c2 = random(bright,test2);
        } 
        //Serial.println("c0 " + String(c0)); 
        combined = (c0<<16) | (c1<<8) | (c2);
        //Serial.println("a " + String(combined)); 
        
        strip.setBrightness(bright);
        strip.setPixelColor(2, combined);
        strip.show();
        //delay(5);

        
          c0 = test0;
          c1 = test1;
          c2 = test2;
        if(test0>=100){
          c0 = random(bright,test0);
        }else if(test1 >= 100) {
          c1 = random(bright,test1);
        }else if(test2 >= 100) {
          c2 = random(bright,test2);
        } 
        combined = (c0<<16) | (c1<<8) | (c2);

        strip.setPixelColor(1, combined);
        strip.show();
        //delay(5);


          c0 = test0;
          c1 = test1;
          c2 = test2;
        if(test0>=100){
          c0 = random(bright,test0);
        }else if(test1 >= 100) {
          c1 = random(bright,test1);
        }else if(test2 >= 100) {
          c2 = random(bright,test2);
        } 
        combined = (c0<<16) | (c1<<8) | (c2);

        strip.setPixelColor(3, combined);
        strip.show(); 
        //delay(5);   


          c0 = test0;
          c1 = test1;
          c2 = test2;
        if(test0>=100){
          c0 = random(bright,test0);
        }else if(test1 >= 100) {
          c1 = random(bright,test1);
        }else if(test2 >= 100) {
          c2 = random(bright,test2);
        } 
        combined = (c0<<16) | (c1<<8) | (c2);

        strip.setPixelColor(0, combined);
        strip.show();
        //delay(5);


          c0 = test0;
          c1 = test1;
          c2 = test2;
        if(test0>=100){
          c0 = random(bright,test0);
        }else if(test1 >= 100) {
          c1 = random(bright,test1);
        }else if(test2 >= 100) {
          c2 = random(bright,test2);
        } 
        combined = (c0<<16) | (c1<<8) | (c2);

        strip.setPixelColor(4, combined);
        strip.show(); 


    }


    void colorWipe2d(uint32_t c, uint8_t bright) {
      
      uint8_t r;
      
        r = random(1,bright);
        strip.setBrightness(bright);
        strip.setPixelColor(2, c);
        strip.show();
        
        r = random(1,r);
        //strip.setBrightness(r);
        strip.setPixelColor(1, c);
        strip.show();

        r = random(1,255);
        //strip.setBrightness(r);
        strip.setPixelColor(3, c);
        strip.show();    

        r = random(1,r);
        //strip.setBrightness(r);
        strip.setPixelColor(0, c);
        strip.show();

        r = random(1,r);
        //strip.setBrightness(r);
        strip.setPixelColor(4, c);
        strip.show(); 


    }


    void colorWipe2(uint32_t c) {
      for(uint16_t i=0; i<strip.numPixels(); i++) {
        strip.setPixelColor(i, c);
        strip.show();
      }
    }


    void colorWipe6(uint32_t c, uint8_t wait) {
      //for(uint16_t i=0; i<strip.numPixels(); i++) {
        uint8_t i=2;
        strip.setPixelColor(i, c);
        strip.show();
        delay(wait);
        
        i=1;
        strip.setPixelColor(i, c);
        strip.show();
        i=3;
        strip.setPixelColor(i, c);
        strip.show();    
        delay(wait);

        i=0;
        strip.setPixelColor(i, c);
        strip.show();
        i=4;
        strip.setPixelColor(i, c);
        strip.show();    
        delay(wait);    

      //}
    }





    // aus von innen nach außen
    void colorWipe3(uint32_t c, uint8_t wait) {
      //for(uint16_t i=0; i<strip.numPixels(); i++) {
        uint8_t i=2;
        strip.setPixelColor(i, 0);
        strip.show();
        delay(wait);
        
        i=1;
        strip.setPixelColor(i, 0);
        strip.show();
        i=3;
        strip.setPixelColor(i, 0);
        strip.show();    
        delay(wait);

        i=0;
        strip.setPixelColor(i, 0);
        strip.show();
        i=4;
        strip.setPixelColor(i, 0);
        strip.show();    
        delay(wait);    

      //}
    }

    void colorWipe4(uint32_t c, uint8_t wait) {
      //for(uint16_t i=0; i<strip.numPixels(); i++) {
        uint8_t i=2;
        strip.setPixelColor(i, c);
        strip.show();
        delay(wait);
        
        i=1;
        strip.setPixelColor(i, c);
        strip.show();
        i=3;
        strip.setPixelColor(i, c);
        strip.show();    
        delay(wait);

        i=0;
        strip.setPixelColor(i, c);
        strip.show();
        i=4;
        strip.setPixelColor(i, c);
        strip.show();    
        delay(wait);    

      //}
    }


    // von aussen nach innen füllen
    void colorWipe5(uint32_t c, uint8_t wait) {

        uint8_t i=2;
        
        i=0;
        strip.setPixelColor(i, c);
        strip.show();
        i=4;
        strip.setPixelColor(i, c);
        strip.show();    
        delay(wait);

        i=1;
        strip.setPixelColor(i, c);
        strip.show();
        i=3;
        strip.setPixelColor(i, c);
        strip.show();    
        delay(wait);   

        i=2;
        strip.setPixelColor(i, c);
        strip.show();    
        delay(wait); 

    }


    void rainbow(uint8_t wait) {
      uint16_t i, j;

      for(j=0; j<256; j++) {
        for(i=0; i<strip.numPixels(); i++) {
          strip.setPixelColor(i, Wheel((i+j) & 255));
        }
        strip.show();
        delay(wait);
      }
    }

    // Slightly different, this makes the rainbow equally distributed throughout
    void rainbowCycle(uint8_t wait) {
      uint16_t i, j;

      for(j=0; j<256*5; j++) { // 5 cycles of all colors on wheel
        for(i=0; i< strip.numPixels(); i++) {
          strip.setPixelColor(i, Wheel(((i * 256 / strip.numPixels()) + j) & 255));
        }
        strip.show();
        delay(wait);
      }
    }

    //Theatre-style crawling lights.
    void theaterChase(uint32_t c, uint8_t wait) {
      for (int j=0; j<10; j++) {  //do 10 cycles of chasing
        for (int q=0; q < 3; q++) {
          for (uint16_t i=0; i < strip.numPixels(); i=i+3) {
            strip.setPixelColor(i+q, c);    //turn every third pixel on
          }
          strip.show();

          delay(wait);

          for (uint16_t i=0; i < strip.numPixels(); i=i+3) {
            strip.setPixelColor(i+q, 0);        //turn every third pixel off
          }
        }
      }
    }

    //Theatre-style crawling lights with rainbow effect
    void theaterChaseRainbow(uint8_t wait) {
      for (int j=0; j < 256; j++) {     // cycle all 256 colors in the wheel
        for (int q=0; q < 3; q++) {
          for (uint16_t i=0; i < strip.numPixels(); i=i+3) {
            strip.setPixelColor(i+q, Wheel( (i+j) % 255));    //turn every third pixel on
          }
          strip.show();

          delay(wait);

          for (uint16_t i=0; i < strip.numPixels(); i=i+3) {
            strip.setPixelColor(i+q, 0);        //turn every third pixel off
          }
        }
      }
    }




    uint32_t dimColor(uint32_t color, uint8_t width) {
      return (((color&0xFF0000)/width)&0xFF0000) + (((color&0x00FF00)/width)&0x00FF00) + (((color&0x0000FF)/width)&0x0000FF);
    }

    // Using a counter and for() loop, input a value 0 to 251 to get a color value.
    // The colors transition like: red - org - ylw - grn - cyn - blue - vio - mag - back to red.
    // Entering 255 will give you white, if you need it.
    uint32_t colorWheel(byte WheelPos) {
      byte state = WheelPos / 21;
      //state = 12;
      switch(state) {
        case 0: return strip.Color(255, 0, 255 - ((((WheelPos % 21) + 1) * 6) + 127)); break;
        case 1: return strip.Color(255, ((WheelPos % 21) + 1) * 6, 0); break;
        case 2: return strip.Color(255, (((WheelPos % 21) + 1) * 6) + 127, 0); break;
        case 3: return strip.Color(255 - (((WheelPos % 21) + 1) * 6), 255, 0); break;
        case 4: return strip.Color(255 - (((WheelPos % 21) + 1) * 6) + 127, 255, 0); break;
        case 5: return strip.Color(0, 255, ((WheelPos % 21) + 1) * 6); break;
        case 6: return strip.Color(0, 255, (((WheelPos % 21) + 1) * 6) + 127); break;
        case 7: return strip.Color(0, 255 - (((WheelPos % 21) + 1) * 6), 255); break;
        case 8: return strip.Color(0, 255 - ((((WheelPos % 21) + 1) * 6) + 127), 255); break;
        case 9: return strip.Color(((WheelPos % 21) + 1) * 6, 0, 255); break;
        case 10: return strip.Color((((WheelPos % 21) + 1) * 6) + 127, 0, 255); break;
        case 11: return strip.Color(255, 0, 255 - (((WheelPos % 21) + 1) * 6)); break;

        //case 12: return strip.Color(((WheelPos % 21) + 1) * 6, 0, 0); break;
        default: return strip.Color(0, 0, 0); break;
      }
    }


    // Cycles - one cycle is scanning through all pixels left then right (or right then left)
    // Speed - how fast one cycle is (32 with 16 pixels is default KnightRider speed)
    // Width - how wide the trail effect is on the fading out LEDs.  The original display used
    //         light bulbs, so they have a persistance when turning off.  This creates a trail.
    //         Effective range is 2 - 8, 4 is default for 16 pixels.  Play with this.
    // Color - 32-bit packed RGB color value.  All pixels will be this color.
    // knightRider(cycles, speed, width, color);
    void knightRider(uint16_t cycles, uint16_t speed, uint8_t width, uint32_t color) {
      uint32_t old_val[NUM_PIXELS]; // up to 256 lights!
      // Larson time baby!
      for(int i = 0; i < cycles; i++){
        for (int count = 1; count<NUM_PIXELS; count++) {
          strip.setPixelColor(count, color);
          old_val[count] = color;
          for(int x = count; x>0; x--) {
            old_val[x-1] = dimColor(old_val[x-1], width);
            strip.setPixelColor(x-1, old_val[x-1]); 
          }
          strip.show();
          delay(speed);
        }
        for (int count = NUM_PIXELS-1; count>=0; count--) {
          strip.setPixelColor(count, color);
          old_val[count] = color;
          for(int x = count; x<=NUM_PIXELS ;x++) {
            old_val[x-1] = dimColor(old_val[x-1], width);
            strip.setPixelColor(x+1, old_val[x+1]);
          }
          strip.show();
          delay(speed);
        }
      }
    }

    void clearStrip() {
      for( int i = 0; i<NUM_PIXELS; i++){
        strip.setPixelColor(i, 0x000000); strip.show();
      }
    }




      uint32_t fire_color   = strip.Color ( 255,  255,  255);
      uint32_t off_color    = strip.Color (  0,  0,  0);

      ///
      /// Fire simulator
      ///
      class NeoFire
      {
        Adafruit_NeoPixel &strip;
      public:

        NeoFire(Adafruit_NeoPixel&);
        void Draw();
        void Clear();
        void AddColor(uint8_t position, uint32_t color);
        void SubstractColor(uint8_t position, uint32_t color);
        uint32_t Blend(uint32_t color1, uint32_t color2);
        uint32_t Substract(uint32_t color1, uint32_t color2);
      };

      ///
      /// Constructor
      ///
      NeoFire::NeoFire(Adafruit_NeoPixel& n_strip)
      : strip (n_strip)
      {
      }

      ///
      /// Set all colors
      ///
      void NeoFire::Draw()
      {
      Clear();

      for(int i=0;i<CNT;i++)
        {
        AddColor(i, fire_color);

              if(led_farbe == 1){
                led_flame = 120;   //grün
              } else if(led_farbe == 2){
                led_flame = 60;   //orange
               } else if(led_farbe == 3){
                led_flame = 80;   //rot
              } else if(led_farbe == 4){
                led_flame = 40;   //lila
               } else {
                led_flame = 20;   //weiss
              }
         
        int r = random(led_flame); 
        uint32_t diff_color = strip.Color ( r, r/2, r/2);
        SubstractColor(i, diff_color);
        }
        
      strip.show();
      }

      ///
      /// Set color of LED
      ///
      void NeoFire::AddColor(uint8_t position, uint32_t color)
      {
      uint32_t blended_color = Blend(strip.getPixelColor(position), color);
      strip.setPixelColor(position, blended_color);
      }

      ///
      /// Set color of LED
      ///
      void NeoFire::SubstractColor(uint8_t position, uint32_t color)
      {
      uint32_t blended_color = Substract(strip.getPixelColor(position), color);
      strip.setPixelColor(position, blended_color);
      }

      ///
      /// Color blending
      ///
      uint32_t NeoFire::Blend(uint32_t color1, uint32_t color2)
      {
      uint8_t r1,g1,b1;
      uint8_t r2,g2,b2;
      //uint8_t r3,g3,b3;

      r1 = (uint8_t)(color1 >> 16),
      g1 = (uint8_t)(color1 >>  8),
      b1 = (uint8_t)(color1 >>  0);

      r2 = (uint8_t)(color2 >> 16),
      g2 = (uint8_t)(color2 >>  8),
      b2 = (uint8_t)(color2 >>  0);

      return strip.Color(constrain(r1+r2, 0, 255), constrain(g1+g2, 0, 255), constrain(b1+b2, 0, 255));
      }

      ///
      /// Color blending
      ///
      uint32_t NeoFire::Substract(uint32_t color1, uint32_t color2)
      {
      uint8_t r1,g1,b1;
      uint8_t r2,g2,b2;
      //uint8_t r3,g3,b3;
      int16_t r,g,b;

      r1 = (uint8_t)(color1 >> 16),
      g1 = (uint8_t)(color1 >>  8),
      b1 = (uint8_t)(color1 >>  0);

      r2 = (uint8_t)(color2 >> 16),
      g2 = (uint8_t)(color2 >>  8),
      b2 = (uint8_t)(color2 >>  0);

      r=(int16_t)r1-(int16_t)r2;
      g=(int16_t)g1-(int16_t)g2;
      b=(int16_t)b1-(int16_t)b2;
      if(r<0) r=0;
      if(g<0) g=0;
      if(b<0) b=0;

      return strip.Color(r, g, b);
      }

      ///
      /// Every LED to black
      ///
      void NeoFire::Clear()
      {
      for(uint16_t i=0; i<strip.numPixels (); i++)
        strip.setPixelColor(i, off_color);
      }

      NeoFire fire(strip);





        void showani(uint8_t color, uint8_t brightness) {

     
            esp_task_wdt_reset(); // Watchdog-Timer zurücksetzen
            uint8_t b_Brightness = brightness; 
            uint8_t v_Color = color;      
            uint32_t combined = 0; // clear it out  
            combined = (m_color[v_Color][0]<<16) | (m_color[v_Color][1]<<8) | (m_color[v_Color][2]);

             

            // ausblenden mit alter farbe
            for(int i=b_Brightness; i>0; i--) {
              strip.setBrightness(i);
              colorWipe(strip.Color(m_color[old_Color][0], m_color[old_Color][1], m_color[old_Color][2]), 5); 
            }  
            clearStrip();
            delay(200); 
            esp_task_wdt_reset(); // Watchdog-Timer zurücksetzen





            //knightRider(3, 32, 4, 0xFF1000); // Cycles, Speed, Width, RGB Color (original orange-red)
            //knightRider(3, 32, 3, 0xFF00FF); // Cycles, Speed, Width, RGB Color (purple)
            //knightRider(3, 32, 2, 0x0000FF); // Cycles, Speed, Width, RGB Color (blue)
           
           
            // nur erste LED vor knightRider
            strip.setBrightness(b_Brightness);
            strip.setPixelColor(0, m_color[v_Color][0], m_color[v_Color][1], m_color[v_Color][2]);
            strip.show();delay(20);
            
            knightRider(1, 120, 200, combined); // Cycles, Speed, Width, RGB Color (red)
            delay(150);
            esp_task_wdt_reset(); // Watchdog-Timer zurücksetzen

            //knightRider(3, 32, 6, 0x00FF00); // Cycles, Speed, Width, RGB Color (green)
            //knightRider(3, 32, 7, 0xFFFF00); // Cycles, Speed, Width, RGB Color (yellow)
            //knightRider(3, 32, 8, 0x00FFFF); // Cycles, Speed, Width, RGB Color (cyan)
            //knightRider(3, 32, 2, 0xFFFFFF); // Cycles, Speed, Width, RGB Color (white)
            //clearStrip();
            

            // Iterate through a whole rainbow of colors
            //for(byte j=0; j<252; j+=7) {
              //knightRider(1, 16, 2, colorWheel(j)); // Cycles, Speed, Width, RGB Color
            //}
            //clearStrip();
            //delay(1000);

            //colorWipe(strip.Color(255, 0, 0), 150); // Red
            //theaterChase(strip.Color(255, 0, 0), 30); // Red
            




            // von links nach rechts füllen
            colorWipe(strip.Color(m_color[v_Color][0], m_color[v_Color][1], m_color[v_Color][2]), 100); // Red
            delay(150);

            // von mitte aus leeren
            colorWipe3(strip.Color(m_color[v_Color][0], m_color[v_Color][1], m_color[v_Color][2]), 100); // Red
            delay(150);

             esp_task_wdt_reset(); // Watchdog-Timer zurücksetzen
            // von aussen nach innen füllen
            colorWipe5(strip.Color(m_color[v_Color][0], m_color[v_Color][1], m_color[v_Color][2]), 100); // Red
            delay(150);
            


            // von mitte füllen
            //colorWipe4(strip.Color(m_color[v_Color][0], m_color[v_Color][1], m_color[v_Color][2]), 150); // Red
            //delay(200);

         
         
            // puls von Vorgabe(50) zu hell
            for(int i=b_Brightness; i<255; i++) {
              strip.setBrightness(i);
              colorWipe2(strip.Color(m_color[v_Color][0], m_color[v_Color][1], m_color[v_Color][2])); // Red
            }
          
            // puls von  hell zu dunkel
            for(int i=255; i>2; i--) {
              strip.setBrightness(i);
              colorWipe2(strip.Color(m_color[v_Color][0], m_color[v_Color][1], m_color[v_Color][2])); // Red
            }   
            esp_task_wdt_reset(); // Watchdog-Timer zurücksetzen
           
            // puls von dunkel zu hell
            for(int i=2; i<255; i++) {
              strip.setBrightness(i);
              colorWipe2(strip.Color(m_color[v_Color][0], m_color[v_Color][1], m_color[v_Color][2])); // Red
            }
            
            // puls von hell zu dunkel Vorgabe(50)
            for(int i=255; i>b_Brightness; i--) {
              strip.setBrightness(i);
              colorWipe2(strip.Color(m_color[v_Color][0], m_color[v_Color][1], m_color[v_Color][2])); // Red
            }   

        
                


            strip.setBrightness(b_Brightness);
            colorWipe(strip.Color(m_color[v_Color][0], m_color[v_Color][1], m_color[v_Color][2]), 1); // Red
            //delay(2000);
            esp_task_wdt_reset(); // Watchdog-Timer zurücksetzen

 

           old_Color = v_Color;


        }








        void showcolor(uint8_t color, uint8_t brightness) {

     
            uint8_t b_Brightness = brightness; 
            uint8_t v_Bright = brightness; 
            uint8_t v_Color = color;  
            v_flamme = color;   
            //uint32_t combined = 0; // clear it out  
            //combined = (m_color[v_Color][0]<<16) | (m_color[v_Color][1]<<8) | (m_color[v_Color][2]);



            //fire_color = strip.Color (m_color[v_Color][0]/2, m_color[v_Color][1]/2, m_color[v_Color][2]/2);
            
            //for(int i=0; i<30; i++) {
                //fire.Draw();
                //delay(random(20,150));
            //}

          if(boot_ani_off2 == false && g_now_ani_led == false){     // false = led pulsen

           // Serial.println("[IFFF] showcolor ");

            // puls von Vorgabe(50) zu hell
            for(int i=b_Brightness; i<255; i++) {
              //strip.setBrightness(i);
              v_Bright = i;
              colorWipe2b(strip.Color(m_color[v_Color][0], m_color[v_Color][1], m_color[v_Color][2]),v_Bright); // Red
            }
          
            // puls von  hell zu dunkel
            for(int i=255; i>2; i--) {
              //strip.setBrightness(i);
              v_Bright = i;
              colorWipe2b(strip.Color(m_color[v_Color][0], m_color[v_Color][1], m_color[v_Color][2]),v_Bright); // Red
            }   
           
            // puls von dunkel zu hell
            for(int i=2; i<255; i++) {
              //strip.setBrightness(i);
              v_Bright = i;
              colorWipe2b(strip.Color(m_color[v_Color][0], m_color[v_Color][1], m_color[v_Color][2]),v_Bright); // Red
            }
            
            // puls von hell zu dunkel Vorgabe(50)
            for(int i=255; i>b_Brightness; i--) {
              //strip.setBrightness(i);
              v_Bright = i;
              colorWipe2b(strip.Color(m_color[v_Color][0], m_color[v_Color][1], m_color[v_Color][2]),v_Bright); // Red
            }  


          }  //boot_ani_off2 == false
            
            strip.setBrightness(b_Brightness);
            colorWipe(strip.Color(m_color[v_Color][0], m_color[v_Color][1], m_color[v_Color][2]), 1); // Red
  

          g_now_ani_led = false;

        }




#endif
//******************** N E O P I X E L *******************************


  uint16_t g_LEDT_T_KNX = 0;  //0=Standard  Top KNX led EIN



//*********************************************************************
   void g_progLedOff()
    {

       //Serial.println("-progLedOff");
      
        //strip.setBrightness(0);
        //clearStrip(); // Initialize all pixels to 'off'

        strip.setBrightness(0);
        v_Colortknx = 0;    
        //  0=aus     1=rot   2=grün  3=blau    4=weiss    5=orange   6=lila  
        colorWipe2(strip.Color(m_color[v_Colortknx][0], m_color[v_Colortknx][1], m_color[v_Colortknx][2])); 



    }

    void g_progLedOn()
    {

       //Serial.println("-progLedOn");
       
        strip.setBrightness(130);
        v_Colortknx = 1;    
        //  0=aus     1=rot   2=grün  3=blau    4=weiss    5=orange   6=lila  
        colorWipe2(strip.Color(m_color[v_Colortknx][0], m_color[v_Colortknx][1], m_color[v_Colortknx][2])); 

    }
//*********************************************************************






//*********************************************************************
#ifdef W_PROV
void SysProvEvent(system_event_t *sys_event,wifi_prov_event_t *prov_event)
{
    if(sys_event) {
      switch (sys_event->event_id) {
      case SYSTEM_EVENT_STA_GOT_IP:
          Serial.print("\n[IF] Connected IP address : ");
          Serial.println(ip4addr_ntoa(&sys_event->event_info.got_ip.ip_info.ip));
          break;
      case SYSTEM_EVENT_STA_DISCONNECTED:
          if (count_reconn >= 59 || count_reconn == 1) {
            Serial.println("\n[IF] Disconnected. Connecting to the AP again... ");
          }
          break;
      default:
          break;
      }      
    }

    if(prov_event) {
        switch (prov_event->event) {
        case WIFI_PROV_START:
            Serial.println("\nProvisioning started\nGive Credentials of your access point using \" Android app \"");
            break;
        case WIFI_PROV_CRED_RECV: { 
            Serial.println("\nReceived Wi-Fi credentials");
            wifi_sta_config_t *wifi_sta_cfg = (wifi_sta_config_t *)prov_event->event_data;
            Serial.print("\tSSID : ");
            Serial.println((const char *) wifi_sta_cfg->ssid);
            Serial.print("\tPassword : ");
            Serial.println((char const *) wifi_sta_cfg->password);
            break;
        }
        case WIFI_PROV_CRED_FAIL: { 
            wifi_prov_sta_fail_reason_t *reason = (wifi_prov_sta_fail_reason_t *)prov_event->event_data;
            Serial.println("\nProvisioning failed!\nPlease reset to factory and retry provisioning\n");
            if(*reason == WIFI_PROV_STA_AUTH_ERROR) 
                Serial.println("\nWi-Fi AP password incorrect");
            else
                Serial.println("\nWi-Fi AP not found....Add API \" nvs_flash_erase() \" before beginProvision()");        
            break;
        }
        case WIFI_PROV_CRED_SUCCESS:
            Serial.println("\nProvisioning Successful");
            break;
        case WIFI_PROV_END:
            Serial.println("\nProvisioning Ends");
            break;
        default:
            break;
        }      
    }
}
#endif
//************************************************************************












#define siebenSegment

#ifdef siebenSegment

  #include "LedController.hpp"
  //Der Pin an dem CS angeschlossen ist
  //#define MOSI 
  //#define DIN 
  //#define CLK 
  //#define CS 

  //Die CS Pins für die einzelnen Zeilen
  //#define CS_BOTTOM 
  //#define CS_TOP 


  bool Segment_task;
  bool Segment_no_sensor;

  //Die Anzahl der in Reihe geschlossenen Segmente
  #define Segments 1

  //Die Anzahl der Ziffern pro Segment.
  //Der Wert kann aller von 1 bis 8 sein und frei geändert werden.
  #define digitsPerSegment 4

  //Eine Verschiebung, um auszuwählen auf welche Ziffern ausgegeben wird.
  //probier einfach ein paar Werte aus.
  #define positionOffset 2

  //Die Anzahl der Ziffern, die für die Darstellung von floats verwendet werden soll
  const unsigned int NUMBER_OF_DIGITS = 4;

  //LedController<1,1> lc;
  LedController<Segments,1> lc = LedController<Segments,1>();

    bool g_radon_new_seg;

    bool g_radon_new_led;
    bool g_t_led_change;
    bool g_t_led_off;
    bool g_radon_new_tb;
    bool g_radon_send_tb;
    uint8_t g_sensor_online = 3;  //0-2 = ok
    bool g_sensor_boot = false;
    bool g_Seg__boot_ani;
    bool g_wlan_read = false;
    bool set_bit_wait_front_view = false;
    bool only_one;

     bool g__boot_restart;




  //Diese Funktion berechnet die größte Zahl, die angezeigt werden kann
  unsigned long long getLargestNumber() {
    return (unsigned long long) pow(10,Segments*digitsPerSegment);
  }

  //Diese Funktion setzt die Anzeige auf eine gegebene Zahl
  void setLEDs (unsigned long long number) {
    //Diese Schleife zerlegt die Zahl und setzt die einzelnen Ziffern
    for(unsigned int i = 0; i < Segments*digitsPerSegment; i++) {
      unsigned long long divisor = 1;
      for(unsigned int j=0; j < i; j++) {
        divisor *= 10;
      }

      byte num = number/divisor % 10;
      lc.setDigit(Segments-i/digitsPerSegment-1,i%digitsPerSegment+positionOffset,num,false);
    }

  }

  //Diese Funktion kann einen float Wert auf einer 7-Segment-anzeige anzeigen.
  //Es wird die Annahme getroffen, dass der LedController nur eine Spalte hat.
  //Die gewünschte Zeile kann mit den zweiten Parameter ausgewählt werden.
  //Das dritte Parameter bestimmt die Anzahl der Stellen nach dem Komma.
  //Das vierte Parameter schiebt die angezeigte Zahl nach links.
  void displayFloat(float value, unsigned int row = 0, unsigned int decimalPlaces = 1,unsigned int digitOffset = 0){
    unsigned int total_length = NUMBER_OF_DIGITS;
    if(NUMBER_OF_DIGITS<decimalPlaces){return;};

    if(value < 0){
      lc.setChar(row,total_length-1+digitOffset,'-',false);
      total_length--;
    };

    for(unsigned int i = 0; i < decimalPlaces; i ++){
      value*=10.0f;
    }

    unsigned int v = (unsigned int) (value < 0 ? -value : value);

    for (unsigned int i = 0; i < total_length;i++){
      lc.setDigit(row,i+digitOffset,v%10,i == decimalPlaces);
      v/=10;
    }

  }


#endif




/*
void playMelody() {
  
  // iterate over the notes of the melody:
  int size = sizeof(noteDurations) / sizeof(int);

  for (int thisNote = 0; thisNote < size; thisNote++) {

    // to calculate the note duration, take one second divided by the note type.
    //e.g. quarter note = 1000 / 4, eighth note = 1000/8, etc.
    int noteDuration = 1000 / noteDurations[thisNote];
   // tone(BUZZZER_PIN, melody[thisNote], noteDuration);

    // to distinguish the notes, set a minimum time between them.
    // the note's duration + 30% seems to work well:
    int pauseBetweenNotes = noteDuration * 1.30;
    delay(pauseBetweenNotes);
    // stop the tone playing:
   // noTone(BUZZZER_PIN);

  }


}
*/

/*
void playMelody2() {

  ledcWriteTone(channel, toneFrequenz1);
  delay(PAUSE);
  ledcWriteTone(channel, toneFrequenz2);


}
*/



  //-------------------------------------------------------------- 
  // Funktion zur Anzeige der KNX-Adresse
void displayKNXAddress(int areat, int linet, int devicet) {
    
    if (linet < 10) {
     
      if (devicet >= 100) {
          lc.setChar(0,0, char(areat), true);
          lc.setChar(0,1, char(linet), true);
          lc.setChar(0,2, '-', false);
          lc.setChar(0,3, '-', false);
      } else if (devicet >= 10) {
          // Wenn devicet zweistellig ist
          lc.setChar(0,0, char(areat), true);
          lc.setChar(0,1, char(linet), true);
          lc.setChar(0,2, char(devicet / 10), false);
          lc.setChar(0,3, char(devicet % 10), false);
      } else {
          // Wenn devicet einstellig ist
          lc.setChar(0,0, ' ', false);
          lc.setChar(0,1, char(areat), true);
          lc.setChar(0,2, char(linet), true);
          lc.setChar(0,3, char(devicet), false);
      }

    }else{

      if (devicet < 10) {

        if (linet >= 100) {
            lc.setChar(0,0, char(areat), true);
            lc.setChar(0,1, '-', false);
            lc.setChar(0,2, '-', false);
            lc.setChar(0,3, char(devicet), false);
        } else if (linet >= 10) {
            // Wenn devicet zweistellig ist
            lc.setChar(0,0, char(areat), true);
            lc.setChar(0,1, char(linet / 10), false);
            lc.setChar(0,2, char(linet % 10), true);
            lc.setChar(0,3, char(devicet), false);
        } else {
            // Wenn devicet einstellig ist
            lc.setChar(0,0, ' ', false);
            lc.setChar(0,1, char(areat), true);
            lc.setChar(0,2, char(linet), true);
            lc.setChar(0,3, char(devicet), false);
        }


      }else{
        lc.setChar(0,0, '-', false);
        lc.setChar(0,1, ' ', false);
        lc.setChar(0,2, ' ', false);
        lc.setChar(0,3, '-', false);
      }

    }
    
            ledcWrite(ledChannel2, 0);     //   GPIO02  Bq/m³
            ledcWrite(ledChannel15, 0);    //   GPIO15  PcI/L  
            ledcWrite(ledChannel26, 0);    //   GPIO38  NTP
            ledcWrite(ledChannel,  0);     //   dp
}
  //--------------------------------------------------------------



void playMelody0() {

      startplayer = true;
      
      String notes[] = { "B1","B2", "B3", "B4", "B5", "B6", "B7", "B8", "B9" };
      // Create a melody
      Melody melody = MelodyFactory.load("Nice Melody", 250, notes, 9);
    
      player.playAsync(melody);
      startPlay = millis();
 
 
 
      Serial.println(String("Playing: ") + (player.isPlaying() ? "true" : "false"));


      startplayer = false;


}





void playMelody3() {

  startplayer = true;
  
  Serial.println("Loading melody...");
  //const int nNotes = 8;
  //String notes[nNotes] = { "C4", "G3", "G3", "A3", "G3", "SILENCE", "B3", "C4" };
 
  const int nNotes = 2;
  String notes[nNotes] = { "C4", "G3"};

  //const int timeUnit = 175;
  const int timeUnit = 120;
  // create a melody
  Melody melody = MelodyFactory.load("Nice Melody", timeUnit, notes, nNotes);

  // get basic info about the melody
  Serial.println(String(" Title:") + melody.getTitle());
  Serial.println(String(" Time unit:") + melody.getTimeUnit());

  Serial.print("Start playing in blocking mode... ");
  player.play(melody);
  Serial.println("Melody ends!");

  //delay(1500);

  //Serial.print("Start playing in non-blocking mode...");
  //player.playAsync(melody);
  //Serial.println(" Melody is playing!");
  //ledcWrite(buzzerPin, 255);

  //pinMode (buzzerPin, OUTPUT);
  //digitalWrite(buzzerPin, HIGH);

  //player.pause();
  player.stop();

  startplayer = false;

}


//TB#*****
// Firmware title and version used to compare with remote version, to check if an update is needed.
// Title needs to be the same and version needs to be different --> downgrading is possible


constexpr char FW_STATE_UP_TO_DATE[] PROGMEM = "currently";


// Whether the given script is using encryption or not,
// generally recommended as it increases security (communication with the server is not in clear text anymore),
// it does come with an overhead tough as having an encrypted session requires a lot of memory,
// which might not be avaialable on lower end devices.
#define ENCRYPTED false
// Whether the given script generates the deviceName from the included mac address on the WiFi chip,
// as a fallback option, if no other deviceName is given.
// If not the access token generated by the cloud will be used as the device name instead
#define USE_MAC_FALLBACK false


// PROGMEM can only be added when using the ESP32 WiFiClient,
// will cause a crash if using the ESP8266WiFiSTAClass instead.

//char WIFI_SSID[] = "FRITZ!Box 6490 Holger";
//char WIFI_PASSWORD[] = "15400240614617116002";

const char* hostping = "www.google.com";       // Oder ein anderer bekannter Server
const char* hostping2 = "www.livair.io"; // Oder ein anderer bekannter Server
bool pingFehler = true; 
bool Internt_online = false;
int fehlerZaehler = 0;  // Zähler für fehlgeschlagene Ping-Tests
bool g_force_ping;
unsigned long lastPingTime = 0;
const unsigned long pingInterval = 1200000; // 20 Minuten in Millisekunden


uint8_t p_fw_success = 0;

//const char* PARAM_INPUT_1 = "output";
//const char* PARAM_INPUT_2 = "state";
//WiFiServer server2(8080);
// Create AsyncWebServer object on port 80
#ifdef Webserver
AsyncWebServer server(80);
#endif


// Variable to store the HTTP request
//String header;
// Auxiliar variables to store the current output state
//String output26State = "off";
//String output27State = "off";
// Assign output variables to GPIO pins
//const int output26 = 26;
//const int output27 = 27;
// Previous time
unsigned long previousTime = 0; 
// Define timeout time in milliseconds (example: 2000ms = 2s)
const long timeoutTime = 2000;
// Current time
unsigned long currentTime = millis();



bool g_save_attribut;



// Thingsboard we want to establish a connection too
constexpr char THINGSBOARD_SERVER[] PROGMEM = "dashboard.livair.io";


// MQTT port used to communicate with the server, 1883 is the default unencrypted MQTT port,
// whereas 8883 would be the default encrypted SSL MQTT port
constexpr uint16_t THINGSBOARD_PORT PROGMEM = 1883U;


// Maximum size packets will ever be sent or received by the underlying MQTT client,
// if the size is to small messages might not be sent or received messages will be discarded
// constexpr uint32_t MAX_MESSAGE_SIZE PROGMEM = 128U;
// constexpr uint16_t MAX_MESSAGE_SIZE PROGMEM = 256U;
   constexpr uint16_t MAX_MESSAGE_SIZE PROGMEM = 512U;


// Baud rate for the debugging serial connection
// If the Serial output is mangled, ensure to change the monitor speed accordingly to this variable
constexpr uint32_t SERIAL_DEBUG_BAUD PROGMEM = 115200U;





// Firmware state send at the start of the firmware, to inform the cloud about the current firmware and that it was installed correctly,
// especially important when using OTA update, because the OTA update sends the last firmware state as UPDATING, meaning the device is restarting
// if the device restarted correctly and has the new given firmware title and version it should then send thoose to the cloud with the state UPDATED,
// to inform any end user that the device has successfully restarted and does actually contain the version it was flashed too
//constexpr char FW_STATE_UPDATED[] PROGMEM = "UPDATED";   //"UPDATED";


// Maximum amount of retries we attempt to download each firmware chunck over MQTT
constexpr uint8_t FIRMWARE_FAILURE_RETRIES PROGMEM = 12U;

// Size of each firmware chunck downloaded over MQTT,
// increased packet size, might increase download speed
//constexpr uint16_t FIRMWARE_PACKET_SIZE PROGMEM = 512U; 
//constexpr uint16_t FIRMWARE_PACKET_SIZE PROGMEM = 1024U; 
//constexpr uint16_t FIRMWARE_PACKET_SIZE PROGMEM = 2048U; 
//constexpr uint16_t FIRMWARE_PACKET_SIZE PROGMEM = 3072U; 
constexpr uint16_t FIRMWARE_PACKET_SIZE PROGMEM = 4096U;

uint8_t wait_bot_time = 0;

// Statuses for updating
bool currentFWSent = false;
bool updateRequestSent = false;
bool updateRequestSentu = false;
bool updateRequestSentu2 = false;
bool g_fw_dl_fail = false;

/// @brief Updated callback that will be called as soon as the firmware update finishes
/// @param success Either true (update succesfull) or false (update failed)
void updatedCallback(const bool& success) {
  
  //Serial.println("updatedCallback");
  if (success) {
  
    Serial.println(F("Done, Reboot now"));
    esp_task_wdt_reset(); 
    lc.setIntensity(15); //5=Standard   Helligkeit forne
    lc.setRow(0,0,0x00);
    lc.setChar(0,1,'Y',false);
    lc.setChar(0,2,'E',false);
    lc.setChar(0,3,'S',false);

    akt_fw_load = false;

    p_fw_success = 1;
    Preferences preferences;
    preferences.begin("eenvs", false);                         //Ordner eenvs anlegen/verwenden
    preferences.putUChar("fw_success", p_fw_success);                         //Variable speichern
    verzoegerung_fw_update = 0;
    preferences.putUChar("fw_verz_update", verzoegerung_fw_update);    //  0=Standard  aus   
    preferences.end(); 
    g_fw_dl_fail = false;

    delay(4000);

    esp_restart(); 

    return;
  }

  Serial.println(F("Downloading firmware failed"));
  g_fw_dl_fail = true;

    lc.setIntensity(15); //5=Standard   Helligkeit forne
    lc.setChar(0,0,'F',false);
    lc.setChar(0,1,'A',false);
    lc.setChar(0,2,'I',false);
    lc.setChar(0,3,'L',false);
    esp_task_wdt_reset(); 
    delay(4000);
    esp_task_wdt_reset(); 

    akt_fw_load = false;

    gFW_Update_start = 0;  // 1= neue FW verfügbar temporär entfernen

  //Callback_fail_FW
  //esp_restart();


}


  

  
      bool send_ok_data = true;
      uint8_t start_sequenz;
      bool without_time = false;
      bool data_with_time = false;

      uint32_t getfreesize;
      uint32_t getfreesize_v = 2800;
      uint32_t lastStringLength;
      unsigned long incoming_data,raw_data;
      unsigned long ag_Clock = 0;
      File fsUploadFile; 


      // Benutzername und Passwort für die Authentifizierung
      const char* http_username = "root";
      //const char* http_password1 = "admin#x2";

      WebServer server3(80);
      WebSocketsServer webSocket = WebSocketsServer(81); // WebSocket auf Port 81

      // Funktion zur Authentifizierung
      bool isAuthenticated() {
        if (!server3.authenticate(http_username, correctPassword)) {
          server3.requestAuthentication();
          return false;
        }
        return true;
      }





/// @brief Progress callback that will be called every time we downloaded a new chunk successfully
/// @param currentChunk 
/// @param totalChuncks 
void progressCallback(const uint32_t& currentChunk, const uint32_t& totalChuncks) {
  
 

      //--------------------------------------------------------  
      if(gFW_Update_start == 1 || TB_currFwVersion != TB_newFwVersion){     

              

            
            if(schreib_sperre == false){

                //Serial.println("[IF] progressCallback");
                
                strip.setBrightness(150);
                colorWipe(strip.Color(m_color[4][0], m_color[4][1], m_color[4][2]), 5);    

                Serial.print("[IF] Installierte  FW ");
                Serial.println(TB_currFwVersion); // CURRENT_FIRMWARE_VERSION     aktuall    Get_Firmware_Version()
              
                Serial.print("[IF] Neue FW in Cloud ");
                Serial.println(TB_newFwVersion); // new   



                    disable_server = 0; 
                    Preferences preferences;
                    preferences.begin("eenvs", false);                         //Ordner eenvs anlegen/verwenden
                    preferences.putUChar("g_server", disable_server);    //  1=Standard   AN 

                                           
                //verzoegerung_fw_update = 0;
                //preferences.putUChar("fw_verz_update", verzoegerung_fw_update);    //  0=Standard  aus 
                //Serial.print("[IF] ++++++++ verzoegerung_fw_update ++++++++: "); Serial.println(verzoegerung_fw_update); 
               
         
           
                preferences.putString("t_fw_version", TB_newFwVersion); 

                g_boot_fail = 1;
                preferences.putUChar("boot_g_fail", g_boot_fail);    // 

                gFW_Update_start = 1;  // neue FW verfügbar
                preferences.putUChar("fw_s_upd", gFW_Update_start);    //  0=Standard  aus 
                
                preferences.end();

                 lc.setIntensity(8); //5=Standard   Helligkeit forne

                 lc.setChar(0,0,'L',false);
                 lc.setChar(0,1,'o',false);
                 lc.setChar(0,2,'a',false);
                 lc.setChar(0,3,'d',false);
                 g_set_new_FW = true;
                 g_set_new_FW_time = 0;


               schreib_sperre = true;

            }

             
          
            
            


      }
      //----------------------------------------------------------------------------


              lc.setIntensity(15); //5=Standard   Helligkeit forne

              rest_dl = static_cast<float>(currentChunk * 100U) / totalChuncks;
              byte einer = rest_dl % 10;
              byte zehner = (rest_dl / 10) % 10;
              byte hunderter = (rest_dl / 100) % 10;
              //byte tausender = (rest_dl / 1000) % 10;
             // byte ztausender = (rest_dl / 10000) % 10;

              gFW_write = !gFW_write;

              if(rest_dl<10){
                 lc.setChar(0,0,'F',gFW_write);
                 lc.setRow(0,1,0x00);
                 lc.setRow(0,2,0x00);
                lc.setChar(0,3,char(einer),false);
              } else if(rest_dl<100){
                 lc.setChar(0,0,'F',gFW_write);
                 lc.setRow(0,1,0x00);
                lc.setChar(0,2,char(zehner),false);
                lc.setChar(0,3,char(einer),false);

              } else {
                lc.setChar(0,0,'F',gFW_write);
                lc.setChar(0,1,char(hunderter),false);
                lc.setChar(0,2,char(zehner),false);
                lc.setChar(0,3,char(einer),false);
              }




        g_set_new_FW = false;
        g_set_new_FW_time = 0;
      
      
      
      wait_bot_time = 0;
      g_end_boot_time = 30;
      
      esp_task_wdt_reset(); 


        // Zähler erhöhen
        printCounter++;
        printCounter2++;
        
        // Überprüfen, ob der Zähler 1 oder 10 erreicht hat
        if ((printCounter == 1 || printCounter % 10 == 0 || rest_dl >= 100) && printCounter_save) {
            
            printCounter_save = false;
            Serial.printf("[FW] Progress %.2f%%\n", static_cast<float>(currentChunk * 100U) / totalChuncks);Serial.println(F(" "));
            if (printCounter2 == 1 || printCounter2 % 20 == 0) {
              //printf("[AP] FREE HEAP: now: %u, contiguous: %u, lowest: %u\n",xPortGetFreeHeapSize(),heap_caps_get_largest_free_block(MALLOC_CAP_DEFAULT),xPortGetMinimumEverFreeHeapSize());//Serial.println(F(" "));
            
            }
            // Zähler zurücksetzen, wenn 10 erreicht wurde
            if (printCounter >= 10) {
                printCounter = 0;
            }
            if (printCounter2 >= 20) {
                printCounter2 = 0;
            }

        }else{
            printCounter_save = true;
        }

        akt_fw_load = true;


}

//const OTA_Update_Callback callbackota(&progressCallback, &updatedCallback, CURRENT_FIRMWARE_TITLE, CURRENT_FIRMWARE_VERSION, FIRMWARE_FAILURE_RETRIES, FIRMWARE_PACKET_SIZE);
ESP32_Updater updater;
                          // inline void Firmware_Shared_Attribute_Received(const Shared_Attribute_Data& data) {
  const OTA_Update_Callback callback(&progressCallback, &updatedCallback, CURRENT_FIRMWARE_TITLE, CURRENT_FIRMWARE_VERSION, &updater, FIRMWARE_FAILURE_RETRIES, FIRMWARE_PACKET_SIZE);
  


// See https://thingsboard.io/docs/user-guide/device-provisioning/
// to understand how to create a device profile to be able to provision a device

//constexpr char PROVISION_DEVICE_KEY[] PROGMEM = "l1326go2l2a7u0kf9g5g";      //alt
//constexpr char PROVISION_DEVICE_SECRET[] PROGMEM = "2vhwifbkmiru90hz9umb";   //

constexpr char PROVISION_DEVICE_KEY[] PROGMEM = "ufx1fnjpidki1tgj5yww";      //neu
constexpr char PROVISION_DEVICE_SECRET[] PROGMEM = "pacozuhnids4gk1grzsz";   //

// Optionally keep the device name empty and the WiFi mac address of the integrated
// wifi chip on ESP32 or ESP8266 will be used as the name instead
// Ensuring your device name is unique, even when reusing this code for multiple devices



 uint8_t ee_provision = 0;
 

 String p_tb_client_id,p_tb_username,p_tb_password;

 bool g_TB_connect_Status = false;
 bool tb_FW_update = true;
 bool tb_shared_update = false;
 bool tb_task;
 bool epoch_task;


 bool g_view_fw = true;
 long time_view_fw = 2;
 byte fw_00;
 byte fw_01;
 byte fw_02;

 bool tb_upload = false;     //nur zum testen

 bool uhrzeit_update = true;
 bool time_update = true;
 bool sperre_10Time = false;
  bool sperre_10Time2 = false;
    bool sperre_10Time3 = true;
 bool write_to_file = false;
 bool write_to_file17 = false;
 
 uint8_t write_to_file_count;
bool write_to_mqtt = false;
 




  uint16_t g_unit_ist = 1; //1=Standard   1 = bqm3  0=pCi
  uint16_t g_unit_soll = 1;    //1=Standard   1 = bqm3  0=pCi  

  uint16_t g_unitpos_ist = 1;     //0=Standard   1 = mittig
  uint16_t g_unitpos_soll = 1;    //0=Standard   1 = mittig
              
  uint16_t g_LEDT_T_ist = 1;  //1=Standard  Top led EIN
  uint16_t g_LEDT_T_soll = 1;  

  uint16_t g_LEDT_TF_ist = 1; //1=Standard   LED oben Flamme
  uint16_t g_LEDT_TF_soll = 1; 

  uint16_t g_LEDT_F_ist = 1;   //1=Standard  7 Segment  EIN
  uint16_t g_LEDT_F_soll = 1;  //1=Standard  7 Segment  EIN

  uint16_t g_KNX_S_ist = 0;   //0=Standard  0 KNX  AUS
  uint16_t g_KNX_S_soll = 0;  //0=Standard  0 KNX  AUS
 
  uint16_t g_LEDT_FB_ist = 5; //5=Standard   Helligkeit forne
  uint16_t g_LEDT_FB_soll = 5;  

  uint8_t g_LEDT_T_color;
  uint8_t currentColor = 20;
 
  uint16_t g_LEDT_TB_ist = 50;//50=Standard  Top LED Helligkeit
  uint16_t g_LEDT_TB_soll = 50;  //50=Standard  Top LED Helligkeit

  uint16_t g_Range_T_ist = 300;//300=Standard   oben Range ROT
  uint16_t g_Range_T_soll = 300; //300=Standard   oben Range ROT
 
  uint16_t g_Range_M_ist = 100;//100=Standard   mitte Range Orange
  uint16_t g_Range_M_soll = 100; //100=Standard   mitte Range Orange
 
  uint16_t g_Range_U_ist = 0; //  0=Standard   unten Range Grün
  uint16_t g_Range_U_soll = 0;  //  0=Standard   unten Range Grün

  uint16_t g_u_clock_ist = 1;  // 1= 24h   2= 12h   3=Datum
  uint16_t g_u_clock_soll = 1;  

 

  uint16_t g_Buzzer_ist = 300;        //300=Standard   Buzzer
  uint16_t g_Buzzer_soll = 300;       //300=Standard   Buzzer
  uint16_t g_u_buzzer_ea = 0;         //  0=Standard   Buzzer e/a
  uint16_t g_Buzzer_time = 0;         // Buzzer Time temp
  uint16_t g_Buzzer_time_ist = 450;   //450=Standard   Buzzer Time     450(*2s) = 15min
  uint16_t g_Buzzer_boot_time = 10; 
  
  uint16_t g_u_view_switch_ist = 2;  //   0=Radon  1= Uhr  2= Wechsel
  uint16_t g_u_view_switch_soll = 2;  
  uint8_t view_switch_time = 0;
  uint8_t g_switch_anzeige;
  




  String g_u_timezone_ist = "CET-1CEST,M3.5.0,M10.5.0/3";
  String g_u_timezone_soll = "CET-1CEST,M3.5.0,M10.5.0/3"; 

  uint16_t g_u_beacon_ist = 0;   //  0=Aus   
  uint16_t g_u_beacon_soll = 0;  //  0=Aus   


  uint16_t g_u_mez_ea_ist = 1;   //  0=Aus   
  uint16_t g_u_mez_ea_soll = 1;  //  0=Aus   


  uint16_t g_u_identify_ist = 0;   //  0=Aus   
  uint16_t g_u_identify_soll = 0;  //  0=Aus   
  bool g_identify;  
  uint8_t g_identify_byte;
  uint8_t g_identify_byte_temp;
  uint8_t identifyCounter = 0; // Zähler für die 20 Sekunden

  bool g_beacon_reset = false;
  uint8_t g_beacon_time = 30;

  uint16_t g_G00_soll,g_G00_ist;
  uint16_t g_G01_soll,g_G01_ist;
  uint16_t g_G02_soll,g_G02_ist;
  uint16_t g_G18_soll,g_G18_ist;
  uint16_t g_G19_soll,g_G19_ist;
  uint16_t g_G21_soll,g_G21_ist;

  uint16_t g_checken_soll,g_checken_ist;
  uint16_t g_kalibrieren_soll,g_kalibrieren_ist;    // 41573 = delete
  uint16_t g_kal_write_soll,g_kal_write_ist;



   uint16_t g_S00_soll;  
   uint16_t g_S01_soll; 
   uint16_t g_S02_soll; 
   uint16_t g_S18_soll; 
   uint16_t g_S19_soll; 
   uint16_t g_S21_soll; 
   uint8_t  g_time_set_kal_val,g_time_set_check_val; 
   bool b_bit_st_kal;

  bool b_calibrieren;    // Sensor öffnen
  bool b_checken;
  bool b_cal_write;
  bool b_re_checked;
  bool b_re_kalibrieren;  // Sensor ent kalibrieren
       

bool g_shared_empf_send_to_TB = false;

bool g_shared_send_after_boot = true;
bool g_other_attr;
/*
char buffer_other[300];
*/
 char buffer_other[300];


uint8_t SubscribeDone,SubscribeDone2,SubscribeDone3,SubscribeDone4,SubscribeDone5;

String p_i_fw_title;
String p_i_fw_version;
String p_i_fw_tag;
String p_i_fw_size;
String p_i_fw_checksum_algorithm;
String p_i_fw_checksum;

String p_i_G00,p_i_G01,p_i_G02,p_i_G18,p_i_G19,p_i_G21;

uint16_t mb_cal01,mb_cal02,mb_cal03,mb_cal04, mb_cal05, mb_cal06, mb_cal07, mb_cal08, mb_cal09, mb_cal10, mb_cal11, mb_cal12, mb_cal13, mb_cal14, mb_cal15,mb_cal12_send,mb_cal13_send; 
uint16_t mb_cal20,mb_cal21,mb_cal22,mb_cal23, mb_cal24, mb_cal25; 
bool mb_stufen_start, mb_stufen_read;

uint32_t Count_long_ist_over;     
uint32_t Radon_12h_ist,Radon_live_value; 
/*
uint32_t Radon_live_value_2h[14];
*/
 uint32_t Radon_live_value_2h[14];

uint32_t radon_2h_ist = 0;
uint8_t count_2h = 0;
uint8_t C_2_umlauf = 0;
/*
uint32_t Radon_live_value_1h[7];
*/
 uint32_t Radon_live_value_1h[7];
uint32_t radon_1h_ist = 0;
uint8_t count_1h = 0;
uint8_t C_1_umlauf = 0;

static wl_status_t  WiFi_status;
byte TB_status;


//const int attribute_items_28 = 5;












char DEVICE_NAME[10] = "00000000";

// Client Attributes   Rückmeldung vom Sensor 
constexpr char G08_KEY[]            PROGMEM = "G08";                // Live Radon value 
constexpr char G09_KEY[]            PROGMEM = "G09";                // Impulse mit  Abzug 6*10min     G09   RCounts
constexpr char G12_KEY[]            PROGMEM = "G12";                // Impulse ohne Abzug 6*10min     G12    
constexpr char G30_KEY[]            PROGMEM = "G30";                // 12h Radon Wert
constexpr char G31_KEY[]            PROGMEM = "G31";                // Eintäge seit start Kalibrieren
constexpr char G32_KEY[]            PROGMEM = "G32";                // Summe mb_cal12   Impulse mit  Abzug 6*10min     G09*sum
constexpr char G33_KEY[]            PROGMEM = "G33";                // summe mb_cal13   Impulse ohne Abzug 6*10min     G12*sum
constexpr char G34_KEY[]            PROGMEM = "G34";                // 2h Radon mittelwert
constexpr char G52_KEY[]            PROGMEM = "G52";                // Version
constexpr char G00_KEY[]            PROGMEM = "G00";                // calibration value    *10
constexpr char G01_KEY[]            PROGMEM = "G01";                // Radon count average  +100= Auto
constexpr char G02_KEY[]            PROGMEM = "G02";                // Darkcount setting 
constexpr char G18_KEY[]            PROGMEM = "G18";                // Glaettung Faktor 
constexpr char G19_KEY[]            PROGMEM = "G19";                // Leerwert             *10
constexpr char G21_KEY[]            PROGMEM = "G21";                // Leerwert unten       *10
constexpr char C_s_checked_KEY[]    PROGMEM = "Sensor_checked";     // Sensor gechecked
constexpr char C_s_kalibriert_KEY[] PROGMEM = "Sensor_kalibriert";  // Sensor kalibriert
constexpr char clock_KEY[]          PROGMEM = "Clock";              // Uhr
constexpr char view_switch_KEY[]    PROGMEM = "Clock_view_switch";  //
constexpr char TIMEZONE_KEY[]       PROGMEM = "Timezone";           // Uhr
constexpr char beacon_KEY[]         PROGMEM = "beacon"; 
constexpr char identify_KEY[]       PROGMEM = "identify"; 


// Shared Attributes fürs Kalibrieren
constexpr char S00_KEY[]           PROGMEM = "S00";            // calibration value    *10
constexpr char S01_KEY[]           PROGMEM = "S01";            // Radon count average  +100= Auto
constexpr char S02_KEY[]           PROGMEM = "S02";            // Darkcount setting 
constexpr char S18_KEY[]           PROGMEM = "S18";            // Glaettung Faktor 
constexpr char S19_KEY[]           PROGMEM = "S19";            // Leerwert             *10
constexpr char S21_KEY[]           PROGMEM = "S21";            // Leerwert unten       *10
constexpr char U_checken_KEY[]     PROGMEM = "u_checken";      // check start
constexpr char U_kalibrieren_KEY[] PROGMEM = "u_kalibrieren";  // kalibrieren start
constexpr char U_kal_write_KEY[]   PROGMEM = "u_kal_write";    // kalibrierwerte schreiben



// SHARED SOLL Vorgaben
constexpr char U_UNIT_KEY[]       PROGMEM = "u_unit";        // bq/m3 or pci
constexpr char U_LED_T_KEY[]      PROGMEM = "u_led_t";       // LED oben an-aus
constexpr char U_LED_F_KEY[]      PROGMEM = "u_led_f";       // LED vorne an-aus
constexpr char U_KNX_S_KEY[]      PROGMEM = "u_knx_s";       // KNX an-aus
constexpr char U_LED_FB_KEY[]     PROGMEM = "u_led_fb";      // Helligkeit forne
constexpr char U_LED_TB_KEY[]     PROGMEM = "u_led_tb";      // Helligkeit oben
constexpr char U_LED_TF_KEY[]     PROGMEM = "u_led_tf";      // LED oben Flamme
constexpr char U_RANGE_T_KEY[]    PROGMEM = "u_range_t";     // LED oben rot
constexpr char U_RANGE_M_KEY[]    PROGMEM = "u_range_m";     // LED oben orange
constexpr char U_RANGE_U_KEY[]    PROGMEM = "u_range_u";     // LED oben grün
constexpr char U_CLOCK_KEY[]      PROGMEM = "u_clock";       // 0=Aus   1=EIN 24h   2=EIN 12h   3=Datum
constexpr char U_view_switch_KEY[]PROGMEM = "u_view_switch"; // 0=Radon  1= Uhr  2= Wechsel

constexpr char U_TIMEZONE_KEY[]   PROGMEM = "u_timezone";   // 
constexpr char u_ble_beacon_KEY[] PROGMEM = "u_ble_beacon"; 
constexpr char u_identify_KEY[]   PROGMEM = "u_identify"; 

constexpr char U_NTP1_KEY[]   PROGMEM = "u_ntp1"; 
constexpr char U_NTP2_KEY[]   PROGMEM = "u_ntp2"; 
constexpr char U_NTP3_KEY[]   PROGMEM = "u_ntp3";  

constexpr char U_CLOUD_ea_KEY[]       PROGMEM = "u_cloud_ea";      //  0=Standard   Cloud Ein Aus
constexpr char U_CLOUD_server_KEY[]   PROGMEM = "u_cloud_server";  //  loragate2.de
constexpr char U_CLOUD_page_KEY[]     PROGMEM = "u_cloud_page";    //  LoRaWAN-Live-Link-K1-W64rt39bd41np75L/lora_radon.php
constexpr char U_CLOUD_pre_KEY[]      PROGMEM = "u_cloud_pre";     //  submit=Date
constexpr char U_CLOUD_port_KEY[]     PROGMEM = "u_cloud_port";    //  80
constexpr char U_CLOUD_chain_KEY[]    PROGMEM = "u_cloud_chain";   //  &p

constexpr char u_mez_ea_KEY[]     PROGMEM = "u_mez_ea"; 

constexpr char u_file_start[]     PROGMEM = "u_file_start";
constexpr char u_file_end[]       PROGMEM = "u_file_end";
constexpr char u_file_read[]      PROGMEM = "u_file_read";

constexpr char U_buzzer_soll_KEY[]    PROGMEM = "u_buzzer_soll";     // 
constexpr char U_buzzer_ea_KEY[]      PROGMEM = "u_buzzer_ea";     //

constexpr char U_TIME_TB_KEY[]     PROGMEM = "u_time_upload";      // HTime upload

constexpr char U_sw_checksum[]     PROGMEM = "sw_checksum"; 



// Telemetry
constexpr char RADON_KEY[]        PROGMEM = "radon";     // Radonwert
constexpr char fw_state_KEY[]     PROGMEM = "fw_state";  // FW Status
constexpr char dw_nr_KEY[]        PROGMEM = "devicenumber";  // mb_Seriennummer

String fw_state_i = "INITIATED";



constexpr char CREDENTIALS_TYPE[]           PROGMEM = "credentialsType";
constexpr char CREDENTIALS_VALUE[]          PROGMEM = "credentialsValue";
constexpr char CLIENT_ID[]                  PROGMEM = "clientId";
constexpr char CLIENT_PASSWORD[]            PROGMEM = "password";
constexpr char CLIENT_USERNAME[]            PROGMEM = "userName";
constexpr char TEMPERATURE_KEY[]            PROGMEM = "temperature";
constexpr char HUMIDITY_KEY[]               PROGMEM = "humidity";
constexpr char ACCESS_TOKEN_CRED_TYPE[]     PROGMEM = "ACCESS_TOKEN";
constexpr char MQTT_BASIC_CRED_TYPE[]       PROGMEM = "MQTT_BASIC";
constexpr char X509_CERTIFICATE_CRED_TYPE[] PROGMEM = "X509_CERTIFICATE";
constexpr char SERIAL_KEY[]                 PROGMEM = "sernr";

constexpr char UNIT_KEY[]    PROGMEM = "unit";
constexpr char LED_T_KEY[]   PROGMEM = "led_t";  //LED oben an-aus
constexpr char LED_F_KEY[]   PROGMEM = "led_f";  //LED vorne an-aus
constexpr char LED_FB_KEY[]  PROGMEM = "led_fb";  //Helligkeit forne
constexpr char LED_TB_KEY[]  PROGMEM = "led_tb";  //Helligkeit oben

constexpr char RANGE_T_KEY[] PROGMEM = "range_t";
constexpr char RANGE_M_KEY[] PROGMEM = "range_m";
constexpr char RANGE_U_KEY[] PROGMEM = "range_u";




constexpr char lastActivityTime_KEY[] PROGMEM = "lastActivityTime";
constexpr char lastConnectTime_KEY[]  PROGMEM = "lastConnectTime";
constexpr char lastDisconnectTime_KEY[]  PROGMEM = "lastDisconnectTime";
constexpr char provisionState_KEY[]  PROGMEM = "provisionState";
constexpr char isOnline_KEY[]  PROGMEM = "isOnline";


// vom Client zurück lesen
constexpr char C_UNIT_KEY[]    PROGMEM = "d_unit";       //bq/m3 or 
constexpr char C_LED_T_KEY[]   PROGMEM = "d_led_t";     //LED oben an-aus
constexpr char C_LED_F_KEY[]   PROGMEM = "d_led_f";     //LED vorne an-aus
constexpr char C_KNX_S_KEY[]   PROGMEM = "d_knx_s";     //KNX  an-aus
constexpr char C_LED_FB_KEY[]  PROGMEM = "d_led_fb";   //Helligkeit forne
constexpr char C_LED_TB_KEY[]  PROGMEM = "d_led_tb";   //Helligkeit oben
constexpr char C_LED_TF_KEY[]  PROGMEM = "d_led_tf";   //Flamme oben

constexpr char C_RANGE_T_KEY[] PROGMEM = "d_range_t";  //LED oben rot
constexpr char C_RANGE_M_KEY[] PROGMEM = "d_range_m";  //LED oben orange
constexpr char C_RANGE_U_KEY[] PROGMEM = "d_range_u";  //LED oben grün

constexpr char C_KALIBRIERT_KEY[] PROGMEM = "d_kalibrieren";  //kalibrieren start
constexpr char C_CHECKEN_KEY[]    PROGMEM = "d_checken";  //
constexpr char C_kal_write_KEY[]  PROGMEM = "d_kal_write";  //

constexpr char C_SERIAL_KEY[]     PROGMEM = "serialNumber";



constexpr const char FW_TAG_KEY[] PROGMEM = "fw_tag";
constexpr const char TEST_KEY[]   PROGMEM = "d_led_tb";

constexpr char CONNECTING_MSG[]   PROGMEM = "Connecting to: (%s) with token (%s)";
constexpr char DEVICE_TYPE_KEY[]  PROGMEM = "device_type";
constexpr char ACTIVE_KEY[]       PROGMEM = "active";
constexpr char SENSOR_VALUE[]     PROGMEM = "sensor";


// Device IST Zustand
constexpr char D_UNIT_KEY[]         PROGMEM = "d_unit";
constexpr char D_LED_T_KEY[]        PROGMEM = "d_led_t";   //LED oben an-aus
constexpr char D_LED_F_KEY[]        PROGMEM = "d_led_f";   //LED vorne an-aus
constexpr char D_KNX_S_KEY[]        PROGMEM = "d_knx_s";   //KNX an-aus
constexpr char D_LED_FB_KEY[]       PROGMEM = "d_led_fb";  //Helligkeit forne
constexpr char D_LED_TB_KEY[]       PROGMEM = "d_led_tb";  //Helligkeit oben

constexpr char D_RANGE_T_KEY[]      PROGMEM = "d_range_t";
constexpr char D_RANGE_M_KEY[]      PROGMEM = "d_range_m";
constexpr char D_RANGE_U_KEY[]      PROGMEM = "d_range_u";

constexpr char D_u_clock_KEY[]      PROGMEM = "d_clock";       // 0=Aus   1=EIN 24h   2=EIN 12h   3=Datum
constexpr char D_u_view_switch_KEY[]PROGMEM = "d_view_switch"; // 0=Radon  1= Uhr  2= Wechsel

constexpr char D_u_timzone_KEY[]    PROGMEM = "d_timezone";
constexpr char D_u_beacon_KEY[]     PROGMEM = "d_beacon";
constexpr char D_u_identify_KEY[]   PROGMEM = "d_identify";

constexpr char D_FIRMWARE_KEY[]     PROGMEM = "d_firmware";
constexpr char D_FIRMWARE_DATE_KEY[]     PROGMEM = "d_firmw_date";

constexpr char D_KALIBRIEREN_KEY[]  PROGMEM = "d_kalibrieren";
constexpr char D_CHECKEN_KEY[]      PROGMEM = "d_checken";

constexpr char D_kal_write_KEY[]    PROGMEM = "d_kal_write";

constexpr char D_u_buzzer_ist_KEY[] PROGMEM = "d_buzzer_ist";
constexpr char D_u_buzzer_ea_KEY[]  PROGMEM = "d_buzzer_ea";

constexpr char D_NTP1_KEY[]         PROGMEM = "d_ntp1";
constexpr char D_NTP2_KEY[]         PROGMEM = "d_ntp2";
constexpr char D_NTP3_KEY[]         PROGMEM = "d_ntp3";


constexpr char D_Cloud_ea_KEY[]       PROGMEM = "d_Cloud_ea";
constexpr char D_Cloud_server_KEY[]   PROGMEM = "d_Cloud_server";
constexpr char D_Cloud_page_KEY[]     PROGMEM = "d_Cloud_page";
constexpr char D_Cloud_pre_KEY[]      PROGMEM = "d_Cloud_pre";
constexpr char D_Cloud_port_KEY[]     PROGMEM = "d_Cloud_port";
constexpr char D_Cloud_chain_KEY[]    PROGMEM = "d_Cloud_chain";

constexpr char D_Passwort_KEY[]     PROGMEM = "d_PW_KEY";

constexpr char D_WLAN_on_KEY[]   PROGMEM = "wlan_on";
constexpr char D_Send_staus_KEY[]   PROGMEM = "send_status";
constexpr char D_Send_staus_t_KEY[]   PROGMEM = "send_status_t";
constexpr char D_night_staus_KEY[]   PROGMEM = "night_status";

constexpr char D_AvailableKeys_KEY[]PROGMEM = "availableKeys";
char d_AvailableKeys[10] = "['radon']";
String d_AvailableKeys_s = "['radon']";








// Initialize underlying client, used to establish a connection
#if ENCRYPTED
WiFiClientSecure espClient;
#else
WiFiClient espClient;
#endif
// Initialize ThingsBoard instance with the maximum needed buffer size
//ThingsBoard tb(espClient, MAX_MESSAGE_SIZE);


// The SDK setup with 128 bytes for JSON buffer
ThingsBoard tb(espClient, MAX_MESSAGE_SIZE);

// The SDK setup with 64 bytes for JSON buffer
//ThingsBoard tb(espClient);



uint32_t previous_processing_time = 0U;

// Statuses for provisioning
bool provisionRequestSent = false;
bool provisionResponseProcessed = false;

// Statuses for requesting of attributes
bool requestedClient = false;
bool requestedClient2 = false;
bool requestedClient3 = false;
bool requestedShared = false;
bool requestedShared1 = false;
bool requestedShared2 = false;
bool requestedShared3 = false;
bool requestedShared4 = false;
bool requestedShared5 = false;
bool requestedShared6 = false;
bool requestedShared7 = false;
bool requestedShared8 = false;
bool requestedShared9 = false;
bool requestedSharedt = false;

uint16_t g_fail_requestedClient;

bool g_bl_radon_read = false;

bool g_requestedShared_x = false;
bool g_requestedShared_sq = false;

bool requestedShared_fail = false;
bool requestedShared1_fail = false;
bool requestedShared2_fail = false;
bool requestedShared3_fail = false;
bool requestedShared4_fail = false;
bool requestedShared5_fail = false;
bool requestedSharedx_fail = false;
bool requestedShared_client = false;
bool requestedSharedt_fail = false;

bool Shared_Attributes_Subscribe_fail = false;

uint8_t requestedShared5_fail_count,Shared_Attributes_Subscribe_fail_count;


bool requestedShared4_end = false;
bool g_sperr_bit_time = true;


// Struct for client connecting after provisioning
struct Credentials {
  std::string client_id;
  std::string username;
  std::string password;
};
Credentials credentials;

struct Credentials2 {
  std::string i_fw_title;
  std::string i_fw_version;
  std::string i_fw_tag;
  std::string i_fw_size;
  std::string i_fw_checksum_algorithm;
  std::string i_fw_checksum;
  std::string i_RANGE_M_KEY;
  std::string i_RANGE_T_KEY;
  std::string i_RANGE_U_KEY;
  std::string i_LED_TB_KEY;
  std::string i_LED_FB_KEY;
  std::string i_LED_TF_KEY;
  std::string i_LED_T_KEY;
  std::string i_LED_F_KEY;
  std::string i_KNX_S_KEY;
  std::string i_UNIT_KEY;
  std::string i_checken_KEY;
  std::string i_kalibrieren_KEY;
  std::string i_kal_write_KEY;
  std::string i_u_clock_KEY;
  std::string i_u_view_switch_KEY;
  std::string i_u_timezone_KEY;
  std::string i_u_ntp1_KEY;
  std::string i_u_ntp2_KEY;
  std::string i_u_ntp3_KEY;
  std::string i_u_ble_beacon_KEY;
  std::string i_u_mez_ea_KEY;
  std::string i_u_identify_KEY;
  std::string i_S00_KEY;
  std::string i_S01_KEY;
  std::string i_S02_KEY;
  std::string i_S18_KEY;
  std::string i_S19_KEY;
  std::string i_S21_KEY; 
  std::string i_buzzer_soll_KEY; 
  std::string i_buzzer_ea_KEY; 
  std::string i_u_cloud_ea_KEY; 
  std::string i_u_cloud_server_KEY; 
  std::string i_u_cloud_page_KEY; 
  std::string i_u_cloud_pre_KEY; 
  std::string i_u_cloud_port_KEY; 
  std::string i_u_cloud_chain_KEY; 
};
Credentials2 credentials2;




    /*
    // nicht gesendet
    g_G00_ist;
    g_G01_ist;
    g_G02_ist;
    g_G18_ist;
    g_G19_ist;
    g_G21_ist;
   */

/*
  const int attribute_items2 = 5;
  Attribute attributes2[attribute_items2] = {
    { D_FIRMWARE_KEY,  CURRENT_FIRMWARE_VERSION },
    { D_KALIBRIEREN_KEY,  g_kalibrieren }, //kalibrieren start
    { D_CHECKEN_KEY,  g_checken },
    { D_kal_write_KEY,  g_kal_write },
    { D_AvailableKeys_KEY,  d_AvailableKeys },
  };
*/



// Shared attributes we want to request from the server
constexpr std::array<const char*, 5U> SUBSCRIBED_RPC_ATTRIBUTES PROGMEM = {
  lastActivityTime_KEY,
  lastConnectTime_KEY,
  lastDisconnectTime_KEY,
  provisionState_KEY,
  isOnline_KEY
};




// Shared attributes we want to request from the server
constexpr std::array<const char*, 10> SUBSCRIBED_SHARED_ATTRIBUTES PROGMEM = {
  U_UNIT_KEY,
  U_LED_T_KEY,
  U_LED_F_KEY,
  U_LED_FB_KEY,
  U_LED_TF_KEY,
  U_LED_TB_KEY,
  U_RANGE_T_KEY,
  U_RANGE_M_KEY,
  U_RANGE_U_KEY,
  U_checken_KEY
};



// Shared attributes we want to request from the server
constexpr std::array<const char*, 10> SUBSCRIBED_SHARED_ATTRIBUTES2 PROGMEM = {
  S19_KEY,
  U_kalibrieren_KEY,
  U_kal_write_KEY,
  U_CLOCK_KEY,
  U_view_switch_KEY,
  U_TIMEZONE_KEY,
  u_ble_beacon_KEY,
  u_mez_ea_KEY,
  u_identify_KEY,
  S00_KEY
  };
  
  
// Shared attributes we want to request from the server
constexpr std::array<const char*, 10> SUBSCRIBED_SHARED_ATTRIBUTES3 PROGMEM = {
  S02_KEY,
  S21_KEY,
  u_file_start,
  u_file_end,
  u_file_read,
  U_buzzer_soll_KEY,
  U_buzzer_ea_KEY,
  U_NTP1_KEY,
  U_NTP2_KEY,
  U_NTP3_KEY
  };
  
// Shared attributes we want to request from the server
constexpr std::array<const char*, 10> SUBSCRIBED_SHARED_ATTRIBUTES4 PROGMEM = {
  S01_KEY,
  U_CLOUD_ea_KEY,
  U_CLOUD_server_KEY,
  U_CLOUD_page_KEY,
  U_CLOUD_pre_KEY,
  U_CLOUD_port_KEY,
  U_CLOUD_chain_KEY, 
  FW_TITLE_KEY,
  FW_TAG_KEY,
  S18_KEY
  
  };

// Shared attributes we want to request from the server
constexpr std::array<const char*, 1> SUBSCRIBED_SHARED_ATTRIBUTES5 PROGMEM = {
  U_KNX_S_KEY
  
  };
  
  
  /*
  FW_CHKS_KEY,
  FW_CHKS_ALGO_KEY,
  FW_SIZE_KEY,
  F_VER_KEY
  */






// Shared attributes we want to request from the server
constexpr std::array<const char*, 6> REQUESTED_SHARED_ATTRIBUTES PROGMEM = {
  FW_CHKS_KEY,
  FW_CHKS_ALGO_KEY,
  FW_SIZE_KEY,
  FW_TAG_KEY,
  FW_TITLE_KEY,
  FW_VER_KEY
};

// Shared attributes we want to request from the server
constexpr std::array<const char*, 6> REQUESTED_SHARED_ATTRIBUTES4 PROGMEM = {
  S00_KEY,
  S01_KEY,
  S02_KEY,
  S18_KEY,
  S19_KEY,
  S21_KEY 
};


constexpr std::array<const char*, 6> REQUESTED_SHARED_ATTRIBUTES3 PROGMEM = {
  U_RANGE_T_KEY,
  U_RANGE_M_KEY,
  U_RANGE_U_KEY,
  u_ble_beacon_KEY,
  u_mez_ea_KEY,
  u_identify_KEY
};


constexpr std::array<const char*, 6> REQUESTED_SHARED_ATTRIBUTES2 PROGMEM = {
  U_checken_KEY,
  U_kalibrieren_KEY,
  U_kal_write_KEY,
  U_CLOCK_KEY,
  U_view_switch_KEY,
  U_TIMEZONE_KEY
};

constexpr std::array<const char*, 6> REQUESTED_SHARED_ATTRIBUTES1 PROGMEM = {
  U_UNIT_KEY,
  U_LED_T_KEY,
  U_KNX_S_KEY,
  U_LED_FB_KEY,
  U_LED_TF_KEY,
  U_LED_TB_KEY
};


constexpr std::array<const char*, 3> REQUESTED_SHARED_ATTRIBUTES5 PROGMEM = {
   U_LED_F_KEY,
   U_CLOCK_KEY,
   U_view_switch_KEY  
};

constexpr std::array<const char*, 5> REQUESTED_SHARED_ATTRIBUTES6 PROGMEM = {
  u_file_start,
  u_file_end,
  u_file_read,
  U_buzzer_soll_KEY,
  U_buzzer_ea_KEY
};

constexpr std::array<const char*, 3> REQUESTED_SHARED_ATTRIBUTES7 PROGMEM = {
  U_NTP1_KEY,
  U_NTP2_KEY,
  U_NTP3_KEY
};

constexpr std::array<const char*, 6> REQUESTED_SHARED_ATTRIBUTES8 PROGMEM = {
  U_CLOUD_ea_KEY,
  U_CLOUD_server_KEY,
  U_CLOUD_page_KEY,
  U_CLOUD_pre_KEY,
  U_CLOUD_port_KEY,
  U_CLOUD_chain_KEY
};


// Client-side attributes we want to request from the server
constexpr std::array<const char*, 10> REQUESTED_CLIENT_ATTRIBUTES PROGMEM = {
  C_UNIT_KEY,
  C_LED_T_KEY,
  C_LED_F_KEY,
  C_LED_FB_KEY,
  C_LED_TB_KEY,
  C_LED_TF_KEY,
  C_RANGE_T_KEY,
  C_RANGE_M_KEY,
  C_RANGE_U_KEY,
  C_KALIBRIERT_KEY
};

// Client-side attributes we want to request from the server
constexpr std::array<const char*, 10> REQUESTED_CLIENT_ATTRIBUTES2 PROGMEM = {
  C_CHECKEN_KEY,
  C_s_checked_KEY,
  C_s_kalibriert_KEY,
  C_kal_write_KEY,
  clock_KEY,
  view_switch_KEY,
  TIMEZONE_KEY,
  C_SERIAL_KEY,
  beacon_KEY,
  identify_KEY
};

// Client-side attributes we want to request from the server
constexpr std::array<const char*, 1> REQUESTED_CLIENT_ATTRIBUTES3 PROGMEM = {
  C_KNX_S_KEY
};


// List of shared attributes for subscribing to their updates
constexpr std::array<const char *, 21U> SHARED_ATTRIBUTES_LIST PROGMEM = {
  U_UNIT_KEY,
  U_LED_T_KEY,
  U_LED_F_KEY,
  U_LED_FB_KEY,
  U_LED_TF_KEY,
  U_LED_TB_KEY,
  U_RANGE_T_KEY,
  U_RANGE_M_KEY,
  U_RANGE_U_KEY,
  U_checken_KEY,
  U_kalibrieren_KEY,
  U_kal_write_KEY,
  U_CLOCK_KEY,
  U_view_switch_KEY,
  U_TIMEZONE_KEY,
  u_ble_beacon_KEY,
  u_mez_ea_KEY,
  u_identify_KEY,
  U_buzzer_soll_KEY,
  U_buzzer_ea_KEY,
  U_KNX_S_KEY
};


constexpr std::array<const char*, 2> REQUESTED_SHARED_ATTRIBUTESt PROGMEM = {
  U_TIME_TB_KEY,
  U_sw_checksum
};




// Statuses for subscribing to shared attributes
bool subscribedSHARED = false;
bool subscribedSHARED2 = false;
bool subscribedSHARED3 = false;
bool subscribedSHARED4 = false;
bool subscribedSHARED5 = false;
// Statuses for subscribing to rpc
bool subscribedRPC = false;

//----------------------------------
void saveAttribute() {

  //Serial.println("saveAttribute");
  //Serial.println("------------------------------------------");
  
  Preferences preferences;
  preferences.begin("eenvs", false);                         //Ordner eenvs anlegen/verwenden


  preferences.putUShort("p_unit_ist", g_unit_ist);     //  1=Standard   1 = bqm3  0=pCi
  preferences.putUShort("p_LEDT_T", g_LEDT_T_ist);     //  1=Standard   Top led EIN
  preferences.putUShort("p_LEDT_F", g_LEDT_F_ist);     //  1=Standard   7 Segment  EIN
  preferences.putUShort("p_KNX_S", g_KNX_S_ist);       //  0=Standard   KNX Aus

  preferences.putUShort("p_LEDT_FB", g_LEDT_FB_ist);    // 5=Standard   Helligkeit forne
  preferences.putUShort("p_LEDT_TB", g_LEDT_TB_ist);    //50=Standard   Top LED Helligkeit
  preferences.putUShort("p_LEDT_TF", g_LEDT_TF_ist);    // 1=Standard   LED oben Flamme

  preferences.putUShort("g_Range_T", g_Range_T_ist);   //300=Standard   oben Range ROT
  preferences.putUShort("g_Range_M", g_Range_M_ist);   //150=Standard   mitte Range Orange
  preferences.putUShort("g_Range_U", g_Range_U_ist);   //  0=Standard   unten Range Grün  
 
  preferences.putUShort("g_u_clock", g_u_clock_ist);          //1=24h   2=12h   3=Datum
  preferences.putUShort("g_u_view_s", g_u_view_switch_ist);   // 0=Radon  1= Uhr      2=Wechsel
  preferences.putString("g_u_timezone", g_u_timezone_ist);  // Time Zone
 
  preferences.putString("g_u_ntp1", String(g_u_ntp1_ist));  // Time NTP Server 1
  preferences.putString("g_u_ntp2", String(g_u_ntp2_ist));  // Time NTP Server 2
  preferences.putString("g_u_ntp3", String(g_u_ntp3_ist));  // Time NTP Server 3


  preferences.putUShort("g_beacon", g_u_beacon_ist);   //  0=Aus
 
  preferences.putUShort("g_mez_ea", g_u_mez_ea_ist);   //  1=EIN  

  preferences.putUShort("g_buz_ea", g_u_buzzer_ea);   //  1=EIN  
  preferences.putUShort("g_buz_ist", g_Buzzer_ist);   //  Sollwert Radon Alarm  Buzzer


  preferences.putUShort("g_file_start", g_file_start);  
  preferences.putUShort("g_file_end", g_file_end);  
  preferences.putUShort("g_file_read", g_file_read);  




  preferences.putUShort("g_G00", g_G00_ist);
  preferences.putUShort("g_G01", g_G01_ist);
  preferences.putUShort("g_G02", g_G02_ist);
  preferences.putUShort("g_G18", g_G18_ist);
  preferences.putUShort("g_G19", g_G19_ist);
  preferences.putUShort("g_G21", g_G21_ist);

  //preferences.putUInt("g_Gcheck", g_checked_soll);
  //preferences.putUInt("g_Gkali", g_kalibrieren_soll);

  
    #ifdef sPACE_DEBUG
      printf("[AP] FREE HEAP: now: %u, contiguous: %u, lowest: %u\n",xPortGetFreeHeapSize(),heap_caps_get_largest_free_block(MALLOC_CAP_DEFAULT),xPortGetMinimumEverFreeHeapSize());
    
    #endif

  //Serial.println("[IF] Save Values from Shared Attributs");
  //Serial.println(F("-----------------------------------------"));
  //Serial.println(F(" "));
  
  WiFi_status = WL_CONNECTED;




    if(requestedShared4_end == false){
      
      if(requestedShared_client == false){
        g_shared_empf_send_to_TB = true;
        requestedShared4_end = true;
      }
       requestedShared_client = true;     

    }   

    preferences.end();

}
//----------------------------------




//----------------------------------
void send_client_attribute(){
//Serial.println(F(" "));
              #ifdef sPACE_DEBUG
              printf("[AP] FREE HEAP: now: %u, contiguous: %u, lowest: %u\n",xPortGetFreeHeapSize(),heap_caps_get_largest_free_block(MALLOC_CAP_DEFAULT),xPortGetMinimumEverFreeHeapSize());
              #endif
//Serial.println("-----------------------------------"); 
//Serial.println("[SA] Sending Client attributes 1..."); 

      TB_currFwVersion = String(CURRENT_FIRMWARE_VERSION);

        char tMember[20];
        int length = TB_currFwVersion.length();
        TB_currFwVersion.toCharArray(tMember, length+1); 
       // D_FIRMWARE_DATE_KEY        FIRMWARE_DATE_TIME
       
        //-------------------------------------------------------------------
          //const int attribute_items_25 = 5;
          Attribute attributes25[5] = {
            { D_FIRMWARE_KEY,  tMember },        
            { D_KALIBRIEREN_KEY,  g_kalibrieren }, // kalibrieren start
            { D_CHECKEN_KEY,  g_checken },
            { D_kal_write_KEY,  g_kal_write },
            { D_AvailableKeys_KEY,  d_AvailableKeys },
          };

          // Vergleiche die aktuellen Werte mit den vorherigen
          bool attributesChangedFlag25 = strcmp(tMember, prev_tMember) != 0 ||
                                        strcmp(d_AvailableKeys, prev_d_AvailableKeys) != 0 ||
                                        g_kalibrieren != prev_g_kalibrieren ||
                                        g_checken != prev_g_checken ||
                                        g_kal_write != prev_g_kal_write;

                  if (attributesChangedFlag25) {
                      // Aktualisiere die vorherigen Werte und debugge die Änderungen
                      if (strcmp(tMember, prev_tMember) != 0) {
                          TB_DEBUG_MAX_PRINT(F("[IF][25] Firmware change von "));
                          TB_DEBUG_MAX_PRINT(prev_tMember);
                          TB_DEBUG_MAX_PRINT(F(" zu "));
                          TB_DEBUG_MAX_PRINTLN(tMember);
                          strncpy(prev_tMember, tMember, sizeof(prev_tMember));
                      }
                      if (strcmp(d_AvailableKeys, prev_d_AvailableKeys) != 0) {
                          TB_DEBUG_MAX_PRINT(F("[IF][25] AvailableKeys change von "));
                          TB_DEBUG_MAX_PRINT(prev_d_AvailableKeys);
                          TB_DEBUG_MAX_PRINT(F(" zu "));
                          TB_DEBUG_MAX_PRINTLN(d_AvailableKeys);
                          strncpy(prev_d_AvailableKeys, d_AvailableKeys, sizeof(prev_d_AvailableKeys));
                      }
                      if (g_kalibrieren != prev_g_kalibrieren) {
                          TB_DEBUG_MAX_PRINT(F("[IF][25] kalibrieren change von "));
                          TB_DEBUG_MAX_PRINT(prev_g_kalibrieren);
                          TB_DEBUG_MAX_PRINT(F(" zu "));
                          TB_DEBUG_MAX_PRINTLN(g_kalibrieren);
                          prev_g_kalibrieren = g_kalibrieren;
                      }
                      if (g_checken != prev_g_checken) {
                          TB_DEBUG_MAX_PRINT(F("[IF][25] checken change von "));
                          TB_DEBUG_MAX_PRINT(prev_g_checken);
                          TB_DEBUG_MAX_PRINT(F(" zu "));
                          TB_DEBUG_MAX_PRINTLN(g_checken);
                          prev_g_checken = g_checken;
                      }
                      if (g_kal_write != prev_g_kal_write) {
                          TB_DEBUG_MAX_PRINT(F("[IF][25] kal_write change von "));
                          TB_DEBUG_MAX_PRINT(prev_g_kal_write);
                          TB_DEBUG_MAX_PRINT(F(" zu "));
                          TB_DEBUG_MAX_PRINTLN(g_kal_write);
                          prev_g_kal_write = g_kal_write;
                      }
                      TB_DEBUG_MAX_PRINTLN(F("[IF][25] attributes wurden modifiziert"));
                  } else {
                      // TB_DEBUG_MAX_PRINTLN("[IF][25] attributes sind unmodifiziert");
                  }


        //-------------------------------------------------------------------
        

        //-------------------------------------------------------------------
          //const int attribute_items_26 = 5;
          Attribute attributes26[5] = {
            { D_UNIT_KEY,  g_unit_ist }, //1=Standard   1 = bqm3  0=pCi
            { D_LED_T_KEY,  g_LEDT_T_ist },//1=Standard  Top led EIN
            { D_LED_F_KEY,  g_LEDT_F_ist },//1=Standard  7 Segment  EIN
            { D_LED_FB_KEY,  g_LEDT_FB_ist },  //5=Standard   Helligkeit forne
            { D_LED_TB_KEY,  g_LEDT_TB_ist },//50=Standard  Top LED Helligkeit
          };

          // Vergleiche die aktuellen Werte mit den vorherigen
          bool attributesChangedFlag26 = g_unit_ist != prev_g_unit_ist ||
                                        g_LEDT_T_ist != prev_g_LEDT_T_ist ||
                                        g_LEDT_F_ist != prev_g_LEDT_F_ist ||
                                        g_LEDT_FB_ist != prev_g_LEDT_FB_ist ||
                                        g_LEDT_TB_ist != prev_g_LEDT_TB_ist;

              if (attributesChangedFlag26) {
                  // Aktualisiere die vorherigen Werte und debugge die Änderungen
                  if (g_unit_ist != prev_g_unit_ist) {
                      TB_DEBUG_MAX_PRINT(F("[IF][26] unit change von "));
                      TB_DEBUG_MAX_PRINT(prev_g_unit_ist);
                      TB_DEBUG_MAX_PRINT(F(" zu "));
                      TB_DEBUG_MAX_PRINTLN(g_unit_ist);
                      prev_g_unit_ist = g_unit_ist;
                  }
                  if (g_LEDT_T_ist != prev_g_LEDT_T_ist) {
                      TB_DEBUG_MAX_PRINT(F("[IF][26] LED_T change von "));
                      TB_DEBUG_MAX_PRINT(prev_g_LEDT_T_ist);
                      TB_DEBUG_MAX_PRINT(F(" zu "));
                      TB_DEBUG_MAX_PRINTLN(g_LEDT_T_ist);
                      prev_g_LEDT_T_ist = g_LEDT_T_ist;
                  }
                  if (g_LEDT_F_ist != prev_g_LEDT_F_ist) {
                      TB_DEBUG_MAX_PRINT(F("[IF][26] LED_F change von "));
                      TB_DEBUG_MAX_PRINT(prev_g_LEDT_F_ist);
                      TB_DEBUG_MAX_PRINT(F(" zu "));
                      TB_DEBUG_MAX_PRINTLN(g_LEDT_F_ist);
                      prev_g_LEDT_F_ist = g_LEDT_F_ist;
                  }
                  if (g_LEDT_FB_ist != prev_g_LEDT_FB_ist) {
                      TB_DEBUG_MAX_PRINT(F("[IF][26] LED_FB change von "));
                      TB_DEBUG_MAX_PRINT(prev_g_LEDT_FB_ist);
                      TB_DEBUG_MAX_PRINT(F(" zu "));
                      TB_DEBUG_MAX_PRINTLN(g_LEDT_FB_ist);
                      prev_g_LEDT_FB_ist = g_LEDT_FB_ist;
                  }
                  if (g_LEDT_TB_ist != prev_g_LEDT_TB_ist) {
                      TB_DEBUG_MAX_PRINT(F("[IF][26] LED_TB change von "));
                      TB_DEBUG_MAX_PRINT(prev_g_LEDT_TB_ist);
                      TB_DEBUG_MAX_PRINT(F(" zu "));
                      TB_DEBUG_MAX_PRINTLN(g_LEDT_TB_ist);
                      prev_g_LEDT_TB_ist = g_LEDT_TB_ist;
                  }
                  TB_DEBUG_MAX_PRINTLN(F("[IF][26] attributes wurden modifiziert"));
              } else {
                  // TB_DEBUG_MAX_PRINTLN("[IF][26] attributes sind unmodifiziert");
              }


        //-------------------------------------------------------------------


        //-------------------------------------------------------------------
          //const int attribute_items_27 = 5;
          Attribute attributes27[5] = {
            { D_RANGE_T_KEY,  g_Range_T_ist },   // 300=Standard   oben Range ROT
            { D_RANGE_M_KEY,  g_Range_M_ist },   // 150=Standard   mitte Range Orange
            { D_RANGE_U_KEY,  g_Range_U_ist },   //   0=Standard   unten Range Grün
            { beacon_KEY,  g_u_beacon_ist },     //   0=Aus
            { identify_KEY,  g_u_identify_ist }, //   0=Aus
          };  

          // Vergleiche die aktuellen Werte mit den vorherigen
          bool attributesChangedFlag27 = g_Range_T_ist != prev_g_Range_T_ist ||
                                        g_Range_M_ist != prev_g_Range_M_ist ||
                                        g_Range_U_ist != prev_g_Range_U_ist ||
                                        g_u_beacon_ist != prev_g_u_beacon_ist ||
                                        g_u_identify_ist != prev_g_u_identify_ist;

              if (attributesChangedFlag27) {
                  // Aktualisiere die vorherigen Werte und debugge die Änderungen
                  if (g_Range_T_ist != prev_g_Range_T_ist) {
                      TB_DEBUG_MAX_PRINT(F("[IF][27] Range_T change von "));
                      TB_DEBUG_MAX_PRINT(prev_g_Range_T_ist);
                      TB_DEBUG_MAX_PRINT(F(" zu "));
                      TB_DEBUG_MAX_PRINTLN(g_Range_T_ist);
                      prev_g_Range_T_ist = g_Range_T_ist;
                  }
                  if (g_Range_M_ist != prev_g_Range_M_ist) {
                      TB_DEBUG_MAX_PRINT(F("[IF][27] Range_M change von "));
                      TB_DEBUG_MAX_PRINT(prev_g_Range_M_ist);
                      TB_DEBUG_MAX_PRINT(F(" zu "));
                      TB_DEBUG_MAX_PRINTLN(g_Range_M_ist);
                      prev_g_Range_M_ist = g_Range_M_ist;
                  }
                  if (g_Range_U_ist != prev_g_Range_U_ist) {
                      TB_DEBUG_MAX_PRINT(F("[IF][27] Range_U change von "));
                      TB_DEBUG_MAX_PRINT(prev_g_Range_U_ist);
                      TB_DEBUG_MAX_PRINT(F(" zu "));
                      TB_DEBUG_MAX_PRINTLN(g_Range_U_ist);
                      prev_g_Range_U_ist = g_Range_U_ist;
                  }
                  if (g_u_beacon_ist != prev_g_u_beacon_ist) {
                      TB_DEBUG_MAX_PRINT(F("[IF][27] beacon change von "));
                      TB_DEBUG_MAX_PRINT(prev_g_u_beacon_ist);
                      TB_DEBUG_MAX_PRINT(F(" zu "));
                      TB_DEBUG_MAX_PRINTLN(g_u_beacon_ist);
                      prev_g_u_beacon_ist = g_u_beacon_ist;
                  }
                  if (g_u_identify_ist != prev_g_u_identify_ist) {
                      TB_DEBUG_MAX_PRINT(F("[IF][27] identify change von "));
                      TB_DEBUG_MAX_PRINT(prev_g_u_identify_ist);
                      TB_DEBUG_MAX_PRINT(F(" zu "));
                      TB_DEBUG_MAX_PRINTLN(g_u_identify_ist);
                      prev_g_u_identify_ist = g_u_identify_ist;
                  }
                  TB_DEBUG_MAX_PRINTLN(F("[IF][27] attributes wurden modifiziert"));
              } else {
                  // TB_DEBUG_MAX_PRINTLN("[IF][27] attributes sind unmodifiziert");
              }


        //-------------------------------------------------------------------
 




          //-------------------------------------------------------------------

           char t_str2c[16];
           char t_str3c[18];
           char t_str4c[18];
           char t_channelc[4];

          strncpy(t_str2c, WiFi.localIP().toString().c_str(), sizeof(t_str2c));
          strncpy(t_str3c, WiFi.BSSIDstr().c_str(), sizeof(t_str3c));
          strncpy(t_str4c, WiFi.macAddress().c_str(), sizeof(t_str4c));
          snprintf(t_channelc, sizeof(t_channelc), "%d", WiFi.channel());

          Attribute attributes28[5] = {
            { "channel",  t_channelc},
            { "bssid",  t_str3c},
            { "mac",  t_str4c},
            { "localIp",  t_str2c},
            { D_u_buzzer_ea_KEY,  g_u_buzzer_ea }, 
          };

          if (attributesChangedFlag28) {
              // Aktualisiere die vorherigen Werte und debugge die Änderungen
              if (strcmp(t_channelc, prev_t_channelc) != 0) {
                  TB_DEBUG_MAX_PRINT(F("[IF][28] channel change von "));
                  TB_DEBUG_MAX_PRINT(prev_t_channelc);
                  TB_DEBUG_MAX_PRINT(F(" zu "));
                  TB_DEBUG_MAX_PRINTLN(t_channelc);
                  strncpy(prev_t_channelc, t_channelc, sizeof(prev_t_channelc));
              }
              if (strcmp(t_str3c, prev_t_str3c) != 0) {
                  TB_DEBUG_MAX_PRINT(F("[IF][28] bssid change von "));
                  TB_DEBUG_MAX_PRINT(prev_t_str3c);
                  TB_DEBUG_MAX_PRINT(F(" zu "));
                  TB_DEBUG_MAX_PRINTLN(t_str3c);
                  strncpy(prev_t_str3c, t_str3c, sizeof(prev_t_str3c));
              }
              if (strcmp(t_str4c, prev_t_str4c) != 0) {
                  TB_DEBUG_MAX_PRINT(F("[IF][28] mac change von "));
                  TB_DEBUG_MAX_PRINT(prev_t_str4c);
                  TB_DEBUG_MAX_PRINT(F(" zu "));
                  TB_DEBUG_MAX_PRINTLN(t_str4c);
                  strncpy(prev_t_str4c, t_str4c, sizeof(prev_t_str4c));
              }
              if (strcmp(t_str2c, prev_t_str2c) != 0) {
                  TB_DEBUG_MAX_PRINT(F("[IF][28] localIp change von "));
                  TB_DEBUG_MAX_PRINT(prev_t_str2c);
                  TB_DEBUG_MAX_PRINT(F(" zu "));
                  TB_DEBUG_MAX_PRINTLN(t_str2c);
                  strncpy(prev_t_str2c, t_str2c, sizeof(prev_t_str2c));
              }
              if (g_u_buzzer_ea != prev_g_u_buzzer_ea) {
                  TB_DEBUG_MAX_PRINT(F("[IF][28] buzzer_ea change von "));
                  TB_DEBUG_MAX_PRINT(prev_g_u_buzzer_ea);
                  TB_DEBUG_MAX_PRINT(F(" zu "));
                  TB_DEBUG_MAX_PRINTLN(g_u_buzzer_ea);
                  prev_g_u_buzzer_ea = g_u_buzzer_ea;
              }
              TB_DEBUG_MAX_PRINTLN(F("[IF][28] attributes wurden modifiziert"));
          } else {
              // TB_DEBUG_MAX_PRINTLN("[IF][28] attributes sind unmodifiziert");
          }


          //-------------------------------------------------------------------



          //-------------------------------------------------------------------
          //String t_str;
          //t_str = constrain(2 * (WiFi.RSSI() + 100), 0, 100);
            char t_strc[5]; // Platz für bis zu 4 Zeichen + Nullterminierung
            snprintf(t_strc, sizeof(t_strc), "%d", constrain(2 * (WiFi.RSSI() + 100), 0, 100));

            char rssi_strc[5]; // Ein weiteres Array für den zweiten Wert
            snprintf(rssi_strc, sizeof(rssi_strc), "%d", constrain(2 * (WiFi.RSSI() + 100), 0, 100));

            

            //const int attribute_items_30 = 3;
            Attribute attributes30[4] = {
              { "dBm",  t_strc }, 
              { D_u_buzzer_ist_KEY,  g_Buzzer_ist },
              { "rssi_dBm",  rssi_strc }, 
              { D_FIRMWARE_DATE_KEY,  FIRMWARE_DATE_TIME },
            };

            // Vergleiche die aktuellen Werte mit den vorherigen
            bool attributesChangedFlag30 = strcmp(t_strc, prev_t_strc) != 0 || 
                               g_Buzzer_ist != prev_g_Buzzer_ist ||
                               strcmp(rssi_strc, prev_rssi_strc) != 0 || 
                               strcmp(FIRMWARE_DATE_TIME, prev_firmware_date_time) != 0; // Überprüfe Änderung des Firmware-Datums

              if (attributesChangedFlag30) {
                  // Aktualisiere die vorherigen Werte und debugge die Änderungen
                  if (strcmp(t_strc, prev_t_strc) != 0) {
                      TB_DEBUG_MAX_PRINT(F("[IF][30] t_strc change von "));
                      TB_DEBUG_MAX_PRINT(prev_t_strc);
                      TB_DEBUG_MAX_PRINT(F(" zu "));
                      TB_DEBUG_MAX_PRINTLN(t_strc);
                      strncpy(prev_t_strc, t_strc, sizeof(prev_t_strc)); 
                  }
                  if (g_Buzzer_ist != prev_g_Buzzer_ist) {
                      TB_DEBUG_MAX_PRINT(F("[IF][30] Buzzer change von "));
                      TB_DEBUG_MAX_PRINT(prev_g_Buzzer_ist);
                      TB_DEBUG_MAX_PRINT(F(" zu "));
                      TB_DEBUG_MAX_PRINTLN(g_Buzzer_ist);
                      prev_g_Buzzer_ist = g_Buzzer_ist;
                  }
                  if (strcmp(rssi_strc, prev_rssi_strc) != 0) {
                      TB_DEBUG_MAX_PRINT(F("[IF][30] rssi_strc change von "));
                      TB_DEBUG_MAX_PRINT(prev_rssi_strc);
                      TB_DEBUG_MAX_PRINT(F(" zu "));
                      TB_DEBUG_MAX_PRINTLN(rssi_strc);
                      strncpy(prev_rssi_strc, rssi_strc, sizeof(prev_rssi_strc)); 
                  }
                  if (strcmp(FIRMWARE_DATE_TIME, prev_firmware_date_time) != 0) {        // d_PW_KEY
                      TB_DEBUG_MAX_PRINT(F("[IF][30] Firmware Datum/Uhrzeit Änderung von "));
                      TB_DEBUG_MAX_PRINT(prev_firmware_date_time);
                      TB_DEBUG_MAX_PRINT(F(" zu "));
                      TB_DEBUG_MAX_PRINTLN(FIRMWARE_DATE_TIME);
                  }
                  TB_DEBUG_MAX_PRINTLN(F("[IF][30] attributes wurden modifiziert"));
              } else {
                  // TB_DEBUG_MAX_PRINTLN("[IF][30] attributes sind unmodifiziert");
              }



            //-------------------------------------------------------------------





            //-------------------------------------------------------------------
            //const int attribute_items_29 = 5;
            Attribute attributes29[5] = {
              { "ssid",  read_SSID_String.c_str() },
              { fw_state_KEY,  fw_state_i.c_str() }, 
              { TIMEZONE_KEY,  v_timezone.c_str() }, // 1=24h   2=12h   3=Datum
              { clock_KEY,  g_u_clock_ist },  // Uhr
              { view_switch_KEY,  g_u_view_switch_ist },  //   0=Radon  1= Uhr  2= Wechsel
            }; 

            // Vergleiche die aktuellen Werte mit den vorherigen
            bool attributesChangedFlag29 = strcmp(read_SSID_String.c_str(), prev_read_SSID_String) != 0 ||
                                          strcmp(fw_state_i.c_str(), prev_fw_state_i) != 0 || 
                                          strcmp(v_timezone.c_str(), prev_v_timezone) != 0 ||
                                          g_u_clock_ist != prev_g_u_clock_ist ||
                                          g_u_view_switch_ist != prev_g_u_view_switch_ist;

                  if (attributesChangedFlag29) {
                      // Aktualisiere die vorherigen Werte und debugge die Änderungen
                      if (strcmp(read_SSID_String.c_str(), prev_read_SSID_String) != 0) {
                          TB_DEBUG_MAX_PRINT(F("[IF][29] ssid change von "));
                          TB_DEBUG_MAX_PRINT(prev_read_SSID_String);
                          TB_DEBUG_MAX_PRINT(F(" zu "));
                          TB_DEBUG_MAX_PRINTLN(read_SSID_String.c_str());
                          strncpy(prev_read_SSID_String, read_SSID_String.c_str(), sizeof(prev_read_SSID_String));
                      }
                      if (strcmp(fw_state_i.c_str(), prev_fw_state_i) != 0) {
                          TB_DEBUG_MAX_PRINT(F("[IF][29] fw_state change von "));
                          TB_DEBUG_MAX_PRINT(prev_fw_state_i);
                          TB_DEBUG_MAX_PRINT(F(" zu "));
                          TB_DEBUG_MAX_PRINTLN(fw_state_i.c_str());
                          strncpy(prev_fw_state_i, fw_state_i.c_str(), sizeof(prev_fw_state_i));
                      }
                      if (strcmp(v_timezone.c_str(), prev_v_timezone) != 0) {
                          TB_DEBUG_MAX_PRINT(F("[IF][29] timezone change von "));
                          TB_DEBUG_MAX_PRINT(prev_v_timezone);
                          TB_DEBUG_MAX_PRINT(F(" zu "));
                          TB_DEBUG_MAX_PRINTLN(v_timezone.c_str());
                          strncpy(prev_v_timezone, v_timezone.c_str(), sizeof(prev_v_timezone));
                      }
                      if (g_u_clock_ist != prev_g_u_clock_ist) {
                          TB_DEBUG_MAX_PRINT(F("[IF][29] clock change von "));
                          TB_DEBUG_MAX_PRINT(prev_g_u_clock_ist);
                          TB_DEBUG_MAX_PRINT(F(" zu "));
                          TB_DEBUG_MAX_PRINTLN(g_u_clock_ist);
                          prev_g_u_clock_ist = g_u_clock_ist;
                      }
                      if (g_u_view_switch_ist != prev_g_u_view_switch_ist) {
                          TB_DEBUG_MAX_PRINT(F("[IF][29] view_switch change von "));
                          TB_DEBUG_MAX_PRINT(prev_g_u_view_switch_ist);
                          TB_DEBUG_MAX_PRINT(F(" zu "));
                          TB_DEBUG_MAX_PRINTLN(g_u_view_switch_ist);
                          prev_g_u_view_switch_ist = g_u_view_switch_ist;
                      }
                      TB_DEBUG_MAX_PRINTLN(F("[IF][29] attributes wurden modifiziert"));
                  } else {
                      // TB_DEBUG_MAX_PRINTLN("[IF][29] attributes sind unmodifiziert");
                  }


          //-------------------------------------------------------------------



        //-------------------------------------------------------------------
          Attribute attributes31[5] = {
            { C_SERIAL_KEY,  mb_Seriennummer },
            { C_s_checked_KEY,  g_checked },
            { C_s_kalibriert_KEY,  g_kalibriert },
            { G34_KEY,  radon_2h_ist },
            { D_KNX_S_KEY,  g_KNX_S_ist },
          };

          // Vergleiche die aktuellen Werte mit den vorherigen
          bool attributesChangedFlag31 = strcmp(mb_Seriennummer, prev_mb_Seriennummer) != 0 ||
                                        g_checked != prev_g_checked ||
                                        g_kalibriert != prev_g_kalibriert ||
                                        radon_2h_ist != prev_radon_2h_ist ||
                                        g_KNX_S_ist != prev_g_KNX_S_ist;
              if (attributesChangedFlag31) {
                  // Aktualisiere die vorherigen Werte und debugge die Änderungen
                  if (strcmp(mb_Seriennummer, prev_mb_Seriennummer) != 0) {
                      TB_DEBUG_MAX_PRINT(F("[IF][31] Seriennummer change von "));
                      TB_DEBUG_MAX_PRINT(prev_mb_Seriennummer);
                      TB_DEBUG_MAX_PRINT(F(" zu "));
                      TB_DEBUG_MAX_PRINTLN(mb_Seriennummer);
                      strncpy(prev_mb_Seriennummer, mb_Seriennummer, sizeof(prev_mb_Seriennummer));
                  }
                  if (g_checked != prev_g_checked) {
                      TB_DEBUG_MAX_PRINT(F("[IF][31] checked change von "));
                      TB_DEBUG_MAX_PRINT(prev_g_checked);
                      TB_DEBUG_MAX_PRINT(F(" zu "));
                      TB_DEBUG_MAX_PRINTLN(g_checked);
                      prev_g_checked = g_checked;
                  }
                  if (g_kalibriert != prev_g_kalibriert) {
                      TB_DEBUG_MAX_PRINT(F("[IF][31] kalibriert change von "));
                      TB_DEBUG_MAX_PRINT(prev_g_kalibriert);
                      TB_DEBUG_MAX_PRINT(F(" zu "));
                      TB_DEBUG_MAX_PRINTLN(g_kalibriert);
                      prev_g_kalibriert = g_kalibriert;
                  }
                  if (radon_2h_ist != prev_radon_2h_ist) {
                      TB_DEBUG_MAX_PRINT(F("[IF][31] radon_2h change von "));
                      TB_DEBUG_MAX_PRINT(prev_radon_2h_ist);
                      TB_DEBUG_MAX_PRINT(F(" zu "));
                      TB_DEBUG_MAX_PRINTLN(radon_2h_ist);
                      prev_radon_2h_ist = radon_2h_ist;
                  }
                  if (g_KNX_S_ist != prev_g_KNX_S_ist) {
                      TB_DEBUG_MAX_PRINT(F("[IF][31] KNX Status change von "));
                      TB_DEBUG_MAX_PRINT(prev_g_KNX_S_ist);
                      TB_DEBUG_MAX_PRINT(F(" zu "));
                      TB_DEBUG_MAX_PRINTLN(g_KNX_S_ist);
                      prev_g_KNX_S_ist = g_KNX_S_ist;
                  }
                  TB_DEBUG_MAX_PRINTLN(F("[IF][31] attributes wurden modifiziert"));
              } else {
                  // TB_DEBUG_MAX_PRINTLN("[IF][31] attributes sind unmodifiziert");
              }

        //-------------------------------------------------------------------


        //-------------------------------------------------------------------
        //D_Passwort_KEY
          //const int attribute_items_32 = 3;
          Attribute attributes32[4] = {
              { D_NTP1_KEY,  g_u_ntp1_ist },
              { D_NTP2_KEY,  g_u_ntp2_ist },
              { D_NTP3_KEY,  g_u_ntp3_ist },
              { D_Passwort_KEY, correctPassword } // Füge das Passwort-Attribut hinzu
          };

          // Vergleiche die aktuellen Werte mit den vorherigen
          bool attributesChangedFlag32 = strcmp(g_u_ntp1_ist, prev_g_u_ntp1_ist) != 0 ||
                                        strcmp(g_u_ntp2_ist, prev_g_u_ntp2_ist) != 0 ||
                                        strcmp(g_u_ntp3_ist, prev_g_u_ntp3_ist) != 0 ||
                                        strcmp(correctPassword, prev_correctPassword) != 0; // Überprüfe Passwortänderung

                  if (attributesChangedFlag32) {
                      // Aktualisiere die vorherigen Werte und debugge die Änderungen
                      if (strcmp(g_u_ntp1_ist, prev_g_u_ntp1_ist) != 0) {
                          TB_DEBUG_MAX_PRINT(F("[IF][32] NTP1 change von "));
                          TB_DEBUG_MAX_PRINT(prev_g_u_ntp1_ist);
                          TB_DEBUG_MAX_PRINT(F(" zu "));
                          TB_DEBUG_MAX_PRINTLN(g_u_ntp1_ist);
                          strncpy(prev_g_u_ntp1_ist, g_u_ntp1_ist, sizeof(prev_g_u_ntp1_ist));
                      }
                      if (strcmp(g_u_ntp2_ist, prev_g_u_ntp2_ist) != 0) {
                          TB_DEBUG_MAX_PRINT(F("[IF][32] NTP2 change von "));
                          TB_DEBUG_MAX_PRINT(prev_g_u_ntp2_ist);
                          TB_DEBUG_MAX_PRINT(F(" zu "));
                          TB_DEBUG_MAX_PRINTLN(g_u_ntp2_ist);
                          strncpy(prev_g_u_ntp2_ist, g_u_ntp2_ist, sizeof(prev_g_u_ntp2_ist));
                      }
                      if (strcmp(g_u_ntp3_ist, prev_g_u_ntp3_ist) != 0) {
                          TB_DEBUG_MAX_PRINT(F("[IF][32] NTP3 change von "));
                          TB_DEBUG_MAX_PRINT(prev_g_u_ntp3_ist);
                          TB_DEBUG_MAX_PRINT(F(" zu "));
                          TB_DEBUG_MAX_PRINTLN(g_u_ntp3_ist);
                          strncpy(prev_g_u_ntp3_ist, g_u_ntp3_ist, sizeof(prev_g_u_ntp3_ist));
                      }
                      if (strcmp(correctPassword, prev_correctPassword) != 0) {
                          TB_DEBUG_MAX_PRINT(F("[IF][32] Passwort Änderung von "));
                          TB_DEBUG_MAX_PRINT(prev_correctPassword);
                          TB_DEBUG_MAX_PRINT(F(" zu "));
                          TB_DEBUG_MAX_PRINTLN(correctPassword);
                      }
                      TB_DEBUG_MAX_PRINTLN(F("[IF][32] attributes wurden modifiziert"));
                  } else {
                      // TB_DEBUG_MAX_PRINTLN("[IF][32] attributes sind unmodifiziert");
                  }


        //-------------------------------------------------------------------


        //-------------------------------------------------------------------
          //  const int attribute_items_33 = 6;
          Attribute attributes33[6] = {
            { D_Cloud_ea_KEY,  g_Cloud_ea_ist },           //   0=Standard   E/A
            { D_Cloud_server_KEY,  p_inputcloudserver.c_str() },   //   loragate2.de
            { D_Cloud_page_KEY,  p_inputcloudpage.c_str() },       //   LoRaWAN-Live-Link-K1-W64rt39bd41np75L/lora_radon_alphatracer_1.php
            { D_Cloud_pre_KEY,  p_inputcloudprec },         //   submit=Daten
            { D_Cloud_port_KEY,  p_inputcloudporti },       //   80
            { D_Cloud_chain_KEY,  p_inputcloudchain.c_str() },     //   &p
          };   

          // Vergleiche die aktuellen Werte mit den vorherigen
          bool attributesChangedFlag33 = g_Cloud_ea_ist != prev_g_Cloud_ea_ist ||
                                        strcmp(p_inputcloudserver.c_str(), prev_p_inputcloudserver) != 0 ||
                                        strcmp(p_inputcloudpage.c_str(), prev_p_inputcloudpage) != 0 ||
                                        strcmp(p_inputcloudprec, prev_p_inputcloudpre) != 0 ||
                                        p_inputcloudporti != prev_p_inputcloudporti ||
                                        strcmp(p_inputcloudchain.c_str(), prev_p_inputcloudchain) != 0;

                  if (attributesChangedFlag33) {
                      // Aktualisiere die vorherigen Werte und debugge die Änderungen
                      if (g_Cloud_ea_ist != prev_g_Cloud_ea_ist) {
                          TB_DEBUG_MAX_PRINT(F("[IF][33] Cloud_ea change von "));
                          TB_DEBUG_MAX_PRINT(prev_g_Cloud_ea_ist);
                          TB_DEBUG_MAX_PRINT(F(" zu "));
                          TB_DEBUG_MAX_PRINTLN(g_Cloud_ea_ist);
                          prev_g_Cloud_ea_ist = g_Cloud_ea_ist;
                      }
                      if (strcmp(p_inputcloudserver.c_str(), prev_p_inputcloudserver) != 0) {
                          TB_DEBUG_MAX_PRINT(F("[IF][33] Cloud_server change von "));
                          TB_DEBUG_MAX_PRINT(prev_p_inputcloudserver);
                          TB_DEBUG_MAX_PRINT(F(" zu "));
                          TB_DEBUG_MAX_PRINTLN(p_inputcloudserver.c_str());
                          strncpy(prev_p_inputcloudserver, p_inputcloudserver.c_str(), sizeof(prev_p_inputcloudserver));
                      }
                      if (strcmp(p_inputcloudpage.c_str(), prev_p_inputcloudpage) != 0) {
                          TB_DEBUG_MAX_PRINT(F("[IF][33] Cloud_page change von "));
                          TB_DEBUG_MAX_PRINT(prev_p_inputcloudpage);
                          TB_DEBUG_MAX_PRINT(F(" zu "));
                          TB_DEBUG_MAX_PRINTLN(p_inputcloudpage.c_str());
                          strncpy(prev_p_inputcloudpage, p_inputcloudpage.c_str(), sizeof(prev_p_inputcloudpage));
                      }
                      if (strcmp(p_inputcloudprec, prev_p_inputcloudpre) != 0) {
                          TB_DEBUG_MAX_PRINT(F("[IF][33] Cloud_pre change von "));
                          TB_DEBUG_MAX_PRINT(prev_p_inputcloudpre);
                          TB_DEBUG_MAX_PRINT(F(" zu "));
                          TB_DEBUG_MAX_PRINTLN(p_inputcloudprec);
                          strncpy(prev_p_inputcloudpre, p_inputcloudprec, sizeof(prev_p_inputcloudpre));
                      }
                      if (p_inputcloudporti != prev_p_inputcloudporti) {
                          TB_DEBUG_MAX_PRINT(F("[IF][33] Cloud_port change von "));
                          TB_DEBUG_MAX_PRINT(prev_p_inputcloudporti);
                          TB_DEBUG_MAX_PRINT(F(" zu "));
                          TB_DEBUG_MAX_PRINTLN(p_inputcloudporti);
                          prev_p_inputcloudporti = p_inputcloudporti;
                      }
                      if (strcmp(p_inputcloudchain.c_str(), prev_p_inputcloudchain) != 0) {
                          TB_DEBUG_MAX_PRINT(F("[IF][33] Cloud_chain change von "));
                          TB_DEBUG_MAX_PRINT(prev_p_inputcloudchain);
                          TB_DEBUG_MAX_PRINT(F(" zu "));
                          TB_DEBUG_MAX_PRINTLN(p_inputcloudchain.c_str());
                          strncpy(prev_p_inputcloudchain, p_inputcloudchain.c_str(), sizeof(prev_p_inputcloudchain));
                      }
                      TB_DEBUG_MAX_PRINTLN(F("[IF][33] attributes wurden modifiziert"));
                  } else {
                      // TB_DEBUG_MAX_PRINTLN("[IF][33] attributes sind unmodifiziert");
                  }


        //-------------------------------------------------------------------


                esp_task_wdt_reset(); 
                if (attributesChangedFlag26) {
                    attributesChangedFlag26 = !attributesChangedFlag26;
                  //Serial.println("[IF] attributes26");
                  sendAttributes26_ok = true;
                  delay(200);
                  sendAttributes26_ok = tb.sendAttributes(attributes26, 5);
                  send_ueberw_counter_start ++;
                  send_ueberw_counter_start_[26]++;
                  if(sendAttributes26_ok == false){
                    Serial.println("[SA] Sending attributes 26 fail"); 
                    send_ueberw_counter ++;
                    send_ueberw_counter_error_[26]++;
                  }else{send_ueberw_counter_success ++;send_ueberw_counter_success_[26]++;}
                }
                  
                if (attributesChangedFlag25) {
                    attributesChangedFlag25 = !attributesChangedFlag25;
                    //Serial.println("[IF] attributes25");
                    sendAttributes25_ok = true;
                    delay(200);
                    sendAttributes25_ok = tb.sendAttributes(attributes25, 5);
                    send_ueberw_counter_start ++;
                    send_ueberw_counter_start_[25]++;
                    if(sendAttributes25_ok == false){
                      Serial.println("[SA] Sending attributes 25 fail"); 
                      send_ueberw_counter ++;
                      send_ueberw_counter_error_[25]++;
                    }else{send_ueberw_counter_success ++;send_ueberw_counter_success_[25]++;}
                }
                  
                if (attributesChangedFlag27) {
                    attributesChangedFlag27 = !attributesChangedFlag27;
                  //Serial.println("[IF] attributes27");
                  sendAttributes27_ok = true;
                  delay(200);
                  sendAttributes27_ok = tb.sendAttributes(attributes27, 4);
                  send_ueberw_counter_start ++;
                  send_ueberw_counter_start_[27]++;
                  if(sendAttributes27_ok == false){
                    Serial.println("[SA] Sending attributes 27 fail"); 
                    send_ueberw_counter ++;
                    send_ueberw_counter_error_[27]++;
                  }else{send_ueberw_counter_success ++;send_ueberw_counter_success_[27]++;}
                }
                
                  
                  // Vergleiche die aktuellen Attribute mit den vorherigen
                if (attributesChangedFlag28) {
                    attributesChangedFlag28 = !attributesChangedFlag28;
                  sendAttributes28_ok = true;
                  delay(200);
                  sendAttributes28_ok = tb.sendAttributes(attributes28, 5);
                  send_ueberw_counter_start ++;
                  send_ueberw_counter_start_[28]++;
                  if(sendAttributes28_ok == false){
                    Serial.println("[SA] Sending attributes 28 fail"); 
                    send_ueberw_counter ++;
                    send_ueberw_counter_error_[28]++;
                  }else{send_ueberw_counter_success ++;send_ueberw_counter_success_[28]++;}

                }
                
                 
                   esp_task_wdt_reset(); 
                   if (attributesChangedFlag29) {
                  //Serial.println("[IF] attributes29");
                  sendAttributes29_ok = true;
                  delay(200);
                  sendAttributes29_ok = tb.sendAttributes(attributes29, 4);
                  send_ueberw_counter_start ++;
                  send_ueberw_counter_start_[29]++;
                  if(sendAttributes29_ok == false){
                    Serial.println("[SA] Sending attributes 29 fail"); 
                    send_ueberw_counter ++;
                    send_ueberw_counter_error_[29]++;
                  }else{send_ueberw_counter_success ++;send_ueberw_counter_success_[29]++;}
                   }

                 
                 if (attributesChangedFlag31) {
                  //Serial.println("[IF] attributes31");
                  sendAttributes31_ok = true;
                  delay(200);
                  sendAttributes31_ok = tb.sendAttributes(attributes31, 4);
                  send_ueberw_counter_start ++;
                  send_ueberw_counter_start_[31]++;
                  if(sendAttributes31_ok == false){
                    Serial.println("[SA] Sending attributes 31 fail"); 
                    send_ueberw_counter ++;
                    send_ueberw_counter_error_[31]++;
                  }else{send_ueberw_counter_success ++;send_ueberw_counter_success_[31]++;}
                 }

               
                  if (attributesChangedFlag32) {
                  //Serial.println("[IF] attributes31");
                  sendAttributes32_ok = true;
                  delay(200);
                  sendAttributes32_ok = tb.sendAttributes(attributes32, 3);
                  send_ueberw_counter_start ++;
                  send_ueberw_counter_start_[32]++;
                  if(sendAttributes32_ok == false){
                    Serial.println("[SA] Sending attributes 32 fail"); 
                    send_ueberw_counter ++;
                    send_ueberw_counter_error_[32]++;
                  }else{send_ueberw_counter_success ++;send_ueberw_counter_success_[32]++;}
                  }


               
                  if (attributesChangedFlag33) {
                  //Serial.println("[IF] attributes31");
                  sendAttributes33_ok = true;
                  delay(200);
                  sendAttributes33_ok = tb.sendAttributes(attributes33, 6);
                  send_ueberw_counter_start ++;
                  send_ueberw_counter_start_[33]++;
                  if(sendAttributes33_ok == false){
                    Serial.println("[SA] Sending attributes 33 fail"); 
                    send_ueberw_counter ++;
                    send_ueberw_counter_error_[33]++;
                  }else{send_ueberw_counter_success ++;send_ueberw_counter_success_[33]++;}
                  }

              
                 if(TB_currFwVersion == TB_newFwVersion){
                
                  //Serial.println("[IF] attributes30");
                  if (attributesChangedFlag30) {
                  sendAttributes30_ok = true;
                  delay(200);
                  sendAttributes30_ok = tb.sendAttributes(attributes30, 1);
                  send_ueberw_counter_start ++;
                  send_ueberw_counter_start_[30]++;
                  if(sendAttributes30_ok == false){
                    Serial.println("[SA] Sending attributes 30 fail"); 
                    send_ueberw_counter ++;
                    send_ueberw_counter_error_[30]++;
                  }else{send_ueberw_counter_success ++;send_ueberw_counter_success_[30]++;}
                  }
                 }

                 g_end_boot = true;

                 delay(200);
                 tb.sendTelemetryData("WTD", ee_var_01);


      //Serial.println("[SA] Sending Client attributes 1 done");     
               


}
//----------------------------------


//----------------------------------
void send_client2_attribute(){      //  void send_shared_attribute(){

            // Serial.println("[SA] Subscribe Shared attributes..."); 
             //Serial.println("[SA] Sending Client attributes 2..."); 
             
              if(TB_currFwVersion == TB_newFwVersion){

                   //tb.sendAttributeString(fw_state_KEY, "INITIATED");     //fw_state  Insatllierte FW
                    //----------------------------
                      //const int attribute_items_19 = 1;
                      Attribute attributes19[1] = {
                        { fw_state_KEY,  fw_state_i.c_str() },
                      };

                  // Vergleiche die aktuellen Werte mit den vorherigen
                  bool attributesChangedFlag19 = strcmp(fw_state_i.c_str(), prev_fw_state) != 0;

                  if (attributesChangedFlag19) {
                      // Aktualisiere die vorherigen Werte
                      strncpy(prev_fw_state, fw_state_i.c_str(), sizeof(prev_fw_state));


                      sendAttributes19_ok = true;
                      delay(200);
                      sendAttributes19_ok = tb.sendAttributes(attributes19, 1);
                      send_ueberw_counter_start ++;
                      send_ueberw_counter_start_[19]++;
                      if(sendAttributes19_ok == false){
                        Serial.println("[SA] Sending attributes 19 fail"); 
                        send_ueberw_counter ++;
                        send_ueberw_counter_error_[19]++;
                      }else{send_ueberw_counter_success ++;send_ueberw_counter_success_[19]++;}
                      
                    TB_DEBUG_MAX_PRINTLN(F("[IF][19] attributes wurden modifiziert"));
                  }else{
                    //Serial.println("[IF][19] attributes sind unmodifiziert");
                  }
                    //----------------------------
              }




                 //-----------------------------------------------------
                  Attribute attributes11[1] = {
                    { G52_KEY,  mb_radon_F3_Version },
                  };
                  // Vergleiche die aktuellen Werte mit den vorherigen
                  bool attributesChangedFlag11 = mb_radon_F3_Version != prev_mb_radon_F3_Version;

                  if (attributesChangedFlag11) {
                      // Aktualisiere die vorherigen Werte
                    prev_mb_radon_F3_Version = mb_radon_F3_Version;

                    sendAttributes11_ok = true;
                    delay(200);
                    sendAttributes11_ok = tb.sendAttributes(attributes11, 1);
                    send_ueberw_counter_start ++;
                    send_ueberw_counter_start_[11]++;
                      if(sendAttributes11_ok == false){
                        Serial.println("[SA] Sending attributes 11 fail"); 
                        send_ueberw_counter ++;
                        send_ueberw_counter_error_[11]++;
                      }else{send_ueberw_counter_success ++;send_ueberw_counter_success_[11]++;}
                    TB_DEBUG_MAX_PRINTLN(F("[IF][11] attributes wurden modifiziert"));
                  }else{
                    //Serial.println("[IF][11] attributes sind unmodifiziert");
                  }
                 //-----------------------------------------------------
                    
                
                 //-----------------------------------------------------
                    Attribute attributes12[1] = {
                     { D_AvailableKeys_KEY,  d_AvailableKeys },
                    };
                    // Vergleiche die aktuellen Werte mit den vorherigen
                    bool attributesChangedFlag12 = strcmp(d_AvailableKeys, prev_d_AvailableKeys) != 0;

                  if (attributesChangedFlag12) {
                        // Aktualisiere die vorherigen Werte
                        strncpy(prev_d_AvailableKeys, d_AvailableKeys, sizeof(prev_d_AvailableKeys));

                    sendAttributes12_ok = true;
                    delay(200);
                    sendAttributes12_ok = tb.sendAttributes(attributes12, 1);
                    send_ueberw_counter_start ++;
                    send_ueberw_counter_start_[12]++;
                      if(sendAttributes12_ok == false){
                        Serial.println("[SA] Sending attributes 12 fail"); 
                        send_ueberw_counter ++;
                        send_ueberw_counter_error_[12]++;
                      }else{send_ueberw_counter_success ++;send_ueberw_counter_success_[12]++;}
                    TB_DEBUG_MAX_PRINTLN(F("[IF][12] attributes wurden modifiziert"));
                  }else{
                    //Serial.println("[IF][12] attributes sind unmodifiziert");
                  }
                 //-----------------------------------------------------


                 //-----------------------------------------------------
                    Attribute attributes13[1] = {
                     { C_s_checked_KEY,  g_checked },
                    };
                    // Vergleiche die aktuellen Werte mit den vorherigen
                    bool attributesChangedFlag13 = g_checked != prev_g_checked;

                  if (attributesChangedFlag13) {
                        // Aktualisiere die vorherigen Werte
                        prev_g_checked = g_checked;

                    sendAttributes13_ok = true;
                    delay(200);
                    sendAttributes13_ok = tb.sendAttributes(attributes13, 1);
                    send_ueberw_counter_start ++;
                    send_ueberw_counter_start_[13]++;
                      if(sendAttributes13_ok == false){
                        Serial.println("[SA] Sending attributes 13 fail"); 
                        send_ueberw_counter ++;
                        send_ueberw_counter_error_[13]++;
                      }else{send_ueberw_counter_success ++;send_ueberw_counter_success_[13]++;}

                    TB_DEBUG_MAX_PRINTLN(F("[IF][13] attributes wurden modifiziert"));
                  }else{
                    //Serial.println("[IF][13] attributes sind unmodifiziert");
                  }
                 //-----------------------------------------------------


                 //-----------------------------------------------------
                    Attribute attributes14[1] = {
                     { C_s_kalibriert_KEY,  g_kalibriert },
                    };

                  // Vergleiche die aktuellen Werte mit den vorherigen
                  bool attributesChangedFlag14 = g_kalibriert != prev_g_kalibriert;

                  if (attributesChangedFlag14) {
                      // Aktualisiere die vorherigen Werte
                      prev_g_kalibriert = g_kalibriert;
                    sendAttributes14_ok = true;
                    delay(200);
                    sendAttributes14_ok = tb.sendAttributes(attributes14, 1);
                    send_ueberw_counter_start ++;
                    send_ueberw_counter_start_[14]++;
                      if(sendAttributes14_ok == false){
                        Serial.println("[SA] Sending attributes 14 fail"); 
                        send_ueberw_counter ++;
                        send_ueberw_counter_error_[14]++;
                      }else{send_ueberw_counter_success ++;send_ueberw_counter_success_[14]++;}
             
                    TB_DEBUG_MAX_PRINTLN(F("[IF][14] attributes wurden modifiziert"));
                  }else{
                    //Serial.println("[IF][14] attributes sind unmodifiziert");
                  }
                 //-----------------------------------------------------


                 //-----------------------------------------------------
                   if(g_kalibrieren_ist == 0){   // kal nicht aktiv
                      Attribute attributes15[1] = {
                      { G34_KEY,  radon_2h_ist },
                      };

                    // Vergleiche die aktuellen Werte mit den vorherigen
                    bool attributesChangedFlag15 = radon_2h_ist != prev_radon_2h_ist;

                    if (attributesChangedFlag15) {
                        // Aktualisiere die vorherigen Werte
                        prev_radon_2h_ist = radon_2h_ist;
                      sendAttributes15_ok = true;
                      delay(200);
                      sendAttributes15_ok = tb.sendAttributes(attributes15, 1);
                      send_ueberw_counter_start ++;
                      send_ueberw_counter_start_[15]++;
                      if(sendAttributes15_ok == false){
                        Serial.println("[SA] Sending attributes 15 fail"); 
                        send_ueberw_counter ++;
                        send_ueberw_counter_error_[15]++;
                      }else{send_ueberw_counter_success ++;send_ueberw_counter_success_[15]++;}
                 
                      
             
                      TB_DEBUG_MAX_PRINTLN(F("[IF][15] attributes wurden modifiziert"));
                    }else{
                     // Serial.println("[IF][15] attributes sind unmodifiziert");
                    }

                   }
                 //-----------------------------------------------------


                 //-----------------------------------------------------
                      Attribute attributes16[1] = {
                      { D_Passwort_KEY,  correctPassword},
                      };

                    // Vergleiche die aktuellen Werte mit den vorherigen
                    //bool attributesChangedFlag16 = correctPassword != prev_correctPassword;
                    bool attributesChangedFlag16 = strcmp(correctPassword, prev_correctPassword) != 0;

                    if (attributesChangedFlag16) {
                        // Aktualisiere die vorherigen Werte
                      strcpy(prev_correctPassword, correctPassword);
                      sendAttributes16_ok = true;
                      delay(200);
                      sendAttributes16_ok = tb.sendAttributes(attributes16, 1);
                      send_ueberw_counter_start ++;
                      send_ueberw_counter_start_[16]++;
                      if(sendAttributes16_ok == false){
                        Serial.println("[SA] Sending attributes 16 fail"); 
                        send_ueberw_counter ++;
                        send_ueberw_counter_error_[16]++;
                      }else{send_ueberw_counter_success ++;send_ueberw_counter_success_[16]++;}
                   
             
                      TB_DEBUG_MAX_PRINTLN(F("[IF][16] attributes wurden modifiziert"));
                    }else{
                     // Serial.println("[IF][15] attributes sind unmodifiziert");
                    }
                 //-----------------------------------------------------




                 //-----------------------------------------------------
                    Attribute attributes17[1] = {
                      { D_FIRMWARE_DATE_KEY,  FIRMWARE_DATE_TIME},
                    };

                    // Vergleiche die aktuellen Werte mit den vorherigen
                    bool attributesChangedFlag17 = strcmp(FIRMWARE_DATE_TIME, prev_firmware_date_time) != 0;


                    if (attributesChangedFlag17) {
                        // Aktualisiere die vorherigen Werte
                      sendAttributes17_ok = true;
                      delay(200);
                      sendAttributes17_ok = tb.sendAttributes(attributes17, 1);
                      send_ueberw_counter_start ++;
                      send_ueberw_counter_start_[17]++;
                      if(sendAttributes17_ok == false){
                        Serial.println("[SA] Sending attributes 17 fail"); 
                        send_ueberw_counter ++;
                        send_ueberw_counter_error_[17]++;
                      }else{send_ueberw_counter_success ++;send_ueberw_counter_success_[17]++;}
                   
             
                      TB_DEBUG_MAX_PRINTLN(F("[IF][17] attributes wurden modifiziert"));

                    }else{
                     // Serial.println("[IF][15] attributes sind unmodifiziert");
                    }
                 //-----------------------------------------------------
           






                    /*
                    const int attribute_items_t2 = 5;
                    Attribute attributes10[attribute_items_t2] = {
                      { C_SERIAL_KEY,  mb_Seriennummer },
                      { G52_KEY,  mb_radon_F3_Version },
                      { D_AvailableKeys_KEY,  d_AvailableKeys },
                      { C_s_checked_KEY,  g_checked },
                      { C_s_kalibriert_KEY,  g_kalibriert },
                    };
                    tb.sendAttributes(attributes10, attribute_items_t2);
                      */
                  //----------------------------

                  
                  //Serial.println("[SA] Sending Client attributes 2 done");
                  //Serial.println("-----------------------------------");

                  alles_senden_fertig = true;
                  g_check_send_ueberwachung = true;
                    // Setze die Flag-Variable, um anzuzeigen, dass die Übertragungen abgeschlossen sind
                  transferCompleteTime = millis();
                  internetTransferComplete = true;

                  //tb.disconnect();
                  //Serial.println("[SA] TB disconnect.");

                  
}
//----------------------------------



//---------------------------------- 
void send_telemetry_step_data(){

  TB_DEBUG_MAX_PRINTLN(F("[SA] Sending Telemetry Step Data 1...")); 

  tb.sendTelemetryData("Impulse", mb_cal20); delay(200);
  tb.sendTelemetryData("Loopradonauto", mb_cal21); delay(200);
  tb.sendTelemetryData("Reverscount", mb_cal22); delay(200);
  tb.sendTelemetryData("RCounts", mb_cal24); delay(200);
  tb.sendTelemetryData("Stufen_anpassung", mb_cal23); delay(200);
  tb.sendTelemetryData("WTD", ee_var_01); delay(200);

  TB_DEBUG_MIN_PRINTLN(F("[SA] Sending Telemetry Step Data done")); 
  
  #ifdef IF_DEBUG
  //float usedRAM = (ESP.getHeapSize() - ESP.getFreeHeap()) / (1024.0 * 1024.0);
  //IF_DEBUG_PRINT(F("Used RAM: "));
  //Serial.print(usedRAM, 3);Serial.println(F(" MB"));
  #endif

}
//----------------------------------



//----------------------------------
void send_telemetry_data(){

  TB_DEBUG_MAX_PRINTLN(F("[SA] Sending Telemetry Data 1...")); 

  tb.sendTelemetryData(RADON_KEY, mb_radon_live_32bit); delay(200);

  TB_DEBUG_MIN_PRINTLN(F("[SA] Sending Telemetry Data done")); 

}
//----------------------------------


//----------------------------------
void send_telemetry_data_json(){      // MQTT alles gesendet

  Serial.println(F("[SA] Sending Telemetry Data 2...")); 

    sendTelemetryJson_ok = false;
      
      /*
      String payload3 = "{\"";
      payload3 += "devicenumber";  
      payload3 += "\":";
      payload3 += mb_Seriennummer;
                              
      payload3 += ",";
      payload3 += "\"";
      payload3 += "radon";  
      payload3 += "\":";
      payload3 += mb_radon_live_32bit;// String(random(0,1500));  // mb_radon_live_32bit

      payload3 += "}";

      char attributes[Default_Buffering_Size];
      payload3.toCharArray(attributes, Default_Buffering_Size);
      sendTelemetryJson_ok = tb.sendTelemetryJson(attributes);
      delay(200);
      */
      char payload3[200]; // Puffer für das Payload

      snprintf(payload3, sizeof(payload3), "{\"devicenumber\":\"%s\",\"radon\":%u}",
              mb_Seriennummer, mb_radon_live_32bit);

      sendTelemetryJson_ok = tb.sendTelemetryJson(payload3);
      delay(200);

      if(sendTelemetryJson_ok == true){
        TB_DEBUG_MAX_PRINTLN(F("[SA] Sending Telemetry Data 2 success")); 
      }else{
        TB_DEBUG_MAX_PRINTLN(F("[SA] Sending Telemetry Data 2 fail")); 
        // Zusätzliche Fehlerbehandlung
        //Serial.println("Fehlermeldung: " + tb.getLastError());
      }


}
//----------------------------------







//----------------------------------
 #ifndef aktivate_psram_flash
    
    void send_telemetry_data_json_step(){      // MQTT alles gesendet

      TB_DEBUG_MAX_PRINTLN(F("[SA] Sending Telemetry Data json...")); 



        sendTelemetryJson_ok = false;
          /*
          String payload3 = "{\"";

          payload3 += "devicenumber";  
          payload3 += "\":";
          payload3 += mb_Seriennummer;
                                  
          payload3 += ",";
          payload3 += "\"";
          payload3 += "radon";  
          payload3 += "\":";
          payload3 += mb_radon_live_32bit;// String(random(0,1500));  // mb_radon_live_32bit

          payload3 += "}";

          char attributes[Default_Buffering_Size];
          payload3.toCharArray(attributes, Default_Buffering_Size);
          send_ueberw_counter_t_start ++;
          sendTelemetryJson_ok = tb.sendTelemetryJson(attributes);
          delay(200);
          */
          char payload3[200]; // Angemessene Größe für das Payload

          snprintf(payload3, sizeof(payload3), "{\"devicenumber\":\"%s\",\"radon\":%u}",
                  mb_Seriennummer, mb_radon_live_32bit);

          send_ueberw_counter_t_start++;
          sendTelemetryJson_ok = tb.sendTelemetryJson(payload3);
          delay(200);


          if(sendTelemetryJson_ok == true){
            send_ueberw_counter_t_success ++;
          // Serial.println("[SA] Sending Telemetry Data json success: " + payload3); 
                send_client_attribute();delay(200);
                send_client2_attribute();delay(200);
          }else{
            send_ueberw_counter_t_error ++;
           TB_DEBUG_MAX_PRINTLN(F("[SA] Sending Telemetry Data json fail")); 
          }
              //float usedRAM = (ESP.getHeapSize() - ESP.getFreeHeap()) / (1024.0 * 1024.0);
              //Serial.print(F("Used RAM: "));Serial.print(usedRAM, 3);Serial.println(F(" MB"));
          //TB_DEBUG_MAX_PRINTLN(F("--------------------------------------------------------")); 

    }

#else

void send_telemetry_data_json_step() {      // MQTT alles gesendet
    Serial.println(F("[SA] Sending Telemetry Data json..."));

    sendTelemetryJson_ok = false;

    // Große Puffer im PSRAM speichern
    char* attributes = (char*)heap_caps_malloc(Default_Buffering_Size, MALLOC_CAP_SPIRAM | MALLOC_CAP_8BIT);
    if (attributes == NULL) {
        Serial.println(F("Fehler beim Zuordnen von PSRAM für attributes"));
        return;
    }

    // JSON-Payload als C-Strings zusammenstellen und formatieren
    snprintf(attributes, Default_Buffering_Size,
             "{\"devicenumber\":\"%s\",\"radon\":%u}", 
             mb_Seriennummer, mb_radon_live_32bit);

    send_ueberw_counter_t_start++;
    sendTelemetryJson_ok = tb.sendTelemetryJson(attributes);
    delay(200);

    if (sendTelemetryJson_ok) {
        send_ueberw_counter_t_success++;
        send_client_attribute();
        delay(200);
        send_client2_attribute();
        delay(200);
    } else {
        send_ueberw_counter_t_error++;
        Serial.println(F("[SA] Sending Telemetry Data json fail"));
    }
    
    float usedRAM = (ESP.getHeapSize() - ESP.getFreeHeap()) / (1024.0 * 1024.0);
    Serial.print(F("Used RAM: "));
    Serial.print(usedRAM, 3);
    Serial.println(F(" MB"));
    Serial.println(F("--------------------------------------------------------"));

    // Speicher freigeben
    free(attributes);
}




#endif
//----------------------------------





//----------------------------------
void save_Shared_data(){

           TB_DEBUG_MAX_PRINTLN(F("[SA] Save Shared attributes when change Data on Server"));  // wenn geändert wird auf dem Server

           
              #ifdef sPACE_DEBUG
               //Serial.println("[AP] min Free memory  : " + String(esp_get_minimum_free_heap_size()) + " bytes");
              #endif


              if(TB_currFwVersion == TB_newFwVersion){
               TB_FW_up_to_date = true;   // 1 = FW ist aktuell
              }else{
                TB_FW_up_to_date = false;  // 0 = neue FW verfügbar
              }

              Preferences preferences;
              preferences.begin("eenvs", false); 
              
              if(TB_FW_up_to_date == true){
                
                if(TB_FW_up_to_date_info == true){
                  TB_FW_up_to_date_info = false;
                  TB_DEBUG_MAX_PRINT(F("[IF] Firmware is already up to date: ")); 
                  TB_DEBUG_MAX_PRINTLN(TB_newFwVersion);
                  TB_DEBUG_MAX_PRINTLN(F("-------------------------------"));

                  gFW_Update_start = 0;  //  FW aktuell
                                        
                  preferences.putUChar("fw_s_upd", gFW_Update_start);    //  0=Standard  aus 
                  gFW_counter = 0;
                  preferences.putUChar("fw_counter", gFW_counter); 

                }
                
                if(disable_server == 0){
                  disable_server = 1; 
                  

                  preferences.putUChar("g_server", disable_server);    //  1=Standard   AN 
                  #ifdef Webserver
                    server.begin();
                  #endif
                  TB_DEBUG_MAX_PRINTLN(F("[IF] Enable Server"));
                  TB_DEBUG_MAX_PRINTLN(F("[IF] Restart ESP"));

                  g_esp_restsrt = true;
                }

              }else{
                
                if(TB_FW_up_to_date_info == false){
                  TB_FW_up_to_date_info = true;
                  TB_DEBUG_MAX_PRINTLN(F("[IF] A new Firmware is available."));
                  g_set_new_FW = true;
                  g_set_new_FW_time = 0;
                  gFW_Update_start = 1;  // neue FW verfügbar
                    
                  preferences.putUChar("fw_s_upd", gFW_Update_start);    //  0=Standard  aus 
                }              

                if(disable_server >= 1){
                  disable_server = 0; //void setup()
                  
                  preferences.putUChar("g_server", disable_server);    //  1=Standard   AN 
                  #ifdef Webserver
                    server.end();
                  #endif
                  Serial.println("[IF] Disable Server");
                }

              }


          
           
              //Serial.println("[IF] Connected to: " + String(WiFi.SSID()));
              //Serial.print("[IF] IP: ");
              //Serial.println(WiFi.localIP());

              
              //Serial.print("[IF] TB Connect: ");
              //Serial.println(TB_status);
       
        TB_DEBUG_MAX_PRINTLN(F("[SA] Save Shared attributes"));



        preferences.putUShort("p_unit_ist", g_unit_ist);  //1=Standard   1 = bqm3  0=pCi
        preferences.putUShort("p_LEDT_T", g_LEDT_T_ist); //1=Standard  Top led EIN
        preferences.putUShort("p_LEDT_F", g_LEDT_F_ist);  //1=Standard  7 Segment  EIN
        preferences.putUShort("p_KNX_S", g_KNX_S_ist);    // 0=Standard   KNX Aus
        preferences.putUShort("p_LEDT_FB", g_LEDT_FB_ist);  //5=Standard   Helligkeit forne
        preferences.putUShort("p_LEDT_TB", g_LEDT_TB_ist); //50=Standard  Top LED Helligkeit
        preferences.putUShort("g_Range_M", g_Range_T_ist); //300=Standard   oben Range ROT
        preferences.putUShort("g_Range_M", g_Range_M_ist); //150=Standard   mitte Range Orange
        preferences.putUShort("g_Range_U", g_Range_U_ist);  //  0=Standard   unten Range Grün

        preferences.putUShort("g_G00", g_G00_ist);
        preferences.putUShort("g_G01", g_G01_ist);
        preferences.putUShort("g_G02", g_G02_ist);
        preferences.putUShort("g_G18", g_G18_ist);
        preferences.putUShort("g_G19", g_G19_ist);
        preferences.putUShort("g_G21", g_G21_ist);

        //preferences.putUInt("g_Gcheck", g_checked_soll);
        //preferences.putUInt("g_Gkali", g_kalibriert_soll);


  


        //-----------------

          String tempstr;
          tempstr = credentials2.i_UNIT_KEY.c_str();
          preferences.putString("t_UNIT_KEY", credentials2.i_UNIT_KEY.c_str()); 

          tempstr = credentials2.i_LED_T_KEY.c_str();
          preferences.putString("t_LED_T_KEY", credentials2.i_LED_T_KEY.c_str()); 

          tempstr = credentials2.i_LED_F_KEY.c_str();
          preferences.putString("t_LED_F_KEY", credentials2.i_LED_F_KEY.c_str()); 

          tempstr = credentials2.i_KNX_S_KEY.c_str();
          preferences.putString("t_KNX_S_KEY", credentials2.i_KNX_S_KEY.c_str()); 

          tempstr = credentials2.i_LED_FB_KEY.c_str();
          preferences.putString("t_LED_FB_KEY", credentials2.i_LED_FB_KEY.c_str()); 

          tempstr = credentials2.i_LED_TB_KEY.c_str();
          preferences.putString("t_LED_TB_KEY", credentials2.i_LED_TB_KEY.c_str()); 

          tempstr = credentials2.i_RANGE_T_KEY.c_str();
          preferences.putString("t_RANGE_T_KEY", credentials2.i_RANGE_T_KEY.c_str()); 

          tempstr = credentials2.i_RANGE_M_KEY.c_str();
          preferences.putString("t_RANGE_M_KEY", credentials2.i_RANGE_M_KEY.c_str()); 

          tempstr = credentials2.i_fw_title.c_str();
          preferences.putString("t_fw_title", credentials2.i_fw_title.c_str());          
         
          //tempstr = credentials2.i_fw_version.c_str();
          preferences.putString("t_fw_version", TB_newFwVersion); 
         
          tempstr = credentials2.i_fw_tag.c_str();
          preferences.putString("t_fw_tag", credentials2.i_fw_tag.c_str());           
         
          tempstr = credentials2.i_fw_size.c_str();
          preferences.putString("t_fw_size", credentials2.i_fw_size.c_str());    
         
          tempstr = credentials2.i_fw_checksum_algorithm.c_str();
          preferences.putString("t_fw_algorithm", credentials2.i_fw_checksum_algorithm.c_str()); 
         
          tempstr = credentials2.i_fw_checksum.c_str();
          preferences.putString("t_fw_checksum", credentials2.i_fw_checksum.c_str()); 

          tempstr = credentials2.i_u_clock_KEY.c_str();
          preferences.putString("t_u_clock_KEY", credentials2.i_u_clock_KEY.c_str()); 

          tempstr = credentials2.i_u_view_switch_KEY.c_str();
          preferences.putString("t_u_view_switch_KEY", credentials2.i_u_view_switch_KEY.c_str()); 
          
         
          tempstr = credentials2.i_u_timezone_KEY.c_str();
          preferences.putString("t_u_timez_KEY", credentials2.i_u_timezone_KEY.c_str()); 

          tempstr = credentials2.i_u_ntp1_KEY.c_str();
          preferences.putString("t_u_ntp1_KEY", credentials2.i_u_ntp1_KEY.c_str()); 
         
          tempstr = credentials2.i_u_ntp2_KEY.c_str();
          preferences.putString("t_u_ntp2_KEY", credentials2.i_u_ntp2_KEY.c_str()); 
         
          tempstr = credentials2.i_u_ntp3_KEY.c_str();
          preferences.putString("t_u_ntp3_KEY", credentials2.i_u_ntp3_KEY.c_str()); 



          tempstr = credentials2.i_u_cloud_ea_KEY.c_str();
          preferences.putString("t_u_cloud_ea_KEY", credentials2.i_u_cloud_ea_KEY.c_str()); 
          
          tempstr = credentials2.i_u_cloud_server_KEY.c_str();
          preferences.putString("t_u_cloud_server_KEY", credentials2.i_u_cloud_server_KEY.c_str()); 
          
          tempstr = credentials2.i_u_cloud_page_KEY.c_str();
          preferences.putString("t_u_cloud_page_KEY", credentials2.i_u_cloud_page_KEY.c_str()); 
          
          tempstr = credentials2.i_u_cloud_pre_KEY.c_str();
          preferences.putString("t_u_cloud_pre_KEY", credentials2.i_u_cloud_pre_KEY.c_str()); 
          
          tempstr = credentials2.i_u_cloud_port_KEY.c_str();
          preferences.putString("t_u_cloud_port_KEY", credentials2.i_u_cloud_port_KEY.c_str()); 
          
          tempstr = credentials2.i_u_cloud_chain_KEY.c_str();
          preferences.putString("t_u_cloud_chain_KEY", credentials2.i_u_cloud_chain_KEY.c_str()); 



         
          tempstr = credentials2.i_u_ble_beacon_KEY.c_str();
          preferences.putString("t_u_ble_beacon_KEY", credentials2.i_u_ble_beacon_KEY.c_str()); 
         
          tempstr = credentials2.i_u_mez_ea_KEY.c_str();
          preferences.putString("t_u_mez_ea_KEY", credentials2.i_u_mez_ea_KEY.c_str()); 

          tempstr = credentials2.i_u_identify_KEY.c_str();
          preferences.putString("t_u_identify_KEY", credentials2.i_u_identify_KEY.c_str()); 

          tempstr = credentials2.i_S00_KEY.c_str();
          preferences.putString("t_S00_KEY", credentials2.i_S00_KEY.c_str()); 

          tempstr = credentials2.i_S01_KEY.c_str();
          preferences.putString("t_S01_KEY", credentials2.i_S01_KEY.c_str()); 

          tempstr = credentials2.i_S02_KEY.c_str();
          preferences.putString("t_S02_KEY", credentials2.i_S02_KEY.c_str()); 

          tempstr = credentials2.i_S18_KEY.c_str();
          preferences.putString("t_S18_KEY", credentials2.i_S18_KEY.c_str()); 

          tempstr = credentials2.i_S19_KEY.c_str();
          preferences.putString("t_S19_KEY", credentials2.i_S19_KEY.c_str()); 

          tempstr = credentials2.i_S21_KEY.c_str();
          preferences.putString("t_S21_KEY", credentials2.i_S21_KEY.c_str()); 


        //-------------------

          //Serial.println("[SA] Sending Shared attributes..."); 
          //tb.Set_Attributes(attributes, attribute_items);

        preferences.end();

}
//----------------------------------






          boolean Sommerzeit_aktiv (int year, int month, int day, int hour)
          // ausgehend das die RTC in der Zeitzone UTC+1, also "Winterzeit Berlin" dauerhaft läuft
          // European Daylight Savings Time calculation by "jurs" for German Arduino Forum
          // input parameters: "normal time" for year, month, day, hour
          // return value: returns true during Daylight Saving Time, false otherwise
          { 
            static int x1, x2, lastYear; // Zur Beschleunigung des Codes ein Cache für einige statische Variablen
            int x3;
            if (month < 3 || month > 10) return false; // keine Sommerzeit in Jan, Feb, Nov, Dez
            if (month > 3 && month < 10) return true;  // Sommerzeit in Apr, Mai, Jun, Jul, Aug, Sep
            // der nachfolgende Code wird nur für Monat 3 und 10 ausgeführt
            // Umstellung erfolgt auf Stunde utc_hour=1, in der Zeitzone Berlin entsprechend 2 Uhr MEZ
            // Es wird ein Cache-Speicher für die Variablen x1 und x2 verwendet, 
            // dies beschleunigt die Berechnung, wenn sich das Jahr bei Folgeaufrufen nicht ändert
            // x1 und x2 werden nur neu Berechnet, wenn sich das Jahr bei nachfolgenden Aufrufen ändert
            if (year != lastYear) 
              { // Umstellungsbeginn und -ende
              x1 = 1 + 1 + 24 * (31 - (5 * year / 4 + 4) % 7);  
              x2 = 1 + 1 + 24 * (31 - (5 * year / 4 + 1) % 7);
              lastYear = year;
            }  
            x3 = hour + 24 * day;
            if ((month == 3 && x3 >= x1) || (month == 10 && x3 < x2)) return true; else return false;
          }   










     //----------------------------------
        void printLocalEpoch(){


          //----------
              time_t now;
              epochTime_esp = time(&now);     // Zeit mit Zeitzone und Sommer Winter Offset
              epochTime_diff = epochTime_esp - epochTime_start;  // p_uptime  esp32_uptimep_uptime
              
              epochTime_mqtt = epochTime_esp;     // Zeit mit Zeitzone und Sommer Winter Offset

            
              if(epochTime_rtc >= epochTime_esp){
                epochTime_r_e_diff = epochTime_rtc - epochTime_esp;
                g_epochTime_diff= true;
              }else{
                epochTime_r_e_diff = epochTime_esp - epochTime_rtc;
                g_epochTime_diff= false;
              }
          //----------


        }
     //----------------------------------







     //----------------------------------
      void printLocalTime(){
            

          struct tm timeinfo;
          time_t now;

              if (WiFi.status() == WL_CONNECTED) {
                if (!getLocalTime(&timeinfo)) {
                  #if TM_DEBUG_LEVEL  == TM_DEBUG_MAX
                    Serial.println("[TM] Failed to obtain time");
                  #endif
                }else{
                  Serial.print(F("[TM] 5: "));
                  Serial.println(&timeinfo, "%A, %B %d %Y %H:%M:%S");
                }
              } else {
                #if TM_DEBUG_LEVEL  == TM_DEBUG_MAX
                  Serial.println("[TM] WiFi nicht verbunden. Zeit wird vom ESP abgerufen.");
                #endif
                time(&now);
                localtime_r(&now, &timeinfo);
              }

          second = timeinfo.tm_sec;
          minute = timeinfo.tm_min;
          hour = timeinfo.tm_hour;
          day = timeinfo.tm_mday;
          month = timeinfo.tm_mon + 1;
          year = timeinfo.tm_year + 1900;
          weekday = timeinfo.tm_wday;
          yday = timeinfo.tm_yday;
          hour12h = timeinfo.tm_hour;
          istdst = timeinfo.tm_isdst;
          //Serial.print("[TM] get DST from ESP (1=Sommer): ");Serial.println(istdst);

          // diew kommen von hier   Callback_tb_task
          /*
          currentSec = second;
          currentmin = minute;
          currenthour = hour;
          currentdate = day;
          currentmonth = month;
          esp_year_t = timeinfo.tm_year + 1900-2000;
          currentyear = esp_year_t;
          currentYearTwoDigits = esp_year_t % 100;
          esp_dOW = weekday;
          */



        
        #if TM_DEBUG_LEVEL  >= TM_DEBUG_MED
            Serial.print("[TM] Uhrzeit: "); 
            Serial.println(uhrzeit_c); 
        #endif  
        
        

        // strftime(timeHour12h,3, "%I", &timeinfo);



        #if TM_DEBUG_LEVEL >= TM_DEBUG_MAX
          Serial.print("     ");
          Serial.println(&timeinfo, "%A, %B %d %Y %H:%M:%S");

          Serial.print("     Day of week: ");
          Serial.println(&timeinfo, "%A");

          Serial.print("     Month: ");
          Serial.println(&timeinfo, "%B");

          Serial.print("     Day of Month: ");
          Serial.println(&timeinfo, "%d");

          Serial.print("     Year: ");
          Serial.println(&timeinfo, "%Y");
          
          Serial.print("     Hour: ");
          Serial.println(&timeinfo, "%H");

          Serial.print("     Hour (12 hour format): ");
          Serial.println(&timeinfo, "%I");

          Serial.print("     AM/PM (12 hour format): ");
          Serial.println(&timeinfo, "%p");

          Serial.print("     Minute: ");
          Serial.println(&timeinfo, "%M");

          Serial.print("     Second: ");
          Serial.println(&timeinfo, "%S");

          Serial.println("     Time variables: ");
          Serial.print("     ");
          char timeHour[3];
          strftime(timeHour,3, "%H", &timeinfo);
          Serial.println(timeHour);
          
          char timeHour12h2[3];
          strftime(timeHour12h2,3, "%I", &timeinfo);
          Serial.print("     ");
          Serial.println(timeHour12h2);

          char timeWeekDay[10];
          strftime(timeWeekDay,10, "%A", &timeinfo);
          Serial.print("     ");
          Serial.println(timeWeekDay);


        #endif

        

        epochTime_esp = time(&now);     // Zeit mit Zeitzone und Sommer Winter Offset
        epochTime_diff = epochTime_esp - epochTime_start;  // p_uptime  esp32_uptimep_uptime
        
        epochTime_mqtt = epochTime_esp;     // Zeit mit Zeitzone und Sommer Winter Offset

       
        if(epochTime_rtc >= epochTime_esp){
          epochTime_r_e_diff = epochTime_rtc - epochTime_esp;
          g_epochTime_diff= true;
        }else{
          epochTime_r_e_diff = epochTime_esp - epochTime_rtc;
          g_epochTime_diff= false;
        }



        #if TM_DEBUG_LEVEL >= TM_DEBUG_MED
          //timeClient.update();
          Serial.println(timeClient.getEpochTime());
          Serial.println(time(&now));

          Serial.print("[TM] EpochTime: ");Serial.println(epochTime_esp);
          Serial.println("[TM] Sensor Start: " + String(epochTime_start));  
          Serial.println("[TM] Sensor diff: " + String(epochTime_diff)); 
        #endif


        



          runMillis= millis();
          allSeconds=millis()/1000;
          runHours= allSeconds/3600;
          secsRemaining=allSeconds%3600;
          runMinutes=secsRemaining/60;
          runSeconds=secsRemaining%60;
          sprintf(tbuf,"%02d:%02d:%02d",runHours,runMinutes,runSeconds);

         // p_uptime2 = String(runHours);

        #if TM_DEBUG_LEVEL >= TM_DEBUG_MAX
          //Serial.print("[TM] Millis Uhrzeit: "); 
          //Serial.println(tbuf);   
        #endif

        #if TM_DEBUG_LEVEL >= TM_DEBUG_MAX
          Serial.print("[TM] Run Millis: ");Serial.println(runMillis);
          //Serial.print("[TM] Run h: ");Serial.println(runHours);
          //Serial.print("[TM] Run Rem: ");Serial.println(secsRemaining);
        #endif

      }
      //------------------------------------





    //------------------------------------
    void Set_alarm1(){

                myRTC.turnOffAlarm(1);
                // Test of alarm functions
                // set A1 to one minute past the time we just set the clock
                // on current day of week.
                //                                         alarmBits, alarmDayIsDay, alarmH12, alarmPM)
                myRTC.setA1Time(alarmDay, alarmHour, alarmMinute, alarmSecond, alarmBits, alarmDayIsDay, alarmH12, alarmPM);
                myRTC.setA1Time(day, hour, minute+1, second, 0x0, true, false, false);
                // Turn on both alarms, with external interrupt
                myRTC.turnOnAlarm(1);
                // clear Alarm 1 flag
                myRTC.checkIfAlarm(1);



                //  Add code to prevent Alarm 2 from interfering with the interrupt,
                //  by setting A2Minute to a value that can never match the time
                //  and setting AlarmBits to 0b01100000: alarm "when minutes match".
                //  Also clear the A2 alarm flag.

                //alarmMinute = 0xFF; // a value that will never match the time
                //alarmBits = 0b01100000; // Alarm 2 when minutes match, i.e., never
                
                // Upload the parameters to prevent Alarm 2 entirely
                myRTC.setA2Time(alarmDay, alarmHour, 0xFF, 0b01100000, false, false, false);
                // disable Alarm 2 interrupt
                myRTC.turnOffAlarm(2);
                // clear Alarm 2 flag
                myRTC.checkIfAlarm(2);



    }
    //------------------------------------


    //------------------------------------
    void Set_ESP_clock(){

          
          if(epochTime_esp >= 1704067200 && epochTime_esp <= 2524608000){
              
              Serial.print("[TM] ESP Uhr Stellen, Epochtime: ");Serial.println(epochTime_esp);
              
              Serial.println("[TM] Set ESP Clock Valid");
              struct timespec tp;
              tp.tv_sec = epochTime_esp;
              clock_settime(CLOCK_REALTIME, &tp); 

          }

    }
    //------------------------------------

    //------------------------------------
       /*
        String readCSV() {
          File file = SPIFFS.open("/zones.csv");
          if (!file) {
            Serial.println("Fehler beim Öffnen der CSV-Datei");
            return "";
          }

          String csvContent;
          while (file.available()) {
            csvContent += char(file.read());
          }
          file.close();
          return csvContent;
        }
       */
     /*
        String readCSV() {
            const char* ptr = zones_csv;
            String csvContent;
            
            while (pgm_read_byte(ptr) != 0) {
                csvContent += (char)pgm_read_byte(ptr++);
            }
            
            return csvContent;
        }
        */

       #ifndef Firmware_backup
       
       
        String readCSV() {
            return FPSTR(zones_csv);
        }
  


      String generateTimezoneOptions() {
          String csv = readCSV();
          if (csv == "") return "";

          // Debug-Ausgabe deaktiviert
          // Serial.println(F("CSV Inhalt:"));
          // Serial.println(csv); // Debug-Ausgabe der CSV-Daten

          String options = F("<option value=\"0\" selected>Standard (UTC-Zeitzone)</option>");
          int startIndex = 0;
          int lineNumber = 1;

          while (startIndex < csv.length()) {
              int endIndex = csv.indexOf('\n', startIndex);
              if (endIndex == -1) endIndex = csv.length();

              String line = csv.substring(startIndex, endIndex);
              // Debug-Ausgabe deaktiviert
              // Serial.print(F("Zeile ")); // Debug-Ausgabe der aktuellen Zeile
              // Serial.print(lineNumber);
              // Serial.print(F(" vor trim: "));
              // Serial.println(line);
              line.trim();
              // Debug-Ausgabe deaktiviert
              // Serial.print(F("Zeile ")); // Debug-Ausgabe der Zeile nach trim
              // Serial.print(lineNumber);
              // Serial.print(F(" nach trim: "));
              // Serial.println(line);

              int commaIndex = line.indexOf(',');
              if (commaIndex == -1) {
                  // Debug-Ausgabe deaktiviert
                  // Serial.print(F("Error: Invalid CSV format in line "));
                  // Serial.println(lineNumber); // Fehlermeldung bei fehlendem Komma
              } else {
                  String zoneName = line.substring(0, commaIndex);
                  String zoneValue = line.substring(commaIndex + 1);
                  // Debug-Ausgabe deaktiviert
                  // Serial.print(F("Zone Name vor trim: ")); // Debug-Ausgabe des Zonennamens vor trim
                  // Serial.println(zoneName);
                  // Serial.print(F("Zone Value vor trim: ")); // Debug-Ausgabe des Zonenwerts vor trim
                  // Serial.println(zoneValue);

                  zoneName.trim();
                  zoneValue.trim();
                  // Debug-Ausgabe deaktiviert
                  // Serial.print(F("Zone Name nach trim: ")); // Debug-Ausgabe des Zonennamens nach trim
                  // Serial.println(zoneName);
                  // Serial.print(F("Zone Value nach trim: ")); // Debug-Ausgabe des Zonenwerts nach trim
                  // Serial.println(zoneValue);

                  // Konvertiere jede FPSTR-Konstante zu einem String
                  String optionPrefix = String(F("<option value=\""));
                  String optionMiddle = String(F("\">"));
                  String optionSuffix = String(F("</option>"));

                  options += optionPrefix + zoneValue + optionMiddle + zoneName + optionSuffix;
              }
              startIndex = endIndex + 1;
              lineNumber++;
          }

          // Debug-Ausgabe deaktiviert
          // Serial.println(F("Generated Options:")); // Debug-Ausgabe der generierten Optionen
          // Serial.println(options);

          return options;
      }



      String generateCustomZoneOptions() {
          // Debug-Ausgabe deaktiviert
          // Serial.println(F("generateCustomZoneOptions"));
          String csv = readCSV();
          if (csv == "") {
              // Debug-Ausgabe deaktiviert
              // Serial.println(F("Error: CSV content is empty or could not be read."));
              return ""; // Abbruch bei leerem CSV-Inhalt
          }

          String options = F("<option value=\"0\" selected>Keine</option>");
          int startIndex = 0;
          int lineNumber = 1;
          csv.trim(); // Entferne führende und nachfolgende Leerzeichen oder unsichtbare Zeichen

          while (startIndex < csv.length()) {
              int endIndex = csv.indexOf('\n', startIndex);
              if (endIndex == -1) endIndex = csv.length();

              String line = csv.substring(startIndex, endIndex);
              // Debug-Ausgabe deaktiviert
              // Serial.print(F("Zeile ")); // Debug-Ausgabe der aktuellen Zeile
              // Serial.print(lineNumber);
              // Serial.print(F(": "));
              // Serial.println(line);

              int commaIndex = line.indexOf(',');
              if (commaIndex == -1) {
                  // Debug-Ausgabe deaktiviert
                  // Serial.print(F("Error: Invalid CSV format, missing comma in line "));
                  // Serial.println(lineNumber); // Fehlermeldung bei fehlendem Komma
                  return ""; // Abbruch bei ungültigem CSV-Format
              }

              String zoneName = line.substring(0, commaIndex);
              String zoneValue = line.substring(commaIndex + 1);
              zoneName.replace("\"", ""); // Entferne die Anführungszeichen separat
              zoneValue.replace("\"", ""); // Entferne die Anführungszeichen separat

              // Debug-Ausgabe deaktiviert
              // Serial.print(F("Zone Name: ")); // Debug-Ausgabe des Zonennamens
              // Serial.println(zoneName);
              // Serial.print(F("Zone Value: ")); // Debug-Ausgabe des Zonenwerts
              // Serial.println(zoneValue);

              // Konvertiere jede FPSTR-Konstante zu einem String
              String optionPrefix = String(F("<option value=\""));
              String optionMiddle = String(F("\">"));
              String optionSuffix = String(F("</option>"));

              options += optionPrefix + zoneValue + optionMiddle + zoneName + optionSuffix;
              startIndex = endIndex + 1;
              lineNumber++;
          }

          // Debug-Ausgabe deaktiviert
          // Serial.println(F("Generated Options:")); // Debug-Ausgabe der generierten Optionen
          // Serial.println(options);

          return options;
      }
      String generateFirstDropdownOptions() {
          // Debug-Ausgabe deaktiviert
          // Serial.println(F("generateFirstDropdownOptions"));
          String csv = readCSV();
          if (csv == "") {
              Serial.println(F("Error: CSV content is empty or could not be read."));
              return ""; // Abbruch bei leerem CSV-Inhalt
          }

          String options = F("<option value=\"0\" selected>W&auml;hle eine Region</option>");
          String regions[100]; // Array zum Speichern der Regionen
          int regionCount = 0;
          int startIndex = 0;
          int lineNumber = 1;
          csv.trim(); // Entferne führende und nachfolgende Leerzeichen oder unsichtbare Zeichen

          while (startIndex < csv.length()) {
              int endIndex = csv.indexOf('\n', startIndex);
              if (endIndex == -1) endIndex = csv.length();

              String line = csv.substring(startIndex, endIndex);
              // Debug-Ausgabe deaktiviert
              // Serial.print(F("Zeile ")); // Debug-Ausgabe der aktuellen Zeile
              // Serial.print(lineNumber);
              // Serial.print(F(": "));
              // Serial.println(line);

              int commaIndex = line.indexOf(',');
              if (commaIndex == -1) {
                  // Debug-Ausgabe deaktiviert
                  // Serial.print(F("Error: Invalid CSV format, missing comma in line "));
                  // Serial.println(lineNumber); // Fehlermeldung bei fehlendem Komma
                  return ""; // Abbruch bei ungültigem CSV-Format
              }

              String zoneName = line.substring(0, commaIndex);
              String region = zoneName.substring(0, zoneName.indexOf('/'));

              // Entferne Anführungszeichen
              region.replace("\"", "");

              // Überprüfen, ob die Region bereits im Array vorhanden ist
              bool regionExists = false;
              for (int i = 0; i < regionCount; i++) {
                  if (regions[i] == region) {
                      regionExists = true;
                      break;
                  }
              }

              // Wenn die Region nicht vorhanden ist, füge sie zum Array hinzu
              if (!regionExists && regionCount < 100) {
                  regions[regionCount++] = region;
              }

              startIndex = endIndex + 1;
              lineNumber++;
          }

          // Optionen für das erste Dropdown-Menü generieren
          for (int i = 0; i < regionCount; i++) {
              // Konvertiere jede FPSTR-Konstante zu einem String
              String optionPrefix = String(F("<option value=\""));
              String optionMiddle = String(F("\">"));
              String optionSuffix = String(F("</option>"));

              options += optionPrefix + regions[i] + optionMiddle + regions[i] + optionSuffix;
          }

          // Debug-Ausgabe deaktiviert
          // Serial.println(F("Generated Options:")); // Debug-Ausgabe der generierten Optionen
          // Serial.println(options);

          return options;
      }

      String generateSecondDropdownOptions(String selectedRegion) {
          // Debugging-Ausgabe deaktiviert
          // Serial.println(F("Selected Region: ") + selectedRegion);

          String csv = readCSV();
          if (csv == "") {
              // Debugging-Ausgabe deaktiviert
              // Serial.println(F("Error: CSV content is empty or could not be read."));
              return ""; // Abbruch bei leerem CSV-Inhalt
          }

          String options = F("<option value=\"0\" selected>Wähle eine Stadt</option>");
          int startIndex = 0;
          int lineNumber = 1;
          csv.trim(); // Entferne führende und nachfolgende Leerzeichen oder unsichtbare Zeichen

          while (startIndex < csv.length()) {
              int endIndex = csv.indexOf('\n', startIndex);
              if (endIndex == -1) endIndex = csv.length();

              String line = csv.substring(startIndex, endIndex);
              // Debugging-Ausgabe deaktiviert
              // Serial.print(F("Zeile ")); 
              // Serial.print(lineNumber);
              // Serial.print(F(": "));
              // Serial.println(line);

              line.replace("\"", ""); // Entferne alle Anführungszeichen
              int commaIndex = line.indexOf(',');
              if (commaIndex == -1) {
                  // Debugging-Ausgabe deaktiviert
                  // Serial.print(F("Error: Invalid CSV format, missing comma in line "));
                  // Serial.println(lineNumber);
                  return ""; // Abbruch bei ungültigem CSV-Format
              }

              String zoneName = line.substring(0, commaIndex);
              String region = zoneName.substring(0, zoneName.indexOf('/'));

              // Debugging-Ausgabe deaktiviert
              // Serial.print(F("Region: "));
              // Serial.println(region);
              // Serial.print(F("Zone Name: "));
              // Serial.println(zoneName);

              if (region == selectedRegion) {
                  String cityName = zoneName.substring(zoneName.indexOf('/') + 1);
                  String zoneValue = line.substring(commaIndex + 1);
                  
                  // Konvertiere jede FPSTR-Konstante zu einem String
                  String optionPrefix = String(F("<option value=\""));
                  String optionMiddle = String(F("\">"));
                  String optionSuffix = String(F("</option>"));
                  
                  options += optionPrefix + zoneValue + optionMiddle + cityName + optionSuffix;

                  // Debugging-Ausgabe deaktiviert
                  // Serial.print(F("City Name: "));
                  // Serial.println(cityName);
                  // Serial.print(F("Zone Value: "));
                  // Serial.println(zoneValue);
              }
              startIndex = endIndex + 1;
              lineNumber++;
          }

          // Debugging-Ausgabe deaktiviert
          // Serial.println(F("Generated Options: "));
          // Serial.println(options);

          return options;
      }

     #endif
    //------------------------------------









//------------------------------------
void Set_RTC_clock_after_ntp(){
    
  bool updateSuccess1 = false;
  bool updateSuccess2 = false;
  bool updateSuccess3 = false;


          //------------------    
    if (timeClient.forceUpdate()) {

          updateSuccess1 = true;

          update_ok_ready = true;
          unsigned long epochTimet = timeClient.getEpochTime();
          #if TM_DEBUG_LEVEL >= TM_DEBUG_MED
          Serial.printf("[IF][x] UTC :\t\t%lu\n", epochTimet);
          Serial.println(F(" "));
          #endif


          #if TM_DEBUG_LEVEL >= TM_DEBUG_MED
          // Berechnung der UTC-Zeit
          int utcHours = (epochTimet % 86400L) / 3600;
          int utcMinutes = (epochTimet % 3600) / 60;
          int utcSeconds = epochTimet % 60;
          Serial.printf("[IF][x] UTC time:\t\t%02d:%02d:%02d\n", utcHours, utcMinutes, utcSeconds);
          Serial.println(F(" "));
          #endif


                    // Aktualisiere die interne Uhr des ESP
                    //unsigned long  epochTimet = timeClient.getEpochTime(); // Hier wird epochTime direkt aktualisiert
                  struct timespec tp;
                  tp.tv_sec = epochTimet;
                  tp.tv_nsec = 0;

                  tp.tv_sec = epochTimet;  //hier die Uhrzeit stellen
                  clock_settime(CLOCK_REALTIME, &tp);

          // Berechnung der lokalen Zeit aus der epochTime
          time_t now = epochTimet;
          struct tm timeinfo;
          localtime_r(&now, &timeinfo);

          // Debugging: Lokale Zeit anzeigen
          char strftime_buf[64];
          strftime(strftime_buf, sizeof(strftime_buf), "%H:%M:%S", &timeinfo);
          Serial.printf("[IF][x] Lokale Zeit:\t%s\n", strftime_buf);Serial.println(F(" "));

          // Debugging: Zeit vom NTP-Server abgerufen
          /*
          Serial.println("[TM][x] Zeit vom NTP-Server abgerufen:");
          Serial.printf("Wochentag: %d\n", timeinfo.tm_wday);Serial.println(F(" "));
          Serial.printf("Monat: %d\n", timeinfo.tm_mon + 1);Serial.println(F(" "));
          Serial.printf("Tag: %d\n", timeinfo.tm_mday);Serial.println(F(" "));
          Serial.printf("Jahr: %d\n", timeinfo.tm_year + 1900);Serial.println(F(" "));
          Serial.printf("Stunde: %d\n", timeinfo.tm_hour);Serial.println(F(" "));
          Serial.printf("Minute: %d\n", timeinfo.tm_min);Serial.println(F(" "));
          Serial.printf("Sekunde: %d\n", timeinfo.tm_sec);Serial.println(F(" "));
          */

          s_second = timeinfo.tm_sec;
          s_minute = timeinfo.tm_min;
          s_hour = timeinfo.tm_hour;
          s_date = timeinfo.tm_mday;
          s_month = timeinfo.tm_mon + 1;
          unsigned long temp_year = timeinfo.tm_year + 1900 - 2000;
          s_dOW = timeinfo.tm_wday;
          byte buf[1] = {(byte) temp_year};
          s_year = buf[0];

           
                  
            myRTC.setSecond(s_second);
            myRTC.setMinute(s_minute); 
            myRTC.setHour2(s_hour);               
            myRTC.setDate(s_date);     
            myRTC.setDoW(s_dOW); 
            myRTC.setMonth(s_month);      
            myRTC.setYear(s_year);  

          #if TM_DEBUG_LEVEL >= TM_DEBUG_MAX 
          Serial.println(F("Debugging: Zeitkomponenten nach Erhalten der lokalen Zeit"));
          Serial.printf("----set_year: %d\r\n", s_year);
          Serial.printf("----set_month: %d\r\n", s_month);
          Serial.printf("----set_date: %d\r\n", s_date);
          Serial.printf("----set_dOW: %d\r\n", s_dOW);
          Serial.printf("----set_hour: %d\r\n", s_hour);
          Serial.printf("----set_minute: %d\r\n", s_minute);
          Serial.printf("----set_second: %d\r\n", s_second);
          Serial.println(F(" "));
          #endif





            currentSec = s_second;
            currentmin = s_minute;
            currenthour = s_hour;
            currenthour12 = currenthour;
                  if(g_u_clock_ist == 1){ 
                    currenthourAM_PM = false;
                  }
                  if(g_u_clock_ist == 2){ 
                    currenthour12 = currenthour;  
                    currenthourAM_PM = false;
                    if( currenthour12 == 0 ){currenthour12 = 12;currenthourAM_PM = true;}
                    if( currenthour12 > 12 ){currenthour12 = currenthour12 - 12;currenthourAM_PM = true;}
                  } 
        
           // sprintf(p_uhrzeit,"%02d:%02d:%02d",currenthour,currentmin,currentSec);



    }else{
      update_ok_ready = false;
    }


     //---- JETZT die aktualisierung aller Server 
     
      bool useNewFunction = true; // Statik-Bit zur Umschaltung zwischen den Funktionen

      if(useNewFunction == true){

            TM_DEBUG_MAX_PRINTLN("*************************************");
            update_ntp_ready = 0;
            if (updateSuccess1 == true) {
                TM_DEBUG_MAX_PRINT("Server 1 Update Success: ");
                TM_DEBUG_MAX_PRINT("Server 1 Time: ");
                TM_DEBUG_MAX_PRINTLN(timeClient.getFormattedTime());
                update_ntp_ready = 1;
            } else {
                TM_DEBUG_MAX_PRINTLN("Failed to update from Server 1");

               #ifdef ntp_2_3
                if (timeClient2.forceUpdate()) {
                    TM_DEBUG_MAX_PRINT("Server 2 Update Success: ");
                    TM_DEBUG_MAX_PRINT("Server 2 Time: ");
                    TM_DEBUG_MAX_PRINTLN(timeClient2.getFormattedTime());
                    update_ntp_ready = 1;
                } else {
                    TM_DEBUG_MAX_PRINTLN("Failed to update from Server 2");

                    if (timeClient3.forceUpdate()) {
                        TM_DEBUG_MAX_PRINT("Server 3 Update Success: ");
                        TM_DEBUG_MAX_PRINT("Server 3 Time: ");
                        TM_DEBUG_MAX_PRINTLN(timeClient3.getFormattedTime());
                        update_ntp_ready = 1;
                    } else {
                        TM_DEBUG_MAX_PRINTLN("Failed to update from Server 1,2,3");
                        update_ntp_ready = 0;
                    }
                }
                #endif

            }

            TM_DEBUG_MAX_PRINTLN("*************************************");




      }else{

        TM_DEBUG_MED_PRINTLN("*************************************");

          if (updateSuccess1 == true) {
              update_ntp_ready = 1;
              TM_DEBUG_MED_PRINT("Server 1 Update Success: ");
              #if TM_DEBUG_LEVEL >= TM_DEBUG_MED
              TM_DEBUG_MED_PRINT("Server 1 Time: ");
              #endif
              timeClient.getFormattedTime();

          } else {
              update_ntp_ready = 0;
              TM_DEBUG_MED_PRINTLN("Failed to update from Server 1");
          }
          #ifdef ntp_2_3
          if (timeClient2.forceUpdate()) {
              updateSuccess2 = true;
              TM_DEBUG_MED_PRINT("Server 2 Update Success: ");
              #if TM_DEBUG_LEVEL >= TM_DEBUG_MED
              TM_DEBUG_MED_PRINT("Server 2 Time: ");
              #endif
              timeClient2.getFormattedTime();
          } else {
              TM_DEBUG_MED_PRINTLN("Failed to update from Server 2");
          }

          if (timeClient3.forceUpdate()) {
              updateSuccess3 = true;
              TM_DEBUG_MED_PRINT("Server 3 Update Success: ");
              #if TM_DEBUG_LEVEL >= TM_DEBUG_MED
              TM_DEBUG_MED_PRINT("Server 3 Time: ");
              #endif
              timeClient3.getFormattedTime();
          } else {
              TM_DEBUG_MED_PRINTLN("Failed to update from Server 3");
          }
          #endif

        if (updateSuccess1 && updateSuccess2 && updateSuccess3) {
            
            #if TM_DEBUG_LEVEL >= TM_DEBUG_MED
            #ifdef ntp_2_3
            unsigned long time1 = timeClient.getEpochTime();
            unsigned long time2 = timeClient2.getEpochTime();
            unsigned long time3 = timeClient3.getEpochTime();
            #endif
            #else
            timeClient.getEpochTime();
            timeClient2.getEpochTime();
            timeClient3.getEpochTime();
            #endif

            TM_DEBUG_MED_PRINT("Server 1 Time: ");
            timeClient.getFormattedTime();
            #ifdef ntp_2_3
            TM_DEBUG_MED_PRINT("Server 2 Time: ");
            timeClient2.getFormattedTime();
            TM_DEBUG_MED_PRINT("Server 3 Time: ");
            timeClient3.getFormattedTime();
            #endif

            // Berechne die Abweichungen zwischen den Zeiten ohne abs
            #if TM_DEBUG_LEVEL >= TM_DEBUG_MED
            #ifdef ntp_2_3
            unsigned long delta1 = (time1 > time2) ? (time1 - time2) : (time2 - time1);
            unsigned long delta2 = (time1 > time3) ? (time1 - time3) : (time3 - time1);
            unsigned long delta3 = (time2 > time3) ? (time2 - time3) : (time3 - time2);
            #endif
            #endif

            // Debug-Ausgaben der Abweichungen
            #ifdef ntp_2_3
            TM_DEBUG_MED_PRINT("Delta1 (Server 1 - Server 2): ");
            TM_DEBUG_MED_PRINTLN(delta1);
            TM_DEBUG_MED_PRINT("Delta2 (Server 1 - Server 3): ");
            TM_DEBUG_MED_PRINTLN(delta2);
            TM_DEBUG_MED_PRINT("Delta3 (Server 2 - Server 3): ");
            TM_DEBUG_MED_PRINTLN(delta3);
            #endif

            // Wähle die Zeit aus, die am konsistentesten ist und gib den entsprechenden Server an
            #if TM_DEBUG_LEVEL >= TM_DEBUG_MED
            unsigned long selectedTime;
            const char* selectedServer;
            #ifdef ntp_2_3
            if (delta1 <= delta2 && delta1 <= delta3) {
                selectedTime = (time1 + time2) / 2;
                selectedServer = "Server 1 & Server 2";
            } else if (delta2 <= delta1 && delta2 <= delta3) {
                selectedTime = (time1 + time3) / 2;
                selectedServer = "Server 1 & Server 3";
            } else {
                selectedTime = (time2 + time3) / 2;
                selectedServer = "Server 2 & Server 3";
            }
            #endif
            #endif

            TM_DEBUG_MED_PRINT("Selected Time: ");
            TM_DEBUG_MED_PRINTLN(selectedTime);
            TM_DEBUG_MED_PRINT("Selected Server(s): ");
            TM_DEBUG_MED_PRINTLN(selectedServer);
            // Hier kannst du die ausgewählte Zeit für deine Anwendung verwenden
        } else {
            TM_DEBUG_MED_PRINTLN("Failed to update from one or more servers");
        }

        TM_DEBUG_MED_PRINTLN("*************************************");


      }
       
        //---------------------------------------


}
//------------------------------------



//------------------------------------
void Set_RTC_clock(){

  //  if (strstr(bufferReceive.c_str(), "STIME") != NULL)

      #ifdef RTC_Clock_DS3231

      Serial.print(F("[TM] RTC Uhr Stellen, Epochtime: "));Serial.println(epochTime_bl);


       unsigned long epochTime_calc;
       bool epochTime_ok;

       epochTime_ok = true;

     
       //if(epochTime_bl >= 1704067200 && epochTime_bl <= 2524608000){
          //epochTime_ok = true;
          //---------------
            if(epochTime_bl > epochTime_esp){ //Zeit schneller
               epochTime_calc = epochTime_bl - epochTime_esp;
               epochTime_ok = false;
               Serial.print(F("[TM] ------Valid1 "));Serial.println(epochTime_calc);
               if(epochTime_calc <= 31104000){ //1 jahr max
                 epochTime_ok = true;
               }
            }
          //---------------
          //---------------
            if(epochTime_bl < epochTime_esp){ //Zeit langsamer
               epochTime_calc = epochTime_esp - epochTime_bl;
               epochTime_ok = false;
               Serial.print(F("[TM] ------Valid2 "));Serial.println(epochTime_calc);
               if(epochTime_calc <= 31104000){ //1 jahr max
                 epochTime_ok = true;
               }
            }
          //---------------
       //}else{
         //epochTime_ok = false;
       //}
       if(epochTime_bl == 0){
        epochTime_ok = false;
       }

       if(epochTime_ok == true){

            //- bluetooth Daten übernehmen

            Serial.print(F("[TM] Set RTC Clock Valid: "));Serial.println(epochTime_bl);

            if(epochTime_bl <= 1710000000){
              //timeClient.update();
              epochTime_bl = timeClient.getEpochTime();
            }

            //epochTime_bl = epochTime_bl;  // + 6; //offset für verzögerung
            //timeClient.setEpochTime(epochTime_bl);  // epochTime_start

            struct timespec tp;
            tp.tv_sec = epochTime_bl;
            tp.tv_nsec = 0;
            epochTime_esp = epochTime_bl;
            clock_settime(CLOCK_REALTIME, &tp);
            //epochTime_bl = 0;

            //printLocalTime();
            printLocalEpoch();


              unsigned long temp_year;
              byte buf[4];

              struct tm timeinfo;
              time_t now;

              if (WiFi.status() == WL_CONNECTED) {
                if (!getLocalTime(&timeinfo)) {
                  #if TM_DEBUG_LEVEL >= TM_DEBUG_MAX
                    Serial.println("[TM] Failed to obtain time");
                  #endif
                }else{
                  Serial.print(F("[TM] 6: "));
                  Serial.println(&timeinfo, "%A, %B %d %Y %H:%M:%S");
                }
              } else {
                #if TM_DEBUG_LEVEL >= TM_DEBUG_MAX
                  Serial.println("[TM] WiFi nicht verbunden. Zeit wird vom ESP abgerufen.");
                #endif
                time(&now);
                localtime_r(&now, &timeinfo);
              }

              
              s_second = timeinfo.tm_sec;
              s_minute = timeinfo.tm_min;
              s_hour = timeinfo.tm_hour;
              s_date = timeinfo.tm_mday;
              s_month = timeinfo.tm_mon + 1;
              temp_year = timeinfo.tm_year + 1900-2000;
              s_dOW = timeinfo.tm_wday;

              buf[0] = (byte) temp_year;
              s_year = buf[0];


              
            // feed UnixTimeStamp and don' t use localtime
            //constexpr time_t tstmp {1660644000UL};
            //Clock.setEpoch(tstmp, false);

            if(W_setClockMode == false){
              myRTC.setClockMode(false);  // set to 24h
              W_setClockMode = true;
            }
            //setClockMode(true); // set to 12h
            // h12Flag
            // pmFlag

            //myRTC.setEpoch(epochTime_esp);
           //#ifdef RTCDebug 
            Serial.print(F("----s_year ")); 
            Serial.println(s_year);
            Serial.print(F("----s_month ")); 
            Serial.println(s_month);
            Serial.print(F("----s_date ")); 
            Serial.println(s_date);
            Serial.print(F("----s_dOW ")); 
            Serial.println(s_dOW);
            Serial.print(F("----s_hour ")); 
            Serial.println(s_hour);
            Serial.print(F("----s_minute ")); 
            Serial.println(s_minute);
            Serial.print(F("----s_second ")); 
            Serial.println(s_second);

           //#endif
            
            myRTC.setMinute(s_minute); 
            myRTC.setSecond(s_second);
            myRTC.setHour2(s_hour);               
            myRTC.setDate(s_date);     
            myRTC.setDoW(s_dOW); 
            myRTC.setMonth(s_month);      
            myRTC.setYear(s_year);      



            
   
            rtc_time_valid = 1;   // Uhr wurde gestellt
            update_rtc_ready = rtc_time_valid;

            Preferences preferences;
            preferences.begin("eenvs", false);                         //Ordner eenvs anlegen/verwenden
            preferences.putUInt("rtc_time_valid", rtc_time_valid);     //Variable speichern
            preferences.end();

              #ifdef ea_webserver
              #ifdef j_2_webserver
              //if(disable_server >= 1 && TB_currFwVersion == TB_newFwVersion) {
              static char time_line[60] = "";
              sprintf(time_line,"          [TM] RTC Clock Set Time %02d-%02d-%02d %02d:%02d:%02d",s_year,s_month,s_date,s_hour,s_minute,s_second);        
              if (loggingEnabled) {things_list_t_16 = String(time_line);write_to_log(things_list_t_16);}
              //}
              #endif
              #endif

        }else{
          Serial.print(F("[TM] NOT SET, RTC Clock NOT Valid: "));Serial.println(epochTime_bl);
        }


      #endif

}






void echo_clock_info(){

        //Serial.println("[TM] echo_clock_info");
         
       // Serial.print("h12Flag= ");Serial.println(h12Flag);

         // Start with the year
          /*
            Serial.print("2");
            if (century) {			// Won't need this for 89 years.
              Serial.print("1");
            } else {
              Serial.print("0");
            }
            Serial.print(rtc_year);
            Serial.print('-');
            
            // then the month
            Serial.print(rtc_month);
            Serial.print("-");
            
            // then the date
            Serial.print(rtc_date);
            Serial.print(" ");
            
            
            // Finally the hour, minute, and second
            //Serial.print(myRTC.getHour(h12Flag, pmFlag), DEC);
            Serial.print(rtc_hour);
            Serial.print(":");
            Serial.print(rtc_minute);
            Serial.print(":");
            Serial.print(rtc_second);
           
            Serial.print("  W=");
            Serial.print(rtc_dOW);
            Serial.print(" | ");
*/
            // Add AM/PM indicator
            //h12Flag = false;
            #ifdef RTCDebug
          
            if (h12Flag) {
              if (pmFlag) {
                Serial.print("[TM] PM ");
              } else {
                Serial.print("[TM] AM ");
              }
            } else {
              Serial.print("[TM] 24h ");
            }

            #endif
          
            // Display the temperature
            #ifdef RTCDebug
            Serial.print("T= ");
            #endif
            rtc_temperatur = myRTC.getTemperature() - 1.2;
            #ifdef RTCDebug
            Serial.print(rtc_temperatur, 2);
            Serial.print("°C");
            #endif
            
            // Tell whether the time is (likely to be) valid
            // Returns false if the oscillator has been off for some reason.
            // If this is the case, the time is probably not correct.
            if (myRTC.oscillatorCheck()) {
              #ifdef RTCDebug
              Serial.print(" O+");
              #endif
              rtc_oszi = true;
              //Serial.println("[TM] RTC Uhr online");
           
            } else {
              #ifdef RTCDebug
              Serial.print(" O-");
              #endif
              rtc_oszi = false;

              rtc_time_valid = 0;   // Uhr wurde verstellt
              update_rtc_ready = rtc_time_valid;

              Preferences preferences;
              preferences.begin("eenvs", false);                         //Ordner eenvs anlegen/verwenden
              preferences.putUInt("rtc_time_valid", rtc_time_valid);     //Variable speichern 
              preferences.end();    

            }

            #ifdef RTCDebug
            Serial.println(F(" "));
            Serial.print("[IF] ESP32= ");Serial.print(ESP32temp);Serial.println("°C");
            #endif
          
          /*
          
            // Indicate whether an alarm went off
            if (myRTC.checkIfAlarm(1)) {
              Serial.print(" A1!");
            }
          
            if (myRTC.checkIfAlarm(2)) {
              Serial.print(" A2!");
            }
          
            // New line on display
            Serial.println();
            
            // Display Alarm 1 information
            Serial.print("Alarm 1: ");
            myRTC.getA1Time(alarmDay, alarmHour, alarmMinute, alarmSecond, alarmBits, alarmDy, alarmH12Flag, alarmPmFlag);
            Serial.print(alarmDay, DEC);
            if (alarmDy) {
              Serial.print(" DoW");
            } else {
              Serial.print(" Date");
            }
            Serial.print(' ');
            Serial.print(alarmHour, DEC);
            Serial.print(' ');
            Serial.print(alarmMinute, DEC);
            Serial.print(' ');
            Serial.print(alarmSecond, DEC);
            Serial.print(' ');
            if (alarmH12Flag) {
              if (alarmPmFlag) {
                Serial.print("pm ");
              } else {
                Serial.print("am ");
              }
            }
            if (myRTC.checkAlarmEnabled(1)) {
              Serial.print("enabled");
            }
            Serial.println();
          
            // Display Alarm 2 information
            Serial.print("Alarm 2: ");
            myRTC.getA2Time(alarmDay, alarmHour, alarmMinute, alarmBits, alarmDy, alarmH12Flag, alarmPmFlag);
            Serial.print(alarmDay, DEC);
            if (alarmDy) {
              Serial.print(" DoW");
            } else {
              Serial.print(" Date");
            }
            Serial.print(" ");
            Serial.print(alarmHour, DEC);
            Serial.print(" ");
            Serial.print(alarmMinute, DEC);
            Serial.print(" ");
            if (alarmH12Flag) {
              if (alarmPmFlag) {
                Serial.print("pm");
              } else {
                Serial.print("am");
              }
            }
            if (myRTC.checkAlarmEnabled(2)) {
              Serial.print("enabled");
            }
          
            // display alarm bits
            Serial.println();
            Serial.print("Alarm bits: ");
            Serial.println(alarmBits, BIN);

             */

           // Serial.print("h12Flag= ");Serial.println(h12Flag);


      if(rtc_year > 40  || rtc_year < 24){
          
          rtc_time_valid = 0;
          
          update_rtc_ready = rtc_time_valid;

          Preferences preferences;
          preferences.begin("eenvs", false);                         //Ordner eenvs anlegen/verwenden
          preferences.putUInt("rtc_time_valid", rtc_time_valid);     //Variable speichern   
          preferences.end(); 
      }



}



void read_clock_RTC(){

    //#ifdef RTCDebug
    //Serial.print("[TM] read_clock_RTC  : ");
    //#endif


    
      rtc_year = myRTC.getYear();
      rtc_month = myRTC.getMonth(century);
      rtc_date = myRTC.getDate();
      h12Flag = false;
      pmFlag = false;
      //rtc_hour = myRTC.getHour(h12Flag, pmFlag);
      rtc_hour = myRTC.getHour2();
      //rtc_hour = myRTC.getHour(false, false);
      rtc_minute = myRTC.getMinute();
      rtc_second = myRTC.getSecond();
      rtc_dOW = myRTC.getDoW();

      if(rtc_year > 40  || rtc_year < 24){
          rtc_time_valid = 0;
          
          update_rtc_ready = rtc_time_valid;
          Serial.println(F("[TM] RTC fehler"));

          Preferences preferences;
          preferences.begin("eenvs", false);                         //Ordner eenvs anlegen/verwenden
          preferences.putUInt("rtc_time_valid", rtc_time_valid);     //Variable speichern    
          preferences.end();


      }

      #ifdef RTCDebug
      Serial.print(rtc_year);
      Serial.print("-");
      Serial.print(rtc_month);
      Serial.print("-");
      Serial.print(rtc_date);
      Serial.print(" ");
      Serial.print(rtc_hour); //24-hr
      Serial.print(":");
      Serial.print(rtc_minute);
      Serial.print(":");
      Serial.print(rtc_second);
      Serial.print(" ");
      Serial.print(rtc_dOW);
      Serial.print(" | ");
      #endif
      #ifndef RTCDebug
      //Serial.print(rtc_hour); //24-hr
      //Serial.print(":");
      //Serial.print(rtc_minute);
      //Serial.print(":");
      //Serial.print(rtc_second);
      //Serial.print(" | ");
      #endif
    //  unsigned long epoch = (((rtc_year/4*(365*4+1)+rtc_date[rtc_year%4][rtc_month]+rtc_date)*24+rtc_hour)*60+rtc_minute)*60+rtc_second;

          struct tm t;
          time_t epoch;

          /*
          Das Hinzufügen von 100 zum Jahr (rtc_year + 100) ist notwendig, weil der tm_year-Feld der struct tm-Struktur das Jahr relativ zu 1900 speichert. Das bedeutet:
            tm_year = 0 entspricht dem Jahr 1900.
            tm_year = 100 entspricht dem Jahr 2000.
            tm_year = 124 entspricht dem Jahr 2024.
          */
          t.tm_year = rtc_year+100;
          t.tm_mon = rtc_month-1;
          t.tm_mday = rtc_date;
          t.tm_hour = rtc_hour;
          t.tm_min = rtc_minute;
          t.tm_sec = rtc_second;

          epoch = mktime(&t);
          epochTime_rtc = epoch + daylightOffset_sec;
          #ifndef RTCDebug
          //Serial.println(epochTime_rtc);
          #endif
          //epochTime_rtc = epochTime_rtc + daylightOffset_sec;
          //Serial.println(epoch);
          
          //unsigned long offset = epochTime_esp - epochTime_rtc;
          #ifdef RTCDebug
          Serial.print(epochTime_rtc);Serial.println("  Epoch Echt Real Zeit inkl. Zeitzone (Sommer/Winter excludiert)");
          #endif


      if (update_ntp_ready == 0) {
          //sprintf(p_uhrzeit, "%02d:%02d:%02d", rtc_hour, rtc_minute, rtc_second);
          
          // Überprüfung, ob eine Stunde vergangen ist
          unsigned long currentTime = millis();
          if (currentTime - lastRTCTimePrint >= 3600000) { // 3600000 Millisekunden = 1 Stunde
              Serial.print(F("[IF] Time from RTC "));
              Serial.println(p_uhrzeit);
              lastRTCTimePrint = currentTime; // Aktualisieren Sie die letzte Log-Zeit
          }
      }


      if(update_rtc_ready == 0){

            epochTime_rtc = epochTime_save;
            epochTime_esp = epochTime_save;
            Serial.print(F("[IF] RTC fehler set EPOCH vom Speicher | "));Serial.println(epochTime_save);

            struct tm *ptm = gmtime((time_t *)&epochTime_save);

            // Extrahiere die einzelnen Komponenten
            int year = ptm->tm_year + 1900; // Jahre seit 1900
            int month = ptm->tm_mon + 1;    // Monate seit Januar (0-11)
            int day = ptm->tm_mday;         // Tag des Monats (1-31)
            int hour = ptm->tm_hour;        // Stunden seit Mitternacht (0-23)
            int minute = ptm->tm_min;       // Minuten nach der vollen Stunde (0-59)
            int second = ptm->tm_sec;       // Sekunden nach der vollen Minute (0-59)

             /*
              Serial.print("Year: ");
              Serial.println(year);
              Serial.print("Month: ");
              Serial.println(month);
              Serial.print("Day: ");
              Serial.println(day);
              Serial.print("Hour: ");
              Serial.println(hour);
              Serial.print("Minute: ");
              Serial.println(minute);
              Serial.print("Second: ");
              Serial.println(second);
              */

              rtc_year = year % 100; // Extrahiert die letzten beiden Ziffern
              rtc_month = month;
              rtc_date = day;
              rtc_hour = hour;
              rtc_minute = minute;
              rtc_second = second;

              t.tm_year = rtc_year+100; //bei 2024 ==  124 ist, was 124 Jahre nach 1900 entspricht, also das Jahr 2024.
              t.tm_mon = rtc_month-1;
              t.tm_mday = rtc_date;
              t.tm_hour = rtc_hour;
              t.tm_min = rtc_minute;
              t.tm_sec = rtc_second;



      }



}






//----------------------------------------------
void read_clock_esp32(){

       #if TM_DEBUG_LEVEL >= TM_DEBUG_MED
        Serial.print("[TM] read_clock_esp32: ");
       #endif

      if(update_rtc_ready == 0){   // ansonsten von Callback_tb_task  und  time_update == true;

            struct tm timeinfo;
            time_t now;
              if (WiFi.status() == WL_CONNECTED) {
                if (!getLocalTime(&timeinfo)) {
                  #if TM_DEBUG_LEVEL >= TM_DEBUG_MAX
                    Serial.println("[TM] Failed to obtain time");
                  #endif
                }else{
                  Serial.print(F("[TM] 7: "));
                  Serial.println(&timeinfo, "%A, %B %d %Y %H:%M:%S");
                }
              } else {
                #if TM_DEBUG_LEVEL >= TM_DEBUG_MAX
                  Serial.println("[TM] WiFi nicht verbunden. Zeit wird vom ESP abgerufen.");
                #endif
                time(&now);
                localtime_r(&now, &timeinfo);
              }

              currentSec = timeinfo.tm_sec;
              currentmin = timeinfo.tm_min;
              currenthour = timeinfo.tm_hour;
              currentdate = timeinfo.tm_mday;
              currentmonth = timeinfo.tm_mon + 1;
              esp_year_t = timeinfo.tm_year + 1900-2000;
              currentyear = esp_year_t;
              //currentYearTwoDigits = esp_year_t % 100;
              esp_dOW = timeinfo.tm_wday;

      

                    if(g_u_clock_ist == 1){ 
                      currenthourAM_PM = false;
                    }
                    if(g_u_clock_ist == 2){ 
                      currenthour12 = currenthour;  
                      currenthourAM_PM = false;
                      if( currenthour12 == 0 ){currenthour12 = 12;currenthourAM_PM = true;}
                      if( currenthour12 > 12 ){currenthour12 = currenthour12 - 12;currenthourAM_PM = true;}
                    } 
            
  
              //sprintf(p_uhrzeit,"%02d:%02d:%02d",currenthour,currentmin,currentSec);
              
              counterTime++; // Zähler erhöhen
              if (counterTime >= 10) {
                Serial.print(F("[IF] Time from ESP "));Serial.println(p_uhrzeit);
                counterTime = 0; // Zähler zurücksetzen
              }



      }

        #ifdef RTCDebug
        Serial.print(currentYearTwoDigits, DEC);
        Serial.print("-");
        Serial.print(currentmonth, DEC);
        Serial.print("-");
        Serial.print(currentdate, DEC);
        Serial.print(" ");
        Serial.print(currenthour, DEC); //24-hr
        Serial.print(":");
        Serial.print(currentmin, DEC);
        Serial.print(":");
        Serial.print(currentSec, DEC);
        Serial.print(" ");
        Serial.print(esp_dOW, DEC);
        Serial.print(" | ");
        //Serial.print(" ");
        //Serial.println(hour12h, DEC);
        #endif


      if(update_rtc_ready == 0){ 
          
            time_t now;
            epochTime_esp = time(&now);     // Zeit mit Zeitzone und Sommer Winter Offset
            //epochTime_esp2 = timeClient.getEpochTime();  // getSeconds

            //if(epochTime_esp2 < 10000){
            // timeClient.setEpochTime(epochTime_esp);
            //}

          #ifdef RTCDebug 
          Serial.print(epochTime_esp);Serial.println("  Zeit mit Zeitzone und Sommer Winter Offset");
          #endif
        
          if(epochTime_rtc >= epochTime_esp){
            epochTime_r_e_diff = epochTime_rtc - epochTime_esp;
            g_epochTime_diff= true;
          }else{
            epochTime_r_e_diff = epochTime_esp - epochTime_rtc;
            g_epochTime_diff= false;
          }

      }

}



//----------------------------------------------
void call_time_set_ntp() {
    bool updateSuccess1 = false;
    bool updateSuccess2 = false;
    bool updateSuccess3 = false;

    // Update von timeClient (Haupt-Client)
    update_ok_ready = timeClient.forceUpdate();
    if (update_ok_ready == true) {
        Serial.println(F("[TM] NTP Update erfolgreich"));
        update_ntp_ready = 1;
        set_manual_time = true;
        Set_RTC_clock_after_ntp();
        count_ntp_fail = 0;
        updateSuccess1 = true;
    } else {
        Serial.println(F("[TM] NTP Update Fehler"));
        update_ntp_ready = 0;
        count_ntp_fail += 1;
    }

    // Backup-Clients nur bei Fehler des Haupt-Clients abfragen
    if (!updateSuccess1) {
       #ifdef ntp_2_3
        if (timeClient2.forceUpdate()) {
            updateSuccess2 = true;
            Serial.print(F("Server 2 Update Success: "));
            Serial.println(timeClient2.getFormattedTime());
            timeClient.setEpochTime(timeClient2.getEpochTime());  // Zeit von timeClient2 zu timeClient übernehmen
            update_ntp_ready = 1;  // Erfolgreiches Update
        } else {
            Serial.println(F("Failed to update from Server 2-"));
        }

        if (timeClient3.forceUpdate()) {
            updateSuccess3 = true;
            Serial.print(F("Server 3 Update Success: "));
            Serial.println(timeClient3.getFormattedTime());
            timeClient.setEpochTime(timeClient3.getEpochTime());  // Zeit von timeClient3 zu timeClient übernehmen
            update_ntp_ready = 1;  // Erfolgreiches Update
        } else {
            Serial.println(F("Failed to update from Server 3-"));
        }
        #endif
    }

    if (update_ntp_ready == 1 && !updateSuccess1) {
        unsigned long selectedTime;
        const char* selectedServer;

        if (updateSuccess1 && updateSuccess2 && updateSuccess3) {
            
            #ifdef ntp_2_3
            unsigned long time1 = timeClient.getEpochTime();
            unsigned long time2 = timeClient2.getEpochTime();
            unsigned long time3 = timeClient3.getEpochTime();
            #endif
            #ifdef ntp_2_3
            unsigned long delta1 = (time1 > time2) ? (time1 - time2) : (time2 - time1);
            unsigned long delta2 = (time1 > time3) ? (time1 - time3) : (time3 - time1);
            unsigned long delta3 = (time2 > time3) ? (time2 - time3) : (time3 - time2);
            #endif

            #ifdef ntp_2_3
            if (delta1 <= delta2 && delta1 <= delta3) {
                selectedTime = (time1 + time2) / 2;
                selectedServer = "Server 1 & Server 2";
            } else if (delta2 <= delta1 && delta2 <= delta3) {
                selectedTime = (time1 + time3) / 2;
                selectedServer = "Server 1 & Server 3";
            } else {
                selectedTime = (time2 + time3) / 2;
                selectedServer = "Server 2 & Server 3";
            }
            #endif
        #ifdef ntp_2_3 
        } else if (updateSuccess1 && updateSuccess2) {
            selectedTime = (timeClient.getEpochTime() + timeClient2.getEpochTime()) / 2;
            selectedServer = "Server 1 & Server 2";
        } else if (updateSuccess1 && updateSuccess3) {
            selectedTime = (timeClient.getEpochTime() + timeClient3.getEpochTime()) / 2;
            selectedServer = "Server 1 & Server 3";
        } else if (updateSuccess2 && updateSuccess3) {
            selectedTime = (timeClient2.getEpochTime() + timeClient3.getEpochTime()) / 2;
            selectedServer = "Server 2 & Server 3";
        } else if (updateSuccess1) {
            selectedTime = timeClient.getEpochTime();
            selectedServer = "Server 1";
        } else if (updateSuccess2) {
            selectedTime = timeClient2.getEpochTime();
            selectedServer = "Server 2";
        } else {
            selectedTime = timeClient3.getEpochTime();
            selectedServer = "Server 3";
        #endif
        }

        Serial.print(F("Selected Time: "));
        Serial.println(selectedTime);
        Serial.print(F("Selected Server(s): "));
        Serial.println(selectedServer);
        // Hier kannst du die ausgewählte Zeit für deine Anwendung verwenden
    } //else {
        //Serial.println(F("Failed to update from all servers"));
   // }

    Serial.println(F("_____________________________________"));
}



//----------------------------------------------


//----------------------------------------------
void call_time_set_timezone(){

            // https://github.com/nayarsystems/posix_tz_db/blob/master/zones.csv
          
            //("WET0WEST,M3.5.0/1,M10.5.0");   // Set to Lisabon
            //("WET0WEST,M3.5.0/1,M10.5.0");   // Set for Melbourne/AU
          
            // You must include '0' after first designator e.g. GMT0GMT-1, ',1' is true or ON
            // setenv("TZ", "GMT0BST,M3.5.0/01,M10.5.0/02",1);
            // setenv("TZ",timezone.c_str(),1);  //  Now adjust the TZ.  Clock settings are adjusted to show the new local time
            // tzset();

              struct tm timeinfo;
              time_t now;

              if (WiFi.status() == WL_CONNECTED) {
                if (!getLocalTime(&timeinfo)) {
                  #if TM_DEBUG_LEVEL >= TM_DEBUG_MAX
                    Serial.println("[TM] Failed to obtain time");
                  #endif
                }else{
                  Serial.print(F("[TM] 1: "));
                  Serial.println(&timeinfo, "%A, %B %d %Y %H:%M:%S");
                }
              } else {
                #if TM_DEBUG_LEVEL >= TM_DEBUG_MAX
                  Serial.println("[TM] WiFi nicht verbunden. Zeit wird vom ESP abgerufen.");
                #endif
                time(&now);
                localtime_r(&now, &timeinfo);
              }


              esp_task_wdt_reset();
              // TM_DEBUG_MAX_PRINT("[TM] Epoch: "); TM_DEBUG_MAX_PRINTLN(timeClient.getEpochTime());
              // time_t now;
              // TM_DEBUG_MAX_PRINT("[TM] Time:  "); TM_DEBUG_MAX_PRINTLN(time(&now));     // Zeit mit Zeitzone und Sommer Winter Offset

              TM_DEBUG_MED_PRINTLN(F("------------------"));
              TM_DEBUG_MED_PRINTLN(F("[TM] Load Timezone"));
              v_timezone = "CET-1CEST,M3.5.0,M10.5.0/3";
              v_timezone = g_u_timezone_ist;
              setTimezone(v_timezone); // Set to Berlin

              esp_task_wdt_reset();

}
//----------------------------------------------




 //0 = Winterzeit in Jan, Feb, Nov, Dez      1= Sommerzeit in Apr, Mai, Jun, Jul, Aug, Sep
// European Daylight Savings Time calculation by "jurs" for German Arduino Forum
// input parameters: "normal time" for year, month, day, hour and tzHours (0=UTC, 1=MEZ)
// return value: returns true during Daylight Saving Time, false otherwise
//(0=UTC, 1=MEZ)  
    boolean summertime_EU(int year, byte month, byte day, byte hour, byte tzHours){ 

      //Serial.println(year);
      //Serial.print("[TM] S/W Test: M:");Serial.print(month);Serial.print("  D:");Serial.print(day);Serial.print("  H:");Serial.println(hour);    
      //Serial.println(tzHours);

      //Serial.print("[TM] S/W Test: M:"); 
      //Serial.print(month); Serial.print(" D:"); 
      //Serial.print(day); Serial.print(" H:"); 
      //Serial.println(hour);


      if (month < 3 || month > 10) return false; // keine Sommerzeit in Jan, Feb, Nov, Dez
      if (month > 3 && month < 10) return true; // Sommerzeit in Apr, Mai, Jun, Jul, Aug, Sep
      //if ((month == 3 && (hour + 24 * day) >= (1 + tzHours + 24 * (31 - (5 * year / 4 + 4) % 7))) || ( month == 10 && (hour + 24 * day) < (1 + tzHours + 24 * (31 - (5 * year / 4 + 1) % 7))))
        //return true;
      //else
        //return false;

      if (month == 3){
        if ((hour + 24 * day) >= (1 + tzHours + 24 * (31 - (5 * year / 4 + 4) % 7))){
          //Serial.println("true");
          return true;
        }else{
          //Serial.println("false");
          return false;
        }
      }

      if (month == 10){
        if ((hour + 24 * day) < (1 + tzHours + 24 * (31 - (5 * year / 4 + 1) % 7))){
          //Serial.println("true");
          return true;
        }else{
          //Serial.println("false");
          return false;
        }
      }

      return false; // Standard-Rückgabeanweisung

    }

//---------------------------------------------------------------







  //----------------------------------------------
  void test_sommer_winter(){
      if (sommerzeit == 1) {
          TM_DEBUG_MED_PRINTLN(F("[TM] Sommer | MESZ"));
          g_Set_mesz_tmp = 0;
          Set_mesz = true;
      } else {
          TM_DEBUG_MED_PRINTLN(F("[TM] Winter | MEZ"));
          g_Set_mesz_tmp = 1;
          Set_mesz = false;
      }

      time_t now;
      // char strftime_buf[64];
      struct tm timeinfo;
      time(&now);
      localtime_r(&now, &timeinfo);
      // Überprüfen, ob die Sommerzeit aktiv ist
      if (timeinfo.tm_isdst > 0) {
          TM_DEBUG_MED_PRINTLN(F("[TM] timeinfo Sommerzeit ist aktiv."));
      } else {
          TM_DEBUG_MED_PRINTLN(F("[TM] timeinfo Winterzeit ist aktiv."));
      }


  }
  //----------------------------------------------





//----------------------------------------------
void call_sommer_winter(){  //nur bei ntp

        esp_task_wdt_reset();
        //-------------------------------------------------------------
        // kein NTP verfügbar dann Sommer und winter hier anpassen
          if (g_u_mez_ea_ist == 1) {  //  1=EIN  
              // if(update_ntp_ready == 0 && g_u_mez_ea_ist == 1) {

              if (sommerzeit == 1) {
                  TM_DEBUG_MED_PRINTLN(F("[TM] Es ist Sommer - set | MESZ"));
                  Set_mesz = true;
                  g_Set_mesz = 0;
              } else {
                  TM_DEBUG_MED_PRINTLN(F("[TM] Es ist Winter - set | MEZ"));
                  Set_mesz = false;
                  g_Set_mesz = 1;
              }

              TM_DEBUG_MAX_PRINT(F("g_Set_mesz d: "));
              TM_DEBUG_MAX_PRINTLN(g_Set_mesz);
              Preferences preferences;
              preferences.begin("eenvs", false);  // Ordner eenvs anlegen/verwenden
              preferences.putUInt("g_Set_mesz", g_Set_mesz);  // Variable speichern  
              preferences.end();

          } else {
              if (g_Set_mesz == 0) {
                  g_Set_mesz = 1;
                  TM_DEBUG_MAX_PRINT(F("g_Set_mesz e: "));
                  TM_DEBUG_MAX_PRINTLN(g_Set_mesz);
                  Preferences preferences;
                  preferences.begin("eenvs", false);  // Ordner eenvs anlegen/verwenden
                  preferences.putUInt("g_Set_mesz", g_Set_mesz);  // Variable speichern  
                  preferences.end();
              }            
          }


           //-------------------------------------------------------------
          
          read_clock_esp32();

}
//----------------------------------------------



//----------------------------------------------
void call_time_set_sommer_winter(){


          //-------------------------------------------------------------
          // kein NTP verfügbar dann Sommer und winter hier anpassen
          if(g_u_mez_ea_ist == 1) {
              //if(update_ntp_ready == 0 && g_u_mez_ea_ist == 1){

              if(Set_mesz == true) {
                  TM_DEBUG_MED_PRINTLN(F("[TM] Aktuell ist Sommer | MESZ"));
                  if(update_bl_clock == 0) {  // Bei BL Übertragung ist die Sommer Winterzeit schon mit drin
                      //daylightOffset_sec = 0;
                      noNTPOffset_sec = 0;
                  }
              } else {
                  TM_DEBUG_MED_PRINTLN(F("[TM] Aktuell ist Winter | MEZ"));
                  if(update_bl_clock == 0) {  // Bei BL Übertragung ist die Sommer Winterzeit schon mit drin
                      //daylightOffset_sec = 3600;
                      noNTPOffset_sec = 3600;
                  }
              }

              //read_clock_esp32();
              TM_DEBUG_MAX_PRINTLN(F("[TM] Set ESP Offset clock"));
          }

          //-------------------------------------------------------------

}
//----------------------------------------------



              //  update_bl_clock = 1; // damit ohne NTP ok die Uhr gestellt werden kann
             //   set_BT_RTC_Time = true;
              //  call_time_set_g();


//----------------------------------------------
void call_time_set_g(){

      uint8_t g_Set_mesz_temp = g_Set_mesz;
        
        // ??? Hier im ablauf wird nachdem der NTP erfolgreich aktualisiert wurde die Zeit im Sommer +2 gesetzt, dann erst..
        //Serial.println("[TM] -------> call_time_set_g");
        
          test_sommer_winter(); //sommer =0 
         if (WiFi.status() == WL_CONNECTED) {
           call_time_set_ntp(); // aktualisiere NTP        
         }
          if(update_ntp_ready == 1){  
            sommerzeit = summertime_EU(2000 +currentYearTwoDigits, v_currentmonth, v_currentdate, v_currenthour, 1); //(0=UTC, 1=MEZ)  //0 = Winterzeit in Jan, Feb, Nov, Dez      1= Sommerzeit in Apr, Mai, Jun, Jul, Aug, Sep
            call_sommer_winter(); // MESZ bit set wegen Zeitzone
          }

          if(update_ntp_ready == 1 || set_manual_time == true){  
            set_manual_time = false;
            call_time_set_timezone(); // ändere Zeitzone inkl. Sommer winter
            if(v_currenthour != rtc_hour){
              set_time_so_wi = true;
            }
          }


         
          //------------------------------------------------
          if(g_u_mez_ea_ist == 1){        // aktiv
            if(update_ntp_ready == 0){    // kein ntp
              
              TM_DEBUG_MED_PRINTLN(F("[TM] set Time ohne NTP"));
              set_time_so_wi = false;
              sommerzeit = summertime_EU(2000 +currentYearTwoDigits, v_currentmonth, v_currentdate, v_currenthour, 1); //(0=UTC, 1=MEZ)  //0 = Winterzeit in Jan, Feb, Nov, Dez      1= Sommerzeit in Apr, Mai, Jun, Jul, Aug, Sep
              
              test_sommer_winter(); //sommer =0
              g_Set_mesz_temp = g_Set_mesz_tmp;

              //-----------
              if(g_Set_mesz_temp != g_Set_mesz){   // umstellung erfolgt
               
               
                
                g_Set_mesz = g_Set_mesz_temp;
                Serial.print("g_Set_mesz f: ");Serial.println(g_Set_mesz);
                Preferences preferences;
                preferences.begin("eenvs", false);                         //Ordner eenvs anlegen/verwenden
                preferences.putUInt("g_Set_mesz", g_Set_mesz);             //Variable speichern  
                preferences.end();


                  // ??? hier noch bluetooth einfügen
                  if(update_ntp_ready == 1 || set_BT_RTC_Time == true){
                update_bl_clock = 1; // damit ohne NTP ok die Uhr gestellt werden kann
                    set_BT_RTC_Time = false;
                  }


                set_time_so_wi = true;



              }
              //-----------

            }
          }
          //------------------------------------------------

            unsigned long rtc_currentMillis = millis();
            if (rtc_currentMillis - rtc_previousMillis >= rtc_interval) {
                rtc_previousMillis = rtc_currentMillis;
                if (rtc_time_valid != 1 && update_ntp_ready == 1) {
                    TM_DEBUG_MED_PRINTLN("[TM] RTC Uhr sollte gestellt werden");
                    set_time_so_wi = true;
                }
            }

            unsigned long rtc_currentMillis2 = millis();
            if (rtc_currentMillis2 - rtc_previousMillis2 >= rtc_interval) {
                rtc_previousMillis2 = rtc_currentMillis2;
                if (update_ntp_ready == 1 && set_time_so_wi == true) {
                    set_time_so_wi = false;
                    epochTime_bl = epochTime_esp; // laden zum stellen
                    esp_task_wdt_reset(); 
                    if (not_write_time == false) {
                        TM_DEBUG_MAX_PRINT("[TM] EpochTime inkl. Sommer Winter offset ");
                        TM_DEBUG_MAX_PRINTLN(epochTime_esp);
                        TM_DEBUG_MAX_PRINT("[TM] Set RTC Clock ");
                        Set_RTC_clock();
                    }
                    update_bl_clock = 0;
                }
            }


          if(update_bl_clock == 1){
              
              //if(update_bl_clock == 0){ // Uhr nicht von BL
                //epochTime_bl = epochTime;  // das kommt aus printLocalTime
                //Serial.println("epoch gleich");
              //}

              //if(update_bl_clock == 1){ // Uhr von BL
                //if(Set_mesz == false){ // Winterzeit
                  //epochTime_bl = epochTime_bl - 3600;
                  //Serial.println("epoch abzug");
                //}
              //}

              //epochTime_bl = timeClient.getEpochTime();
                          
              time_t now;
              epochTime_bl = time(&now);          

              esp_task_wdt_reset(); 
              TM_DEBUG_MAX_PRINT("epochTime_blTime ");
              TM_DEBUG_MAX_PRINTLN(epochTime_bl);
              epochTime_esp = epochTime_bl; // laden zum stellen

              TM_DEBUG_MAX_PRINT("[TM] EpochTime: ");
              TM_DEBUG_MAX_PRINTLN(epochTime_esp);
              TM_DEBUG_MAX_PRINT("[TM] Set RTC Clock ");
              Set_RTC_clock();
              update_bl_clock = 0;

          }


          read_clock_esp32();
          //Serial.println("[TM] read_clock_RTC  1 ");
          read_clock_RTC();
         



}
//----------------------------------------------











     //------------------------------------    deinPasswort2
      void setTimestamp() {
          if (server3.hasArg("plain") == false) { // Check if body received
              server3.send(400, "application/json", "{\"success\": false, \"message\": \"Kein Body empfangen\"}");
              return;
          }

          // Parse JSON
          String body = server3.arg("plain");
          DynamicJsonDocument doc(1024);
          deserializeJson(doc, body);

          long timestamp = doc["timestamp"];
          int timezone = doc["timezone"];     // nur -12 bis 12
          bool dst = doc["dst"];
          String customZone = doc["customZone"];
          bool bit = doc["bit"];
          String region = doc["region"];
          String city = doc["city"];
          uint16_t timeFormat = doc["timeFormat"]; // Neues Feld für das Zeitformat
         
         
          web_timestamp = timestamp;
          web_timezone = timezone;      // nur -12 bis 12
          web_dst = dst;
          web_customZone = customZone;
          web_bit = bit;
          web_region = region;
          web_city = city;

          Serial.print("-> DST: "); Serial.println(web_dst);
          Serial.print("-> Time Zone: "); Serial.println(timezone);
          Serial.print("-> Custom Zone: "); Serial.println(web_customZone);
          Serial.print("-> Region: "); Serial.println(web_region);
          Serial.print("-> City: "); Serial.println(web_city);

          String v_timezone = "0";


          // Auswahl der richtigen Zeitzonenvariable entweder costom oder -12 bis 12
          if (web_customZone != "0") {
              v_timezone = web_customZone;
          } else {
              switch (web_timezone) {
                  case -12:
                      v_timezone = "<+12>-12";
                      break;
                  case -11:
                      v_timezone = "<+11>-11";
                      break;
                  case -10:
                      v_timezone = "<+10>-10";
                      break;
                  case -9:
                      v_timezone = "<+09>-9";
                      break;
                  case -8:
                      v_timezone = "<+08>-8";
                      break;
                  case -7:
                      v_timezone = "<+07>-7";
                      break;
                  case -6:
                      v_timezone = "<+06>-6";
                      break;
                  case -5:
                      v_timezone = "<+05>-5";
                      break;
                  case -4:
                      v_timezone = "<+04>-4";
                      break;
                  case -3:
                      v_timezone = "<+03>-3";
                      break;
                  case -2:
                      v_timezone = "<+02>-2";
                      break;
                  case -1:
                      v_timezone = "<+01>-1";
                      break;
                  case 0:
                      v_timezone = "GMT0";
                      break;
                  case 1:
                      v_timezone = "<-01>1";
                      break;
                  case 2:
                      v_timezone = "<-02>2";
                      break;
                  case 3:
                      v_timezone = "<-03>3";
                      break;
                  case 4:
                      v_timezone = "<-04>4";
                      break;
                  case 5:
                      v_timezone = "<-05>5";
                      break;
                  case 6:
                      v_timezone = "<-06>6";
                      break;
                  case 7:
                      v_timezone = "<-07>7";
                      break;
                  case 8:
                      v_timezone = "<-08>8";
                      break;
                  case 9:
                      v_timezone = "<-09>9";
                      break;
                  case 10:
                      v_timezone = "<-10>10";
                      break;
                  case 11:
                      v_timezone = "<-11>11";
                      break;
                  case 12:
                      v_timezone = "<-12>12";
                      break;
                  case 99:
                      // Optional: Set a specific default if necessary, otherwise, just leave it as is
                      break;
                  default:
                      v_timezone = "GMT0"; // Default to GMT0 if none of the above matches
                      break;
              }
          }

         esp_task_wdt_reset(); 
         
         
         
          if (v_timezone != 0 && web_bit) {
              // Hier den Code einfügen, um den Timestamp, Zeitzone und DST zu setzen
              // Beispiel:
              // setTimeOnESP(timestamp, v_timezone, bit);

            // Überprüfen der Länge von v_timezone
            if (v_timezone.length() > 20) {
                web_dst = 1; // DST auf 1 setzen
                Serial.println("---> DST auf 1 gesetzt, da v_timezone länger als 20 Zeichen ist");
            }else{
               web_dst = 0; // DST auf 0 setzen
            }



              // Log zum Überprüfen
            Serial.print("---> DST: "); Serial.println(web_dst);
            Serial.print("---> Zone: "); Serial.println(v_timezone);
            Serial.print("---> Region: "); Serial.println(web_region);
            Serial.print("---> City: "); Serial.println(web_city);
            Serial.print("---> Timestamp: "); Serial.println(web_timestamp);
            Serial.print("---> Time Format: "); Serial.println(timeFormat);   // "S31"


            Preferences preferences;
            preferences.begin("eenvs", false);                         //Ordner eenvs anlegen/verwenden
  
            preferences.putLong("timestamp", web_timestamp);
            preferences.putInt("timezone", web_timezone);         // nur -12 bis 12
            preferences.putBool("dst", web_dst);
            preferences.putString("customZone", web_customZone);
            preferences.putBool("bit", web_bit);
            preferences.putString("region", web_region);
            preferences.putString("city", web_city);
            
            if(timeFormat == 12){timeFormat = 2;};
            if(timeFormat == 24){timeFormat = 1;};
            if(timeFormat == 0){timeFormat = 1;};
            preferences.putUShort("g_u_clock", timeFormat); // Zeitformat speichern    //1=24h   2=12h   3=Datum
            preferences.putString("g_u_timezone", v_timezone);  // Time Zone
            g_u_timezone_ist = v_timezone;
            g_u_clock_ist = timeFormat;
            
            //preferences.end();
            
            //------------------------------------             
                //-------------------------------------------------------------
                time_t now;
                char strftime_buf[64];
                struct tm timeinfor;
                time(&now);
                setenv("TZ", g_u_timezone_ist.c_str(), 1); // Now adjust the TZ. Clock settings are adjusted to show the new local time
                tzset();
                localtime_r(&now, &timeinfor);
                strftime(strftime_buf, sizeof(strftime_buf), "%c", &timeinfor);
                printf("[IF] The current date/time is: %s\n", strftime_buf);
                //-------------------------------------------------------------
                epochTime_bl = web_timestamp;
                timeClient.setTimeOffset(0);
                Serial.print("[TM] set Epoch Time from Web:  ");Serial.println(epochTime_bl);
                timeClient.setEpochTime(epochTime_bl);              
                  //+++++++++++++++
                  struct timespec tp;
                  tp.tv_sec = epochTime_bl;  //hier die Uhrzeit stellen
                  clock_settime(CLOCK_REALTIME, &tp);
                  Serial.print("[IF] ESP32 Uhr Stellen von RTC Uhr | ");Serial.println(epochTime_bl);
                  time_t nowt;
                  struct tm timeinfot;
                  time(&nowt);
                  Serial.print("[TM] Load Timezone: ");Serial.println(g_u_timezone_ist);
                  setenv("TZ",g_u_timezone_ist.c_str(),1); 
                  tzset();
                  localtime_r(&nowt, &timeinfot);
                  esp_task_wdt_reset(); 

                  strftime(strftime_buf, sizeof(strftime_buf), "%c", &timeinfot);
                  //ESP_LOGI(TAG, "The current date/time in Germany is: %s", strftime_buf);
                  printf("[IF] The current date/time is: %s\n", strftime_buf);
                  //+++++++++++++++
                  time_t rtc = epochTime_bl;
                  timeval tv = { rtc, 0 };
                  settimeofday(&tv, nullptr);

                  struct tm timeinfo;
                  if (WiFi.status() == WL_CONNECTED) {
                    if (!getLocalTime(&timeinfo)) {
                      #if TM_DEBUG_LEVEL >= TM_DEBUG_MAX
                        Serial.println("[TM] Failed to obtain time");
                      #endif
                    }else{
                      Serial.print(F("[TM] 8: "));
                      Serial.println(&timeinfo, "%A, %B %d %Y %H:%M:%S");
                    }
                  } else {
                    #if TM_DEBUG_LEVEL >= TM_DEBUG_MAX
                      Serial.println("[TM] WiFi nicht verbunden. Zeit wird vom ESP abgerufen.");
                    #endif
                    time(&now);
                    localtime_r(&now, &timeinfo);
                  }


                  Serial.print("[TM] get Stunde     from ESP: ");Serial.println(timeClient.getHours());
                  Serial.print("[TM] get minute     from ESP: ");Serial.println(timeClient.getMinutes());
                  Serial.print("[TM] get Sekunde    from ESP: ");Serial.println(timeClient.getSeconds());
                  Serial.print("[TM] get Epoch Time from ESP: ");Serial.println(timeClient.getEpochTime());
                 
                  second = timeinfo.tm_sec;
                  minute = timeinfo.tm_min;
                  hour = timeinfo.tm_hour;
                  day = timeinfo.tm_mday;
                  month = timeinfo.tm_mon + 1;
                  year = timeinfo.tm_year + 1900;
                  weekday = timeinfo.tm_wday;
                  yday = timeinfo.tm_yday;
                  hour12h = timeinfo.tm_hour;
                  istdst = timeinfo.tm_isdst;

                  currentSec = second;
                  currentmin = minute;
                  currenthour = hour;
                  currentdate = day;
                  currentmonth = month;
                  esp_year_t = timeinfo.tm_year + 1900-2000;
                  currentyear = esp_year_t;
                  //currentYearTwoDigits = esp_year_t % 100;
                  esp_dOW = weekday;
                  currenthour12 = currenthour;


                  if(g_u_clock_ist == 1){ 
                    currenthourAM_PM = false;
                  }
                  if(g_u_clock_ist == 2){ 
                    currenthour12 = currenthour;  
                    currenthourAM_PM = false;
                    if( currenthour12 == 0 ){currenthour12 = 12;currenthourAM_PM = true;}
                    if( currenthour12 > 12 ){currenthour12 = currenthour12 - 12;currenthourAM_PM = true;}
                  } 

                  Serial.print("[TM] get Stunde  from ESP: ");Serial.println(currenthour);
                  Serial.print("[TM] get Minute  from ESP: ");Serial.println(currentmin);
                  Serial.print("[TM] get Sekunde from ESP: ");Serial.println(currentSec);
                  Serial.print("[TM] get DST from ESP (1=Sommer): ");Serial.println(istdst);

                  sommerzeit = summertime_EU(2000 +currentYearTwoDigits, currentmonth, currentdate, currenthour, 1); //(0=UTC, 1=MEZ)  //0 = Winterzeit in Jan, Feb, Nov, Dez      1= Sommerzeit in Apr, Mai, Jun, Jul, Aug, Sep
                 if(sommerzeit == 1){  
                        Set_mesz = true;
                        g_Set_mesz = 0;
                        Serial.println("[TM] ESP Es ist Sommer | MESZ ");
                 }else{
                        Set_mesz = false;
                        g_Set_mesz = 1;
                        Serial.println("[TM] ESP Es ist Winter | MEZ  ");
                 } 
                    
                      Serial.print("g_Set_mesz b: ");Serial.println(g_Set_mesz);
                      preferences.putUInt("g_Set_mesz", g_Set_mesz);             //Variable speichern  
                      
                //---------------------------------------------------------------
    
                  if(epochTime_bl >= 1704067200){
                    update_bl_clock = 1; // damit ohne NTP ok die Uhr gestellt werden kann
                    set_manual_time = true;
                    set_BT_time = true;
                    set_BT_RTC_Time = true;
                  }

            //------------------------------------

              preferences.end();

              server3.send(200, "application/json", "{\"success\": true, \"message\": \"Datum und Uhrzeit erfolgreich gesetzt\"}");
          } else {
              server3.send(400, "application/json", "{\"success\": false, \"message\": \"Ungültige Daten\"}");
          }
      }

     //------------------------------------




      void handleSetTimeFormat() {                 //setTimeFormat
        if (server3.hasArg("plain") == false) {
          server3.send(400, "text/plain", "Bad Request");
          return;
        }

        String body = server3.arg("plain");
        DynamicJsonDocument doc(1024);
        DeserializationError error = deserializeJson(doc, body);

        if (error) {
          server3.send(400, "text/plain", "Bad Request: Invalid JSON");
          return;
        }

        int timeFormat = doc["timeFormat"];
        // Hier kannst du den Code hinzufügen, um das Zeitformat zu ändern

        // Beispiel für Fehlerbehandlung
        if (timeFormat != 12 && timeFormat != 24) {
          server3.send(404, "application/json", "{\"success\":false, \"message\":\"Not Found: Der angegebene Endpunkt existiert nicht\"}");
          return;
        }

        // Erfolgreiche Antwort
        server3.send(200, "application/json", "{\"success\":true, \"message\":\"Zeitformat erfolgreich geändert\"}");
      }






















bool g_login = false;
bool g_scan_start;
bool g_scan_start2;
bool g_scan_alternative;
bool g_search_start;
uint8_t g_search_counter;
bool g_bl_connect;
bool g_bt_start_conn;
bool g_connect_start = false;
bool g_connect_WLAN = false;
uint8_t g_search_start_count;








constexpr char BLINKING_INTERVAL_ATTR[] = "blinkingInterval";
constexpr char LED_MODE_ATTR[] = "ledMode";
constexpr char LED_STATE_ATTR[] = "ledState";
constexpr uint16_t BLINKING_INTERVAL_MS_MIN = 10U;
constexpr uint16_t BLINKING_INTERVAL_MS_MAX = 60000U;
volatile uint16_t blinkingInterval = 1000U;
volatile bool ledState = false;
// handle led state and mode changes
//bool attributesChanged = false;

/// @brief Update callback that will be called as soon as one of the provided shared attributes changes value,
/// if none are provided we subscribe to any shared attribute change instead
/// @param data Data containing the shared attributes that were changed and their current value
void processSharedAttributes(const Shared_Attribute_Data &data) {
 
 Serial.println(F("Updated  processSharedAttributes"));
 
  for (auto it = data.begin(); it != data.end(); ++it) {
    if (strcmp(it->key().c_str(), BLINKING_INTERVAL_ATTR) == 0) {
      const uint16_t new_interval = it->value().as<uint16_t>();
      if (new_interval >= BLINKING_INTERVAL_MS_MIN && new_interval <= BLINKING_INTERVAL_MS_MAX) {
        blinkingInterval = new_interval;
        Serial.print("Updated blinking interval to: ");
        Serial.println(new_interval);
      }
    } else if(strcmp(it->key().c_str(), LED_STATE_ATTR) == 0) {
      ledState = it->value().as<bool>();
      //digitalWrite(LED_BUILTIN, ledState ? HIGH : LOW);
      Serial.print("Updated state to: ");
      Serial.println(ledState);
    }
  }
  //attributesChanged = true;
}







//--------------------------------------------------------------------------------
void process_Attribute_Request(const JsonObjectConst &data, JsonObjectConst::iterator &it) {

  const char* key = it->key().c_str();

        TB_DEBUG_MAX_PRINTLN(F("Updated process_Attribute_Request"));

        g_other_attr = false;
        // Shared attributes have to be parsed by their type.
        const uint16_t new_interval = it->value().as<uint16_t>();

         if (strcmp(key, U_UNIT_KEY) == 0) {
          //Serial.println("U_UNIT_KEY"); //1=Standard   1 = bqm3  0=pCi
           g_unit_soll = new_interval;  
           g_unit_ist = g_unit_soll; 
           credentials2.i_UNIT_KEY = data[U_UNIT_KEY].as<std::string>();

         } else if (strcmp(key, u_file_start) == 0) {
           g_file_start = new_interval; 

        } else if (strcmp(key, u_file_end) == 0) {
           g_file_end = new_interval;  

        } else if (strcmp(key, u_file_read) == 0) {
           g_file_read = new_interval;
           if(g_file_read == 1){b_file_read14 = true;}
           if(g_file_read == 2){b_file_read15 = true;}
           if(g_file_read == 99){b_file_delete = true;}
     
        } else if (strcmp(key, U_TIME_TB_KEY) == 0) {
           u_TIME_TB_key_read = new_interval;  
           //Serial.println("u_TIME_TB_key " + String(u_TIME_TB_key_read));

        } else if (strcmp(key, U_sw_checksum) == 0) {
           //const String new_Sinterval = it->value().as<String>();
           //U_sw_checksum_read = new_Sinterval; 
          const char* new_Sinterval = it->value().as<const char*>();
          strncpy(U_sw_checksum_read, new_Sinterval, sizeof(U_sw_checksum_read) - 1);
          U_sw_checksum_read[sizeof(U_sw_checksum_read) - 1] = '\0'; // Sicherstellen, dass es null-terminiert ist
           //Serial.println("U_sw_checksum " + String(U_sw_checksum_read));
        
        } else if (strcmp(key, U_LED_T_KEY) == 0) {
           //Serial.println("U_LED_T_KEY");//1=Standard  Top led EIN
           g_LEDT_T_soll = new_interval;  
           //if(g_LEDT_T_soll >= 1){
            //g_LEDT_T_ist = 1; 
           //}else{
            //g_LEDT_T_ist = 0; 
           //}
           g_LEDT_T_ist = (g_LEDT_T_soll >= 1) ? 1 : 0;
           credentials2.i_LED_T_KEY = data[U_LED_T_KEY].as<std::string>();
           g_t_led_change = true;
           boot_ani_off2 = true;
           g_t_led_off = true;

        } else if (strcmp(key, U_KNX_S_KEY) == 0) {
           //Serial.println("U_KNX_S_KEY");//0=Standard  KNX Aus
           //g_KNX_S_soll = new_interval; 

           //g_KNX_S_ist = (g_KNX_S_soll >= 1) ? 1 : 0;
           //credentials2.i_KNX_S_KEY = data[U_KNX_S_KEY].as<std::string>();


        } else if (strcmp(key, U_LED_F_KEY) == 0) {
           //Serial.println("U_LED_F_KEY");//1=Standard  7 Segment  EIN
           g_LEDT_F_soll = new_interval; 
           //if(g_LEDT_F_soll >= 1){
           // g_LEDT_F_ist = 1; 
           //}else{
           // g_LEDT_F_ist = 0; 
           //}
           g_LEDT_F_ist = (g_LEDT_F_soll >= 1) ? 1 : 0;
           credentials2.i_LED_F_KEY = data[U_LED_F_KEY].as<std::string>();
       
         } else if (strcmp(key, U_LED_FB_KEY) == 0) {
           g_LEDT_FB_soll = new_interval;  
           g_LEDT_FB_ist = (g_LEDT_FB_soll > 15) ? 15 : g_LEDT_FB_soll;
           wlan_led_hell_calc = true;
           lc.setIntensity(g_LEDT_FB_ist);
           credentials2.i_LED_FB_KEY = data[U_LED_FB_KEY].as<std::string>();

        } else if (strcmp(key, U_LED_TF_KEY) == 0) {
           g_LEDT_TF_soll = new_interval; 
           g_LEDT_TF_ist = (g_LEDT_TF_soll >= 1) ? 1 : 0;
           credentials2.i_LED_TF_KEY = data[U_LED_TF_KEY].as<std::string>();
           g_t_led_change = true;

        } else if (strcmp(key, U_LED_TB_KEY) == 0) {
           g_LEDT_TB_soll = new_interval;  
           g_LEDT_TB_ist = (g_LEDT_TB_soll >= 255) ? 255 : g_LEDT_TB_soll;
           credentials2.i_LED_TB_KEY = data[U_LED_TB_KEY].as<std::string>();
           g_t_led_change = true;
           boot_ani_off2 = true;
           v_Brightness = g_LEDT_TB_ist;

        } else if (strcmp(key, U_RANGE_T_KEY) == 0) {
           g_Range_T_soll = new_interval; 
           g_Range_T_ist = (g_Range_T_soll <= g_Range_M_ist) ? g_Range_M_ist + 1 : g_Range_T_soll;
           credentials2.i_RANGE_T_KEY = data[U_RANGE_T_KEY].as<std::string>();
           g_t_led_change = true;

        } else if (strcmp(key, U_RANGE_M_KEY) == 0) {
           g_Range_M_soll = new_interval; 
           g_Range_M_ist = (g_Range_M_soll <= g_Range_U_ist) ? g_Range_U_ist + 1 : g_Range_M_soll;
           if (g_Range_M_ist >= g_Range_T_ist) {
              g_Range_M_ist = g_Range_T_soll - 1;
           }
           credentials2.i_RANGE_M_KEY = data[U_RANGE_M_KEY].as<std::string>();
           g_t_led_change = true;

        } else if (strcmp(key, U_RANGE_U_KEY) == 0) {
           g_Range_U_soll = new_interval;  
           g_Range_U_ist = (g_Range_U_soll <= 0) ? 0 : g_Range_U_soll;
           if (g_Range_U_ist >= g_Range_M_ist) {
              g_Range_U_ist = g_Range_M_soll - 1;
           }
           credentials2.i_RANGE_U_KEY = data[U_RANGE_U_KEY].as<std::string>();
           g_t_led_change = true;

        } else if (strcmp(key, U_buzzer_soll_KEY) == 0) {
           g_Buzzer_soll = new_interval; 
           //if(g_Buzzer_soll != g_Buzzer_ist){Serial.print("u_Buzzer_soll: "); Serial.println(g_Buzzer_soll);}
           g_Buzzer_ist = (g_Buzzer_soll <= 0) ? 0 : g_Buzzer_soll;
           credentials2.i_buzzer_soll_KEY = data[U_buzzer_soll_KEY].as<std::string>();

        } else if (strcmp(key, U_buzzer_ea_KEY) == 0) {
           g_u_buzzer_ea = new_interval;  
           if (g_u_buzzer_ea <= 0) {
              g_u_buzzer_ea = 0;
              g_Buzzer_time = 0;
           } else {
              g_u_buzzer_ea = new_interval; 
           }
           credentials2.i_buzzer_ea_KEY = data[U_buzzer_ea_KEY].as<std::string>();




        } else if (strcmp(key, S00_KEY) == 0) {
           //Serial.println("S00_KEY"); //
           g_S00_soll = new_interval; 
           if(g_S00_soll >= 1 && g_kalibriert == 0){

            g_time_set_kal_val = 10;
            b_bit_st_kal = true;
           }
           credentials2.i_S00_KEY = data[S00_KEY].as<std::string>();

        } else if (strcmp(key, S01_KEY) == 0) {
           //Serial.println("S01_KEY"); //
           g_S01_soll = new_interval; 
           if(g_S01_soll >= 1 && g_kalibriert == 0){
            g_time_set_kal_val = 10;
            b_bit_st_kal = true;
           }
           credentials2.i_S01_KEY = data[S01_KEY].as<std::string>();

        } else if (strcmp(key, S02_KEY) == 0) {
           //Serial.println("S02_KEY"); //
           g_S02_soll = new_interval; 
           if(g_S02_soll >= 1 && g_kalibriert == 0){
            g_time_set_kal_val = 10;
            b_bit_st_kal = true;
           }
           credentials2.i_S02_KEY = data[S02_KEY].as<std::string>();

        } else if (strcmp(key, S18_KEY) == 0) {
           //Serial.println("S18_KEY "); //
           g_S18_soll = new_interval; 
           if(g_S18_soll >= 1 && g_kalibriert == 0){
            g_time_set_kal_val = 10;
            b_bit_st_kal = true;
            //Serial.println(g_S18_soll);
           }
           credentials2.i_S18_KEY = data[S18_KEY].as<std::string>();

        } else if (strcmp(key, S19_KEY) == 0) {
           //Serial.println("S19_KEY"); //
           g_S19_soll = new_interval; 
           if(g_S19_soll >= 1 && g_kalibriert == 0){
            g_time_set_kal_val = 10;
            b_bit_st_kal = true;
           }
           credentials2.i_S19_KEY = data[S19_KEY].as<std::string>();

        } else if (strcmp(key, S21_KEY) == 0) {
           //Serial.println("S21_KEY"); //
           g_S21_soll = new_interval; 
           if(g_S21_soll >= 1 && g_kalibriert == 0){
            g_time_set_kal_val = 10;
            b_bit_st_kal = true;
           }
            if (g_new_search_ntp) { // wenn internet wieder verfügbar
                g_new_search_ntp = false;
                call_time_set_g();
            }
           credentials2.i_S21_KEY = data[S21_KEY].as<std::string>();

        //------- KALIBRIEREN ---------

    } else if (strcmp(key, U_CLOCK_KEY) == 0) {
        //Serial.println("u_clock_KEY");
        g_u_clock_soll = new_interval; // 1=24h 2=12h 3=Datum
        g_u_clock_ist = new_interval;

        if (g_u_clock_soll >= 3) {
            g_u_clock_ist = 3;
            g_u_clock_soll = 3;
        }
        credentials2.i_u_clock_KEY = data[U_CLOCK_KEY].as<std::string>();
        g_t_led_change = true;

    } else if (strcmp(key, U_view_switch_KEY) == 0) {
        //Serial.println("u_view_switch_KEY_");
        g_u_view_switch_soll = new_interval; // 0=Radon 1= Uhr 2= Wechsel
        g_u_view_switch_ist = new_interval;

        if (g_u_view_switch_soll >= 2) {
            g_u_view_switch_ist = 2;
            g_u_view_switch_soll = 2;
        }
        credentials2.i_u_view_switch_KEY = data[U_view_switch_KEY].as<std::string>();
        g_t_led_change = true;

        //---------------cloud---------------
    } else if (strcmp(key, U_CLOUD_ea_KEY) == 0) {
        
        if(lora_change_bt == 0){  // Wenn über BT geändert wurde, wird Thingsboard ignoriert
            g_Cloud_ea_soll = new_interval;

            if (g_Cloud_ea_soll != g_Cloud_ea_ist) {
                g_Cloud_ea_ist = g_Cloud_ea_soll;
            }

            if (g_Cloud_ea_ist >= 1) {
                g_Cloud_ea_ist = 1;
                g_Cloud_ea_soll = 1;
            }
            Preferences preferences;
            preferences.begin("eenvs", false); // Ordner eenvs anlegen/verwenden
            preferences.putUChar("g_cloud_ea", g_Cloud_ea_ist);
            preferences.end();
            credentials2.i_u_cloud_ea_KEY = data[U_CLOUD_ea_KEY].as<std::string>();
            g_t_led_change = true;
        }

    } else if (strcmp(key, U_CLOUD_server_KEY) == 0) {
        const String new_Sinterval = it->value().as<String>();
       if(lora_change_bt == 0){  // Wenn über BT geändert wurde, wird Thingsboard ignoriert
          if (!new_Sinterval.isEmpty() && new_Sinterval != p_inputcloudserver && new_Sinterval != "0") {
              p_inputcloudserver = new_Sinterval;
              //Serial.println("U_CLOUD_server_KEY " + String(p_inputcloudserver));
              Preferences preferences;
              preferences.begin("eenvs", false); // Ordner eenvs anlegen/verwenden
              preferences.putString("p_clserv", p_inputcloudserver); // loragate2.de
              preferences.end();
              credentials2.i_u_cloud_server_KEY = data[U_CLOUD_server_KEY].as<std::string>();
          }
          g_t_led_change = true;
       }

    } else if (strcmp(key, U_CLOUD_page_KEY) == 0) {
        const String new_Sinterval = it->value().as<String>();
        if(lora_change_bt == 0){  // Wenn über BT geändert wurde, wird Thingsboard ignoriert
          if (!new_Sinterval.isEmpty() && new_Sinterval != p_inputcloudpage && new_Sinterval != "0") {
              p_inputcloudpage = new_Sinterval;
              //Serial.println("U_CLOUD_page_KEY " + String(p_inputcloudpage));
              Preferences preferences;
              preferences.begin("eenvs", false); // Ordner eenvs anlegen/verwenden
              preferences.putString("p_clpage", p_inputcloudpage); // LoRaWAN-Live-Link-K1-W64rt39bd41np75L/lora_radon_alphatracer_1.php
              preferences.end();
              credentials2.i_u_cloud_page_KEY = data[U_CLOUD_page_KEY].as<std::string>();
          }
          g_t_led_change = true;
        }

        } else if (strcmp(key, U_CLOUD_pre_KEY) == 0) {
            const String new_Sinterval = it->value().as<String>();
            if (lora_change_bt == 0) { // Wenn über BT geändert wurde, wird Thingsboard ignoriert
                if (!new_Sinterval.isEmpty() && strcmp(new_Sinterval.c_str(), p_inputcloudprec) != 0 && new_Sinterval != "0") {
                    strncpy(p_inputcloudprec, new_Sinterval.c_str(), sizeof(p_inputcloudprec) - 1);
                    p_inputcloudprec[sizeof(p_inputcloudprec) - 1] = '\0';

                    Preferences preferences;
                    preferences.begin("eenvs", false); // Ordner eenvs anlegen/verwenden
                    preferences.putString("p_clpre", new_Sinterval); // submit=Daten
                    preferences.end();

                    credentials2.i_u_cloud_pre_KEY = data[U_CLOUD_pre_KEY].as<std::string>();
                }
                g_t_led_change = true;
            }



    } else if (strcmp(key, U_CLOUD_port_KEY) == 0) {
        
        if(lora_change_bt == 0){  // Wenn über BT geändert wurde, wird Thingsboard ignoriert
          p_inputcloudporti = new_interval;

          if (p_inputcloudporti == 0) {
              p_inputcloudporti = 80;
          }
          Preferences preferences;
          preferences.begin("eenvs", false); // Ordner eenvs anlegen/verwenden
          preferences.putShort("p_clport", p_inputcloudporti);
          preferences.end();
          credentials2.i_u_cloud_port_KEY = data[U_CLOUD_port_KEY].as<std::string>();
          g_t_led_change = true;
        }

    } else if (strcmp(key, U_CLOUD_chain_KEY) == 0) {
        const String new_Sinterval = it->value().as<String>();
       
       if(lora_change_bt == 0){  // Wenn über BT geändert wurde, wird Thingsboard ignoriert
          if (!new_Sinterval.isEmpty() && new_Sinterval != p_inputcloudchain && new_Sinterval != "0") {
              p_inputcloudchain = new_Sinterval;
              //Serial.println("U_CLOUD_chain_KEY " + String(p_inputcloudchain));
              Preferences preferences;
              preferences.begin("eenvs", false); // Ordner eenvs anlegen/verwenden
              preferences.putString("p_clchain", p_inputcloudchain);
              preferences.end();
              credentials2.i_u_cloud_chain_KEY = data[U_CLOUD_chain_KEY].as<std::string>();
          }
          g_t_led_change = true;
       }
           //--------



           //---------------cloud---------------


            } else if (strcmp(key, U_NTP1_KEY) == 0) {
                const String new_Sinterval = it->value().as<String>();
                if (!new_Sinterval.isEmpty() && strcmp(new_Sinterval.c_str(), g_u_ntp1_ist) != 0) {
                    strncpy(g_u_ntp1_ist, new_Sinterval.c_str(), sizeof(g_u_ntp1_ist) - 1);
                    g_u_ntp1_ist[sizeof(g_u_ntp1_ist) - 1] = '\0';
                    strncpy(g_u_ntp1_soll, new_Sinterval.c_str(), sizeof(g_u_ntp1_soll) - 1);
                    g_u_ntp1_soll[sizeof(g_u_ntp1_soll) - 1] = '\0';
                    #ifndef myNTP
                    configTzTime(g_u_timezone_ist.c_str(), g_u_ntp3_ist, g_u_ntp2_ist, g_u_ntp1_ist);
                    #else
                    configTzTime(g_u_timezone_ist.c_str(), ntpServerIP);
                    #endif
                    //Serial.printf("[TM] ForceUpdate, timeZone: %s, server1: %s, server2: %s, server3: %s\n", g_u_timezone_ist.c_str(), g_u_ntp3_ist, g_u_ntp2_ist, g_u_ntp1_ist);
                    call_time_set_g();
                }
                credentials2.i_u_ntp1_KEY = data[U_NTP1_KEY].as<std::string>();

            } else if (strcmp(key, U_NTP2_KEY) == 0) {
                const String new_Sinterval = it->value().as<String>();
                if (!new_Sinterval.isEmpty() && strcmp(new_Sinterval.c_str(), g_u_ntp2_ist) != 0) {
                    strncpy(g_u_ntp2_ist, new_Sinterval.c_str(), sizeof(g_u_ntp2_ist) - 1);
                    g_u_ntp2_ist[sizeof(g_u_ntp2_ist) - 1] = '\0';
                    strncpy(g_u_ntp2_soll, new_Sinterval.c_str(), sizeof(g_u_ntp2_soll) - 1);
                    g_u_ntp2_soll[sizeof(g_u_ntp2_soll) - 1] = '\0';
                    #ifndef myNTP
                    configTzTime(g_u_timezone_ist.c_str(), g_u_ntp3_ist, g_u_ntp2_ist, g_u_ntp1_ist);
                    #else
                    configTzTime(g_u_timezone_ist.c_str(), ntpServerIP);
                    #endif
                    //Serial.printf("[TM] ForceUpdate, timeZone: %s, server1: %s, server2: %s, server3: %s\n", g_u_timezone_ist.c_str(), g_u_ntp3_ist, g_u_ntp2_ist, g_u_ntp1_ist);
                    call_time_set_g();
                }
                credentials2.i_u_ntp2_KEY = data[U_NTP2_KEY].as<std::string>();

            } else if (strcmp(key, U_NTP3_KEY) == 0) {
                const String new_Sinterval = it->value().as<String>();
                if (!new_Sinterval.isEmpty() && strcmp(new_Sinterval.c_str(), g_u_ntp3_ist) != 0) {
                    if(ntp_change_web == 0){
                        strncpy(g_u_ntp3_ist, new_Sinterval.c_str(), sizeof(g_u_ntp3_ist) - 1);
                        g_u_ntp3_ist[sizeof(g_u_ntp3_ist) - 1] = '\0';
                        strncpy(g_u_ntp3_soll, new_Sinterval.c_str(), sizeof(g_u_ntp3_soll) - 1);
                        g_u_ntp3_soll[sizeof(g_u_ntp3_soll) - 1] = '\0';
                        #ifndef myNTP
                        configTzTime(g_u_timezone_ist.c_str(), g_u_ntp3_ist, g_u_ntp2_ist, g_u_ntp1_ist);
                        #else
                        configTzTime(g_u_timezone_ist.c_str(), ntpServerIP);
                        #endif
                        //Serial.printf("[TM] ForceUpdate, timeZone: %s, server1: %s, server2: %s, server3: %s\n", g_u_timezone_ist.c_str(), g_u_ntp3_ist, g_u_ntp2_ist, g_u_ntp1_ist);
                        call_time_set_g();
                    } else {
                        //Serial.println("[BT] NTP Einstellungen wird von Web Daten verwaltet");
                    }
                }
                credentials2.i_u_ntp3_KEY = data[U_NTP3_KEY].as<std::string>();


        } else if (strcmp(key, U_TIMEZONE_KEY) == 0) {
            const String new_Sinterval = it->value().as<String>();
            if (!new_Sinterval.isEmpty() && new_Sinterval != g_u_timezone_ist) {
                g_u_timezone_ist = new_Sinterval;
                g_u_timezone_soll = new_Sinterval;
                if (!g_sperr_bit_time) {
                    Serial.println("------------------");
                    setTimezone(new_Sinterval);
                    update_bl_clock = 1; // damit ohne NTP ok die Uhr gestellt werden kann
                    set_BT_RTC_Time = true;
                    call_time_set_g();
                }
            }
            credentials2.i_u_timezone_KEY = data[U_TIMEZONE_KEY].as<std::string>();
            g_t_led_change = true;

        } else if (strcmp(key, u_ble_beacon_KEY) == 0) {
            g_u_beacon_soll = new_interval;
            if (g_u_beacon_soll != g_u_beacon_ist) {
                g_beacon_reset = true;
                g_beacon_time = 10;
            }
            g_u_beacon_ist = new_interval;

            if (g_u_beacon_ist >= 6) {
                g_u_beacon_ist = 0;
                g_u_beacon_soll = 0;
                g_beacon_reset = false;
                g_beacon_time = 0;
            }
            credentials2.i_u_ble_beacon_KEY = data[u_ble_beacon_KEY].as<std::string>();
            g_t_led_change = true;

        } else if (strcmp(key, u_mez_ea_KEY) == 0) {
            WiFi_status = WL_CONNECTED;
            g_u_mez_ea_soll = new_interval;
            g_u_mez_ea_ist = new_interval;

            if (g_u_mez_ea_ist >= 1) {
                g_u_mez_ea_ist = 1;
                g_u_mez_ea_soll = 1;
            }
            if (!g_sperr_bit_time) {
                update_bl_clock = 1; // damit ohne NTP ok die Uhr gestellt werden kann
                set_BT_RTC_Time = true;
                call_time_set_g();
            }
            credentials2.i_u_mez_ea_KEY = data[u_mez_ea_KEY].as<std::string>();
            g_t_led_change = true;

        } else if (strcmp(key, u_identify_KEY) == 0) {
            g_u_identify_soll = new_interval;
            g_u_identify_ist = new_interval;

            if (g_u_identify_ist >= 1) {
                g_identify = true;
                g_u_identify_soll = 1;
                g_u_identify_ist = 1;
                g_identify_byte = 0;
            } else {
                g_identify = false;
                g_u_identify_soll = 0;
                g_u_identify_ist = 0;
                g_identify_byte = 0;
            }
            credentials2.i_u_identify_KEY = data[u_identify_KEY].as<std::string>();
            g_t_led_change = true;

            //------- KALIBRIEREN ---------

        } else if (strcmp(key, U_checken_KEY) == 0) {
           if(g_checken_soll >= 1){
            
           
            if(g_checken_soll == 41573){
                b_re_checked = true;
            }else{
              if(b_calibrieren == false && b_cal_write == false){        // Sensor öffnen und xxx
                g_checken_ist = 1;
                b_checken = true; 
                g_time_set_check_val = 10;
              }
            }

           }else{
              g_kal_write_ist = 0;
              g_kalibrieren_ist = 0;
              g_checken_ist = 0;
           }
            credentials2.i_checken_KEY = data[U_checken_KEY].as<std::string>();



        } else if (strcmp(key, U_kalibrieren_KEY) == 0) {
            g_kalibrieren_soll = new_interval;

            if (g_kalibriert == 0 || g_kalibrieren_soll == 41573) {
                if (g_kalibrieren_soll >= 1) {
                    if (g_kalibrieren_soll == 41573) {
                        b_re_kalibrieren = true; // Sensor ent kalibrieren
                        b_calibrieren = false; // Sensor öffnen
                        g_kalibrieren_soll = 0;
                        g_checken_ist = 0;
                        g_kal_write_ist = 0;

                        g_kalibriert = 0;
                        Preferences preferences;
                        preferences.begin("eenvs", false); // Ordner eenvs anlegen/verwenden
                        preferences.putUChar("s_kalibriert", g_kalibriert); // kalibrierter Sensor

                        g_checked = 0;
                        //const int attribute_items_24 = 3;
                        Attribute attributes24[3] = {
                            { C_KALIBRIERT_KEY, 0 },
                            { C_s_kalibriert_KEY, g_kalibriert },
                            { C_s_checked_KEY, g_checked },
                        };
                        tb.sendAttributes(attributes24, 3);
                        delay(200);

                        preferences.putUChar("s_checked", g_checked); // checked Sensor
                        preferences.end();

                    } else {
                        g_kalibrieren_soll = 1;
                        ms2 = millis();
                        mb_radon_F3_eintrarge_last = 0;
                        mb_cal12_send = 0;
                        mb_cal13_send = 0;
                        count_2h = 0;

                        if (!b_checken && !b_cal_write) {
                            g_kalibrieren_ist = 1;
                            if (!b_calibrieren) { // Sensor noch nicht offen dann
                                g_start_kalibireung = 1; // starten Sensor öffnen 1-12
                                //const int attribute_items_23 = 1;
                                Attribute attributes23[1] = {
                                    { C_KALIBRIERT_KEY, 1 },
                                };
                                tb.sendAttributes(attributes23, 1);
                                delay(200);
                            }
                            b_calibrieren = true; // Sensor öffnen
                            ms2 = millis();
                            mb_radon_F3_eintrarge_last = 0;
                            mb_cal12_send = 0;
                            mb_cal13_send = 0;
                            count_2h = 0;
                        }
                        g_checken_ist = 0;
                        g_kal_write_ist = 0;
                        //const int attribute_items_22 = 1;
                        Attribute attributes22[1] = {
                            { C_KALIBRIERT_KEY, 0 },
                        };
                        tb.sendAttributes(attributes22, 1);
                        delay(200);
                    }

                } else {
                    b_calibrieren = false; // Sensor öffnen
                    g_kalibrieren_ist = 0;
                }
            }
            credentials2.i_kalibrieren_KEY = data[U_kalibrieren_KEY].as<std::string>();

        } else if (strcmp(key, U_kal_write_KEY) == 0) {
           g_kal_write_soll = new_interval; 
           if(g_kal_write_soll >= 1){
            if(g_kalibriert == 0){
              g_kal_write_ist = 1; 
              b_cal_write = true; 
              g_time_set_kal_val = 10;
              b_bit_st_kal = true;

              b_calibrieren = false;
              b_checken = false;

              //tb.sendAttributeInt(C_KALIBRIERT_KEY, 0);
              //tb.sendAttributeInt(C_CHECKEN_KEY, 0);
                  //----------------------------
                    //const int attribute_items_21 = 2;
                    Attribute attributes21[2] = {
                      { C_KALIBRIERT_KEY,  0 },
                      { C_CHECKEN_KEY,  0 },
                    };
                    tb.sendAttributes(attributes21, 2);delay(200);
                  //----------------------------


            }
            g_checken_ist = 0;
            g_kalibrieren_ist = 0;

           }
           credentials2.i_kal_write_KEY = data[U_kal_write_KEY].as<std::string>();

           
           
        } else if (strcmp(key, FW_TITLE_KEY) == 0) {
            credentials2.i_fw_title = data[FW_TITLE_KEY].as<std::string>();

        } else if (strcmp(key, FW_VER_KEY) == 0) {
            credentials2.i_fw_version = data[FW_VER_KEY].as<std::string>();
            TB_newFwVersion = credentials2.i_fw_version.c_str();
            //Serial.print("-------------FW_VER_KEY-----------: ");Serial.println(TB_newFwVersion);
     
            if(TB_newFwVersion == TB_currFwVersion) {
               verzoegerung_fw_update = 0;
               startFirmwareUpdate = false;
               Preferences preferences;
               preferences.begin("eenvs", false); // Ordner eenvs anlegen/verwenden
               preferences.putUChar("fw_verz_update", verzoegerung_fw_update);    //  0=Standard  aus 
               preferences.end();
            }

 
            if(verzoegerung_fw_update == 0 && TB_newFwVersion != TB_currFwVersion) {
               verzoegerung_fw_update = 1;
              
               Preferences preferences;
               preferences.begin("eenvs", false); // Ordner eenvs anlegen/verwenden
               preferences.putUChar("fw_verz_update", verzoegerung_fw_update);    //  0=Standard  aus 
               preferences.end();

               TB_newFwVersion = TB_currFwVersion;
               // Zufällige Verzögerung hinzufügen (z.B. zwischen 10 Sekunden und 200 Sekunden)
               //randomDelay = random(10000, 200000);
               randomDelay = random(10000, 20000);
               delayStartTime = millis();
               startFirmwareUpdate = true;
               dataFirmwareUpdate = true;

               // Debug-Ausgabe der Verzögerung in Sekunden
               Serial.print("Verzögerung bis zum Start des Updates: ");
               Serial.print(randomDelay / 1000);
               Serial.println(" Sekunden");
               //Firmware_Send_State(FW_STATE_UPDATEDt, NEW_FW);

            }

     


        } else if (strcmp(key, FW_TAG_KEY) == 0) {
            credentials2.i_fw_tag = data[FW_TAG_KEY].as<std::string>();

        } else if (strcmp(key, FW_SIZE_KEY) == 0) {
            credentials2.i_fw_size = data[FW_SIZE_KEY].as<std::string>();

        } else if (strcmp(key, FW_CHKS_ALGO_KEY) == 0) {
            credentials2.i_fw_checksum_algorithm = data[FW_CHKS_ALGO_KEY].as<std::string>();

        } else if (strcmp(key, FW_CHKS_KEY) == 0) {
            credentials2.i_fw_checksum = data[FW_CHKS_KEY].as<std::string>();
            //Serial.println("----------------FW_CHKS_KEY--------------");


        } else {
            Serial.println(it->value().as<const char*>());
            g_other_attr = true;

        }



}
//--------------------------------------------------------------------------------

void scanI2C68() {
    byte error;
    int address = 0x68; // Address to check

    Serial.println(F("[TM] -> Checking address 0x68..."));

    Wire.beginTransmission(address);
    error = Wire.endTransmission();

    if (error == 0) {
        Serial.print(F("[TM] -> I2C device found at address 0x"));
        Serial.print(address, HEX);
        Serial.println(F("  ."));
    } else if (error == 4) {
        Serial.print(F("[TM] Unknown error at address 0x"));
        Serial.print(address, HEX);
        Serial.println();
    } else {
        Serial.print(F("[TM] No I2C device found at address 0x"));
        Serial.print(address, HEX);
        Serial.println();
    }
}



void scanI2C() {
    byte error, address;
    int nDevices;

    Serial.println(F("[TM] Scanning..."));

    nDevices = 0;
    for (address = 1; address < 127; address++) {
        Wire.beginTransmission(address);
        error = Wire.endTransmission();

        if (error == 0) {
            Serial.print(F("[TM] I2C device found at address 0x"));
            if (address < 16) Serial.print(F("0"));
            Serial.print(address, HEX);
            Serial.println(F("  !"));

            nDevices++;
        } else if (error == 4) {
            Serial.print(F("[TM] Unknown error at address 0x"));
            if (address < 16) Serial.print(F("0"));
            Serial.println(address, HEX);
        }
    }
    if (nDevices == 0)
        Serial.println(F("[TM] No I2C devices found\n"));
    else
        Serial.println(F("[TM] done\n"));
}










/// @brief Update callback that will be called as soon as the requested shared attributes, have been received.
/// The callback will then not be called anymore unless it is reused for another request
/// @param data Data containing the shared attributes that were requested and their current value
void processSharedAttributeRequest(const Shared_Attribute_Data &data) {
  //#ifdef MQTT_DEBUG
    //Serial.println("[TB] Lesen Shared Attribute beim Booten und bei anforderung");
    counter_Attribute++;
  //#endif


  for (auto it = data.begin(); it != data.end(); ++it) {

        process_Attribute_Request(data, it);
   
  }
 

      g_shared_empf_send_to_TB = true;
       
      g_requestedShared_x = true;  


      int jsonSize = JSON_STRING_SIZE(measureJson(data));
      char buffer[jsonSize];
      serializeJson(data, buffer, jsonSize);
    

      if(g_other_attr == true){
        
        String tempstr;
        tempstr = String(buffer);

        int length = tempstr.length();
        tempstr.toCharArray(buffer_other, length+1); 
        Serial.print(F("g_other_attr: "));Serial.println(tempstr);

        credentials2.i_fw_title = data[FW_TITLE_KEY].as<std::string>();

      }

      #ifdef MQTT_DEBUG
        Serial.println(buffer);
      #endif
      g_save_attribut =  true;
}



/// @brief Update callback that will be called as soon as the requested client-side attributes, have been received.
/// The callback will then not be called anymore unless it is reused for another request
/// @param data Data containing the client-side attributes that were requested and their current value
void processClientAttributeRequest(const Shared_Attribute_Data &data) {
  TB_DEBUG_MAX_PRINTLN(F("[IF] -> Process Client Attribute Request"));

  for (auto it = data.begin(); it != data.end(); ++it) {
    //Serial.println(it->key().c_str());
    // Shared attributes have to be parsed by their type.
    //Serial.println(it->value().as<const char*>());
        //const uint16_t new_interval = it->value().as<uint16_t>();
        //Serial.print("Client lesen from TB: ");
        //Serial.println(new_interval);
  }

  int jsonSize = JSON_STRING_SIZE(measureJson(data));
  char buffer[jsonSize];
  serializeJson(data, buffer, jsonSize);
  #if TB_DEBUG_LEVEL >= TB_DEBUG_MAX
    Serial.println(buffer);
  #endif
}



void processRpcAttributeUpdate(const Shared_Attribute_Data &data) {
  TB_DEBUG_MAX_PRINTLN(F("process Rpc AttributeUpdate"));

  for (auto it = data.begin(); it != data.end(); ++it) {
    Serial.println(it->key().c_str());
    // Shared attributes have to be parsed by their type.
    //Serial.println(it->value().as<const char*>());
        #if TB_DEBUG_LEVEL >= TB_DEBUG_MAX
          const uint16_t new_interval = it->value().as<uint16_t>();
        #endif
        TB_DEBUG_MAX_PRINT(F("Client lesen from TB: "));
        TB_DEBUG_MAX_PRINTLN(new_interval);

  }

  int jsonSize = JSON_STRING_SIZE(measureJson(data));
  char buffer[jsonSize];
  serializeJson(data, buffer, jsonSize);
  TB_DEBUG_MAX_PRINTLN(buffer);

}







// Standard ansprung bei Shared

/// @brief Update callback that will be called as soon as one of the provided shared attributes changes value,
/// if none are provided we subscribe to any shared attribute change instead
/// @param data Data containing the shared attributes that were changed and their current value
void processSharedAttributeUpdate(const Shared_Attribute_Data &data) {
  
  TB_DEBUG_MAX_PRINTLN(F("[TB] Shared Attribute Update"));


  g_now_ani_led = true;
  
 for (auto it = data.begin(); it != data.end(); ++it) {

        process_Attribute_Request(data, it);

  }
 

      g_shared_empf_send_to_TB = true;
       
      g_requestedShared_x = true;  


      int jsonSize = JSON_STRING_SIZE(measureJson(data));
      char buffer[jsonSize];
      serializeJson(data, buffer, jsonSize);
    

      if(g_other_attr == true){
        
        String tempstr;
        tempstr = String(buffer);

        int length = tempstr.length();
        tempstr.toCharArray(buffer_other, length+1); 
        TB_DEBUG_MAX_PRINT(F("g_other_attr: "));
        TB_DEBUG_MAX_PRINTLN(tempstr);


        credentials2.i_fw_title = data[FW_TITLE_KEY].as<std::string>();

      }

      MQTT_DEBUG_PRINTLN(buffer);

      g_save_attribut =  true;

}


// LED modes: 0 - continious state, 1 - blinking
volatile int ledMode = 0;
// handle led state and mode changes
volatile bool attributesChanged = false;

/// @brief Processes function for RPC call "setLedMode"
/// RPC_Data is a JSON variant, that can be queried using operator[]
/// See https://arduinojson.org/v5/api/jsonvariant/subscript/ for more details
/// @param data Data containing the rpc data that was called and its current value
/// @return Response that should be sent to the cloud. Useful for getMethods
RPC_Response processSetLedMode(const RPC_Data &data) {            // RPC_Subscribe
    TB_DEBUG_MAX_PRINTLN(F("Received the set led state RPC method"));

    // Process data
    int new_mode = data;

    TB_DEBUG_MAX_PRINT(F("Mode to change: "));
    TB_DEBUG_MAX_PRINTLN(new_mode);


  if (new_mode != 0 && new_mode != 1) {
    return RPC_Response("error", "Unknown mode!");
  }

  ledMode = new_mode;

  attributesChanged = true;

  // Returning current mode
  return RPC_Response("newMode", (int)ledMode);
}






// lesen zwischendurch
const Attribute_Request_Callback sharedCallback5(REQUESTED_SHARED_ATTRIBUTES5.cbegin(), REQUESTED_SHARED_ATTRIBUTES5.cend(), processSharedAttributeRequest);
// Lesen Shared beim Booten
const Attribute_Request_Callback sharedCallback8(REQUESTED_SHARED_ATTRIBUTES8.cbegin(), REQUESTED_SHARED_ATTRIBUTES8.cend(), processSharedAttributeRequest);
const Attribute_Request_Callback sharedCallback7(REQUESTED_SHARED_ATTRIBUTES7.cbegin(), REQUESTED_SHARED_ATTRIBUTES7.cend(), processSharedAttributeRequest);
const Attribute_Request_Callback sharedCallback6(REQUESTED_SHARED_ATTRIBUTES6.cbegin(), REQUESTED_SHARED_ATTRIBUTES6.cend(), processSharedAttributeRequest);
const Attribute_Request_Callback sharedCallback4(REQUESTED_SHARED_ATTRIBUTES4.cbegin(), REQUESTED_SHARED_ATTRIBUTES4.cend(), processSharedAttributeRequest);
const Attribute_Request_Callback sharedCallback3(REQUESTED_SHARED_ATTRIBUTES3.cbegin(), REQUESTED_SHARED_ATTRIBUTES3.cend(), processSharedAttributeRequest);
const Attribute_Request_Callback sharedCallback2(REQUESTED_SHARED_ATTRIBUTES2.cbegin(), REQUESTED_SHARED_ATTRIBUTES2.cend(), processSharedAttributeRequest);
const Attribute_Request_Callback sharedCallback1(REQUESTED_SHARED_ATTRIBUTES1.cbegin(), REQUESTED_SHARED_ATTRIBUTES1.cend(), processSharedAttributeRequest);
const Attribute_Request_Callback sharedCallback ( REQUESTED_SHARED_ATTRIBUTES.cbegin(),  REQUESTED_SHARED_ATTRIBUTES.cend(),  processSharedAttributeRequest);
const Attribute_Request_Callback sharedCallbackt(REQUESTED_SHARED_ATTRIBUTESt.cbegin(), REQUESTED_SHARED_ATTRIBUTESt.cend(), processSharedAttributeRequest);

const Attribute_Request_Callback clientCallback ( REQUESTED_CLIENT_ATTRIBUTES.cbegin(),  REQUESTED_CLIENT_ATTRIBUTES.cend(), &processClientAttributeRequest);
const Attribute_Request_Callback clientCallback2(REQUESTED_CLIENT_ATTRIBUTES2.cbegin(), REQUESTED_CLIENT_ATTRIBUTES2.cend(), &processClientAttributeRequest);
const Attribute_Request_Callback clientCallback3(REQUESTED_CLIENT_ATTRIBUTES3.cbegin(), REQUESTED_CLIENT_ATTRIBUTES3.cend(), &processClientAttributeRequest);

const Shared_Attribute_Callback callbackshared ( SUBSCRIBED_SHARED_ATTRIBUTES.cbegin(),  SUBSCRIBED_SHARED_ATTRIBUTES.cend(), processSharedAttributeUpdate);  //rückmeldung beim ändern
const Shared_Attribute_Callback callbackshared2(SUBSCRIBED_SHARED_ATTRIBUTES2.cbegin(), SUBSCRIBED_SHARED_ATTRIBUTES2.cend(), processSharedAttributeUpdate);  //rückmeldung beim ändern
const Shared_Attribute_Callback callbackshared3(SUBSCRIBED_SHARED_ATTRIBUTES3.cbegin(), SUBSCRIBED_SHARED_ATTRIBUTES3.cend(), processSharedAttributeUpdate);  //rückmeldung beim ändern
const Shared_Attribute_Callback callbackshared4(SUBSCRIBED_SHARED_ATTRIBUTES4.cbegin(), SUBSCRIBED_SHARED_ATTRIBUTES4.cend(), processSharedAttributeUpdate);  //rückmeldung beim ändern
const Shared_Attribute_Callback callbackshared5(SUBSCRIBED_SHARED_ATTRIBUTES5.cbegin(), SUBSCRIBED_SHARED_ATTRIBUTES5.cend(), processSharedAttributeUpdate);  //rückmeldung beim ändern


//?????
const Attribute_Request_Callback attribute_shared_request_callback(SHARED_ATTRIBUTES_LIST.cbegin(), SHARED_ATTRIBUTES_LIST.cend(), &processSharedAttributes);
const Shared_Attribute_Callback attributes_callback               (SHARED_ATTRIBUTES_LIST.cbegin(), SHARED_ATTRIBUTES_LIST.cend(), &processSharedAttributes);

//   //Firmware_Shared_Attribute_Received();
// process_shared_attribute_update_message

// Shared_Attributes_Request

/*
const std::array<RPC_Callback, 1U> callbackrpcs = {
  RPC_Callback{ "lastActivityTime", processSetLedMode }
};

const std::array<RPC_Callback, 1U> callbackrpcs2 = {
  RPC_Callback{ "u_buzzer_soll", processSetLedMode }
};
*/
//const RPC_Callback callbackrpcs(SUBSCRIBED_RPC_ATTRIBUTES.cbegin(), SUBSCRIBED_RPC_ATTRIBUTES.cend(), processRpcAttributeUpdate);
//const RPC_Request_Callback sharedCallback9(lastActivityTime_KEY, processSharedAttributeRequest);




constexpr char RPC_REQUEST_CALLBACK_METHOD_NAME[] PROGMEM = "humidity";


/// @brief Processes function for RPC response of "getCurrentTime".
/// If no response is set the callback is called with {"error": "timeout"}, after a few seconds
/// @param data Data containing the rpc response that was sent by the cloud
void processTime(const JsonVariantConst &data) {
  serializeJsonPretty(data, Serial);
  TB_DEBUG_MAX_PRINT(F("jsonSize processTime"));

}

const RPC_Request_Callback callbackrpc(RPC_REQUEST_CALLBACK_METHOD_NAME, &processTime);







      //----------------------------------
      void start_Shared_Attributes(){

           
            //-------------------------------------
                  if (!subscribedSHARED) {
                      TB_DEBUG_MAX_PRINTLN(F(" "));
                      TB_DEBUG_MAX_PRINTLN(F("-----------------------------------------"));
                      TB_DEBUG_MAX_PRINTLN("[IF] Subscribing for Shared 1 attribute updates...");

                      send_ueberw_counter_start++;
                      send_ueberw_counter_start_[1]++;
                      if (!tb.Shared_Attributes_Subscribe(callbackshared)) {
                          count_subscribedSHARED++;
                          TB_DEBUG_MAX_PRINTLN("[IF] Failed to subscribe for Shared attribute updates 1");
                          Shared_Attributes_Subscribe_fail = true;
                          SubscribeDone = 0;
                          send_ueberw_counter++;
                          send_ueberw_counter_error_[1]++;
                      } else {
                          subscribedSHARED = true;
                          count_subscribedSHARED = 0;
                          TB_DEBUG_MAX_PRINTLN("[IF] Subscribe Shared Attributes done 1");
                          Shared_Attributes_Subscribe_fail = false;
                          SubscribeDone = 1;
                          send_ueberw_counter_success++;
                          send_ueberw_counter_success_[1]++;
                      }
                  }

                //-------------------------------------

                //-------------------------------------
                  if (!subscribedSHARED2) {
                      TB_DEBUG_MAX_PRINTLN(F(" "));
                      TB_DEBUG_MAX_PRINTLN(F("-----------------------------------------"));
                      TB_DEBUG_MAX_PRINTLN("[IF] Subscribing for Shared 2 attribute updates...");

                      send_ueberw_counter_start++;
                      send_ueberw_counter_start_[2]++;
                      if (!tb.Shared_Attributes_Subscribe(callbackshared2)) {
                          count_subscribedSHARED2++;
                          TB_DEBUG_MAX_PRINTLN("[IF] Failed to subscribe for Shared attribute updates 2");
                          Shared_Attributes_Subscribe_fail = true;
                          SubscribeDone2 = 0;
                          send_ueberw_counter++;
                          send_ueberw_counter_error_[2]++;
                      } else {
                          subscribedSHARED2 = true;
                          count_subscribedSHARED2 = 0;
                          TB_DEBUG_MAX_PRINTLN("[IF] Subscribe Shared Attributes done 2");
                          Shared_Attributes_Subscribe_fail = false;
                          SubscribeDone2 = 1;
                          send_ueberw_counter_success++;
                          send_ueberw_counter_success_[2]++;
                      }
                  }

                //-------------------------------------

                //-------------------------------------
                  if (!subscribedSHARED3) {
                      TB_DEBUG_MAX_PRINTLN(F(" "));
                      TB_DEBUG_MAX_PRINTLN(F("-----------------------------------------"));
                      TB_DEBUG_MAX_PRINTLN("[IF] Subscribing for Shared 3 attribute updates...");

                      send_ueberw_counter_start++;
                      send_ueberw_counter_start_[3]++;
                      if (!tb.Shared_Attributes_Subscribe(callbackshared3)) {
                          count_subscribedSHARED3++;
                          TB_DEBUG_MAX_PRINTLN("[IF] Failed to subscribe for Shared attribute updates 3");
                          Shared_Attributes_Subscribe_fail = true;
                          SubscribeDone3 = 0;
                          send_ueberw_counter++;
                          send_ueberw_counter_error_[3]++;
                      } else {
                          subscribedSHARED3 = true;
                          count_subscribedSHARED3 = 0;
                          TB_DEBUG_MAX_PRINTLN("[IF] Subscribe Shared Attributes done 3");
                          Shared_Attributes_Subscribe_fail = false;
                          SubscribeDone3 = 1;
                          send_ueberw_counter_success++;
                          send_ueberw_counter_success_[3]++;
                      }
                  }

                //-------------------------------------


              //-------------------------------------
                if (TB_currFwVersion == TB_newFwVersion) {
                    if (!subscribedSHARED5) {
                        TB_DEBUG_MAX_PRINTLN(F(" "));
                        TB_DEBUG_MAX_PRINTLN(F("-----------------------------------------"));
                        TB_DEBUG_MAX_PRINTLN("[IF] Subscribing for Shared 5 attribute updates...");

                        send_ueberw_counter_start++;
                        send_ueberw_counter_start_[5]++;
                        if (!tb.Shared_Attributes_Subscribe(callbackshared5)) {
                            count_subscribedSHARED5++;
                            TB_DEBUG_MAX_PRINTLN("[IF] Failed to subscribe for Shared attribute updates 5");
                            Shared_Attributes_Subscribe_fail = true;
                            SubscribeDone5 = 0;
                            send_ueberw_counter++;
                            send_ueberw_counter_error_[5]++;
                        } else {
                            subscribedSHARED5 = true;
                            count_subscribedSHARED5 = 0;
                            TB_DEBUG_MAX_PRINTLN("[IF] Subscribe Shared Attributes done 5");
                            Shared_Attributes_Subscribe_fail = false;
                            SubscribeDone5 = 1;
                            send_ueberw_counter_success++;
                            send_ueberw_counter_success_[5]++;
                        }
                    }
                }

                //-------------------------------------


                //-------------------------------------
                  if (!subscribedSHARED4) {
                      TB_DEBUG_MAX_PRINTLN(F(" "));
                      TB_DEBUG_MAX_PRINTLN(F("-----------------------------------------"));
                      TB_DEBUG_MAX_PRINTLN("[IF] Subscribing for Shared 4 attribute updates...");

                      send_ueberw_counter_start++;
                      send_ueberw_counter_start_[4]++;
                      if (!tb.Shared_Attributes_Subscribe(callbackshared4)) {
                          count_subscribedSHARED4++;
                          TB_DEBUG_MAX_PRINTLN("[IF] Failed to subscribe for Shared attribute updates 4");
                          Shared_Attributes_Subscribe_fail = true;
                          SubscribeDone4 = 0;
                          send_ueberw_counter++;
                          send_ueberw_counter_error_[4]++;
                      } else {
                          subscribedSHARED4 = true;
                          count_subscribedSHARED4 = 0;
                          TB_DEBUG_MAX_PRINTLN("[IF] Subscribe Shared Attributes done 4");
                          Shared_Attributes_Subscribe_fail = false;
                          SubscribeDone4 = 1;
                          send_ueberw_counter_success++;
                          send_ueberw_counter_success_[4]++;
                      }

                      if (TB_currFwVersion == TB_newFwVersion && verzoegerung_fw_update == 0 && disable_server >= 1) { 
                          tb_shared_update = true;
                          g_shared_empf_send_to_TB = true;
                      }
                  }

                //-------------------------------------


      }
      //----------------------------------







        //-----------------------------------------------
        void TB_connect() {
  
            //Serial.println("[IF] TB-Connecting...");

            if (!tb.connected()) {
                      
               // Connect to the ThingsBoard server, as the provisioned client
               //Serial.printf("[IF] T-Connecting to: (%s)\n", THINGSBOARD_SERVER);
               //if (!tb.connect(THINGSBOARD_SERVER, credentials.username.c_str(), THINGSBOARD_PORT, credentials.client_id.c_str(), credentials.password.c_str())) {
                      count_InitTB ++;


                        char p_tb_username_c[30];
                        char p_tb_client_id_c[30];
                        char p_tb_password_c[30];

                        int length = p_tb_username.length();
                        p_tb_username.toCharArray(p_tb_username_c, length+1); 
                        int length2 = p_tb_client_id.length();
                        p_tb_client_id.toCharArray(p_tb_client_id_c, length2+1); 
                        int length3 = p_tb_password.length();
                        p_tb_password.toCharArray(p_tb_password_c, length3+1); 

                        
                      if (!tb.connect(THINGSBOARD_SERVER, p_tb_username_c, THINGSBOARD_PORT, p_tb_client_id_c, p_tb_password_c)) {

                          //Serial.println("[IF] TB Failed to connect");

                          //Serial.println(credentials.client_id.c_str());
                          //Serial.println(p_tb_client_id);
                          //Serial.println(credentials.username.c_str());
                          //Serial.println(p_tb_username);
                          //Serial.println(credentials.password.c_str());
                          //Serial.println(p_tb_password);                        
                
                      } else {

                  
                          #ifdef MB_DETAIL_DEBUG
                            Serial.println("[IF] Connect"); 
                          #endif
                          g_TB_connect_Status = true;
                          TB_status = 1;

                      }
            } 



        }
        //-------------------------------------------------




      //-------------------------------------------------
        void setupmDNS() {
            uint8_t g_exit = 0;

            strcpy(DEVICE_NAME, device_id_c);

            if (!MDNS.begin(DEVICE_NAME)) {
                WLAN_DEBUG_PRINTLN("Error setting up MDNS responder!");
                WLAN_DEBUG_PRINT("mDNS ");
                WLAN_DEBUG_PRINTLN(DEVICE_NAME);
                while (1) {
                    delay(1000);
                    g_exit++;
                    if (g_exit > 5) {     // bail out on sensor detect
                        g_exit = 0;
                        break;
                    }
                }
            } else {
                WLAN_DEBUG_PRINT(F("[IF] mDNS gestartet. "));
                WLAN_DEBUG_PRINT(F("Hostname: "));
                WLAN_DEBUG_PRINTLN(DEVICE_NAME);
            }

            MDNS.addService("http", "tcp", 80);
        }

      //-------------------------------------------------



      //-------------------------------------------------
       void InitWiFibegin() {

         WiFi.begin(wIFI_SSID_c, wIFI_PASSWORD_c);

       }
      //-------------------------------------------------



      //-------------------------------------------------
      /// @brief Initalizes WiFi connection,
      // will endlessly delay until a connection has been successfully established
      void InitWiFi() {

        esp_task_wdt_reset();
        Serial.print(F("[IF] Connecting to ")); Serial.print(wIFI_SSID_c); Serial.print(" ");  
        g_InitWiFi = false;

        // Attempting to establish a connection to the given WiFi network   FRITZ!Box 6490 Holger
        p_APname_p = F("Radon Home Tracer");
        if (strcmp(device_id_c, "00000000") != 0) { 
          p_APname_p += " "; 
          p_APname_p += String(device_id_c);
        }

          // Kopiere die Daten aus dem PROGMEM in den RAM
          #if defined(g_PROGMEM_aktiv)
              strcpy_P(ram_p_APname_c, p_APname_c);
              strcpy_P(ram_device_id, device_id);
              p_APname_p.toCharArray(ram_p_APname_c, APname_LEN);
          #else
              p_APname_p.toCharArray(p_APname_c, APname_LEN);
          #endif


        InitWiFibegin();
         //Serial.println(F("---- InitWiFibegin -----"));

         printf("[AP] FREE RAMe: now: %.3f MB\n", getUsedRAMMB());   //15 

          #ifdef j_2_webserver
          if(disable_server >= 1 && TB_currFwVersion == TB_newFwVersion) {
            WiFi.setHostname(device_id_c);   //define hostname   MDNS
          }
          #endif

        int i = 0;
        
        while (WiFi.status() != WL_CONNECTED) {
          // Delay 500ms until a connection has been succesfully established
          delay(500);
          if(i > 20)
            break;
          i++; 
          Serial.print(".");
          esp_task_wdt_reset();

        }

        Serial.println(F(" "));
        
        Preferences preferences;
        preferences.begin("eenvs", false); // Ordner eenvs anlegen/verwenden
        
        const wl_status_t status = WiFi.status();
        WiFi_status = status;

        if (WiFi_status == WL_CONNECTED) {

          Serial.println(F("[IF] WLAN Connected"));
          count_reconn = 0;
          count_InitWiFi = 0;

          preferences.putBool("restart_bit", false); // Das Neustart-Bit löschen

        }else{

          count_InitWiFi++;

          bool restartBit_now = preferences.getBool("restart_bit", false);

          if (restartBit_now == 0) {
              preferences.putBool("restart_bit", true); // Das Neustart-Bit setzen
              IF_DEBUG_PRINTLN(F("[IF] Neustart des ESP32 aufgrund eines WiFi-Verbindungsfehlers"));
              delay(2000);
              ESP.restart();
              
          }
          preferences.end();

          switch (WiFi_status) {
              case WL_IDLE_STATUS:
                  IF_DEBUG_PRINTLN(F("[IF] WiFi WL_IDLE_STATUS"));
                  break;
              case WL_NO_SSID_AVAIL:
                  IF_DEBUG_PRINTLN(F("[IF] WiFi WL_NO_SSID_AVAIL"));
                  break;
              case WL_SCAN_COMPLETED:
                  IF_DEBUG_PRINTLN(F("[IF] WiFi WL_SCAN_COMPLETED"));
                  break;
              case WL_CONNECTED:
                  IF_DEBUG_PRINTLN(F("[IF] WiFi WL_CONNECTED"));
                  break;
              case WL_CONNECT_FAILED:
                  IF_DEBUG_PRINTLN(F("[IF] WiFi WL_CONNECT_FAILED"));
                  break;
              case WL_CONNECTION_LOST:
                  IF_DEBUG_PRINTLN(F("[IF] WiFi WL_CONNECTION_LOST"));
                  break;
              case WL_DISCONNECTED:
                  IF_DEBUG_PRINTLN(F("[IF] WiFi WL_DISCONNECTED"));
                  break;
              default:
                  break; // Wird nicht benötigt, wenn Statement(s) vorhanden sind
          }


        }
         //Serial.println(F("---- DNS -----"));
         //printf("[AP] FREE RAMe: now: %.3f MB\n", getUsedRAMMB());   //15 
         setupmDNS();
         //printf("[AP] FREE RAMe: now: %.3f MB\n", getUsedRAMMB());   //15 

        preferences.end();

      }
      //---------------------------------------------------------------------------------




        //-------------------------------------------------
          void checkWiFi() {
            int scanResult = -1; // Deklariere scanResult außerhalb der Bedingung
            unsigned long startTime = millis(); // Speichere die Startzeit

            bool scanAttempted = false;

            if (heap_caps_get_largest_free_block(MALLOC_CAP_DEFAULT) > 5000) {
                g_scan_alternative = false;
                scanAttempted = true;
                scanResult = WiFi.scanNetworks(true); // Starte den Scan im Hintergrund
                startTime = millis(); // Aktualisiere die Startzeit

                if (scanResult == WIFI_SCAN_FAILED) {
                    WLAN_DEBUG_PRINTLN("[WL][  ] WiFi Scan failed to start");
                    WLAN_DEBUG_PRINTLN("[WL][  ] WiFi erneut initialisieren und Scan starten");
                    // Initialisiere das WiFi-Modul nur bei Fehler
                    WiFi.mode(WIFI_STA);
                    WiFi.disconnect(); // Trenne alle bestehenden Verbindungen
                    // Starte den Scan erneut
                    scanResult = WiFi.scanNetworks(true);
                    startTime = millis(); // Aktualisiere die Startzeit
                }

                if (scanResult == WIFI_SCAN_RUNNING) { // WIFI_SCAN_RUNNING: Der Scan läuft noch.
                    // Warte auf das Ende des Scans oder breche nach 20 Sekunden ab
                    while (WiFi.scanComplete() == WIFI_SCAN_RUNNING) { // WIFI_SCAN_RUNNING: Der Scan läuft noch.
                        esp_task_wdt_reset();
                        delay(100);
                        if (millis() - startTime > 20000) { // 20 Sekunden sind vergangen
                            WLAN_DEBUG_PRINTLN("[WL][  ] WiFi Scan aborted after 20 seconds");
                            break;
                        }
                    }
                    scanResult = WiFi.scanComplete();

                    if (scanResult == WIFI_SCAN_FAILED) {
                        WLAN_DEBUG_PRINTLN("[WL][  ] WiFi Scan failed to complete");
                    } else if (scanResult != WIFI_SCAN_RUNNING) {
                        WLAN_DEBUG_PRINTF("[WL][  ] Anzahl der gefundenen WLAN-Netzwerke: %d\n", scanResult);
                        WLAN_DEBUG_PRINTLN(F(" "));
                        bool ssidFound = false;
                        for (int i = 0; i < scanResult; ++i) {
                            WLAN_DEBUG_PRINTF("[  ][ o] SSID: %s, RSSI: %d\n", WiFi.SSID(i).c_str(), WiFi.RSSI(i));
                            WLAN_DEBUG_PRINTLN(F(" "));
                            if (strcmp(WiFi.SSID(i).c_str(), wIFI_SSID_c) == 0) {
                                ssidFound = true;
                            }
                        }
                        if (ssidFound) {
                            WLAN_DEBUG_PRINTLN("[WL][  ] Gespeicherte SSID gefunden, versuche Verbindung herzustellen...");
                            InitWiFi();
                            if (WiFi.status() == WL_CONNECTED) {
                                WLAN_DEBUG_PRINTLN("\n[WL][  ] Verbindung erfolgreich hergestellt!");
                            } else {
                                WLAN_DEBUG_PRINTLN("\n[WL][  ] Verbindung fehlgeschlagen, Passwort möglicherweise geändert.");
                            }
                        } else {
                            //WLAN_DEBUG_PRINTLN("[WI][!!] Result: WLAN's gefunden, aber gespeicherte SSID nicht gefunden.");
                        }
                    }
                } else {
                    // Ausgabe der Anzahl der gefundenen WLAN-Netzwerke
                    WLAN_DEBUG_PRINTF("[WL][ -] Anzahl der gefundenen WLAN-Netzwerke: %d\n", scanResult);
                    WLAN_DEBUG_PRINTLN(F(" "));
                    for (int i = 0; i < scanResult; ++i) {
                        WLAN_DEBUG_PRINTF("[  ][  ] SSID: %s, RSSI: %d\n", WiFi.SSID(i).c_str(), WiFi.RSSI(i));
                        WLAN_DEBUG_PRINTLN(F(" "));
                    }
                }

            } else {
                #ifdef WLAN_DEBUG
                size_t largestFreeBlock = heap_caps_get_largest_free_block(MALLOC_CAP_DEFAULT);
                #endif
                WLAN_DEBUG_PRINT("[WI][ -] Kein Scan möglich wegen zu wenig Arbeitsspeicher: ");
                WLAN_DEBUG_PRINTLN(largestFreeBlock);
                scanResult = 0;
            }

            // Hier kannst du scanResult weiter verwenden
            if (scanAttempted) {
                if (scanResult > 0) {
                    // Weitere Verarbeitung der Scan-Ergebnisse
                    WLAN_DEBUG_PRINTLN("[WI][!!] Result: WLAN's gefunden, aber gespeicherte SSID nicht gefunden.");
                } else {
                    // Behandlung des Fehlers oder der Abbruchbedingung
                    WLAN_DEBUG_PRINTLN("[WI][!!] Result: Kein WLAN gefunden");
                }
            }
        }

        //-------------------------------------------------







    /// @brief Reconnects the WiFi uses InitWiFi if the connection has been removed
    /// @return Returns true as soon as a connection has been established again
        void reconnect() {
            // Check to ensure we aren't connected yet
            
            WLAN_DEBUG_PRINTLN(F("-------------------------------"));
            WLAN_DEBUG_PRINT(F("[IF] "));
            WLAN_DEBUG_PRINT(p_uhrzeit);
            WLAN_DEBUG_PRINTLN(F(" --> reconnect WLAN -->"));

            const wl_status_t status = WiFi.status();
            WiFi_status = status;
            
            if (WiFi_status != WL_CONNECTED) {
                WiFi_status = WL_CONNECT_FAILED;
                ledcWrite(ledChannel14, 0); // GPIO14 WLAN
                WiFi.mode(WIFI_STA);
                WiFi.disconnect();
                delay(1000); // Warte eine Sekunde
                
                //InitWiFi();
                checkWiFi();
                init_wifi_counter++;
                WLAN_DEBUG_PRINTLN("-------------------------------");
            }

            if (WiFi_status == WL_CONNECTED) {
                ledcWrite(ledChannel14, dutyCycle_t215); // GPIO14 WLAN
            }

            setupmDNS();
        }





        void restartWiFiAndClients() {

            tb.disconnect();
            WiFi.disconnect();

            delay(1000); // Warte eine Sekunde

            InitWiFibegin();

            //esp_wifi_set_ps(WIFI_PS_NONE); // WLAN-Stromsparmodus deaktivieren
            while (WiFi.status() != WL_CONNECTED) {
                delay(500);
                WLAN_DEBUG_PRINT(".");
                esp_task_wdt_reset();
            }
            WLAN_DEBUG_PRINTLN("WiFi verbunden");

            setupmDNS();

            //WiFi.setAutoReconnect(true); // Diese Methode stellt sicher, dass der ESP32 automatisch versucht, die Verbindung wiederherzustellen, wenn sie verloren geht.
            
            espClient.stop(); // Beende die aktuelle Verbindung
            espClient = WiFiClient(); // Erstelle eine neue Instanz
            ThingsBoard tb(espClient, MAX_MESSAGE_SIZE); // Initialisiere ThingsBoard mit der neuen Instanz
            /*
            if (espClient.connect("server_address2", THINGSBOARD_PORT)) {
                WLAN_DEBUG_PRINTLN("espClient verbunden");
            } else {
                WLAN_DEBUG_PRINTLN("espClient Verbindung fehlgeschlagen");
            }
            */
            if (WiFi.status() == WL_CONNECTED) {
              TB_connect();
            }

            radonClient1.stop(); // Beende die aktuelle Verbindung
            radonClient1 = WiFiClient(); // Erstelle eine neue Instanz
            if (radonClient1.connect("server_address1", p_inputcloudporti)) {
                WLAN_DEBUG_PRINTLN("radonClient1 verbunden");
            } else {
                WLAN_DEBUG_PRINTLN("radonClient1 Verbindung fehlgeschlagen");
            }
        }




      //---------------------------------
      void restartWiFi() {
        


          // WLAN deaktivieren
          WiFi.disconnect(false);
          WiFi.mode(WIFI_OFF);
          delay(1000); // Kurze Pause, um sicherzustellen, dass das WLAN-Modul ausgeschaltet ist

          // WLAN neu initialisieren
          WiFi.mode(WIFI_STA);


          InitWiFibegin();

          //(WIFI_PS_NONE); // WLAN-Stromsparmodus deaktivieren
          uint8_t i = 0; // Initialisiere i mit 0
          // Warten, bis die Verbindung hergestellt ist
          while (WiFi.status() != WL_CONNECTED) {
            // Delay 500ms until a connection has been succesfully established
            delay(500);
            if(i > 20)
              break;
            i++; // increase i by 1
            //Serial.print(F("."));
            Serial.print(".");
            esp_task_wdt_reset();

          }


      }
      //---------------------------------


      //---------------------------------
      void restarttb() {
         
          tb.disconnect();


      }
      //---------------------------------



      //---------------------------------
          void ausloesenw() {
            // Deine Funktion, die nach 20 Sekunden ausgelöst wird

            WLAN_DEBUG_PRINTLN(F("-----------------------------------------"));
            //printf("[AP] FREE HEAP: now: %u, contiguous: %u, lowest: %u\n",xPortGetFreeHeapSize(),heap_caps_get_largest_free_block(MALLOC_CAP_DEFAULT),xPortGetMinimumEverFreeHeapSize());

            // [AP] FREE HEAP: now: 7504, contiguous: 5276, lowest: 5780

            // Ausgabe der Nachricht
            WLAN_DEBUG_PRINT(F("[IF] [ "));
            WLAN_DEBUG_PRINT(p_uhrzeit);
            WLAN_DEBUG_PRINTLN(F(" ] WLAN disconnected"));

            tb.disconnect();
            WiFi.disconnect(); // Trenne alle bestehenden Verbindungen

            delay(1000); // Kurze Pause, um sicherzustellen, dass das WLAN-Modul ausgeschaltet ist

            WLAN_DEBUG_PRINTLN(F("[IF] WLAN initialisieren"));
            // WLAN neu initialisieren
            WiFi.mode(WIFI_STA);

            InitWiFibegin();

            uint8_t i = 0; // Initialisiere i mit 0
            // Warten, bis die Verbindung hergestellt ist
            WLAN_DEBUG_PRINT(F("[IF] WLAN verbinden "));
            while (WiFi.status() != WL_CONNECTED) {
                // Delay 500ms until a connection has been successfully established
                delay(500);
                if (i > 20) {
                    break;
                }
                i++; // increase i by 1
                //Serial.print(F("."));
                WLAN_DEBUG_PRINT(F("."));
                esp_task_wdt_reset();
            }

            WLAN_DEBUG_PRINTLN(F(" "));
            const wl_status_t status = WiFi.status();
            WiFi_status = status;
            if (WiFi_status == WL_CONNECTED) {
                WLAN_DEBUG_PRINTLN(F("[IF] WLAN Verbindung hergestellt"));

                TB_connect();
                TB_status = tb.connected();

                WLAN_DEBUG_PRINT(F("[IF] TB Verbindung Status: "));
                WLAN_DEBUG_PRINTLN(TB_status);
            } else {
                WLAN_DEBUG_PRINTLN(F("[IF] WLAN NOT connected!"));
            }
            WLAN_DEBUG_PRINTLN(F("-----------------------------------------"));
        }

      //---------------------------------


      //---------------------------------
      void processProvisionResponse(const Provision_Data &data) {
        int jsonSize = JSON_STRING_SIZE(measureJson(data));
        char buffer[jsonSize];
        serializeJson(data, buffer, jsonSize);
        Serial.printf("Received device provision response (%s)\n", buffer);

        if (strncmp(data["status"], "SUCCESS", strlen("SUCCESS")) != 0) {
          Serial.printf("Provision response contains the error: (%s)\n", data["errorMsg"].as<const char*>());
          return;
        }

        if (strncmp(data[CREDENTIALS_TYPE], ACCESS_TOKEN_CRED_TYPE, strlen(ACCESS_TOKEN_CRED_TYPE)) == 0) {
          credentials.client_id = "";
          credentials.username = data[CREDENTIALS_VALUE].as<std::string>();
          credentials.password = "";

          
          p_tb_client_id = credentials.client_id.c_str();
          p_tb_username = credentials.username.c_str();
          p_tb_password = credentials.password.c_str();


              Preferences preferences;
              preferences.begin("eenvs", false);                         //Ordner eenvs anlegen/verwenden
              ee_provision = 1;
              preferences.putUInt("eprovision", ee_provision);  

              preferences.putString("p_client_id", p_tb_client_id);                         //Variable speichern 
              preferences.putString("p_username", p_tb_username);                         //Variable speichern 
              preferences.putString("p_password", p_tb_password);                         //Variable speichern 
              preferences.end();


        }
        else if (strncmp(data[CREDENTIALS_TYPE], MQTT_BASIC_CRED_TYPE, strlen(MQTT_BASIC_CRED_TYPE)) == 0) {
          auto credentials_value = data[CREDENTIALS_VALUE].as<JsonObjectConst>();
          credentials.client_id = credentials_value[CLIENT_ID].as<std::string>();
          credentials.username = credentials_value[CLIENT_USERNAME].as<std::string>();
          credentials.password = credentials_value[CLIENT_PASSWORD].as<std::string>();

          Serial.print("jsonSize2");

          p_tb_client_id = credentials.client_id.c_str();
          p_tb_username = credentials.username.c_str();
          p_tb_password = credentials.password.c_str();

          Preferences preferences;
          preferences.begin("eenvs", false);                         //Ordner eenvs anlegen/verwenden
          ee_provision = 1;
          preferences.putUInt("eprovision", ee_provision);  

          preferences.putString("p_client_id", p_tb_client_id);                         //Variable speichern 
          preferences.putString("p_username", p_tb_username);                         //Variable speichern 
          preferences.putString("p_password", p_tb_password);                         //Variable speichern 
          preferences.end();



        }
        else {
          Serial.printf("Unexpected provision credentialsType: (%s)\n", data[CREDENTIALS_TYPE].as<const char*>());
          return;
        }

        // Disconnect from the cloud client connected to the provision account, because it is no longer needed the device has been provisioned
        // and we can reconnect to the cloud with the newly generated credentials.
        if (tb.connected()) {
          tb.disconnect();
          count_InitTB ++;
        }
        provisionResponseProcessed = true;
        //provisionRequestSent = true;

      }
      //---------------------------------



      //---------------------------------
      /*
      String generate_password() {
          const char charset[] = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
          const size_t length = 12;
          String password;

          for (size_t i = 0; i < length; ++i) {
              password += charset[random(sizeof(charset) - 1)];
          }

          return password;
      }
     */



      // Generiere ein Passwort, das in das char Array passt
      void generate_password(char *password, size_t length) {
          const char charset[] = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
          for (size_t i = 0; i < length - 1; ++i) {
              password[i] = charset[random(sizeof(charset) - 1)];
          }
          password[length - 1] = '\0'; // Null-terminate the string
      }

      //---------------------------------



void generate_device_id() {
    char mac_add[3] = {0}; // Platz für 2 Zeichen + Nullterminator
    char random_characters[3] = {0}; // Platz für 2 Zeichen + Nullterminator
    char random_number[4] = {0}; // Platz für 3 Zeichen + Nullterminator

    String w_macAddress_s;
    String w_id_s;

    byte mac[6]; // die MAC-Adresse Ihres WiFi-Moduls

    Serial.println(WiFi.macAddress().c_str());

    WiFi.macAddress(mac);
    Serial.print("MAC: ");
    for (int i = 0; i < 6; i++) {
        Serial.print(mac[i], HEX);
        if (i < 5) Serial.print(":");
    }
    Serial.println();

    // Letzte beiden Zeichen der MAC-Adresse kopieren
    snprintf(mac_add, sizeof(mac_add), "%02X", mac[5]); // Letztes Byte der MAC-Adresse kopieren
    mac_add[2] = '\0'; // Nullterminator hinzufügen
    w_macAddress_s = mac_add;
    Serial.print("MAC-: "); Serial.println(w_macAddress_s);

    w_id_s = "H";

    // Zufallszahlengenerator initialisieren
    randomSeed(micros());

    // Zufällige Zeichen (A-Z und 0-9) generieren
    for (int i = 0; i < 2; i++) {
        int random_value = random(0, 36); // 0-25 für A-Z, 26-35 für 0-9
        if (random_value < 26) {
            random_characters[i] = 'A' + random_value; // Buchstabe
        } else {
            random_characters[i] = '0' + (random_value - 26); // Zahl
        }
    }

    // Zufällige Reihenfolge festlegen
    if (random(0, 2) == 1) {
        char temp = random_characters[0];
        random_characters[0] = random_characters[1];
        random_characters[1] = temp;
    }
    
    random_characters[2] = '\0'; // Nullterminator hinzufügen

    w_id_s += random_characters;
    w_id_s.toCharArray(device_id, DeviceID_LEN + 1);

    Serial.print("2: "); Serial.println(device_id);

    int num = random(100, 999);
    snprintf(random_number, sizeof(random_number), "%d", num);
    Serial.print("1 random_number "); Serial.println(random_number);
    Serial.print("3: "); Serial.println(device_id);

    // Normaler RAM-Option
    strncat(device_id, random_number, sizeof(device_id) - strlen(device_id) - 1);
    device_id[sizeof(device_id) - 1] = '\0';  // Nullterminierung sicherstellen
    Serial.print("4: ");
    Serial.println(device_id);

    // Normaler RAM-Option
    strncat(device_id, mac_add, sizeof(device_id) - strlen(device_id) - 1);
    device_id[sizeof(device_id) - 1] = '\0';  // Nullterminierung sicherstellen

    Serial.print("mac_add: ");
    Serial.println(mac_add);
    Serial.print("5: ");
    Serial.println(device_id);

    Serial.print("device_id Char: ");
    Serial.println(device_id);
    Serial.print("6: ");
    Serial.println(device_id);

    strcpy(device_id_c, device_id);
    Serial.print(F("device_id: "));
    Serial.println(device_id_c);
          
    generate_password(correctPassword, sizeof(correctPassword));

    Serial.print(F("Generated Password: "));
    Serial.println(correctPassword);

    Preferences preferences;
    preferences.begin("eenvs", false); // Ordner eenvs anlegen/verwenden
    preferences.putBytes("p_device_id", device_id_c, DeviceID_LEN); // provision Variable speichern
    preferences.putString("password", correctPassword);     
    preferences.end();
}







//-------------
void delete_prov_id() {

     
     
        Preferences preferences;
        preferences.begin("eenvs", false);                         //Ordner eenvs anlegen/verwenden
        ee_provision = 0;
        preferences.putUInt("eprovision", ee_provision);  
        preferences.end(); 
        
        Serial.println(F("[SA] Generate new ID: "));
        generate_device_id();
       
        strcpy(DEVICE_NAME, device_id_c);   

        //correctPassword = generate_password();  // Generiertes Passwort
        generate_password(correctPassword, sizeof(correctPassword));





}
//-------------




//TB#*****





uint16_t port = 502;                      // port of modbus server
uint16_t aWebPort = 80;                      // port of Web server
uint8_t m_max_clients = 4;
uint32_t mbus_baud = 9600;  
uint16_t resp_tim_out = 1500;  
uint32_t mbus_baud_last = 9600;  

// Create a ModbusRTU client instance
ModbusClientRTU MB(Serial1);

#ifdef MB_Gateway
// Create server
ModbusBridgeWiFi MBbridge;
#endif


bool mb_Acknowledge = false;
String mb_Acknowledge_s = "";
byte mb_low = 0;
byte mb_high = 0;
//uint16_t mb_word = word(mb_high, mb_low);
uint32_t mb_long = 0;
byte mb_arry_byte[30];
byte i_loop = 0;
uint16_t mb_byte_size = 0;
uint16_t mb_byte_header = 4;
uint16_t mb_byte_resault = 2;
uint16_t mb_byte_header_t = 3;
byte responsegetFunctionCode = 0;

uint32_t mb_radon_ist_long = 0;
uint16_t  mb_radon_ist_word = 0;
uint32_t mb_radon_long = 0;
uint16_t  mb_radon_int = 0;
uint16_t  mb_radon_eintrarge = 0;
bool g_mb_sensor_3_online = false;
bool g_mb_sensor_4_online = false;
bool cb_g_mb_read_radon = false;

uint8_t cb_sensor_mb_ok = 0;
uint8_t cb_sensor_mb_time = 0;
uint8_t cb_sensor_mb_count = 0;
bool  cb_g_mb_sensor = true;
bool g_set_mb_reload = true;

uint8_t  mb_client_id = 1;
uint8_t  abfr_mb_finish = 0;
uint8_t  sensor_mb_3_ok = 0;
uint8_t  sensor_mb_4_ok = 0;
bool mb_man_read_radon;


uint32_t radon_tag = 0;
uint32_t radon_temp = 0;
uint16_t  radonTagCount = 0;
uint16_t  radonTagEintrCount = 0;
uint16_t  radonTagCountvorgabe = 96; 
uint16_t  radonMore14Day = 0;
uint16_t  mb_radon_ist_word_long0;
uint16_t  mb_radon_ist_word_long1;

uint16_t  mb_radon_live_word_0;
uint16_t  mb_radon_live_word_1;

            uint16_t mb_min;
            uint16_t mb_hour;
            uint16_t mb_day;
            uint16_t mb_month;
            uint16_t mb_ist_pwd;
            uint16_t mb_sreset;

       

uint16_t  mb_radon_live_word_0_m[11];
uint16_t  mb_radon_live_word_1_m[11];

uint16_t  mb_radon_word_long0;
uint16_t  mb_radon_word_long1;


uint32_t previousReceivedCount = 0;
uint32_t previousReceivedCountRTU = 0;
uint32_t requestCounterRTU = 0;
uint32_t requestCounterTCP = 0;
uint32_t lastRequestCounterTCP = 0;
uint32_t lastResetTime = 0;
uint32_t totalBytesReceivedRTU = 0;
uint32_t totalBytesReceivedTCP = 0;
uint32_t lastPrintTime = 0;
uint32_t mb_currentTime; 
uint32_t lastSecondTime;
uint32_t resetInterval = 1200000; // 3600000 = 1 Stunde    600000 = 10min
 // Variablen zur Speicherung der Anfragen innerhalb der letzten Minute
#define INTERVAL 60 // 60 Sekunden
uint32_t requestTimes[INTERVAL] = {0};
uint32_t requestIndex = 0;

uint32_t requestCounter = 0; uint32_t lastRequestTime = 0;
uint32_t received_size = 0;
uint32_t received_count = 0;uint32_t received_countg = 0;
uint32_t totalBytesReceived = 0;
uint32_t response_size = 0;
uint32_t response_ServerID = 0;
uint32_t received_response_size = 0;
uint32_t received_response_size_k = 0;
uint32_t received_response_size_m = 0;
uint32_t received_response_size_g = 0;
uint16_t  received_response__g = 0;
unsigned long msRs485 = millis();
unsigned long msRs485_start = millis();
float msRs485_diff = 0;
uint32_t msRs485_eintr = 0;
String p_rs485_data = "0";
String p_rs485_data_b = "0";
String p_rs485s_data = "0";
String p_rs485s_data_b = "0";

uint8_t Expec_b[] = {0, 4, 2, 0, 0};
uint8_t slaveid[] = {2, 3, 2, 0, 3};

String MBbridge_localRequest = "";

float val1, val2;
uint16_t val3, val4, val5, val6, val7, val8, val9, val10;
uint16_t valm1, valm2, valm3, valm4, valm5, valm6, valm7, valm8, valm9, valm10;
uint16_t fval1, fval2, fval3, fval4, fval5, fval6, fval7, fval8, fval9, fval10;
uint32_t rval3,rval4,rval5,rval6;
String rval7 = "          ";

uint16_t testsExecuted = 0;            // Global test cases counter. Incremented in testOutput().
byte count_in = 0;
byte count_out = 0;

uint8_t Tokenb = 1;
uint8_t mb_idscan = 1;
bool gModbusValupdateFlag = false;
uint8_t mb_afrg_Radon = 0;





BLEServer *pServer = NULL;
BLECharacteristic * pTxCharacteristic;
bool deviceConnected = false;
bool oldDeviceConnected = false;
uint8_t txValue = 0;
int connected_users = 0;
int traffic = 0;
size_t receivedTraffic = 0;
size_t sentTraffic = 0;
bool bleScanActive = false;
int scanCount = 0; 
const int maxScanCount = 20;


#define MAX_DEVICES 10
String radonDevices[MAX_DEVICES];
String namedDevices[MAX_DEVICES]; // Zusätzliche Liste für Geräte mit Namen
int radonDeviceCount = 0;
int namedDeviceCount = 0; // Zähler für Geräte mit Namen

int ble_rssi = 0;
int rssiSum = 0;
int rssiCount = 0;
int bestRssi = -100; // Initialwert für den besten RSSI (schlechter Wert)
int worstRssi = 0;   // Initialwert für den schlechtesten RSSI (besserer Wert)


unsigned long scanStartTime;



bool ms1_set;
bool ms2_set;
bool cal_lcd;
bool ms20_set;
bool bt_send_back;
String bufferReceive = "";
String buff_scan = "SCAN";
String buff_connect = "CONNECT:";
String buff_wifistatus ="STATUS";
//String buff_pwd ="k47t58W43Lds8";
char buff_pwd [15]  = "k47t58W43Lds8";
char buff_pwdt [15] = "ab1234567890c";

unsigned long ms3 = millis();


        uint8_t scan_max = 4;  //31
        String tempstr; 
        uint32_t mbus_baud_t;

//#define wlan_St_LEN     50
//char find_wlan[wlan_St_LEN+1]; //buffer to hold incoming packet
//String p_find_wlan = "";
//uint32_t p_find_wlani;
// p_find_wlan.toCharArray(find_wlan, wlan_St_LEN); 
// p_find_wlani = atoi(p_find_wlan.c_str()); 


//char wlan_ssids[30][50]={};
int wlan_found;
int ist_wlan;
String ist_pw = "                                                 ";






//**************************************************************************
 void lesen_next_things(){   






 }
//**************************************************************************




//**************************************************************************
  void bl_send_init(){
    
          String tempstr = "";
          tempstr = "{ts-"; tempstr += String(g1415_Sum_Counter); tempstr += "}\r\n";  
          pTxCharacteristic->setValue(tempstr.c_str());
          pTxCharacteristic->notify();
          size_t message_length = strlen(tempstr.c_str());
          sentTraffic += message_length;   
          delay(100);
          tempstr = "";
    
  }
  void bl_send_init2(){
    
          String tempstr = "";
          tempstr = String(g1415_Sum_Counter);   
          pTxCharacteristic->setValue(tempstr.c_str());
          pTxCharacteristic->notify();
          size_t message_length = strlen(tempstr.c_str());
          sentTraffic += message_length;   
          //delay(100);
          tempstr = "";
    
  }
//**************************************************************************






 //*******************************************************************************
  void datei_lesen_line13()
  {
      String data;
      uint16_t zeilenZaehler = 0;
      int i = 0;
      File file = SPIFFS.open(dateiGr13, "r");
      

      if(!file){

          // Die Datei ist nicht vorhanden
          #ifdef NVS_MQTT_DEBUG
            Serial.println("[FI] Die Datei " + String(dateiGr13) + " existiert nicht!");
          #endif 
          // Datei mit Schreibrechten öffnen, wird erstellt wenn nicht vorhanden
          File file = SPIFFS.open(dateiGr13, FILE_WRITE);
          #ifdef NVS_MQTT_DEBUG
            Serial.println("[FI] Datei " + String(dateiGr13) + " wurde erstellt!");
          #endif
          // Daten in die Datei schreiben
          file.print("0");
          // Schließen der Datei
          file.close();

          // erneut öffnen für lesen 
          file = SPIFFS.open(dateiGr13, "r");
        
      }



      #ifdef NVS_MQTT_DEBUG
        Serial.println("[FI] Lese Daten aus MQTT Datei:");
      #endif

      while(file.available()) {
        data = file.readStringUntil('\n'); // lesen bis Zeilenumbruch...
        #ifdef NVS_MQTT_DEBUG
          Serial.print("[FI] r Zeile ");
          Serial.print(zeilenZaehler);
          Serial.print(": ");
          Serial.println(data);           // ... und wieder ausgegeben
        #endif
        //cloud_list[i] = data;      
        i++;
        zeilenZaehler++;
      } 

          charcount13 = zeilenZaehler;
          charcount13_t = charcount13;

      
      #ifdef NVS_MQTT_DEBUG
      Serial.println("[FI] Aktueller MQTT read Zeilen Zähler: " + String(charcount13)); 
      #endif

      file.close();
      #ifdef NVS_cloud_DEBUG
        //Serial.println(F(" "));
      #endif

  }





void appendFile(fs::FS &fs, const char * path, const char * message){
    Serial.printf("Appending to file: %s\r\n", path);

    File file = fs.open(path, FILE_APPEND);
    if(!file){
        Serial.println("- failed to open file for appending");
        return;
    }
    
    file.print(message); 

    file.close();
}







void datei_schreiben13c(const char* things_list) { // FILE_APPEND
    //Serial.println(F("--------------------------------------------------------"));
    //float usedRAM = (ESP.getHeapSize() - ESP.getFreeHeap()) / (1024.0 * 1024.0);
    //Serial.print(F("Used RAM: ")); Serial.print(usedRAM, 3); Serial.println(F(" MB"));

      IF_DEBUG_PRINT(F("[IF] Speichere Daten in TB Datei 13c: "));
      IF_DEBUG_PRINTLN(things_list);


    File file = SPIFFS.open(dateiGr13, FILE_APPEND);

    if (!file) {
        #ifdef NVS_MQTT_DEBUG
        Serial.println(F("[FI] Die Datei existiert nicht!"));
        #endif
        file = SPIFFS.open(dateiGr13, FILE_WRITE);
        #ifdef NVS_MQTT_DEBUG
        Serial.println(F("[FI] Datei wurde erstellt!"));
        #endif
        file.print("");
        file.close();
    } else {
        file.print(things_list);
        file.print("\n");
        #ifdef NVS_MQTT_DEBUG
        // Serial.println("MQTT w Zeile  : " + String(things_list)); // ... und ausgegeben
        #endif

        file.close();
    }
}







  void datei_schreiben13()   // FILE_APPEND
  {
   
    //#ifdef MQTT_DEBUG

    //Serial.println(F("--------------------------------------------------------")); 
    //float usedRAM = (ESP.getHeapSize() - ESP.getFreeHeap()) / (1024.0 * 1024.0);
    //Serial.print(F("Used RAM: "));Serial.print(usedRAM, 3);Serial.println(F(" MB"));
    
    Serial.print(F("[IF] Speichere Daten in TB Datei 13: "));
    Serial.println(things_list_t);

    //#endif
   
    File file = SPIFFS.open(dateiGr13, FILE_APPEND);

     
    if(!file){
        // Die Datei ist nicht vorhanden
        #ifdef NVS_MQTT_DEBUG
          Serial.println("[FI] Die Datei " + String(dateiGr13) + " existiert nicht!");
        #endif 
        // Datei mit Schreibrechten öffnen, wird erstellt wenn nicht vorhanden
        File file = SPIFFS.open(dateiGr13, FILE_WRITE);
        #ifdef NVS_MQTT_DEBUG
          Serial.println("[FI] Datei " + String(dateiGr13) + " wurde erstellt!");
        #endif
        // Daten in die Datei schreiben
        file.print("");
        // Schließen der Datei
        file.close();
      }else{
          // Die Datei ist vorhanden

           file.print(things_list_t + "\n"); 
             #ifdef NVS_MQTT_DEBUG
                //Serial.println("MQTT w Zeile  : " + things_list_t);           // ... und ausgegeben 
             #endif


          file.close();       
      }
  }





//------------------------------------------------------------------------------------------
//#define DEBUG_MODE // Kommentiere diese Zeile aus, um Debug-Ausgaben zu deaktivieren

// Statische Variablen zur Speicherung des letzten gültigen Jahres, Monats, Tages, der Stunde, des Radonwerts und des Korrekturflags
static int lastValidYear = -1;
static int lastValidMonth = -1;
static int lastValidDay = -1;
static int lastValidHour = -1;
static String lastValidRadonValue = "";
static int correctionCount = 0; // Zähler für die Anzahl der Korrekturen, wegn fehler beim kompilieren habe ich das oben deklariert
static bool lastEntryValid = false; // Flag, um anzuzeigen, ob der letzte Datensatz vollständig korrekt war

bool isLeapYear(int year) {
    if (year % 4 == 0) {
        if (year % 100 == 0) {
            if (year % 400 == 0) return true;
            else return false;
        }
        return true;
    }
    return false;
}

int daysInMonth(int month, int year) {
    switch(month) {
        case 1: case 3: case 5: case 7: case 8: case 10: case 12:
            return 31;
        case 4: case 6: case 9: case 11:
            return 30;
        case 2:
            return isLeapYear(year) ? 29 : 28;
        default:
            return 0;
    }
}

String formatNumber(int num) {
    if (num < 10) {
        return "0" + String(num);
    } else {
        return String(num);
    }
}

// Funktion zur Umwandlung und Neuformatierung
String formatWithLeadingZero(String str) {
    int num = str.toInt();
    return formatNumber(num);
}

String checkAndCorrectDate(String dataLine) {
    #ifdef DEBUG_MODE
    Serial.println(F("  "));
    Serial.print(F("Original data line: "));
    Serial.println(dataLine);
    #endif
    
    // Überprüfe und korrigiere den Eintrag, falls notwendig
    int commaIndex = dataLine.indexOf(',');
    if (commaIndex != -1) {
        String dateTimePart = dataLine.substring(0, commaIndex);
        String radonValuePart = dataLine.substring(commaIndex + 1);
        #ifdef DEBUG_MODE
        Serial.print(F("Date and Time part: "));
        Serial.println(dateTimePart);
        Serial.print(F("Radon value part: "));
        Serial.println(radonValuePart);
        #endif

        // Überprüfe, ob Radonwert vorhanden ist, wenn nicht, verwende den letzten gültigen Wert
        if (radonValuePart.length() == 0) {
            if (lastValidRadonValue != "") {
                #ifdef DEBUG_MODE
                Serial.print(F("Missing radon value, using last valid radon value: "));
                Serial.println(lastValidRadonValue);
                #endif
                radonValuePart = lastValidRadonValue; // Verwende den letzten gültigen Radonwert
                correctionCount++; // Zähler erhöhen
            } else {
                #ifdef DEBUG_MODE
                Serial.print(F("Invalid entry, missing radon value and no valid radon value found in history: "));
                Serial.println(dataLine);
                #endif
                return "";  // Ungültiger Datensatz
            }
        } else {
            // Speichere den gültigen Radonwert
            lastValidRadonValue = radonValuePart;
        }

        int spaceIndex = dateTimePart.indexOf(' ');
        if (spaceIndex != -1) {
            String datePart = dateTimePart.substring(0, spaceIndex);
            String timePart = dateTimePart.substring(spaceIndex + 1);
            #ifdef DEBUG_MODE
            Serial.print(F("Date part: "));
            Serial.println(datePart);
            Serial.print(F("Time part: "));
            Serial.println(timePart);
            #endif

            int firstDotIndex = datePart.indexOf('.');
            int secondDotIndex = datePart.indexOf('.', firstDotIndex + 1);
            
            if (firstDotIndex != -1 && secondDotIndex != -1) {
                String yearString = datePart.substring(0, firstDotIndex);
                String monthString = datePart.substring(firstDotIndex + 1, secondDotIndex);
                String dayString = datePart.substring(secondDotIndex + 1);

                // Entferne die Minuten, wenn im Format HH:MM
                int colonIndex = timePart.indexOf(':');
                if (colonIndex != -1) {
                    timePart = timePart.substring(0, colonIndex);
                }

                int year = yearString.toInt();
                int month = monthString.toInt();
                int day = dayString.toInt();
                int hourb = timePart.toInt();
                
                #ifdef DEBUG_MODE
                Serial.print(F("Found year: "));
                Serial.println(yearString);
                Serial.print(F("Found month: "));
                Serial.println(monthString);
                Serial.print(F("Found day: "));
                Serial.println(dayString);
                Serial.print(F("Found hour: "));
                Serial.println(hourb);
                #endif

                bool validYear = (year >= 21 && year <= 60);
                bool validMonth = (month >= 1 && month <= 12);
                bool validDay = (day >= 1 && day <= 31);
                bool validHour = (hourb >= 0 && hourb <= 23);



                // Korrigiere das Format der Stunden, falls eine führende Null fehlt
                String formattedHour = formatNumber(hourb);

                // Validierung und Korrektur
                if (validYear && validMonth && validDay && validHour &&
                    (year > lastValidYear || (year == lastValidYear && month > lastValidMonth) ||
                     (year == lastValidYear && month == lastValidMonth && day > lastValidDay) ||
                     (year == lastValidYear && month == lastValidMonth && day == lastValidDay && hourb > lastValidHour))) {
                    // Der gesamte Datensatz ist korrekt und liegt in der Zukunft
                    lastValidYear = year;
                    lastValidMonth = month;
                    lastValidDay = day;
                    lastValidHour = hourb;
                    lastEntryValid = true; // Setze das Flag auf true
                } else {
                    // Der Datensatz ist nicht vollständig korrekt
                    if (lastEntryValid) {
                        // Verwende den letzten vollständigen Datensatz, um logische Korrekturen vorzunehmen
                        bool corrected = false;
                        if (!validYear || year <= lastValidYear) {
                            year = lastValidYear;
                            yearString = String(lastValidYear);
                            #ifdef DEBUG_MODE
                            Serial.print(F("Corrected year to: "));
                            Serial.println(yearString);
                            #endif
                            correctionCount++;
                            corrected = true;
                        }
                        if (!validMonth || month < lastValidMonth || (year == lastValidYear && month <= lastValidMonth)) {
                            month = lastValidMonth;
                            monthString = String(month);
                            #ifdef DEBUG_MODE
                            Serial.print(F("Corrected month to: "));
                            Serial.println(monthString);
                            #endif
                            correctionCount++;
                            corrected = true;
                        }
                        if (!validDay || day < lastValidDay || (month == lastValidMonth && day <= lastValidDay)) {
                            if (day == 1 && hourb == 0) {
                                // Wahrscheinlich ein fehlerhafter Timestamp, setze Tag auf letzten gültigen Tag + 1
                                day = lastValidDay + 1;
                                if (day > daysInMonth(lastValidMonth, lastValidYear)) {
                                    day = 1;
                                    month++;
                                    if (month > 12) {
                                        month = 1;
                                        year++;
                                    }
                                }
                            } else {
                                day = lastValidDay;
                            }
                            dayString = String(day);
                            #ifdef DEBUG_MODE
                            Serial.print(F("Corrected day to: "));
                            Serial.println(dayString);
                            #endif
                            correctionCount++;
                            corrected = true;
                        }
                        if (!validHour || hourb <= lastValidHour) {
                            hourb = (lastValidHour + 1) % 24;
                            if (hourb == 0) {
                                day++;
                                if (day > daysInMonth(month, year)) {
                                    day = 1;
                                    month++;
                                    if (month > 12) {
                                        month = 1;
                                        year++;
                                    }
                                }
                            }
                            formattedHour = formatNumber(hourb);
                            #ifdef DEBUG_MODE
                            Serial.print(F("Corrected hour to: "));
                            Serial.println(formattedHour);
                            #endif
                            correctionCount++;
                            corrected = true;
                        }
                        datePart = yearString + "." + monthString + "." + dayString;
                        lastEntryValid = corrected; // Setze das Flag basierend auf den Korrekturen
                    } else {
                        // Kein gültiger letzter Eintrag vorhanden, verwerfe den Datensatz
                        #ifdef DEBUG_MODE
                        Serial.print(F("Invalid date or time detected: "));
                        Serial.println(dataLine);
                        #endif
                        return "";
                    }
                }

                //String correctedEntry = datePart + " " + formattedHour + "," + radonValuePart;
               
                // Wandelt die bestehenden Strings in Integer um und formatiert sie neu
                String yearStringFormatted = formatWithLeadingZero(yearString);
                String monthStringFormatted = formatWithLeadingZero(monthString);
                String dayStringFormatted = formatWithLeadingZero(dayString);
                String hourStringFormatted = formatWithLeadingZero(String(hourb));

                // Setze die neu formatierten Strings zusammen
                String correctedEntry = yearStringFormatted + "." + monthStringFormatted + "." + dayStringFormatted + " " + hourStringFormatted + "," + radonValuePart;

                // Überprüfe auf doppelte Einträge
                if (yearStringFormatted == formatWithLeadingZero(String(lastValidYear)) &&
                    monthStringFormatted == formatWithLeadingZero(String(lastValidMonth)) &&
                    dayStringFormatted == formatWithLeadingZero(String(lastValidDay)) &&
                    hourStringFormatted == formatWithLeadingZero(String(lastValidHour))) {
                    #ifdef DEBUG_MODE
                    Serial.print(F("Duplicate entry detected: "));
                    Serial.println(correctedEntry);
                    #endif
                    return ""; // Verwerfe den Datensatz
                }

                // Aktualisiere die letzten gültigen Variablen vor dem Rückgeben des Eintrags
                lastValidYear = yearStringFormatted.toInt();
                lastValidMonth = monthStringFormatted.toInt();
                lastValidDay = dayStringFormatted.toInt();
                lastValidHour = hourStringFormatted.toInt();
                lastEntryValid = true; // Setze das Flag auf true


                #ifdef DEBUG_MODE
                Serial.print(F("Corrected entry: "));
                Serial.println(correctedEntry);
                #endif
                return correctedEntry;
            }
        }
    }

    #ifdef DEBUG_MODE
    Serial.print(F("Valid and unmodified entry: "));
    Serial.println(dataLine);
    #endif
    return dataLine;
}



//------------------------------------------------------------------------------------------








  void datei_schreiben14(const char* things_list)   // FILE_APPEND
{
    File file = SPIFFS.open(dateiGr14, FILE_APPEND);
    //Serial.print(F("[IF] Speichere Daten in BT Datei 14: "));
    //Serial.println(things_list);

    if(!file){
        // Die Datei ist nicht vorhanden
        #ifdef NVS_14_DEBUG
          Serial.println("[FI] Die Datei existiert nicht!");
        #endif 
        // Datei mit Schreibrechten öffnen, wird erstellt wenn nicht vorhanden
        file = SPIFFS.open(dateiGr14, FILE_WRITE);
        #ifdef NVS_14_DEBUG
          Serial.println("[FI] Datei wurde erstellt!");
        #endif
        // Daten in die Datei schreiben
        file.print("");
        // Schließen der Datei
        file.close();
    } else {
        // Die Datei ist vorhanden
        file.print(things_list); 
        file.print("\n");

        // Debug-Ausgabe (Optional)
        #ifdef NVS_14_DEBUG
          Serial.print("Datei14 w Zeile : ");
          Serial.println(things_list);  
        #endif

        // Schließen der Datei
        file.close();
    }
}


//-----------------------------------------------------------------------------------------------------------------------------








//-----------------------------------------------------------------------------------------------------------------------------
 
 void datei_lesen_line15b() {
    String data;
    uint16_t zeilenZaehler = 0;
    uint16_t t_zeilenZaehler = 0;
    uint16_t maxZeilen = 10010; // Maximale Anzahl der zu übertragenden Werte
    File file = SPIFFS.open(dateiGr15, "r");
    String tempstr = ""; 
    //Serial.print(F("[FI] Datei "));
    //Serial.print(dateiGr15); 
    //Serial.println(F(" wird gelesen!"));    

    if (!file) {
        #ifdef NVS_15_DEBUG
            Serial.println(F("[FI] Die Datei ") + String(dateiGr15) + F(" existiert nicht!"));
        #endif 
        // Datei mit Schreibrechten öffnen, wird erstellt wenn nicht vorhanden
        File file = SPIFFS.open(dateiGr15, FILE_WRITE);
        #ifdef NVS_15_DEBUG
            Serial.println(F("[FI] Datei ") + String(dateiGr15) + F(" wurde erstellt!"));
        #endif
        // Daten in die Datei schreiben
        file.print("0");
        // Schließen der Datei
        file.close();
        // erneut öffnen für lesen 
        file = SPIFFS.open(dateiGr15, "r");
    }

    if (g1415Side == 0) { 
        #ifdef NVS_15_DEBUG
            start_counter++;
            Serial.print(F("[FI] Lese Daten aus Datei Nr.15b ab Zeile ")); Serial.println(start_counter);   // start_counter = g14Filewrite;
            start_counter--;
            Serial.print(F("Aufzeichnungen ")); Serial.print(g1415_Sum_Counter); Serial.print(F(" | g1415_full ")); Serial.print(g1415_full); Serial.print(F(" | g1415Side ")); Serial.println(g1415Side); 
        #endif
    } else {
        start_counter = 0;
        #ifdef NVS_15_DEBUG
            Serial.print(F("[FI] Lese alle Daten aus Datei Nr.15b    Aufzeichnungen vorhanden: ")); Serial.println(g15Filewrite); 
            Serial.print(F(" | g1415_full ")); Serial.print(g1415_full); Serial.print(F(" | g1415Side ")); Serial.println(g1415Side);  
        #endif
    }          

    while (file.available() && zeilenZaehler < maxZeilen) {
        data = file.readStringUntil('\n'); // Lesen bis Zeilenumbruch...

        // Jahr überprüfen und korrigieren
        //data = checkAndCorrectDate(data);

        if (data.length() > 0) { // Nur gültige Einträge hinzufügen
            zeilenZaehler++;
            t_zeilenZaehler++;
            tempstr += data;

            if (t_zeilenZaehler < 10) {
                tempstr += ";";
            }

            if (t_zeilenZaehler >= 10) {
                // Senden
                tempstr += "\r\n";
                pTxCharacteristic->setValue(tempstr.c_str());
                pTxCharacteristic->notify();
                //Serial.println(tempstr);
                size_t message_length = tempstr.length();
                sentTraffic += message_length;
                delay(20);
                t_zeilenZaehler = 0;
                tempstr = "";
            }
        }

        esp_task_wdt_reset();
    } 

    // Überprüfe, ob am Ende des Vorgangs noch Daten übrig sind
    if (t_zeilenZaehler > 0 && zeilenZaehler <= maxZeilen) {
        tempstr += "\r\n";
        pTxCharacteristic->setValue(tempstr.c_str());
        pTxCharacteristic->notify();
        //Serial.println(tempstr);
        t_zeilenZaehler = 0;
        size_t message_length = tempstr.length();
        sentTraffic += message_length;
    }

    file.close();

    // Ausgabe der Anzahl der Korrekturen
    Serial.print(F("Total corrections made: "));
    Serial.println(correctionCount);
}

//-----------------------------------------------------------------------------------------------------------------------------




//-----------------------------------------------------------------------------------------------------------------------------
void datei_schreiben15(const char* things_list)   // FILE_APPEND
{
    File file = SPIFFS.open(dateiGr15, FILE_APPEND);

    // Ausgabe des Datenpuffers zu Serial
    //Serial.print(F("[IF] Speichere Daten in BT Datei 15: "));
    //Serial.println(things_list);

    if(!file){
        // Die Datei ist nicht vorhanden
        #ifdef NVS_14_DEBUG
          Serial.print("[FI] Die Datei ");
          Serial.print(dateiGr15);
          Serial.println(" existiert nicht!");
        #endif 
        // Datei mit Schreibrechten öffnen, wird erstellt wenn nicht vorhanden
        file = SPIFFS.open(dateiGr15, FILE_WRITE);
        #ifdef NVS_14_DEBUG
          Serial.print("[FI] Datei ");
          Serial.print(dateiGr15);
          Serial.println(" wurde erstellt!");
        #endif
        // Daten in die Datei schreiben
        file.print("");
        // Schließen der Datei
        file.close();
    } else {
        // Die Datei ist vorhanden
        file.print(things_list); 
        file.print("\n");

        // Debug-Ausgabe (Optional)
        #ifdef NVS_14_DEBUG
          Serial.print("Datei15 w Zeile: ");
          Serial.println(things_list);
        #endif

        // Schließen der Datei
        file.close();       
    }
}


//-----------------------------------------------------------------------------------------------------------------------------










//-----------------------------------------------------------------------------------------------------------------------------

void datei_lesen_line14b() {
    String data;
    uint16_t zeilenZaehler = 0;
    uint16_t t_zeilenZaehler = 0;
    uint16_t maxZeilen = 10010; // Maximale Anzahl der zu übertragenden Werte
    File file = SPIFFS.open(dateiGr14, "r");
    String tempstr = ""; 
    //Serial.print(F("[FI] Datei "));
    //Serial.print(dateiGr14); 
    //Serial.println(F(" wird gelesen!"));  

    if (!file) {
        #ifdef NVS_14_DEBUG
            Serial.println(F("[FI] Die Datei ") + String(dateiGr14) + F(" existiert nicht!"));
        #endif 
        // Datei mit Schreibrechten öffnen, wird erstellt wenn nicht vorhanden
        File file = SPIFFS.open(dateiGr14, FILE_WRITE);
        #ifdef NVS_14_DEBUG
            Serial.println(F("[FI] Datei ") + String(dateiGr14) + F(" wurde erstellt!"));
        #endif
        // Daten in die Datei schreiben
        file.print("0");
        // Schließen der Datei
        file.close();
        // erneut öffnen für lesen 
        file = SPIFFS.open(dateiGr14, "r");      
    }

    if (g1415Side != 0) { 
        #ifdef NVS_14_DEBUG
            //start_counter ++;
            //Serial.print(F("[FI] Lese Daten aus Datei Nr.14b ab Zeile ")); Serial.println(start_counter);   //start_counter = g14Filewrite;
            //start_counter --;
            //Serial.print(F("Aufzeichnungen "));Serial.print(g1415_Sum_Counter);Serial.print(F(" | g1415_full "));Serial.print(g1415_full);Serial.print(F(" | g1415Side "));Serial.println(g1415Side);  
        #endif
    } else {
        start_counter = 0;
        #ifdef NVS_14_DEBUG
            //Serial.print(F("[FI] Lese alle Daten aus Datei Nr.14b    Aufzeichnungen vorhanden: ")); Serial.println(g14Filewrite); 
            //Serial.print(F(" | g1415_full "));Serial.print(g1415_full);Serial.print(F(" | g1415Side "));Serial.println(g1415Side);  
        #endif
    }          

    while (file.available() && zeilenZaehler < maxZeilen) {
        data = file.readStringUntil('\n'); // Lesen bis Zeilenumbruch...

        // Jahr überprüfen und korrigieren
        //data = checkAndCorrectDate(data);

        if (data.length() > 0) { // Nur gültige Einträge hinzufügen
            zeilenZaehler++;
            t_zeilenZaehler++;
            tempstr += data;

            if (t_zeilenZaehler < 10) {
                tempstr += ";";
            }

            if (t_zeilenZaehler >= 10) {
                // Senden
                tempstr += "\r\n";
                pTxCharacteristic->setValue(tempstr.c_str());
                pTxCharacteristic->notify();
                //Serial.println(tempstr);
                size_t message_length = tempstr.length();
                sentTraffic += message_length;
                delay(20);
                t_zeilenZaehler = 0;
                tempstr = "";
            }
        }

        esp_task_wdt_reset();
    } 

    // Überprüfe, ob am Ende des Vorgangs noch Daten übrig sind
    if (t_zeilenZaehler > 0 && zeilenZaehler <= maxZeilen) {
        tempstr += "\r\n";
        pTxCharacteristic->setValue(tempstr.c_str());
        pTxCharacteristic->notify();
        //Serial.println(tempstr);
        t_zeilenZaehler = 0;
        size_t message_length = tempstr.length();
        sentTraffic += message_length;
    }

    file.close();

    // Ausgabe der Anzahl der Korrekturen
    Serial.print(F("Total corrections made: "));
    Serial.println(correctionCount);
}


//-----------------------------------------------------------------------------------------------------------------------------






#ifdef ea_webserver
const char index_html[] PROGMEM = R"rawliteral(
<!DOCTYPE html>
<html lang='de'>
<head>
  <title>Radon Tracer Home {device_id}</title>
  <link HREF='/favicon-16x16.png' REL='SHORTCUT ICON' title='LivAir | FreshBox AlphaTracer'>
  <meta charset='charset=iso-8859-1'>
  <meta name='copyright' content='Holger Gebauer'>
  <meta name='author' content='Holger Gebauer'>
  <style>

     selectr {
    font-size: .9rem;
    padding: 2px 5px;
  }    
       



  
  </style>

  </head>
  <body>

  <div id='selectr'>Radon</div><div id='selectr'> Tracer Home</div>

    %BUTTONPLACEHOLDER%


  <div class='myDiv'>
    <p><a href='/radon.xml' target='_blank'>API: XML</a></p>
  </div>

  <div class='myDiv'>
   <p><a href='/radon.html' target='_blank'>API: HTML</a></p>
  </div>


</body>
</html>
)rawliteral";

#endif

// Replaces placeholder with button section in your web page
String processor(const String& var){
  //Serial.println(var);
  if(var == "BUTTONPLACEHOLDER"){
    String buttons = "";
        buttons += "<div class='myDiv'><p>Sensor ID: " + String(device_id_c) + "  </p></div>";
        buttons += "<div class='myDiv'><p>Radon Live: " + String(rval3) + " Bq/m&sup3;</p></div>";

    return buttons;
  }
  return String();
}







// ThreadController that will controll all threads
//ThreadController controll = ThreadController();

//Thread* Thread_bt = new Thread();
//Thread* Thread_tb_task = new Thread();  // 1 Sec.
//Thread* Thread_2s = new Thread();
//Thread* Thread_30s = new Thread();
//Thread* Thread_tb_send = new Thread();  // 100sec. 
//Thread* Thread_1m = new Thread();


//Thread* Thread_mb3 = new Thread();
//Thread* Thread_mb4 = new Thread();


//Thread* Thread_tb_FW = new Thread();


//Thread* Thread_fail_FW = new Thread();

//Thread* Thread_45min = new Thread();

//Thread* Thread_clock = new Thread();









// callback 1 Sec.
void Callback_tb_task(){  
     
      //Serial.println(F("-----1sec-----" ));


      //-------------------------
     if(g_end_boot == true) {
        
        if(g_end_boot_time > 0){
          g_end_boot_time --;
        }

        if(g_end_boot_time == 0){
          g_sperre1 =  false;
          g_sperre2 =  false;
        }
        
      }
      //-------------------------


      //-------------------------
      if (knx_program_mode) {           
        
        //Serial.println("[IF] knx_program_mode");
          for(unsigned int i = 0; i < 8;i++){
            lc.setRow(0,i,0x00);
          }

          lc.setIntensity(15); //5=Standard   Helligkeit forne

          // Dezimalpunkt an der aktuellen Position setzen
          lc.setChar(0, positiondc, ' ', true);

          // Position aktualisieren
          positiondc += directiondc;
          if (positiondc == 3 || positiondc == 0) {
              directiondc = -directiondc; // Richtung umkehren
          }
      }
      //-------------------------
  


         if(cb_sensor_mb_time>0){cb_sensor_mb_time --;} 

         ms1_set = true;

         if(g_beacon_time > 0) {g_beacon_time --;}




          if (g_identify == true) {
              g_identify_byte++;
              if (g_identify_byte >= 4) {
                  g_identify_byte = 0;
              }

              // Zähler erhöhen und prüfen, ob 20 Sekunden vergangen sind
              identifyCounter++;
              if (identifyCounter >= 20) {
                  g_identify = false;
                  g_u_identify_soll = 0;
                  g_u_identify_ist = 0;
                  g_identify_byte = 0;
                  identifyCounter = 0; // Zähler zurücksetzen
                  TB_DEBUG_MAX_PRINTLN(F("g_identify wurde nach 20 Sekunden auf false gesetzt."));

                  g_t_led_change = true; 
              }
          } else {
              identifyCounter = 0; // Zähler zurücksetzen, wenn g_identify false ist
          }

         

  
        tb_task = true;
        g_requestedShared_sq = true;
        

       //-----------------------------------------
        if(g_u_clock_ist != 3 && g_LEDT_T_KNX == 0){ // nicht Monat und Tag
          if(g_u_clock_ist != 0 && clock_start == true && gFW_Update_start == 0 && g_identify == false && akt_fw_load == false){    //1=24h   2=12h   3=Datum
            if(g_kalibrieren_ist == 0 && g_checken_ist == 0 && g_kal_write_ist == 0 && g_identify == false){


              tick2 = !tick2;
              if(g_switch_anzeige == 1){ 
                if(g_LEDT_F_ist == 1){ 
                lc.setChar(0,1,char(h_einer),false); //tick2  
                }
              } 

                //Serial.println(g_u_clock_ist);
                // -------   PWM   -------
                if(tick2 == false){
                  dutyCycle_t = 0;
                }else{
                  dutyCycle_t = dutyCycle_dp;
                }
                if(g_switch_anzeige == 1 && g_u_clock_ist != 3){ 
                  if(g_LEDT_F_ist == 1){ 
                  ledcWrite(ledChannel, dutyCycle_t); //dp            sperre_10Time3
                  }
                }else{
                  ledcWrite(ledChannel, 0); //dp
                }

                /*
                Serial.print(F("g_switch_anzeige: " ));Serial.println(g_switch_anzeige);
                Serial.print(F("g_LEDT_F_ist: " ));Serial.println(g_LEDT_F_ist);
                Serial.print(F("dutyCycle_t: " ));Serial.println(dutyCycle_t);
                Serial.print(F("g_u_clock_ist: ") );Serial.println(g_u_clock_ist);
                Serial.print(F("tick2: " ));Serial.println(tick2);
                */
                // -------   PWM   -------

            }
            if (g_identify == true) {
              ledcWrite(ledChannel, 0); //dp
            }
          } 
        }
      //-----------------------------------------




      // g_u_view_switch_ist  0=Radon  1= Uhr  2= Wechsel
      //-----------------------------------------
      if(g_LEDT_F_ist == 1 && g_LEDT_T_KNX == 0){ 

          // Wechselbasierte Logik
          if (currentSec % 10 < 5) {
              g_switch_anzeige = 1; // Sekunden 0-4, 10-14, 20-24, 30-34, 40-44, 50-54
          } else {
              g_switch_anzeige = 0; // Sekunden 5-9, 15-19, 25-29, 35-39, 45-49, 55-59
          }

          // vorladen   //  0=Radon  1= Uhr  2= Wechsel
          if(g_u_view_switch_ist == 0){ 
            g_switch_anzeige = 0;    //  0= Radon 
          }
          if(g_u_view_switch_ist == 1){ 
            g_switch_anzeige = 1;    //  1= Time 
          }

      } // g_LEDT_F_ist == 0
      //-----------------------------------------



     Segment_task = true;


    Segment_no_sensor = true;
     
     if(wait_bot_time < 90){
        wait_bot_time ++;
     }


     if(time_view_fw > 0){
        time_view_fw --;
        g_view_fw = true;
     }else{
        g_view_fw = false;
     }



     if(g_time_set_kal_val > 0){
        g_time_set_kal_val --;
     }

     if(g_time_set_check_val > 0){
        g_time_set_check_val --;
     }

     time_update = true;  
     //Serial.println(F("time_update = true")); 



}
//---------------------- 1 sec. --------------------------------------------------

 
 
 
 
 
    //-------------------------------------------------------
    // callback 1h
    void Callback_tb_FW(){

    tb_shared_update = true;

    tb_FW_update = true;

    g_set_esp_clock = true;  // RTC stellen
    
        
     hourCounter++;
     Preferences preferences;
     preferences.begin("eenvs", false);                         //Ordner eenvs anlegen/verwenden       
     bool restartBit_set = preferences.getBool("restart_bit", false); 
        if (hourCounter >= 24 && restartBit_set == true) {
            preferences.putBool("restart_bit", false);
            hourCounter = 0;
        }
      preferences.end();  






    }
    //-------------------------------------------------------






    //-------------------------------------------------------
    // callback 45min
    void Callback_tb_shared(){

    
    //tb_shared_update = true;


    
        

    }
    //-------------------------------------------------------





    // callback 2h.
    void Callback_fail_FW(){

      if(g_fw_dl_fail == true){
      
        Preferences preferences;
        preferences.begin("eenvs", false);                         //Ordner eenvs anlegen/verwenden       
        g_boot_fail = 1;
        preferences.putUChar("boot_g_fail", g_boot_fail);    // 
        preferences.end();

        Serial.println(F("Done, Reboot now"));
        delay(2000);
        esp_restart();

      }   

    }






// callback 10min.
void Callback_tb_send(){
	//Serial.print("1sec...: ");
    //Serial.println(millis());
    
    //tb_upload = true;   //nur zum testen
    //g_radon_new_tb = true; //nur zum testen

  if(gFW_Update_start != 1){  
    uhrzeit_update = true;
    epoch_task = true;
  }

}





// callback 1 min.
void Callback_1m(){
	
  //Serial.print("2min...: ");
    //Serial.println(millis());
   
  g_Server_ID_mismatch = 0;

  //write_to_file = true;


  Preferences preferences;
  preferences.begin("eenvs", false);                         //Ordner eenvs anlegen/verwenden       
  epochTime_save = epochTime_esp;
  preferences.putLong("epoch_save", epochTime_save);



  // Größe des größten freien Speicherblocks
  size_t largestFreeBlock = xPortGetFreeHeapSize();

  g_time_s = true;

  // Differenz berechnen
  usedHeapSize = totalHeapSize - largestFreeBlock;

  // Speicherblockgröße in einen String umwandeln
  char buffer[20];
  snprintf(buffer, sizeof(buffer), "%zu", largestFreeBlock);
  tb.sendTelemetryData("HEAP", buffer);



  float totalRAM = ESP.getHeapSize() / (1024.0 * 1024.0);
  float usedRAMb = (ESP.getHeapSize() - ESP.getFreeHeap()) / (1024.0 * 1024.0);
  float usedPercentageRAM = (usedRAMb * 100) / totalRAM;

  String formattedRAM = String(usedPercentageRAM, 2); // Formatierung auf 2 Dezimalstellen
  tb.sendTelemetryData("RAM_Prozent", formattedRAM.toFloat()); // Umwandlung zurück in float

  //Serial.print(F("[IF] RAM_Prozent: "));
  //Serial.println(formattedRAM); // Debug-Ausgabe



  // Differenz in einen String umwandeln
  char diffBuffer[20];
  snprintf(diffBuffer, sizeof(diffBuffer), "%zu", usedHeapSize);
  tb.sendTelemetryData("USED_HEAP", diffBuffer);

  //float usedRAM = (ESP.getHeapSize() - ESP.getFreeHeap()) / (1024.0 * 1024.0);
  uint32_t usedRAM = (ESP.getHeapSize() - ESP.getFreeHeap());
  uint32_t freeRAM2 = ESP.getFreeHeap();
  freeRAM_s = freeRAM2;
  tb.sendTelemetryData("USED_RAM", usedRAM);
  tb.sendTelemetryData("FREE_RAM", freeRAM2);


  
   //ntp_min_akualisieren = true;



}







//-------------------------------------------------------------------
// callback 30 sec.
void Callback_30s(){


 

      if (g_end_boot == false) {
        if (WiFi.status() == WL_CONNECTED) {
          
          if (Internt_online == false){
            if (Ping.ping(hostping2)) {
               Internt_online = true;
            }else{
              Internt_online = false;
              g_end_boot = true;  // damit webserver geht
            }
          }

        }
      }



  
 
   const wl_status_t status = WiFi.status();
   WiFi_status = status;

   currentStatus = status;
   cachedWiFiStatus = status;

   currentWiFiStatus = (cachedWiFiStatus == WL_CONNECTED);


    if (WiFi_status == WL_CONNECTED) {
      
      //Serial.println("[IF] WiFi CONNECTED");

      
    }else{

      //Serial.println("[IF] WiFi not CONNECTED");
  
      //Serial.print("[IF] WiFi_status: ");Serial.println(WiFi_status);
        /*
        switch (WiFi_status) {
          case WL_IDLE_STATUS:
            Serial.println("[IF] WiFi WL_IDLE_STATUS");
            break;
          case WL_NO_SSID_AVAIL:
            Serial.println("[IF] WiFi WL_NO_SSID_AVAIL");
            break;
          case WL_SCAN_COMPLETED:
            Serial.println("[IF] WiFi WL_SCAN_COMPLETED");
            break;
          case WL_CONNECTED:
            Serial.println("[IF] WiFi WL_CONNECTED");
            break;
          case WL_CONNECT_FAILED:
            Serial.println("[IF] WiFi WL_CONNECT_FAILED");
            break;
          case WL_CONNECTION_LOST:
            Serial.println("[IF] WiFi WL_CONNECTION_LOST");
            break;
          case WL_DISCONNECTED:
            Serial.println("[IF] WiFi WL_DISCONNECTED");
            break;
          default:
            break; // Wird nicht benötigt, wenn Statement(s) vorhanden sind
        }
       */

    }
  

  //  WL_IDLE_STATUS	0
  //  WL_NO_SSID_AVAIL	1
  //  WL_SCAN_COMPLETED	2
  //  WL_CONNECTED	3
  //  WL_CONNECT_FAILED	4
  //  WL_CONNECTION_LOST	5
  //  WL_DISCONNECTED	6


//---------------------------------------------------------

	//Serial.print("clock...: ");
  
     // printLocalTime();

  


//********************************************************  No keys that we subscribed too were changed        Lesen Shared beim Booten
          /*
           if (WiFi_status == WL_CONNECTED && TB_status == true) {
                   
                   Serial.println("[IF] Send shared time attributes...");
                 
                    u_TIME_TB_key_send = currentSec;
          
                    const int attribute_items_32 = 1;
                    Attribute attributes26[attribute_items_32] = {
                      { U_TIME_TB_KEY,  u_TIME_TB_key_send }, 
                    };
     
                 
                   tb.sendAttributes(attributes26, 1);

                   
                   
                      Serial.println("[IF] Requesting shared time attributes...");
                      const int myArraySize = sizeof(REQUESTED_SHARED_ATTRIBUTESt)/sizeof(REQUESTED_SHARED_ATTRIBUTESt[0]);
                      Serial.print("[IF] | ");
                      for (int i = 0; i < myArraySize;i++) 
                      { 
                        Serial.print(REQUESTED_SHARED_ATTRIBUTESt[i]);
                        Serial.print(" | ");
                      }
                      Serial.println(F(" "));

                      requestedSharedt = tb.Shared_Attributes_Request(sharedCallbackt);
                      requestedSharedt_fail = false;
                      if (!requestedSharedt) {

                        Serial.println("[IF] Failed to request time shared attributes");
                        requestedSharedt = true;
                        requestedSharedt_fail = true;


                      }
            }
            */
//********************************************************


}
//-------------------------------------------------------------------






 #ifdef BLEbeacon_new

      #define GPIO_DEEP_SLEEP_DURATION     10  // sleep x seconds and then wake up

      //RTC_DATA_ATTR static time_t last;        // remember last boot in RTC Memory

      RTC_DATA_ATTR static uint32_t bootcount; // remember number of boots in RTC Memory


      // See the following for generating UUIDs:

      // https://www.uuidgenerator.net/

      //BLEAdvertising *pAdvertising;   // BLE Advertisement type

      //struct timeval now;


      //#define BEACON_UUID "87b99b2c-90fd-11e9-bc42-526af7764f64" // UUID 1 128-Bit (may use linux tool uuidgen or random numbers via https://www.uuidgenerator.net/)

       /*
      class MyAdvertisedDeviceCallbacks: public BLEAdvertisedDeviceCallbacks {
          void onResult(BLEAdvertisedDevice advertisedDevice) {
              Serial.printf("Advertised Device: %s \n", advertisedDevice.toString().c_str());
              ble_rssi = advertisedDevice.getRSSI();
              Serial.printf("RSSI: %d \n", ble_rssi);
              esp_task_wdt_reset();
              // Hier kannst du den RSSI-Wert weiterverarbeiten oder speichern
          }
      };
       */



        class MyAdvertisedDeviceCallbacks: public BLEAdvertisedDeviceCallbacks {
            void onResult(BLEAdvertisedDevice advertisedDevice) {
                int currentRssi = advertisedDevice.getRSSI();
                rssiSum += currentRssi;
                rssiCount++;
                ble_rssi = rssiSum / rssiCount; // Berechnung des Mittelwerts

                // Aktualisiere den besten und schlechtesten RSSI-Wert
                if (currentRssi > bestRssi) {
                    bestRssi = currentRssi;
                }
                if (currentRssi < worstRssi) {
                    worstRssi = currentRssi;
                }

                if (advertisedDevice.haveName() && advertisedDevice.getName().length() > 0) {
                    String deviceName = advertisedDevice.getName().c_str();
                    std::string deviceNameStd = std::string(deviceName.c_str());
                    //Serial.printf("Stored Device: Name: %s, RSSI: %d\n", deviceName.c_str(), currentRssi);

                    // Füge Geräte zur Radon-Liste hinzu
                    if (deviceName.indexOf("Radon") != -1 && radonDeviceCount < MAX_DEVICES) {
                        radonDevices[radonDeviceCount++] = deviceName;
                        BT_DEBUG_MAX_PRINTF("Stored Radon Device: Name: %s, RSSI: %d\n", deviceName.c_str(), currentRssi);
                    } else if (namedDeviceCount < MAX_DEVICES) {
                        // Füge Geräte zur Named-Device-Liste hinzu, außer "Radon"-Geräte
                        if (deviceNameStd.find("Radon") == std::string::npos) {
                            namedDevices[namedDeviceCount++] = deviceName;
                            BT_DEBUG_MAX_PRINTF("Stored Div. Device: Name: %s, RSSI: %d\n", deviceName.c_str(), currentRssi);
                        }
                    }

                }

                esp_task_wdt_reset(); // Watchdog-Timer zurücksetzen
                WTD_tick = !WTD_tick; digitalWrite(WTD_toggle, WTD_tick);
            }
        };






      void startBLEScan() {
          radonDeviceCount = 0;
          namedDeviceCount = 0;   
          esp_task_wdt_reset();
          BLEScan* pBLEScan = BLEDevice::getScan();
          pBLEScan->setAdvertisedDeviceCallbacks(new MyAdvertisedDeviceCallbacks());
          pBLEScan->setActiveScan(true);
          esp_task_wdt_reset();
          pBLEScan->start(10, false); 
          bleScanActive = true;
          scanStartTime = millis();  // Speichere die Startzeit des Scans
          BT_DEBUG_MAX_PRINT(F("BLE-Scan gestartet."));
          set_bit_wait_front_view = false;
      }

      void stopBLEScan() {
          BLEScan* pBLEScan = BLEDevice::getScan();
          pBLEScan->stop();
          bleScanActive = false;
          BT_DEBUG_MAX_PRINT(F("BLE-Scan gestoppt."));
      }








    //--------------------------------------------
 
    //--------------------------------------------
    #endif






void debugLog(const __FlashStringHelper* message) {
    Serial.println(message);
}










  // mb_response_size_rtu = mb_response_size_rtu + MM_data.size();
  //  Serial.println(String(mb_response_size_rtu));
  //Serial.println(mb_response_size_rtu);

// testOutput:  takes the test function name called, the test case name and expected and recieved messages,
// compares both and prints out the result.
// If the test passed, true is returned - else false.

uint8_t bb;
bool testOutput( ModbusMessage expected, ModbusMessage received) {
  
  //Serial.println("------testOutput------");
  testsExecuted++;
  count_in = 0;
  count_out = 0;
  mb_Acknowledge = false;
  
   //if (expected == received) { }
  
   //Serial.print("   Expected:");
  for (auto& b : expected) {
    //Serial.printf(" %02X", b);
    bb = b;
    count_out ++;
  }

  if (expected.size() == 1) {
    //ModbusError me((Error)expected[0]);
    //Modbus::Error me((Modbus::Error)expected[0]);
    //Serial.printf(" %s", (const char *)me);
  }
  
   //Serial.println();
   //Serial.print("   Received:");
  for (auto& b : received) {
   // Serial.printf(" %02X", b);
    bb = b;
    count_in ++;
  }

  // Serial.println("received.size() " + received.size());
  
  received_size = received_size + received.size();
 // s_received_size = String(received_size);
  

  if (expected == received || received.size() == 1 || count_out == count_in) {  
    //ModbusError me((Error)received[0]);
    Modbus::Error me((Modbus::Error)received[0]);
   // Serial.printf(" %s", (const char *)me);
    mb_Acknowledge = true;
    mb_Acknowledge_s = (const char *)me;
  }
 
  return false;
}

bool tick = false;             // Counting nibbles


//-----------------------------------------------------------------
// Helper function to convert hexadecimal ([0-9A-F]) digits in a char array into a vector of bytes

ModbusMessage makeVector(const char *text) {
 
 //Serial.println("------makeVector------");
 
  ModbusMessage rv;            // The vector to be returned
  uint8_t byte = 0;
  uint8_t nibble = 0;
  bool tick = false;             // Counting nibbles
  bool useIt = false;            // true, if a hex digit was read
  const char *cp = text;
  //Serial.println("-------makeVector-------");
  // Loop the char array
  while (*cp) {
    // Is it a decimal digit?
    if ((*cp >= '0' && *cp <= '9')) {
      // Yes. Convert it to a number 0-9
      nibble = (*cp - '0');
      // Flag to use the digit
      useIt = true;
    // No decimal, but a hex digit A-F?
    } else if (*cp >= 'A' && *cp <= 'F') {
      // Yes. Convert it to a number 10-15
      nibble = (*cp - 'A' + 10);
      // Flag to use the digit
      useIt = true;
    // No hexadecimal digit, ignore it.
    } else {
      useIt = false;
    }
    // Shall we use the digit?
    if (useIt) {
      // Yes. Move the previous 4 bits up
      byte <<= 4;
      // add in the digit
      byte |= nibble;
      // Are we at the second nibble of a byte?
      if (tick) {
        // Yes. put the byte into the vector and clear it to be re-used.
        rv.push_back(byte);
        byte = 0;
      }
      // Count up used nibbles
      tick = !tick;
    }
    cp++;
  }
  return rv;
}

//-----------------------------------------------------------------


//  void webSocketEvent(    sendData()    const char sensor_html_template[]   handle_sensor()
//-----------------------------------------------------------------
void onBrowserClosed(uint8_t num) {
    Serial.printf("User %u hat den Browser geschlossen.\n", num);
    user_on_webside = false;
    // Füge hier Logik hinzu, die beim Schließen des Browsers ausgeführt werden soll
}


void webSocketEvent(uint8_t num, WStype_t type, uint8_t * payload, size_t length) {
    switch (type) {
        case WStype_DISCONNECTED:
            Serial.printf("[%u] Disconnected!\n", num);
            break;
        case WStype_CONNECTED: {
            DynamicJsonDocument json(1024);
            String jsonString;

            IPAddress ip = webSocket.remoteIP(num);
            Serial.printf("[%u] Connected from %d.%d.%d.%d\n", num, ip[0], ip[1], ip[2], ip[3]);
            user_on_webside = true;
            
            if (isUserOnSensorPage) {
              String statusMessage = String(wifiSStatus) + ";" + String(ntpStatus) + ";" +
                                     String(unitDEStatus) + ";" + String(unitENStatus) + ";" +
                                     String(amStatus) + ";" + String(pmStatus);
              webSocket.sendTXT(num, "status:" + statusMessage);
              webSocket.sendTXT(num, "imageStatus:" + String(imageStatus));
              webSocket.sendTXT(num, "dpStatus:" + String(dpStatus));
            }

            if (g_LEDT_T_KNX == 1 && isUserOnKNXPage) {
                String knxData = "knx:" + String(area) + "/" + String(line) + "/" + String(device);
                webSocket.sendTXT(num, knxData);
            }

            if (isBleOnSensorPage) {
                json.clear();
                json["type"] = "status";
                json["bleStatus"]["rssi"] = ble_rssi;
                json["bleStatus"]["connectedUsers"] = connected_users;
                json["bleStatus"]["signalPercentage"] = map(ble_rssi, -100, -40, 0, 100);
                json["bleStatus"]["bestRssi"] = bestRssi; 
                json["bleStatus"]["worstRssi"] = worstRssi;
                json["bleStatus"]["receivedTraffic"] = receivedTraffic; 
                json["bleStatus"]["sentTraffic"] = sentTraffic;

                serializeJson(json, jsonString);
                webSocket.sendTXT(num, jsonString);
            }
        }
        break;
        case WStype_TEXT:
            //Serial.printf("[%u] Text received: %s\n", num, (char *)payload);
            if (String((char *)payload) == "browser_closed") {
                onBrowserClosed(num);
            } else if (isUserOnModbusPage) {
                Serial.printf("[%u] Text on Modbus Page: %s\n", num, payload);
            } else if (isUserOnKNXPage) {
                Serial.printf("[%u] Text on KNX Page: %s\n", num, payload);
                String payloadString = String((char *)payload);

                if (payloadString.startsWith("knx:")) {
                    payloadString.replace("knx:", "");
                    int area = payloadString.substring(0, payloadString.indexOf("/")).toInt();
                    payloadString = payloadString.substring(payloadString.indexOf("/") + 1);
                    int line = payloadString.substring(0, payloadString.indexOf("/")).toInt();
                    int device = payloadString.substring(payloadString.indexOf("/") + 1).toInt();
                    displayKNXAddress(area, line, device);
                }

                if (digitalRead(20)) {
                    webSocket.sendTXT(num, "imageStatus:0"); // Rot
                } else {
                    webSocket.sendTXT(num, "imageStatus:4"); // grau
                }
            } else if (isUserOnSensorPage) {
                //Serial.printf("[%u] Text on Sensor Page: %s\n", num, payload);

                String timeData = String(currenthour) + ":" + String(v_currentmin) + ":" + String(v_currentSec);
                webSocket.sendTXT(num, "time:" + timeData);

                String statusMessage = String(wifiSStatus) + ";" + String(ntpStatus) + ";" +
                                       String(unitDEStatus) + ";" + String(unitENStatus) + ";" +
                                       String(amStatus) + ";" + String(pmStatus);
                webSocket.sendTXT(num, "status:" + statusMessage);

                webSocket.sendTXT(num, "imageStatus:" + String(imageStatus));
                webSocket.sendTXT(num, "dpStatus:" + String(dpStatus));
            } else {
                //Serial.printf("[%u] Text received but not on relevant Page: %s\n", num, payload);
            }
            break;
        case WStype_BIN:
            Serial.printf("[%u] Binary data received\n", num);
            break;
        case WStype_ERROR:
            Serial.printf("[%u] Error occurred\n", num);
            break;
        case WStype_FRAGMENT_TEXT_START:
            Serial.printf("[%u] Text fragment start\n", num);
            break;
        case WStype_FRAGMENT_BIN_START:
            Serial.printf("[%u] Binary fragment start\n", num);
            break;
        case WStype_FRAGMENT:
            Serial.printf("[%u] Fragment\n", num);
            break;
        case WStype_FRAGMENT_FIN:
            Serial.printf("[%u] Fragment end\n", num);
            break;
        case WStype_PING:
            //Serial.printf("[%u] Ping\n", num);
            break;
        case WStype_PONG:
            //Serial.printf("[%u] Pong\n", num);
            break;
        default:
            Serial.printf("[%u] Unknown event type: %d\n", num, type);
            break;
    }
}




//-----------------------------------------------------------------



void removeLeadingZeros(char* input, char* output, size_t size) {
    int startIndex = 0;
    while (startIndex < size && input[startIndex] == '0') {
        startIndex++;
    }

    // Kopiere den Rest des Arrays ohne führende Nullen
    strncpy(output, &input[startIndex], size - startIndex);
    output[size - startIndex] = '\0'; // Null-terminate the string
}





  //******************************************************************************
  //                        ModbusMessage für FC4                                *
  //******************************************************************************
  // Error errd = MB.addRequest(1, mb_client_id, READ_INPUT_REGISTER, 0, 6);
  // Error errd2 = MB.addRequest(1, mb_client_id, READ_HOLD_REGISTER, 20, 8);

  void handleData(ModbusMessage response, uint32_t token) 
  {
    //Serial.println("-------------------------------------");

    //esp_task_wdt_reset(); 

    // WebSocket-Nachricht senden, um die LED aufleuchten zu lassen
    //webSocket.broadcastTXT("ledOn");
    

    
    i_loop = 0;
    mb_byte_size = response.size();

    for (auto& byte : response) {
      mb_arry_byte[i_loop] = byte;
      //Serial.printf("%02X ", byte);
      //Serial.println(mb_arry_byte[i_loop]);
      i_loop ++;
    }

    #ifdef MB_DETAIL_DEBUG
    int responseSize = response.size(); // Angenommen, response ist ein Objekt mit der Methode size()
    #endif
    MB_DETAIL_DEBUG_PRINTF("response.size() %d\n", responseSize);
    
    response_size = response_size + response.size();

    response_ServerID =  response.getServerID();

    //Serial.println("------------");
    // alle bytes im Array
   // for (byte i = 0; i < mb_byte_size; i = i + 1) {
     // Serial.println(mb_arry_byte[i]);
     // Serial.printf(" ", mb_arry_byte[i]);
    //} 
  
    
    //Serial.println("------------");
    // nur daten
    mb_byte_resault = mb_byte_size - mb_byte_header;
    mb_byte_header_t = mb_byte_header - 1;
    //for (byte i = mb_byte_header_t; i < mb_byte_size; i = i + 1) {
    // Serial.println(mb_arry_byte[i]);
      //Serial.printf("%02X ", mb_arry_byte[i]);
    // } 
    //Serial.println("");
    
      responsegetFunctionCode = response.getFunctionCode();
    

      MB_DETAIL_DEBUG_PRINT("[MB] responsegetFunctionCode: ");
      MB_DETAIL_DEBUG_PRINTLN(String(responsegetFunctionCode).c_str());
      MB_DETAIL_DEBUG_PRINT("[MB] response.size: ");
      MB_DETAIL_DEBUG_PRINTLN(String(mb_byte_size).c_str());
      MB_DETAIL_DEBUG_PRINT("[MB] response.ServerID: ");
      MB_DETAIL_DEBUG_PRINTLN(String(response_ServerID).c_str());
      MB_DETAIL_DEBUG_PRINTLN("-------------------");
      MB_DETAIL_DEBUG_PRINTLN(" ");
      esp_task_wdt_reset(); // Watchdog-Timer zurücksetzen




    //if (response.getFunctionCode() == 4 || response.getServerID() == 2 || response.size() == 15){
    if (response.getFunctionCode() == 4 && mb_byte_size == 13){  
      //if (response.getFunctionCode() == 4 ){  

      // 0 = 3,4
      // 1 = 5,6     

      // 2 = 7,8

      // 3 = 9,10
      // 4 = 11,12

      // 5 = 13,14

      // 6 = 15,16
      // 7 = 17,18
      // 8 = 19,20
      // 9 = 21,22
      // 10 = 23,24
      // 11 = 25,26

           /*
           mb_Seriennummer_char[0] = (char)mb_arry_byte[3];
           mb_Seriennummer_char[1] = (char)mb_arry_byte[4];
           mb_Seriennummer_char[2] = (char)mb_arry_byte[5];
           mb_Seriennummer_char[3] = (char)mb_arry_byte[6];
           mb_Seriennummer_char[4] = (char)mb_arry_byte[7];
           mb_Seriennummer_char[5] = (char)mb_arry_byte[8];
           mb_Seriennummer_char[6] = (char)mb_arry_byte[9];
           mb_Seriennummer_char[7] = (char)mb_arry_byte[10];
           mb_Seriennummer_char[8] = (char)mb_arry_byte[11];
           mb_Seriennummer_char[9] = (char)mb_arry_byte[12];
           mb_Seriennummer_char[10] = '\0'; // Null-terminate the string
           */

            // Kopiere den Inhalt von mb_Seriennummer_char nach mb_Seriennummer
            //strncpy(mb_Seriennummer, mb_Seriennummer_char, sizeof(mb_Seriennummer) - 1);
            //mb_Seriennummer[sizeof(mb_Seriennummer) - 1] = '\0'; // Sicherstellen, dass es null-terminiert ist

            // Entferne führende Nullen
            int j = 0; // Index für mb_Seriennummer
            bool leadingZero = true; // Flag um führende Nullen zu verfolgen

            // Aktualisiere das char Array mit den neuen Werten
            for (int i = 3; i <= 12; ++i) {
                char currentChar = (char)mb_arry_byte[i];
                if (leadingZero && currentChar == '0') {
                    continue; // Führende Nullen überspringen
                }
                leadingZero = false;
                mb_Seriennummer[j++] = currentChar;
            }

            mb_Seriennummer[j] = '\0'; // Null-terminate the string

             /*
            int startIndex = 0;
            while (startIndex < mb_Seriennummer.length() && mb_Seriennummer.charAt(startIndex) == '0') {
                startIndex++;
            }
            String seriennummerOhneNullen = mb_Seriennummer.substring(startIndex);
            
            // Überprüfe, ob der String leer ist, und setze ihn auf "0", wenn er leer ist
            if (seriennummerOhneNullen.length() == 0) {
                seriennummerOhneNullen = "0";
            }
            
            // Übertrage das Ergebnis in mb_Seriennummer
            mb_Seriennummer = seriennummerOhneNullen;
            */


          MB_DETAIL_DEBUG_PRINT(F("[MB] Seriennummer "));
          MB_DETAIL_DEBUG_PRINTLN(mb_Seriennummer);




 
          MB_DETAIL_DEBUG_PRINTLN(F("-->  Sensor Seriennummer Daten aktualisiert"));



    }   //(response.getFunctionCode() == 4 || response.getServerID() == 2 || response.size() == 15){
    //--------------------------------------------------------------------------------------------------



    //--------------------------------------------------------------------------------------------------
      if (response.getFunctionCode() == 3 && mb_byte_size == 5 && cb_g_mb_read_radon == false){  
           
           if(mb_read_byte == 9){
              #ifdef MB_DETAIL_DEBUG
                MB_DETAIL_DEBUG_PRINTLN(F("PW lesen aus Sensor"));

                uint16_t temp_mb;
                temp_mb = word(mb_arry_byte[3], mb_arry_byte[4]);

                MB_DETAIL_DEBUG_PRINT(F("--> PW: "));
                MB_DETAIL_DEBUG_PRINTLN(temp_mb);

              #endif 
           }
         
           if(mb_read_byte == 1){

                MB_DETAIL_DEBUG_PRINTLN(F("Reset lesen aus Sensor"));

                uint16_t temp_mb;
                temp_mb = word(mb_arry_byte[3], mb_arry_byte[4]);
                mb_sreset = temp_mb;

                MB_DETAIL_DEBUG_PRINT(F("--> Sensor Reset: "));
                MB_DETAIL_DEBUG_PRINTLN(mb_sreset);
 

                String tempstr = "\r\n" ; 
                //tempstr += "Sensor Reset: "; 
                //tempstr += String(mb_sreset);
                //tempstr += "\r\n" ;

                tempstr = "Sensor Reset\t\t| G52: "; tempstr += String(mb_sreset); tempstr += "\r"; 

                pTxCharacteristic->setValue(tempstr.c_str());
                pTxCharacteristic->notify();
                size_t message_length = strlen(tempstr.c_str());
                sentTraffic += message_length; 

           }

           mb_read_byte = 99;


      }
    //--------------------------------------------------------------------------------------------------



    //--------------------------------------------------------------------------------------------------
      if (response.getFunctionCode() == 6 && mb_byte_size == 6){  
            #ifdef MB_KAL_DEBUG
              MB_KAL_DEBUG_PRINTLN(F("[MB] PW schreiben in Sensor"));

              uint16_t temp_mb;
              temp_mb = word(mb_arry_byte[3], mb_arry_byte[4]);

              MB_KAL_DEBUG_PRINT(F("[IF]: "));
              MB_KAL_DEBUG_PRINTLN(temp_mb);

            #endif 
            g_start_kalibireung = 5;  



      }
    //--------------------------------------------------------------------------------------------------




    //--------------------------------------------------------------------------------------------------
      if (response.getFunctionCode() == 3 && mb_byte_size == 11){  
           
           
            MB_KAL_DEBUG_PRINTLN(F("[MB] Zeit lesen aus Sensor"));


                //dutyCycle = 0;
                ledcWrite(ledChannel, 0); //dp

            mb_min = word(mb_arry_byte[3], mb_arry_byte[4]);
            mb_hour = word(mb_arry_byte[5], mb_arry_byte[6]);
            mb_day = word(mb_arry_byte[7], mb_arry_byte[8]);
            mb_month = word(mb_arry_byte[9], mb_arry_byte[10]);
           
            #ifdef MB_KAL_DEBUG
              MB_KAL_DEBUG_PRINT(F("-->    min: "));
              MB_KAL_DEBUG_PRINTLN(mb_min);
              MB_KAL_DEBUG_PRINT(F("-->   hour: "));
              MB_KAL_DEBUG_PRINTLN(mb_hour);
              MB_KAL_DEBUG_PRINT(F("-->    day: "));
              MB_KAL_DEBUG_PRINTLN(mb_day);
              MB_KAL_DEBUG_PRINT(F("-->  month: "));
              MB_KAL_DEBUG_PRINTLN(mb_month);

            #endif 
            // hour+2 *117 /_day 

            mb_ist_pwd = mb_hour + 2;
            mb_ist_pwd = mb_ist_pwd * 117;
            mb_ist_pwd = mb_ist_pwd / mb_day;

            #ifdef MB_KAL_DEBUG
              MB_KAL_DEBUG_PRINT(F("[MB] PW Generiert: "));
              MB_KAL_DEBUG_PRINTLN(mb_ist_pwd);

            #endif 


            g_start_kalibireung = 3;


      }
    //--------------------------------------------------------------------------------------------------




    //--------------------------------------------------------------------------------------------------
      if (response.getFunctionCode() == 3 && mb_byte_size == 15){  
          
            #ifdef MB_KAL_DEBUG
              MB_KAL_DEBUG_PRINTLN(F("[MB] Stufen lesen aus Sensor"));
            #endif 


            mb_cal20 = word(mb_arry_byte[3], mb_arry_byte[4]);     // Impulse
            mb_cal21 = word(mb_arry_byte[5], mb_arry_byte[6]);     // Loopradonauto
            mb_cal22 = word(mb_arry_byte[7], mb_arry_byte[8]);     // Reverscount
            mb_cal23 = word(mb_arry_byte[9], mb_arry_byte[10]);    // Stufen_anpassung
          
            mb_cal24 = word(mb_arry_byte[11], mb_arry_byte[12]);     //   Impulse mit  Abzug 6*10min       impuls36      
            mb_cal25 = word(mb_arry_byte[13], mb_arry_byte[14]);    //   Impulse ohne Abzug 6*10min        G09   // Impuls_graph


            #ifdef MB_KAL_DEBUG
              MB_KAL_DEBUG_PRINT(F("--> Impulse             : "));
              MB_KAL_DEBUG_PRINTLN(mb_cal20);
              MB_KAL_DEBUG_PRINT(F("--> Loopradonauto       : "));
              MB_KAL_DEBUG_PRINTLN(mb_cal21);
              MB_KAL_DEBUG_PRINT(F("--> Reverscount         : "));
              MB_KAL_DEBUG_PRINTLN(mb_cal22);
              MB_KAL_DEBUG_PRINT(F("--> Stufen_anpassung    : "));
              MB_KAL_DEBUG_PRINTLN(mb_cal23);

              MB_KAL_DEBUG_PRINT(F("--> Imp m Abz. G36  : "));
              MB_KAL_DEBUG_PRINTLN(mb_cal24);       // impuls36 imp*3 * kal = Radon 58*(90/10)=522
              MB_KAL_DEBUG_PRINT(F("--> Imp o Abz. G09       : "));
              MB_KAL_DEBUG_PRINTLN(mb_cal25);       // G09
            #endif 

            if(g_bt_start_conn == true){
            tempstr = "Newstart\t|    : "; tempstr += String(mb_cal20); tempstr += "\r";    //    
            pTxCharacteristic->setValue(tempstr.c_str());
            pTxCharacteristic->notify();
            size_t message_length = strlen(tempstr.c_str());
            sentTraffic += message_length; 
            //-----
            tempstr = "Loopradonauto\t|    : "; tempstr += String(mb_cal21); tempstr += "\r";    //    
            pTxCharacteristic->setValue(tempstr.c_str());
            pTxCharacteristic->notify();
            message_length = strlen(tempstr.c_str());
            sentTraffic += message_length; 
            //-----
            tempstr = "Reverscount\t|    : "; tempstr += String(mb_cal22); tempstr += "\r";    //    
            pTxCharacteristic->setValue(tempstr.c_str());
            pTxCharacteristic->notify();
            message_length = strlen(tempstr.c_str());
            sentTraffic += message_length; 
            //-----
            tempstr = "Stufen_anpassung\t|    : "; tempstr += String(mb_cal23); tempstr += "\r";    //    
            pTxCharacteristic->setValue(tempstr.c_str());
            pTxCharacteristic->notify();
            message_length = strlen(tempstr.c_str());
            sentTraffic += message_length; 
            //-----
            tempstr = "Impulse mit Abzug\t| G36: "; tempstr += String(mb_cal24); tempstr += "\r";    //    impuls36
            pTxCharacteristic->setValue(tempstr.c_str());
            pTxCharacteristic->notify();
            message_length = strlen(tempstr.c_str());
            sentTraffic += message_length; 
            //-----
            tempstr = "Impulse mit Abzug\t| G09: "; tempstr += String(mb_cal25); tempstr += "\r";    //    G09
            pTxCharacteristic->setValue(tempstr.c_str());
            pTxCharacteristic->notify();
            message_length = strlen(tempstr.c_str());
            sentTraffic += message_length; 
            }


      }
    //--------------------------------------------------------------------------------------------------






    //--------------------------------------------------------------------------------------------------
      if (response.getFunctionCode() == 4 && mb_byte_size == 21){  
          
            #ifdef MB_KAL_DEBUG
              MB_KAL_DEBUG_PRINTLN(F("[MB] Kalibrierung lesen aus Sensor"));
            #endif 

            mb_cal01 = word(mb_arry_byte[3], mb_arry_byte[4]);     // Impuls_send            G12
            mb_cal02 = word(mb_arry_byte[5], mb_arry_byte[6]);     // Radon_kalibri_word     G00
            mb_cal03 = word(mb_arry_byte[7], mb_arry_byte[8]);     // Radon_count_max        G01
            mb_cal04 = word(mb_arry_byte[9], mb_arry_byte[10]);    // Wrdadc_vorgabe         G02

            mb_cal05 = word(mb_arry_byte[11], mb_arry_byte[12]);   // Count_long_ist_over(2)
            mb_cal06 = word(mb_arry_byte[13], mb_arry_byte[14]);   // Count_long_ist_over(1)
            Count_long_ist_over = mb_cal05 + mb_cal06;             // Counts ab start 

            mb_cal07 = word(mb_arry_byte[15], mb_arry_byte[16]);   // Glaettung_faktor_word   G18
            mb_cal08 = word(mb_arry_byte[17], mb_arry_byte[18]);   // Impuls_leerwert         G19

            mb_cal09 = word(mb_arry_byte[19], mb_arry_byte[20]);   //Impuls_leerwertu         G21

            #ifdef MB_KAL_DEBUG
            MB_KAL_DEBUG_PRINT(F("--> Impuls send : "));
            MB_KAL_DEBUG_PRINTLN(mb_cal01);
            MB_KAL_DEBUG_PRINT(F("--> kalibrierung: "));
            MB_KAL_DEBUG_PRINTLN(mb_cal02);
            MB_KAL_DEBUG_PRINT(F("--> count_max   : "));
            MB_KAL_DEBUG_PRINTLN(mb_cal03);
            MB_KAL_DEBUG_PRINT(F("--> Wrdadc      : "));
            MB_KAL_DEBUG_PRINTLN(mb_cal04);

            //MB_KAL_DEBUG_PRINT(F("--Count: "));
            //MB_KAL_DEBUG_PRINTLN(Count_long_ist_over);

            MB_KAL_DEBUG_PRINT(F("--> Glaettung   : "));
            MB_KAL_DEBUG_PRINTLN(mb_cal07);
            MB_KAL_DEBUG_PRINT(F("--> leerwert    : "));
            MB_KAL_DEBUG_PRINTLN(mb_cal08);
            MB_KAL_DEBUG_PRINT(F("--> leerwert u  : "));
            MB_KAL_DEBUG_PRINTLN(mb_cal09);
            #endif 


            g_start_kalibireung = 7;


      }
    //--------------------------------------------------------------------------------------------------



    //--------------------------------------------------------------------------------------------------
      if (response.getFunctionCode() == 4 && mb_byte_size == 15){  
          
            #ifdef MB_KAL_DEBUG
              MB_KAL_DEBUG_PRINTLN(F("[MB] Ist Kalibrierungswerte lesen aus Sensor"));
            #endif 

            mb_cal10 = word(mb_arry_byte[3], mb_arry_byte[4]);     //                                    G08
            mb_cal11 = word(mb_arry_byte[5], mb_arry_byte[6]);     
            Radon_live_value = mb_cal10 + mb_cal11;
            
            mb_cal12 = word(mb_arry_byte[7], mb_arry_byte[8]);     //   Impulse mit  Abzug 6*10min        G09   // impuls_graph     RCounts 
            mb_cal13 = word(mb_arry_byte[9], mb_arry_byte[10]);    //   Impulse ohne Abzug 6*10min        G12   // Impuls_o_abzug


            mb_cal14 = word(mb_arry_byte[11], mb_arry_byte[12]);   // Radon 12h
            mb_cal15 = word(mb_arry_byte[13], mb_arry_byte[14]);   // Radon 12h
            Radon_12h_ist = mb_cal14 + mb_cal15;                   // Radon 12h 


            #ifdef MB_KAL_DEBUG
              MB_KAL_DEBUG_PRINT(F("--> Radon live          : "));
              MB_KAL_DEBUG_PRINTLN(Radon_live_value);
              MB_KAL_DEBUG_PRINT(F("--> Imp m Abz. G09  G32 : "));
              MB_KAL_DEBUG_PRINTLN(mb_cal12); // RCounts G09 imp * kal = Radon 58*(90/10)=522
              MB_KAL_DEBUG_PRINT(F("--> Imp o Abz. G12  G33 : "));
              MB_KAL_DEBUG_PRINTLN(mb_cal13); // G12
              MB_KAL_DEBUG_PRINT(F("--> Radon 12 h          : "));
              MB_KAL_DEBUG_PRINTLN(Radon_12h_ist);

            #endif 
            
            kal_vars_read = true;

                  if(g_start_kalibireung == 9){ 
                    g_start_kalibireung = 10;
                  }


      }
    //--------------------------------------------------------------------------------------------------




    //---------------------------------------------------------------------------------------------------
      if (response.getFunctionCode() == 3 && mb_byte_size == 7 && cb_g_mb_read_radon == true){  
       
        #ifdef MB_DETAIL_DEBUG
        Serial.println("[MB] Funkton 3 ");
        #endif

        cb_g_mb_read_radon = false;

        mb_radon_live_word_0 = word(mb_arry_byte[3], mb_arry_byte[4]);
        mb_radon_live_word_1 = word(mb_arry_byte[5], mb_arry_byte[6]);
        mb_radon_live_32bit = mb_radon_live_word_0 + mb_radon_live_word_1;

      //!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
       // mb_radon_live_32bit = mb_radon_live_32bit + 23450;
        //if(radon_temp < 9999 && radon_temp >=1000){
      //!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!


        if(mb_radon_live_32bit == 0){
          auto randomNumber1_5 = random(1, 5);   // random number between 1-5
          mb_radon_live_32bit = randomNumber1_5;
        }


        //mb_radon_live_32bit = 1576;
        /*
        mb_radon_live_32bitK_s = String(mb_radon_live_32bit) + " ";
        if(mb_radon_live_32bit>1000){
          mb_radon_live_32bitK = mb_radon_live_32bit / 1000;
          mb_radon_live_32bitK_s = String(mb_radon_live_32bitK) + "k ";
        }
        */

        rval3 = mb_radon_live_32bit;
        //r0_val3 = String(mb_radon_live_32bit);
        mb_radon_ist_long = mb_radon_live_32bit;

        if(mb_radon_live_32bit > 65535){
          val3 = 65535; 
          mb_radon_ist_word = 65535;
        }else{
          val3 = mb_radon_live_word_1;
          mb_radon_ist_word = mb_radon_live_word_1;
        }


        fval1 = mb_radon_ist_word;

         g_radon_new_seg = true;
         g_radon_new_led = true; 
         var_led_t = mb_radon_ist_word;
         //g_radon_new_tb = true;

         if(mb_man_read_radon == true){
          //g_radon_new_tb = false;
          mb_man_read_radon = false;
         }

         g_sensor_online = 0;



        //Serial.println("Radon Ist Long: " + String(mb_radon_live_word_0) + " " + String(mb_radon_live_word_1));
        //Serial.println("Radon Ist Long: " + String(mb_arry_byte[3]) + " " + String(mb_arry_byte[4]) + " " + String(mb_arry_byte[5]) + " " + String(mb_arry_byte[6]) + "  : "  + String(mb_radon_live_32bit));
        #ifdef MB_DETAIL_DEBUG
        Serial.println("[MB] Radon Iive [32bit]: " + String(mb_radon_live_32bit));
        #endif

      }
    //---------------------------------------------------------------------------------------------------

    //---------------------------------------------------------------------------------------------------
      if (response.getFunctionCode() == 3 &&  mb_byte_size >= 17 && mb_byte_size <= 19){  


            #ifdef MB_DETAIL_DEBUG
            Serial.println("[MB] Funkton 3 ");
            #endif

            mb_radon_live_word_0 = word(mb_arry_byte[3], mb_arry_byte[4]);
            mb_radon_live_word_1 = word(mb_arry_byte[5], mb_arry_byte[6]);
            mb_radon_live_32bit = mb_radon_live_word_0 + mb_radon_live_word_1;

            //!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
              //mb_radon_live_32bit = mb_radon_live_32bit + 23450;
              // if(radon_temp < 9999 && radon_temp >=1000){
            //!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

              if(mb_radon_live_32bit == 0){
                rand_radon_0 ++;
                if(rand_radon_0 <= 3){
                  auto randomNumber1_5 = random(1, 5);   // random number between 1-5
                  mb_radon_live_32bit = randomNumber1_5;
                }
              }else{
                rand_radon_0 = 0;
              }


              //mb_radon_live_32bit = 1576;
              /*
              mb_radon_live_32bitK_s = String(mb_radon_live_32bit) + " ";
              if(mb_radon_live_32bit>1000){
                mb_radon_live_32bitK = mb_radon_live_32bit / 1000;
                mb_radon_live_32bitK_s = String(mb_radon_live_32bitK) + "k ";
              }
              */

              rval3 = mb_radon_live_32bit;
              //r0_val3 = String(mb_radon_live_32bit);
              mb_radon_ist_long = mb_radon_live_32bit;

              if(mb_radon_live_32bit > 65535){
                val3 = 65535; 
                mb_radon_ist_word = 65535;
              }else{
                val3 = mb_radon_live_word_1;
                mb_radon_ist_word = mb_radon_live_word_1;
              }


              fval1 = mb_radon_ist_word;

              g_radon_new_seg = true;
              g_radon_new_led = true; 
              var_led_t = mb_radon_ist_word;
              g_radon_new_tb = true;

              if(mb_man_read_radon == true){
                g_radon_new_tb = false;
                mb_man_read_radon = false;
              }

              g_sensor_online = 0;

              
              rad_count ++;
              mb_radon_live_32bit_arr[rad_count] = mb_radon_live_32bit;
              mb_radon_live_32bit_arr_sum = mb_radon_live_32bit;
              if(rad_count >=6){
                rad_count = 0;
                mb_radon_live_32bit_arr_sum = mb_radon_live_32bit_arr[1] + mb_radon_live_32bit_arr[2] +mb_radon_live_32bit_arr[3] +mb_radon_live_32bit_arr[4] +mb_radon_live_32bit_arr[5] +mb_radon_live_32bit_arr[6];
                mb_radon_live_32bit_arr_sum = mb_radon_live_32bit_arr_sum / 6;
              }

                  for (int i=1; i <= 13; i++){
                     radon_2h_ist = radon_2h_ist + Radon_live_value_2h[i];
                     //Serial.print("[Ca] ");Serial.println(radon_2h_ist);
                  }


              //Serial.println("Radon Ist Long: " + String(mb_radon_live_word_0) + " " + String(mb_radon_live_word_1));
              //Serial.println("Radon Ist Long: " + String(mb_arry_byte[3]) + " " + String(mb_arry_byte[4]) + " " + String(mb_arry_byte[5]) + " " + String(mb_arry_byte[6]) + "  : "  + String(mb_radon_live_32bit));
            
              //#ifdef MB_DETAIL_DEBUG
              //Serial.println("-------------------------------");
              //Serial.println(F(" "));
              MB_DEBUG_PRINTLN("[MB] Radon Iive [32bit]: " + String(mb_radon_live_32bit));
              MB_DEBUG_PRINTLN("-------------------------------");

              //#endif




             //-----------------------------------
              Radon_live_value = mb_radon_live_32bit;
              save_rad_val = mb_radon_live_32bit;
              count_2h ++;
              radon_2h_ist = 0;
              if(count_2h > 12){
                count_2h = 1;
                C_2_umlauf = 1;
              }
              Radon_live_value_2h[count_2h] = Radon_live_value;
               //Serial.print("count_2h ");Serial.println(count_2h);

  
              if(C_2_umlauf >= 1){
             
                  // Wiederhole 12 Mal:
                  for (int i=1; i <= 12; i++){
                     radon_2h_ist = radon_2h_ist + Radon_live_value_2h[i];
                     //Serial.print("[Ca] ");Serial.println(radon_2h_ist);
                  }
                  radon_2h_ist = radon_2h_ist / 12;
                  //Serial.print("[Cb2] ");Serial.println(radon_2h_ist);


              }else{

                  // Wiederhole 12 Mal:
                  for (int i=1; i <= count_2h; i++){
                     radon_2h_ist = radon_2h_ist + Radon_live_value_2h[i];
                     //Serial.print("[Cc] ");Serial.println(radon_2h_ist);
                     //Serial.print("i ");Serial.println(i);
                  }
                  radon_2h_ist = radon_2h_ist / count_2h;
                  //Serial.print("[Cd2] ");Serial.println(radon_2h_ist);

              }
              //Serial.print("[Ce2] ");Serial.println(radon_2h_ist);
              //-----------------------------------

              //-----------------------------------
              Radon_live_value = mb_radon_live_32bit;
              count_1h ++;
              radon_1h_ist = 0;
              if(count_1h > 6){
                count_1h = 1;
                C_1_umlauf = 1;
              }
              Radon_live_value_1h[count_1h] = Radon_live_value;
              //Serial.print("count_1h ");Serial.println(count_1h);

  
              if(C_1_umlauf >= 1){
             
                  // Wiederhole 6 Mal:
                  for (int i=1; i <= 6; i++){
                     radon_1h_ist = radon_1h_ist + Radon_live_value_1h[i];
                     //Serial.print("[Ca1] ");Serial.print(i);Serial.print(" | ");Serial.println(radon_1h_ist);
                  }
                  radon_1h_ist = radon_1h_ist / 6;
                  //Serial.print("[Cb1] ");Serial.println(radon_1h_ist);


              }else{

                  // Wiederhole 6 Mal:
                  for (int i=1; i <= count_1h; i++){
                     radon_1h_ist = radon_1h_ist + Radon_live_value_1h[i];
                     //Serial.print("[Cc1] ");Serial.print(i);Serial.print(" | ");Serial.println(radon_1h_ist);
                  }
                  radon_1h_ist = radon_1h_ist / count_1h;
                  //Serial.print("count_1h ");Serial.println(count_1h);
                  //Serial.print("[Cd1] ");Serial.println(radon_1h_ist);

              }

               //Serial.print("[Ce1] ");Serial.println(radon_1h_ist);
             //-----------------------------------







              mb_radon_live_word_0 = word(mb_arry_byte[7], mb_arry_byte[8]);
              mb_radon_live_word_1 = word(mb_arry_byte[9], mb_arry_byte[10]);
              mb_radon_24h_32bit = mb_radon_live_word_0 + mb_radon_live_word_1;
              
              val8 = mb_radon_live_word_1;

              rval4 = mb_radon_24h_32bit;
              //Serial.println("Radon Ist Long: " + String(mb_radon_live_word_0) + " " + String(mb_radon_live_word_1));
              //Serial.println("Radon Ist Long: " + String(mb_arry_byte[3]) + " " + String(mb_arry_byte[4]) + " " + String(mb_arry_byte[5]) + " " + String(mb_arry_byte[6]) + "  : "  + String(mb_radon_live_32bit));
              #ifdef MB_DETAIL_DEBUG
              Serial.println("[MB] Radon 24h  [32bit]: " + String(mb_radon_24h_32bit));
              #endif

              mb_radon_live_word_0 = word(mb_arry_byte[11], mb_arry_byte[12]);
              mb_radon_live_word_1 = word(mb_arry_byte[13], mb_arry_byte[14]);
              mb_radon_long_32bit = mb_radon_live_word_0 + mb_radon_live_word_1;


              rval5 = mb_radon_long_32bit;
              mb_radon_long = mb_radon_long_32bit;
              if(mb_radon_long_32bit > 65535){
                mb_radon_int = 65535; 
                val9 = 65535;
              }else{
                mb_radon_int = mb_radon_live_word_1;
                val9 = mb_radon_live_word_1;
              }

              //Serial.println("Radon Ist Long: " + String(mb_radon_live_word_0) + " " + String(mb_radon_live_word_1));
              //Serial.println("Radon Ist Long: " + String(mb_arry_byte[3]) + " " + String(mb_arry_byte[4]) + " " + String(mb_arry_byte[5]) + " " + String(mb_arry_byte[6]) + "  : "  + String(mb_radon_live_32bit));
              #ifdef MB_DETAIL_DEBUG
                Serial.println("[MB] Radon long [32bit]: " + String(mb_radon_long_32bit));
              #endif


              mb_radon_F3_eintrarge = word(mb_arry_byte[15], mb_arry_byte[16]);


            
              //!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
              //mb_radon_F3_eintrarge = 2;
              //!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

              rval6 = mb_radon_F3_eintrarge;
              mb_radon_eintrarge = mb_radon_F3_eintrarge;

              val10 = mb_radon_eintrarge;

              if(mb_radon_F3_eintrarge >= 1){
                g_sensor_boot = true;
              } 

              mb_radon_F3_eintr_time = mb_radon_F3_eintrarge / 6;  // Stunden laufzeit


              #ifdef MB_DETAIL_DEBUG
                Serial.println("[MB] Aufzeichnungen: " + String(mb_radon_F3_eintrarge));
              #endif



            if(mb_byte_size == 19){
            
              mb_radon_F3_Version = word(mb_arry_byte[17], mb_arry_byte[18]);
            
              #ifdef MB_DETAIL_DEBUG
                Serial.println("[MB] Version: " + String(mb_radon_F3_Version));
              #endif

            }

            #ifdef MB_DETAIL_DEBUG

              Serial.println("[MB] -------------------");

            #endif




            //Serial.println("[MB] READ_HOLD_REGISTER 20, 8  --  Sensor Werte aktualisiert"); 
            g_mb_sensor_3_online = true;      
            sensor_mb_3_ok = 1;
            abfr_mb_finish = 1;

            cb_sensor_mb_ok = 2;
            cb_sensor_mb_count = 0;
            cb_g_mb_sensor = true;
            g_MB_abfrage_boot = false;

            //Serial.print("[MB] cb_g_mb_sensor "); Serial.println(String(cb_g_mb_sensor)); 


            #ifdef MB_DETAIL_DEBUG
            Serial.println("[IF] Sensor Daten aktualisiert");  
            Serial.println(F(" ")); 
            #endif 



            //---------------- Graph save Daten --------------------------   



                  // Formatiere den Datensatz in das char Array
                  snprintf(things_list_t_14, sizeof(things_list_t_14), "%s %s,%u", p_date_YYMMDD, formattedDateHH, radon_1h_ist);

                  // Debug-Ausgaben
                  //Serial.print(F("Date: "));Serial.println(p_date_YYMMDD);
                  //Serial.print(F("Time: "));Serial.println(formattedDateHH);
                  //Serial.print(F("Time: "));Serial.println(formattedDateHHMM);
                  //Serial.print(F("Formatted Entry: "));Serial.println(things_list_t_14);
                

                

              strcpy(chartime16, formattedDateHHMM);
              charInts[48] = mb_radon_live_32bit;  



             //if (currentmin == 0 || currentmin == 30){  
             if (currentmin == 0){  

                mb_radon_save_eintrarge ++;
              
                Preferences preferences;
                preferences.begin("eenvs", false);                         //Ordner eenvs anlegen/verwenden
                preferences.putUShort("r_eintrarge", mb_radon_save_eintrarge);     
               


              #ifdef ea_webserver 
              #ifdef j_2_webserver
                if(disable_server >= 1 && TB_currFwVersion == TB_newFwVersion) {
                  if (loggingEnabled) {
                    if (mb_radon_live_32bit < 10)
                    {
                      //things_list_t_16 = p_uhrzeit + "  [MB] Radon: " + String(mb_radon_live_32bit) + "   bq/m³";
                    } 
                    else if (mb_radon_live_32bit < 100 && mb_radon_live_32bit >= 10) // 4 bq/m³
                    {
                      //things_list_t_16 = p_uhrzeit + "  [MB] Radon: " + String(mb_radon_live_32bit) + "  bq/m³";

                    }
                    else if (mb_radon_live_32bit >= 100)
                    {
                    //things_list_t_16 = p_uhrzeit + "  [MB] Radon: " + String(mb_radon_live_32bit) + " bq/m³";
                    }
                    write_to_log(things_list_t_16);
                  }
                }
              #endif
              #endif
                
                
                
                //Serial.println("[IF] DATA save to Graph");       
                esp_task_wdt_reset();

                char chartempcl[22]; // Puffer für das Kombinieren von Datum und Uhrzeit
                // Datum und Uhrzeit in chartemp kombinieren
                sprintf(chartempcl, "%s %s", p_date_DDMMYY, formattedDateHHMM);
                // chartime16 als String setzen
                //chartime16 = String(chartempcl);
                strcpy(chartime16, chartempcl);

                charInts[48] = radon_1h_ist;  
              
               //------------------------------------------   


                write_to_file = true;    // auch noch bei    Callback_1m   Callback_2s    zum testen
                write_to_mqtt = true;
               //------------------------------------------   
     
                 
                  for (int i = 0; i < 48; i++) {
                      charInts[i] = charInts[i + 1];
                  }
                  esp_task_wdt_reset();
                  //Serial.println("[IF] DATA save to Graph b");
                  
                                  
                

                  //Preferences preferences;
                  //preferences.begin("eenvs", false);      
                  for (int i = 0; i < 49; i++) {
                      char key[7];
                      sprintf(key, "int%02d", i);
                      preferences.putUShort(key, charInts[i]);
                  }
                  esp_task_wdt_reset();
                  // Serial.println("[IF] DATA save to Graph c");

                   
   


             //Serial.println("[IF] DATA save to Graph d");
             #ifdef ea_webserver
             #ifdef j_2_webserver
             if(disable_server >= 1 && TB_currFwVersion == TB_newFwVersion) {

                        

                    strcpy(dgrxx_s, "dgr00a");
                    datei_r_graph(dgrxx_s); 
                    //chartime00 = chartemp;
                    strcpy(chartime00, chartemp);

                    strcpy(dgrxx_s, "dgr00");
                    datei_w_graph(dgrxx_s, chartemp);

                    strcpy(dgrxx_s, "dgr00b");
                    datei_r_graph(dgrxx_s);

                    strcpy(dgrxx_s, "dgr00a");
                    datei_w_graph(dgrxx_s, chartemp);

                    strcpy(dgrxx_s, "dgr01");
                    datei_r_graph(dgrxx_s);

                    strcpy(dgrxx_s, "dgr00b");
                    datei_w_graph(dgrxx_s, chartemp);

                    strcpy(dgrxx_s, "dgr01a");
                    datei_r_graph(dgrxx_s); 
                    //chartime01a = chartemp;
                    strcpy(chartime01a, chartemp);

                    strcpy(dgrxx_s, "dgr01");
                    datei_w_graph(dgrxx_s, chartemp);

                    strcpy(dgrxx_s, "dgr01b");
                    datei_r_graph(dgrxx_s);

                    strcpy(dgrxx_s, "dgr01a");
                    datei_w_graph(dgrxx_s, chartemp);

                    strcpy(dgrxx_s, "dgr02");
                    datei_r_graph(dgrxx_s);

                    strcpy(dgrxx_s, "dgr01b");
                    datei_w_graph(dgrxx_s, chartemp);

                    strcpy(dgrxx_s, "dgr02a");
                    datei_r_graph(dgrxx_s);

                    strcpy(dgrxx_s, "dgr02");
                    datei_w_graph(dgrxx_s, chartemp);

                    strcpy(dgrxx_s, "dgr02b");
                    datei_r_graph(dgrxx_s); 
                    //chartime02b = chartemp;
                    strcpy(chartime02b, chartemp);

                    strcpy(dgrxx_s, "dgr02a");
                    datei_w_graph(dgrxx_s, chartemp);

                    strcpy(dgrxx_s, "dgr03");
                    datei_r_graph(dgrxx_s);

                    strcpy(dgrxx_s, "dgr02b");
                    datei_w_graph(dgrxx_s, chartemp);

                    strcpy(dgrxx_s, "dgr03a");
                    datei_r_graph(dgrxx_s);

                    strcpy(dgrxx_s, "dgr03");
                    datei_w_graph(dgrxx_s, chartemp);

                    strcpy(dgrxx_s, "dgr03b");
                    datei_r_graph(dgrxx_s);

                    strcpy(dgrxx_s, "dgr03a");
                    datei_w_graph(dgrxx_s, chartemp);

                    strcpy(dgrxx_s, "dgr04");
                    datei_r_graph(dgrxx_s); 
                    //chartime04 = chartemp;
                    strcpy(chartime04, chartemp);

                    strcpy(dgrxx_s, "dgr03b");
                    datei_w_graph(dgrxx_s, chartemp);

                    strcpy(dgrxx_s, "dgr04a");
                    datei_r_graph(dgrxx_s);

                    strcpy(dgrxx_s, "dgr04");
                    datei_w_graph(dgrxx_s, chartemp);

                    strcpy(dgrxx_s, "dgr04b");
                    datei_r_graph(dgrxx_s);

                    strcpy(dgrxx_s, "dgr04a");
                    datei_w_graph(dgrxx_s, chartemp);

                    strcpy(dgrxx_s, "dgr05");
                    datei_r_graph(dgrxx_s);

                    strcpy(dgrxx_s, "dgr04b");
                    datei_w_graph(dgrxx_s, chartemp);

                    esp_task_wdt_reset();

                    strcpy(dgrxx_s, "dgr05a");
                    datei_r_graph(dgrxx_s); 
                    //chartime05a = chartemp;
                    strcpy(chartime05a, chartemp);

                    strcpy(dgrxx_s, "dgr05");
                    datei_w_graph(dgrxx_s, chartemp);

                    strcpy(dgrxx_s, "dgr05b");
                    datei_r_graph(dgrxx_s);

                    strcpy(dgrxx_s, "dgr05a");
                    datei_w_graph(dgrxx_s, chartemp);

                    strcpy(dgrxx_s, "dgr06");
                    datei_r_graph(dgrxx_s);

                    strcpy(dgrxx_s, "dgr05b");
                    datei_w_graph(dgrxx_s, chartemp);

                    strcpy(dgrxx_s, "dgr06a");
                    datei_r_graph(dgrxx_s);

                    strcpy(dgrxx_s, "dgr06");
                    datei_w_graph(dgrxx_s, chartemp);

                    strcpy(dgrxx_s, "dgr06b");
                    datei_r_graph(dgrxx_s); 
                    //chartime06b = chartemp;
                    strcpy(chartime06b, chartemp);

                    strcpy(dgrxx_s, "dgr07");
                    datei_r_graph(dgrxx_s);

                    strcpy(dgrxx_s, "dgr06b");
                    datei_w_graph(dgrxx_s, chartemp);

                    esp_task_wdt_reset();

                    strcpy(dgrxx_s, "dgr07a");
                    datei_r_graph(dgrxx_s);

                    strcpy(dgrxx_s, "dgr07");
                    datei_w_graph(dgrxx_s, chartemp);

                    strcpy(dgrxx_s, "dgr07b");
                    datei_r_graph(dgrxx_s);

                    strcpy(dgrxx_s, "dgr07a");
                    datei_w_graph(dgrxx_s, chartemp);

                    strcpy(dgrxx_s, "dgr08");
                    datei_r_graph(dgrxx_s);

                    strcpy(dgrxx_s, "dgr07b");
                    datei_w_graph(dgrxx_s, chartemp);

                    strcpy(dgrxx_s, "dgr08a");
                    datei_r_graph(dgrxx_s); 
                    //chartime08a = chartemp;
                    strcpy(chartime08a, chartemp);

                    strcpy(dgrxx_s, "dgr08");
                    datei_w_graph(dgrxx_s, chartemp);

                    strcpy(dgrxx_s, "dgr08b");
                    datei_r_graph(dgrxx_s);

                    strcpy(dgrxx_s, "dgr08a");
                    datei_w_graph(dgrxx_s, chartemp);

                    strcpy(dgrxx_s, "dgr09");
                    datei_r_graph(dgrxx_s);

                    strcpy(dgrxx_s, "dgr08b");
                    datei_w_graph(dgrxx_s, chartemp);

                    esp_task_wdt_reset();
                    strcpy(dgrxx_s, "dgr09a");
                    datei_r_graph(dgrxx_s); 
                    //chartime09a = chartemp;
                    strcpy(chartime09a, chartemp);

                    strcpy(dgrxx_s, "dgr09");
                    datei_w_graph(dgrxx_s, chartemp);

                    strcpy(dgrxx_s, "dgr09b");
                    datei_r_graph(dgrxx_s);

                    strcpy(dgrxx_s, "dgr09a");
                    datei_w_graph(dgrxx_s, chartemp);

                    strcpy(dgrxx_s, "dgr10");
                    datei_r_graph(dgrxx_s);

                    strcpy(dgrxx_s, "dgr09b");
                    datei_w_graph(dgrxx_s, chartemp);

                    strcpy(dgrxx_s, "dgr10a");
                    datei_r_graph(dgrxx_s);

                    strcpy(dgrxx_s, "dgr10");
                    datei_w_graph(dgrxx_s, chartemp);

                    strcpy(dgrxx_s, "dgr10b");
                    datei_r_graph(dgrxx_s); 
                    //chartime10b = chartemp;
                    strcpy(chartime10b, chartemp);

                    strcpy(dgrxx_s, "dgr10a");
                    datei_w_graph(dgrxx_s, chartemp);

                    strcpy(dgrxx_s, "dgr11");
                    datei_r_graph(dgrxx_s);

                    strcpy(dgrxx_s, "dgr10b");
                    datei_w_graph(dgrxx_s, chartemp);

                    strcpy(dgrxx_s, "dgr11a");
                    datei_r_graph(dgrxx_s);

                    strcpy(dgrxx_s, "dgr11");
                    datei_w_graph(dgrxx_s, chartemp);

                    strcpy(dgrxx_s, "dgr11b");
                    datei_r_graph(dgrxx_s);

                    strcpy(dgrxx_s, "dgr11a");
                    datei_w_graph(dgrxx_s, chartemp);
                                                  
                    strcpy(dgrxx_s, "dgr12");
                    datei_r_graph(dgrxx_s); 
                    //chartime12 = chartemp;
                    strcpy(chartime12, chartemp);

                    strcpy(dgrxx_s, "dgr11b");
                    datei_w_graph(dgrxx_s, chartemp);

                    strcpy(dgrxx_s, "dgr12a");
                    datei_r_graph(dgrxx_s);

                    strcpy(dgrxx_s, "dgr12");
                    datei_w_graph(dgrxx_s, chartemp);

                    strcpy(dgrxx_s, "dgr12b");
                    datei_r_graph(dgrxx_s);

                    strcpy(dgrxx_s, "dgr12a");
                    datei_w_graph(dgrxx_s, chartemp);

                    strcpy(dgrxx_s, "dgr13");
                    datei_r_graph(dgrxx_s);

                    strcpy(dgrxx_s, "dgr12b");
                    datei_w_graph(dgrxx_s, chartemp);

                    strcpy(dgrxx_s, "dgr13a");
                    datei_r_graph(dgrxx_s); 
                    //chartime13a = chartemp;
                    strcpy(chartime13a, chartemp);

                    strcpy(dgrxx_s, "dgr13");
                    datei_w_graph(dgrxx_s, chartemp);

                    strcpy(dgrxx_s, "dgr13b");
                    datei_r_graph(dgrxx_s);

                    strcpy(dgrxx_s, "dgr13a");
                    datei_w_graph(dgrxx_s, chartemp);

                    strcpy(dgrxx_s, "dgr14");
                    datei_r_graph(dgrxx_s);

                    strcpy(dgrxx_s, "dgr13b");
                    datei_w_graph(dgrxx_s, chartemp);

                    strcpy(dgrxx_s, "dgr14a");
                    datei_r_graph(dgrxx_s);

                    strcpy(dgrxx_s, "dgr14");
                    datei_w_graph(dgrxx_s, chartemp);

                    strcpy(dgrxx_s, "dgr14b");
                    datei_r_graph(dgrxx_s); 
                    //chartime14b = chartemp;
                    strcpy(chartime14b, chartemp);

                    strcpy(dgrxx_s, "dgr14a");
                    datei_w_graph(dgrxx_s, chartemp);

                    strcpy(dgrxx_s, "dgr15");
                    datei_r_graph(dgrxx_s);

                    strcpy(dgrxx_s, "dgr14b");
                    datei_w_graph(dgrxx_s, chartemp);

                    strcpy(dgrxx_s, "dgr15a");
                    datei_r_graph(dgrxx_s);

                    strcpy(dgrxx_s, "dgr15");
                    datei_w_graph(dgrxx_s, chartemp);

                    strcpy(dgrxx_s, "dgr15b");
                    datei_r_graph(dgrxx_s);

                    strcpy(dgrxx_s, "dgr15a");
                    datei_w_graph(dgrxx_s, chartemp);

                    strcpy(dgrxx_s, "dgr16");
                    datei_r_graph(dgrxx_s);

                    strcpy(dgrxx_s, "dgr15b");
                    datei_w_graph(dgrxx_s, chartemp);

                    // Datum und Uhrzeit in chartemp kombinieren
                    sprintf(chartemp, "%s %s", p_date_DDMMYY, formattedDateHHMM);
                    // Ergebnis in chartemp schreiben
                    strcpy(dgrxx_s, "dgr16");
                    datei_w_graph(dgrxx_s, chartemp);

                    strcpy(chartime16, chartemp);


                                                      
   

             }
             #endif
             #endif

                 esp_task_wdt_reset(); // Watchdog-Timer zurücksetzen   

          }

         
         //------------------------------------------   

        if(mb_stufen_start == true){
         
          mb_stufen_read = true;

        }


      }



        //-------------------------------------
        if(g_bl_radon_read == true){

          g_bl_radon_read = false;

              String tempstr = "";

              tempstr = "Radon Iive\t\t\t|: "; tempstr += String(mb_radon_live_32bit); tempstr += " |.\r";  
              pTxCharacteristic->setValue(tempstr.c_str());
              pTxCharacteristic->notify();
              size_t message_length = strlen(tempstr.c_str());
              sentTraffic += message_length; 

              tempstr = "Radon 24h\t\t\t|: "; tempstr += String(radon_mittelwert_24h); tempstr += " |.\r";  
              pTxCharacteristic->setValue(tempstr.c_str());
              pTxCharacteristic->notify();
              message_length = strlen(tempstr.c_str());
              sentTraffic += message_length; 

              tempstr = "Radon 24h2\t\t\t|: "; tempstr += String(radon_mittelwert_24_2h); tempstr += " |.\r";  
              pTxCharacteristic->setValue(tempstr.c_str());
              pTxCharacteristic->notify();
              message_length = strlen(tempstr.c_str());
              sentTraffic += message_length; 

              tempstr = "Radon long\t\t\t|: "; tempstr += String(radon_mittelwert_long); tempstr += " |.\r";  
              pTxCharacteristic->setValue(tempstr.c_str());
              pTxCharacteristic->notify();
              message_length = strlen(tempstr.c_str());
              sentTraffic += message_length; 

              tempstr = "Stunden laufzeit\t\t|: "; tempstr += String(mb_radon_save_eintrarge); tempstr += " |.\r";  
              pTxCharacteristic->setValue(tempstr.c_str());
              pTxCharacteristic->notify();
              message_length = strlen(tempstr.c_str());
              sentTraffic += message_length; 

              tempstr = "Sensor Version\t\t|: "; tempstr += String(mb_radon_F3_Version); tempstr += " |.\r";  
              pTxCharacteristic->setValue(tempstr.c_str());
              pTxCharacteristic->notify();
              message_length = strlen(tempstr.c_str());
              sentTraffic += message_length; 

              tempstr = "Seriennummer\t\t|: "; tempstr += mb_Seriennummer; tempstr += " |.\r";  
              pTxCharacteristic->setValue(tempstr.c_str());
              pTxCharacteristic->notify();
              message_length = strlen(tempstr.c_str());
              sentTraffic += message_length; 


        }
        //-------------------------------------





  }
  
 //***********************************************************************************


//-----------------------------------------------------------------
void mb_read_radon(){


      if(g_boot_fail == 0 && boot_ani_off == false){ 
       // boot_ani_off2 = false;   // kein animation bei geziehltem reboot rücksetzen
      }
      
              #ifdef sPACE_DEBUG
              printf("[AP02] FREE HEAP: now: %u, contiguous: %u, lowest: %u\n",xPortGetFreeHeapSize(),heap_caps_get_largest_free_block(MALLOC_CAP_DEFAULT),xPortGetMinimumEverFreeHeapSize());
              #endif 
                      
                  MB_DEBUG_PRINTLN(F("-------------------------------"));
                  MB_DEBUG_PRINT(F("[IF] "));
                  MB_DEBUG_PRINTLN(p_uhrzeit);

                  mb_client_id = 1;
                  mb_man_read_radon = true;
                  MB_DEBUG_PRINTLN(F("[MB] Sensor abfrage Radonwerte")); 
                  //MB_DEBUG_PRINTLN("-------------------------------");





                      g_sensor_online ++;   //Fehlerzähler
                      //--- ABFRAGE FUNKTION 3 -----
                      MB.setTimeout(resp_tim_out);
                      Modbus::Error errd2 = MB.addRequest(1, mb_client_id, READ_HOLD_REGISTER, 20, 8);   //  void handleData(ModbusMessage response, uint32_t token) 
                      //Serial.print("[MB] "); Serial.println(errd2); 
                      //ModbusError e(errd2);
                      //LOG_E("Error creating request: %02X - %s\n", (int)e, (const char *)e);


                      if (errd2!=SUCCESS) {
                         #ifdef ea_webserver
                         #ifdef j_2_webserver
                         if(disable_server >= 1 && TB_currFwVersion == TB_newFwVersion) {
                          if (loggingEnabled) {
                          //things_list_t_16 = p_uhrzeit + "  [MB] Sensor abfrage Radonwerte fehlgeschlagen";
                          write_to_log(things_list_t_16);
                          }
                         }
                        #endif
                        #endif

                      }
                          //ModbusError e(err);
                          abfr_mb_finish = 2;
                          //LOG_E("aaaError creating request: %02X - %s\n", (int)e, (const char *)e);
                          

                          g_mb_sensor_3_online = false;
                          //#ifdef MB_DETAIL_DEBUG
                          //Serial.println("[MB] READ_HOLD_REGISTER 20, 8  --  Sensor abfrage fehlgeschlagen"); 
                          //#endif


                     // }else{
                          //Serial.println("ok");
                          //#ifdef MB_DETAIL_DEBUG
                          //Serial.println("[MB] READ_HOLD_REGISTER 20, 8  --  Sensor Werte aktualisieren"); 
                          //#endif
                 
                          
                       // boot_ani_off2 = false;
                     

                     // }



}
//-----------------------------------------------------------------




//-----------------------------------------------------------------
void mb_read_stufen(){
     



                      //--- ABFRAGE FUNKTION 3 -----
                      MB.setTimeout(resp_tim_out);
                      Modbus::Error errd2 = MB.addRequest(1, mb_client_id, READ_HOLD_REGISTER, 10, 6);   //  void handleData(ModbusMessage response, uint32_t token) 
                      //Serial.print("[MB] "); Serial.println(errd2); 
                      //ModbusError e(errd2);
                      //LOG_E("Error creating request: %02X - %s\n", (int)e, (const char *)e);


                      if (errd2!=SUCCESS) {

                      }


}
//-----------------------------------------------------------------





//-----------------------------------------------------------------
void mb_read_reset(){
     

                #ifdef MB_DETAIL_DEBUG
                  Serial.println("[MB] READ_HOLD_REGISTER  1,1  --  Read Reset"); 
                #endif

                mb_read_byte = 1;

                // Read register
                  Modbus::Error err = MB.addRequest(1, mb_client_id, READ_HOLD_REGISTER, 1, 1);
                  if (err!=SUCCESS) {
                    ModbusError e(err);
                    LOG_E("Error creating request: %02X - %s\n", (int)e, (const char *)e);
                  }else{
                     Serial.println(F("[MB] READ_HOLD_REGISTER ok")); 
                  }  




}
//-----------------------------------------------------------------



//-----------------------------------------------------------------
void mb_read_pwd(){
     

                #ifdef MB_DETAIL_DEBUG
                  Serial.println("[MB] READ_HOLD_REGISTER  9,1  --  Read PWD"); 
                #endif

                mb_read_byte = 9;

                // Read register
                  Modbus::Error err = MB.addRequest(1, mb_client_id, READ_HOLD_REGISTER, 9, 1);
                  if (err!=SUCCESS) {
                    ModbusError e(err);
                    LOG_E("Error creating request: %02X - %s\n", (int)e, (const char *)e);
                  }else{
                     Serial.println(F("[MB] READ_HOLD_REGISTER ok")); 
                  }  




}
//-----------------------------------------------------------------






//-----------------------------------------------------------------
void mb_read_calibrierung(){
     
                      //--- ABFRAGE FUNKTION 4 -----

                      MB.setTimeout(resp_tim_out);
                      Modbus::Error errd = MB.addRequest(1, mb_client_id, READ_INPUT_REGISTER, 11, 9);    // void handleData(ModbusMessage response, uint32_t token) 
                      //rror errd = MB.addRequest(1, mb_client_id, READ_INPUT_REGISTER, 0, 6);
                      //while (abfr_mb_finish <= 0) {
                      // Serial.println("------------------------ abfr --"); 
                        //Serial.println(errd); 
                        
                        if (errd!=SUCCESS ) {
                            //ModbusError e(err);
     
                            //LOG_E("aaaError creating request: %02X - %s\n", (int)e, (const char *)e);


                            #ifdef MB_DETAIL_DEBUG
                            Serial.println("[MB] READ_INPUT_REGISTER 11, 8  --  Kalibrierung abfrage fehlgeschlagen");  
                            #endif


                        }else{
                            //Serial.println("ok");
                            #ifdef MB_DETAIL_DEBUG
                            Serial.println("[MB] READ_INPUT_REGISTER 11, 8  --  Kalibrierung aktualisiert"); // responsegetFunctionCode
                            #endif
 



                        }


  }
//-----------------------------------------------------------------




//-----------------------------------------------------------------
void mb_write_pwd(){
     
                       // hour+2 *117 /_day  

                          #ifdef MB_DETAIL_DEBUG
                          Serial.println("[MB] WRITE_HOLD_REGISTER  9  --  Write PW"); 
                          #endif
                      
                        Modbus::Error err = MB.addRequest(2, mb_client_id, WRITE_HOLD_REGISTER, 9, mb_ist_pwd);

                        if (err!=SUCCESS) {
                          ModbusError e(err);
                          LOG_E("Error creating request: %02X - %s\n", (int)e, (const char *)e);
                          //Serial.println("[MB] err");  
                        //}else{
                           //Serial.println("[MB] WRITE_HOLD_REGISTER ok"); 
                        }     


}
//-----------------------------------------------------------------




//-----------------------------------------------------------------
void mb_write_cal(){
     
   
        #ifdef MB_KAL_DEBUG
        Serial.println("[MB] Kalibrierungswerte schreiben"); 
        #endif

        if(g_S00_soll > 0){
          #ifdef MB_KAL_DEBUG
            Serial.println("[MB] WRITE_HOLD_REGISTER  30  --  Kalibrierungswert"); 
          #endif
          Modbus::Error err = MB.addRequest(2, mb_client_id, WRITE_HOLD_REGISTER, 30, g_S00_soll);
          if (err!=SUCCESS) {
            ModbusError e(err);
            LOG_E("Error creating request: %02X - %s\n", (int)e, (const char *)e);
          }   
        } 
        //---------------------------------------
        if(g_S01_soll > 0){
           #ifdef MB_KAL_DEBUG
          Serial.println("[MB] WRITE_HOLD_REGISTER  31  --  Count Max"); 
           #endif
          Modbus::Error err = MB.addRequest(2, mb_client_id, WRITE_HOLD_REGISTER, 31, g_S01_soll);
          if (err!=SUCCESS) {
            ModbusError e(err);
            LOG_E("Error creating request: %02X - %s\n", (int)e, (const char *)e);
          }   
        } 
        //---------------------------------------   
        if(g_S02_soll > 0){
         #ifdef MB_KAL_DEBUG
          Serial.println("[MB] WRITE_HOLD_REGISTER  32  --  Darkkount"); 
          #endif
          Modbus::Error err = MB.addRequest(2, mb_client_id, WRITE_HOLD_REGISTER, 32, g_S02_soll);
          if (err!=SUCCESS) {
            ModbusError e(err);
            LOG_E("Error creating request: %02X - %s\n", (int)e, (const char *)e);
          }   
        } 
        //---------------------------------------  
        if(g_S18_soll > 0){
           #ifdef MB_KAL_DEBUG
          Serial.println("[MB] WRITE_HOLD_REGISTER  33  --  Glättungsfaktor"); 
             #endif
          Modbus::Error err = MB.addRequest(2, mb_client_id, WRITE_HOLD_REGISTER, 33, g_S18_soll);
          if (err!=SUCCESS) {
            ModbusError e(err);
            LOG_E("Error creating request: %02X - %s\n", (int)e, (const char *)e);
          }   
        } 
        //---------------------------------------  
        if(g_S19_soll > 0){
           #ifdef MB_KAL_DEBUG
          Serial.println("[MB] WRITE_HOLD_REGISTER  34  --  Leerwert"); 
            #endif
          Modbus::Error err = MB.addRequest(2, mb_client_id, WRITE_HOLD_REGISTER, 34, g_S19_soll);
          if (err!=SUCCESS) {
            ModbusError e(err);
            LOG_E("Error creating request: %02X - %s\n", (int)e, (const char *)e);
          }   
        } 
        //--------------------------------------- 
        if(g_S21_soll > 0){
        #ifdef MB_KAL_DEBUG
          Serial.println("[MB] WRITE_HOLD_REGISTER  35  --  Leerwert unten"); 
         #endif
          Modbus::Error err = MB.addRequest(2, mb_client_id, WRITE_HOLD_REGISTER, 35, g_S21_soll);
          if (err!=SUCCESS) {
            ModbusError e(err);
            LOG_E("Error creating request: %02X - %s\n", (int)e, (const char *)e);
          }   
        } 
        //--------------------------------------- 




}
//-----------------------------------------------------------------





//-----------------------------------------------------------------
void mb_read_time(){
     

                      Serial.println(F("-------------------------------"));Serial.print(F("[IF] "));Serial.println(p_uhrzeit);
                      Serial.println(F("[MB] Sensor abfrage Uhrzeit")); 
                       
                        ModbusMessage n = MB.syncRequest(1, mb_client_id, READ_HOLD_REGISTER, 0, 1);  //void handleData(  
                        Modbus::Error err = n.getError();

                        if (err != SUCCESS ) {
                            ModbusError me(err);
                            Serial.printf("%d : %s\n", mb_client_id, (const char *)me);
                        } else {
                           ModbusError me(err);
                           Serial.printf("%d : %s\n", mb_client_id, (const char *)me);
                        }  


                         
                      //--- ABFRAGE FUNKTION 3 -----
                      MB.setTimeout(resp_tim_out);
                      Modbus::Error errd2 = MB.addRequest(1, mb_client_id, READ_HOLD_REGISTER, 5, 4);   //  void handleData(ModbusMessage response, uint32_t token) 

                      if (errd2!=SUCCESS ) {
                          //ModbusError e(err);
                          //bfr_mb_finish = 2;
                          //LOG_E("aaaError creating request: %02X - %s\n", (int)e, (const char *)e);
                          
                        
                     
                          #ifdef MB_KAL_DEBUG
                          Serial.println("[MB] READ_HOLD_REGISTER 5, 4  --  Read Time fehlgeschlagen"); 
                          #endif


                      }else{
                          //Serial.println("ok");
                          #ifdef MB_KAL_DEBUG
                          Serial.println("[MB] READ_HOLD_REGISTER 5, 4  --  Read Time aktualisieren"); 
                          #endif
                  
                          
                        
                          //abfr_mb_finish = 1;

                      }



}
//-----------------------------------------------------------------




//-----------------------------------------------------------------
void mb_read_cal_vals(){
     
                     // #ifdef MB_KAL_DEBUG
                      MB_DEBUG_PRINTLN(F("-------------------------------"));
                      MB_DEBUG_PRINT(F("[IF] ")); MB_DEBUG_PRINTLN(p_uhrzeit);
                      MB_DEBUG_PRINTLN(F("[MB] Sensor abfrage Kalibrierungswerte")); 
                     // #endif
                     
                      //--- ABFRAGE FUNKTION 4 -----
                      MB.setTimeout(resp_tim_out);
                      Modbus::Error errd = MB.addRequest(1, mb_client_id, READ_INPUT_REGISTER, 26, 6);    // void handleData(ModbusMessage response, uint32_t token) 
                      //rror errd = MB.addRequest(1, mb_client_id, READ_INPUT_REGISTER, 0, 6);
                      //while (abfr_mb_finish <= 0) {
                      // Serial.println("------------------------ abfr --"); 
                        //Serial.println(errd); 
                        
                        if (errd!=SUCCESS ) {
                            //ModbusError e(err);
     
                            //LOG_E("aaaError creating request: %02X - %s\n", (int)e, (const char *)e);


                            #ifdef MB_KAL_DEBUG
                            Serial.println("[MB] READ_INPUT_REGISTER 26, 4  --  Kalibrierung abfrage fehlgeschlagen");  
                            #endif


                        }else{
                            //Serial.println("ok");
                            #ifdef MB_KAL_DEBUG
                            Serial.println("[MB] READ_INPUT_REGISTER 26, 4  --  Kalibrierung aktualisiert"); // responsegetFunctionCode
                            #endif
 



                        }


  }
//-----------------------------------------------------------------



//-----------------------------------------------------------------
void mb3_request(){
          
                    //--- ABFRAGE FUNKTION 3 -----

                      MB_DEBUG_PRINTLN(F("-------------------------------"));
                      MB_DEBUG_PRINT(F("[IF] "));MB_DEBUG_PRINTLN(p_uhrzeit);
                      MB_DEBUG_PRINTLN(F("[MB] Sensor abfrage Radonwert")); 


    cb_g_mb_read_radon = true;
    MB.setTimeout(resp_tim_out);
    MB.addRequest(1, mb_client_id, READ_HOLD_REGISTER, 20, 2);   //  void handleData(ModbusMessage response, uint32_t token) 




}





// Define an onError handler function to receive error responses
// Arguments are the error code returned and a user-supplied token to identify the causing request
void handleError(Modbus::Error error, uint32_t token) 
{
  // ModbusError wraps the error code and provides a readable error message for it
  

  #ifdef MB_DETAIL_DEBUG
    MB_DEBUG_PRINTLN(F("[MB] Modbus Error")); 
    ModbusError me(error);
    LOG_E("Error response: %02X - %s\n", (int)me, (const char *)me);
  #endif
  
  if(disable_server >= 1 && TB_currFwVersion == TB_newFwVersion) {
    if(g_Server_ID_mismatch == 0 && mb_man_read_radon == true){
      g_Server_ID_mismatch = 1;
      mb_read_radon();
    }
  }
  

}





//-----------------------------------------------------------------
void mb3Callback(){

                      MB_DEBUG_PRINTLN(F("-------------------------------"));
                      MB_DEBUG_PRINT(F("[IF] "));
                      MB_DEBUG_PRINTLN(p_uhrzeit);

                      MB_DEBUG_PRINTLN(F("[MB] Sensor abfrage Radonwerte")); 
                      g_sensor_online ++; //Fehlerzähler
                    
                      //Serial.print("[MB] cb_g_mb_sensor "); Serial.println(String(cb_g_mb_sensor)); 

                          abfr_mb_finish = 2;
                         
                          sensor_mb_3_ok = 0;
                          g_mb_sensor_3_online = false;

                          cb_sensor_mb_ok = 1;
                          cb_sensor_mb_time = 5;
                          cb_sensor_mb_count ++;
                          cb_g_mb_sensor = false;
                    
                    
                    
                      //--- ABFRAGE FUNKTION 3 -----
                      MB.setTimeout(resp_tim_out);
                      //Error errd2 = MB.addRequest(1, mb_client_id, READ_HOLD_REGISTER, 20, 8);   //  void handleData(ModbusMessage response, uint32_t token) 
                      MB.addRequest(1, mb_client_id, READ_HOLD_REGISTER, 20, 8);   //  void handleData(ModbusMessage response, uint32_t token) 
                      //Serial.print("[MB] "); Serial.println(errd2); 
                      //ModbusError e(errd2);
                      //LOG_E("Error creating request: %02X - %s\n", (int)e, (const char *)e);

          //g_radon_new_tb = true;

                      //if (errd2!=SUCCESS ) {


                      //}







                         // #ifdef MB_DETAIL_DEBUG
                          //Serial.println("[MB] READ_HOLD_REGISTER 20, 8  --  Sensor abfrage fehlgeschlagen"); 
                         // #endif


                      //}else{
                          //Serial.println("ok");
                          //#ifdef MB_DETAIL_DEBUG
                          //Serial.println("[MB] READ_HOLD_REGISTER 20, 8  --  Sensor Werte aktualisieren"); 
                         // #endif
                          //g_mb_sensor_3_online = true;
                          
                          //sensor_mb_3_ok = 1;
                          //abfr_mb_finish = 1;

                     // }




}
//-----------------------------------------------------------------





//-----------------------------------------------------------------
void force_ping(){

          if (WiFi.status() == WL_CONNECTED) {
            if (Ping.ping(hostping2)) {
              Internt_online = true;
            } else {
              Internt_online = false;
            }
          }

}
//-----------------------------------------------------------------




//-----------------------------------------------------------------
//90min
void mb4Callback(){
                 

    if (WiFi.status() == WL_CONNECTED) {
        // Testen Sie die Internetverbindung durch einen Ping-Test
        if (Ping.ping(hostping2)) {
          #ifdef WLAN_DEBUG
          Serial.println("[WL][x ] Internetverbindung vorhanden!");
          #endif
          pingFehler = false;
          Internt_online = true;
          fehlerZaehler = 0; // Zähler zurücksetzen
        } else {
          #ifdef WLAN_DEBUG
          Serial.println("[WL][x ] Keine Internetverbindung.");
          #endif
          pingFehler = true;
          Internt_online = false;
          fehlerZaehler++; // Zähler erhöhen
          g_end_boot = true;  // damit webserver geht
          if (fehlerZaehler >= 3) {
            #ifdef WLAN_DEBUG
            Serial.println("[WL][x ] Drei fehlgeschlagene Ping-Tests. ESP wird neu gestartet...");
            #endif
            Preferences preferences;
            preferences.begin("eenvs", false); // Ordner eenvs anlegen/verwenden
            preferences.end();

            g_esp_soft_restart = true;
          }
        }
    } else {
      #ifdef WLAN_DEBUG
        Serial.println(F("[WL][x ] WLAN nicht verbunden, keinen Ping Test."));
        #endif
        Internt_online = false;
    }
                 
                 
                      //--- ABFRAGE FUNKTION 4 -----

                      #ifdef MB_DETAIL_DEBUG
                      Serial.println(F("-------------------------------"));Serial.print(F("[IF] "));Serial.println(p_uhrzeit);
                      Serial.println(F("[MB] Sensor abfrage Seriennummer")); 
                      #endif

                      MB.setTimeout(resp_tim_out);
                      Modbus::Error errd = MB.addRequest(1, mb_client_id, READ_INPUT_REGISTER, 6, 5);    // void handleData(ModbusMessage response, uint32_t token) 
                      //rror errd = MB.addRequest(1, mb_client_id, READ_INPUT_REGISTER, 0, 6);
                      //while (abfr_mb_finish <= 0) {
                      // Serial.println("------------------------ abfr --"); 
                        //Serial.println(errd); 
                        
                        if (errd!=SUCCESS ) {
                            //ModbusError e(err);
                            abfr_mb_finish = 2;
                            //LOG_E("aaaError creating request: %02X - %s\n", (int)e, (const char *)e);

                            sensor_mb_4_ok = 0;
                            g_mb_sensor_4_online = false;
                            #ifdef MB_DETAIL_DEBUG
                            Serial.println("[MB] READ_INPUT_REGISTER 6, 5  --  Sensor abfrage fehlgeschlagen");  
                            #endif


                        }else{
                            //Serial.println("ok");
                            #ifdef MB_DETAIL_DEBUG
                            Serial.println("[MB] READ_INPUT_REGISTER 6, 5  --  Sensor Werte aktualisieren"); // responsegetFunctionCode
                            #endif
                            g_mb_sensor_4_online = true;

                            sensor_mb_4_ok = 1;

                        }


}
//-----------------------------------------------------------------






// Function to print the current time and time difference
void printTimeAndDifference() {
    
   if(disable_server >= 1) {  
          //Serial.println(F("-----------------------------------------"));

          unsigned long epochTimet;

          if (timeClient.forceUpdate()) {
            update_ok_ready = true;
              // Aktualisiere die interne Uhr des ESP
              epochTimet = timeClient.getEpochTime();
              struct timespec tp;
              tp.tv_sec = epochTimet;
              tp.tv_nsec = 0;
              tp.tv_sec = epochTimet;  //hier die Uhrzeit stellen
              clock_settime(CLOCK_REALTIME, &tp);
          }else{
            update_ok_ready = false;
          }

          epochTimet = timeClient.getEpochTime();

          Serial.printf("[IF] UTC :\t\t%lu\n", epochTimet);Serial.println(F(" "));
          
              
          //----------------
          // Funktion, um die Epoch-Zeit der lokalen Zeit zu berechnen
          time_t now;
          char strftime_buf[64];
          struct tm timeinfo;
          time(&now);
          localtime_r(&now, &timeinfo);
          // Überprüfen, ob die Sommerzeit aktiv ist
          if (timeinfo.tm_isdst > 0) {
              //Serial.println("[IF] Sommerzeit ist aktiv.");
          } else {
              //Serial.println("[IF] Winterzeit ist aktiv.");
          }
          /*
          struct tm timeinfot;
          // Zeitinformationen aus den Variablen setzen
          timeinfot.tm_year = (year < 100 ? year + 100 : year) - 1900; // Jahre seit 1900
          timeinfot.tm_mon = currentmonth - 1;  
          timeinfot.tm_mday = currentdate;
          timeinfot.tm_hour = currenthour;
          timeinfot.tm_min = currentmin;
          timeinfot.tm_sec = currentSec;
          timeinfot.tm_isdst = -1;         // Automatische Sommerzeit-Erkennung
        */
          // Epoch-Zeit der lokalen Zeit berechnen
          //time_t localEpochTime = mktime(&timeinfot);
          //Serial.printf("[IF] Local Epoch Time:\t%ld\n", localEpochTime);Serial.println(F(" "));
          //----------------

          // Calculate UTC time in hours, minutes, and seconds
          int utcHours = (epochTimet % 86400L) / 3600;
          int utcMinutes = (epochTimet % 3600) / 60;
          int utcSeconds = epochTimet % 60;
          Serial.printf("[IF] UTC time:\t\t%02d:%02d:%02d\n", utcHours, utcMinutes, utcSeconds); Serial.println(F(" "));
        

          // Print the local time
          strftime(strftime_buf, sizeof(strftime_buf), "%H:%M:%S", &timeinfo);
          printf("[IF] Local time:\t%s\n", strftime_buf);

          // Calculate the time difference in hours
          timeDifference = timeinfo.tm_hour - utcHours;
              char signc = '+';
              if (timeDifference < 0) {
                  timeDifference += 24;
                  signc = '+';
              } else if (timeDifference > 12) {
                  timeDifference -= 24;
                  signc = '-';
              } else if (timeDifference == 0) {
                  signc = '+';
              }





          // Print the time difference
          Serial.printf("[IF] Time difference to UTC: %c%d hours\n", signc, timeDifference);Serial.println(F(" "));

            // Create a string variable to store the time difference
            char timeDifferenceStr_c[10];
            sprintf(timeDifferenceStr_c, "%c%d", signc, timeDifference);
            timeDifferenceStr = String(signc) + String(timeDifference);

            // Print the time difference
            //Serial.println(timeDifferenceStr_c);
            //Serial.println(F(" "));
        // printf("[AP] FREE HEAP: now: %u, contiguous: %u, lowest: %u\n",xPortGetFreeHeapSize(),heap_caps_get_largest_free_block(MALLOC_CAP_DEFAULT),xPortGetMinimumEverFreeHeapSize());
          

                          Serial.print("Hour: ");
                          Serial.print(myRTC.getHour2());
                          Serial.print(" | Minute: ");
                          Serial.print(myRTC.getMinute());
                          Serial.print(" | Second: ");
                          Serial.println(myRTC.getSecond());
                      
                          //currentSec = timeClient.getSeconds();
                          //currentmin = timeClient.getMinutes();
                          //currenthour = currenthour; // Stunden mit Sommer Winter

                          //sprintf(uhrzeit_c,"%02d:%02d:%02d",currenthour,currentmin,currentSec);
                          //p_uhrzeit = String(uhrzeit_c);
                          Serial.print("Hour: ");
                          Serial.print(currenthour);
                          Serial.print(" | Minute: ");
                          Serial.print(timeClient.getMinutes());
                          Serial.print(" | Second: ");
                          Serial.println(timeClient.getSeconds());


          Serial.println(F("-----------------------------------------"));
    }
}
//------------------------------------------------------------------




//------------------------------------------------------------------
  // pingFehler = false;   // false ist internet ok
  // Internt_online
     //     if(g_u_mez_ea_ist == 1){        // aktiv
    //        if(update_ntp_ready == 0){    // kein ntp
    //  call_time_set_g

void checkAndAdjustNTPTime() {
    
    esp_task_wdt_reset();

    // Prüfen, ob die Zeit 02:00 oder 03:59 erreicht ist und ob es sich um den Beginn einer neuen Minute handelt
    if (!alreadyAdjustedcheck && currentmin == 0) {
       alreadyAdjustedcheck = true;

          TM_DEBUG_MAX_PRINT(F("sommerzeit: ")); 
          TM_DEBUG_MAX_PRINTLN(sommerzeit);
          TM_DEBUG_MAX_PRINT(F("v_currenthour: ")); 
          TM_DEBUG_MAX_PRINTLN(v_currenthour);
          TM_DEBUG_MAX_PRINT(F("g_Set_mesz: ")); 
          TM_DEBUG_MAX_PRINTLN(g_Set_mesz);
          TM_DEBUG_MAX_PRINT(F("Set_mesz: ")); 
          TM_DEBUG_MAX_PRINTLN(Set_mesz);

          TM_DEBUG_MAX_PRINT(F("Zeiteinstellung: "));
          TM_DEBUG_MAX_PRINTLN(sommerzeit ? F("Sommerzeit") : F("Winterzeit"));
          TM_DEBUG_MAX_PRINT(F("Zeit MESZ Bit: "));
          TM_DEBUG_MAX_PRINTLN(Set_mesz ? F("True") : F("False"));

          sommerzeit = summertime_EU(2000 + s_year, s_month, s_date, v_currenthour, 1);

          TM_DEBUG_MAX_PRINTLN(F(" "));

          TM_DEBUG_MAX_PRINT(F("sommerzeit: ")); 
          TM_DEBUG_MAX_PRINTLN(sommerzeit);
          TM_DEBUG_MAX_PRINT(F("v_currenthour: ")); 
          TM_DEBUG_MAX_PRINTLN(v_currenthour);
          TM_DEBUG_MAX_PRINT(F("g_Set_mesz: ")); 
          TM_DEBUG_MAX_PRINTLN(g_Set_mesz);
          TM_DEBUG_MAX_PRINT(F("Set_mesz: ")); 
          TM_DEBUG_MAX_PRINTLN(Set_mesz);

          TM_DEBUG_MAX_PRINT(F("Zeiteinstellung: "));
          TM_DEBUG_MAX_PRINTLN(sommerzeit ? F("Sommerzeit") : F("Winterzeit"));
          TM_DEBUG_MAX_PRINT(F("Zeit MESZ Bit: "));
          TM_DEBUG_MAX_PRINTLN(Set_mesz ? F("True") : F("False"));




          if ((sommerzeit == 1 && Set_mesz == false) || (sommerzeit == 0 && Set_mesz == true)) {  // bei Unterschied ausführen
              if (sommerzeit == 1) {
                  TM_DEBUG_MED_PRINTLN(F("[TM] !!! Es ist Sommer, bit falsch - set2 | MESZ"));
                  Set_mesz = true;
                  g_Set_mesz = 0;
              } else {
                  TM_DEBUG_MED_PRINTLN(F("[TM] !!! Es ist Winter, bit falsch - set2 | MEZ"));
                  Set_mesz = false;  // Winter
                  g_Set_mesz = 1;    // Winter
              }

              Preferences preferences;
              preferences.begin("eenvs", false);  // Ordner eenvs anlegen/verwenden
              preferences.putUInt("g_Set_mesz", g_Set_mesz);  // Variable speichern  
              preferences.end();
          }




          if (!sommerzeit && v_currenthour == 2) {
              TM_DEBUG_MED_PRINTLN(F("[TM]++++++++++++++++++ Keine Aktion, da wir hier die Winterzeit beibehalten"));
          } else {
              if (!sommerzeit && v_currenthour == 3 && g_Set_mesz == 1) {
                  //currenthour--; // Winterzeit erkennen
                  TM_DEBUG_MED_PRINTLN(F("[TM]++++++++++++++++++ Winterzeit erkannt, eine Stunde zurückstellen"));
                  alreadyAdjusted = true;
              } else if (sommerzeit && v_currenthour == 2 && g_Set_mesz == 0) {
                  //currenthour++; // Sommerzeit erkennen
                  TM_DEBUG_MED_PRINTLN(F("[TM]++++++++++++++++++ Sommerzeit erkannt, eine Stunde hinzufügen"));
                  alreadyAdjusted = true;
              } else {
                  TM_DEBUG_MED_PRINTLN(F("[TM]++++++++++++++++++ Keine Aktion."));
                  TM_DEBUG_MED_PRINT(F("Zeiteinstellung: "));
                  TM_DEBUG_MED_PRINTLN(sommerzeit ? F("Sommerzeit") : F("Winterzeit"));
                  TM_DEBUG_MED_PRINT(F("Zeit MESZ Bit: "));
                  TM_DEBUG_MED_PRINTLN(Set_mesz ? F("True") : F("False"));
              }

              if (alreadyAdjusted) {
                  TM_DEBUG_MED_PRINTLN(F("[TM]++++++++++++++++++ Zeitkomponenten aktualisieren"));



                  //update_bl_clock = 1; // damit ohne NTP ok die Uhr gestellt werden kann
                  //set_BT_RTC_Time = true;
                  not_write_time = true;
                  call_time_set_g();
                  not_write_time = false;

                  // CET-1CEST,M3.5.0,M10.5.0/3

                  // Variable speichern

                  Preferences preferences;
                  preferences.begin("eenvs", false); // Ordner "eenvs" anlegen/verwenden
                  //preferences.putUInt("g_Set_mesz", g_Set_mesz); // Variable speichern

                  alreadyAdjusted = false;
                  TM_DEBUG_MAX_PRINTLN(F("[TM]++++++++++++++++++ alreadyAdjusted zurückgesetzt"));
                  preferences.putBool("alreadyAdjusted", alreadyAdjusted); // Variable speichern
                  preferences.end();
              }
          }





    }



    // alreadyAdjustedcheck um Mitternacht zurücksetzen
    if (alreadyAdjustedcheck == true) {
      if (currentmin != 0) {

          alreadyAdjustedcheck = false;
          //Serial.println(F("[TM]++++++++++++++++++ alreadyAdjustedcheck zurückgesetzt"));

      }
    }


    if (alreadycheckNTP == true && currentmin == 52) {
      ntp_update_start = false;
      alreadycheckNTP = false;
    }
    if (alreadycheckNTP == false && currentmin == 56) {
      alreadycheckNTP = true;
    }



}
//------------------------------------------------------------------------

// 23:59:30 26-10-2024    //dann 00:59:30 27-10-2024  //dann ist 2:58 und sollte von 3uhr auf 2uhr zurückgestellt werden
// 05:59:30 27-10-2024 


// 00:59:50 30-03-2025


 //Time difference to UTC

//------------------------------------------------------------------




      //------------------------------------------------------------------
      void readAndSendData(int mode) {

          g_wlan_read = true;
          
          File file = SPIFFS.open("/wlan_data.txt", FILE_READ);
          if (!file) {
              Serial.println("Failed to open file for reading");
              return;
          }

          int count = 0;          
          while (file.available()) {
              String line = file.readStringUntil('\n');
              count++;
              int firstDelimiter = line.indexOf(",|");
              int secondDelimiter = line.indexOf(",|", firstDelimiter + 2);
              String ssid = line.substring(firstDelimiter + 2, secondDelimiter);
              ssid.trim(); // Entfernt führende und nachfolgende Leerzeichen
              if (count < maxSSIDs) {
                  ssid.toCharArray(wlan_ssids[count], 32);
              }
              esp_task_wdt_reset();
          }

          if (mode == 0) {
              Serial.println(F("[BT] Ausgabe nur die Anzahl Seriell"));
          } else if (mode == 1) {
              Serial.println(F("[BT] Ausgabe alles nur Seriell"));
          } else if (mode == 2) {
              Serial.println(F("[BT] Ausgabe alles Seriell und BT"));
          } else if (mode == 3) {
              Serial.println(F("[BT] Ausgabe Anzahl Seriell und BT"));
          }


          String foundMessage = "Found:" + String(count);  // +1 ?
          wlan_found = count;
          //Serial.println(foundMessage);

          if (mode == 2 || mode == 3) {
              // Bluetooth code to send the found message
              String btMessage = foundMessage + "\r\n";
              pTxCharacteristic->setValue(btMessage.c_str());
              pTxCharacteristic->notify();

              size_t message_length = strlen(btMessage.c_str());
              sentTraffic += message_length; 
              delay(300); // bluetooth stack will go into congestion, if too many packets are sent
              esp_task_wdt_reset();
          }

          if (mode != 0) {
              file.seek(0); // Reset file pointer to the beginning

              while (file.available()) {
                  String line = file.readStringUntil('\n');
                  if (mode == 1 || mode == 2) {
                      //Serial.print("[BF] ");
                      //Serial.println(line);
                  }
                  if (mode == 2) {
                      // Bluetooth code to send the data
                      pTxCharacteristic->setValue(line.c_str());
                      pTxCharacteristic->notify();
                      size_t message_length = strlen(line.c_str());
                      sentTraffic += message_length; 
                      delay(100); // bluetooth stack will go into congestion, if too many packets are sent
                  }
                  esp_task_wdt_reset();
              }
          }

          file.close();

          
          Serial.println(F("------------------------------"));
          g_wlan_read = false;
      }
      //------------------------------------------------------------------












//-----------------------------------------------------------------
void btCallback(){


        //---------------------------------------------------- 
        if (startplayer == true && g_LEDT_T_KNX == 0) {
          tick6 = !tick6;
          if (tick6 == true) {
                     if(g_unit_ist == 1){  
                      if(g_LEDT_F_ist == 1){  
                        ledcWrite(ledChannel2, dutyCycle_t215);    //   GPIO02  Bq/m³
                      }
                        ledcWrite(ledChannel15, 0);                //   GPIO15  PcI/L
                        
                     }else{
                      if(g_LEDT_F_ist == 1){ 
                         ledcWrite(ledChannel15, dutyCycle_t215);  //   GPIO15  PcI/L
                      }
                         ledcWrite(ledChannel2, 0);                //   GPIO02  Bq/m³
                     } 
          }else{
                     if(g_unit_ist == 1){  
                        ledcWrite(ledChannel2, 0);    //   GPIO02  Bq/m³
                        ledcWrite(ledChannel15, 0);                //   GPIO15  PcI/L
                        
                     }else{
                         ledcWrite(ledChannel15, 0);  //   GPIO15  PcI/L
                         ledcWrite(ledChannel2, 0);                //   GPIO02  Bq/m³
                     } 
          }
        } 
        //---------------------------------------------------- 





        

    
    bt_send_back = false;
    if (deviceConnected && bt_send_back == true) {
        bt_send_back = false;
        
      
        String tempstr;
        tempstr = "FRITZ!Box 6490 Holger";
        int length = tempstr.length();
        tempstr.toCharArray(find_wlan, length+1); 

        pTxCharacteristic->setValue(find_wlan);
        pTxCharacteristic->notify();
        size_t message_length = strlen(find_wlan);
        sentTraffic += message_length;  
        //Serial.println(find_wlan);
      

          Preferences preferences;
          preferences.begin("eenvs", false);                         // Ordner eenvs anlegen/verwenden       
          preferences.putBytes("wSSID_s", wIFI_SSID_c, strlen(wIFI_SSID_c) + 1); 
          preferences.putBytes("wPWD_s", wIFI_PASSWORD_c, strlen(wIFI_PASSWORD_c) + 1); 
          preferences.putBytes("encryption", wlan_encryptionType[ist_wlan], strlen(wlan_encryptionType[ist_wlan]) + 1);
          preferences.end();

         /*
          int lengtht = wIFI_SSID_s.length();
          wIFI_SSID_s.toCharArray(wIFI_SSID_c, lengtht+1); 
          lengtht = wIFI_PASSWORD_s.length();
          wIFI_PASSWORD_s.toCharArray(wIFI_PASSWORD_c, lengtht+1); 
          */
          // Keine Konvertierungen mehr notwendig, da direkt mit char Arrays gearbeitet wird
          strcpy(wIFI_SSID_c, "FRITZ!Box 6490 Holger"); // Initialisiere das char Array mit dem SSID
          strcpy(wIFI_PASSWORD_c, "15400240614617116002"); // Initialisiere das char Array mit dem Passwort

          

        
        WiFi.disconnect();
        g_InitWiFi = true;     // InitWiFi();  
       
        
        //pTxCharacteristic->setValue(&txValue, 1);
        //pTxCharacteristic->notify();
        //txValue++;
		//delay(10); // bluetooth stack will go into congestion, if too many packets are sent
	}
    

    // disconnecting
    if (!deviceConnected && oldDeviceConnected) {
        //delay(500); // give the bluetooth stack the chance to get things ready
        pServer->startAdvertising(); // restart advertising
        //Serial.println("[BT] Start advertising");
        Serial.println(F("[BT] BT disconnect"));
        g_bt_start_conn = false;
        g_login = false;
        g_bl_connect = false;
        g_connect_start = false;   // neue Verbindung init
        oldDeviceConnected = deviceConnected;

    }
    // connecting
    if (deviceConnected && !oldDeviceConnected) {
		// do stuff here on connecting
        oldDeviceConnected = deviceConnected;
        if(g_bt_start_conn == false){
          g_bt_start_conn = true;
          Serial.println(F("[BT] BT Start Connect"));
          g_bl_connect = true;
          g_showani = true;   // LED Animation aktivieren
          #ifdef ea_webserver
          #ifdef j_2_webserver
          if(disable_server >= 1 && TB_currFwVersion == TB_newFwVersion) {
          if (loggingEnabled) {
          //things_list_t_16 = p_uhrzeit + "  [BT] BT Start Connect";
          write_to_log(things_list_t_16);
          }
          }
          #endif
          #endif
        }
        

    }


}
//-----------------------------------------------------------------



      //-----------------------------------------------------------------

            volatile bool sendNotification = false;
            volatile bool sendNotification_task = false;
            String notificationMessagestr;
            char notificationMessage[512]; 

            QueueHandle_t notificationQueue;
            TaskHandle_t notificationTaskHandle;

        
            void notificationTask(void *pvParameters) {
                char message[512];
                for (;;) {
                    if (xQueueReceive(notificationQueue, &message, portMAX_DELAY)) {
                        // Debug-Ausgabe
                        //Serial.print(F("Nachrichtenlaenge: "));
                        //Serial.println(strlen(message));
                        //Serial.print(F("Benachrichtigung sendet: "));
                        //Serial.println(message);

                        // Nachricht senden
                        pTxCharacteristic->setValue(message);
                        pTxCharacteristic->notify();

                        // Benachrichtigung als gesendet markieren
                        sendNotification = false;
                        sendNotification_task = false;

                        // Watchdog zurücksetzen
                        esp_task_wdt_reset();
                    }
                }
            }
         /*
          void notificationTask(void *pvParameters) {
              char message[512];
              for (;;) {
                  if (xQueueReceive(notificationQueue, &message, portMAX_DELAY)) {
                      // Länge extrahieren
                      int message_length = 0;
                      sscanf(message, "%04d", &message_length);
                      if (message_length > 0 && message_length < sizeof(message) - 4) {
                          char actual_message[512];
                          strncpy(actual_message, message + 4, message_length);
                          actual_message[message_length] = '\0';  // Nullterminierung sicherstellen

                          // Debug-Ausgabe
                          Serial.print("Nachrichtenlänge: ");
                          Serial.println(strlen(actual_message));
                          Serial.print("Benachrichtigung sendet: ");
                          Serial.println(actual_message);


                          // Nachricht senden
                          pTxCharacteristic->setValue(actual_message);
                          pTxCharacteristic->notify();
                      } else {
                          Serial.println("Fehler: Ungültige Nachrichtenlänge");
                      }

                      // Benachrichtigung als gesendet markieren
                      sendNotification = false;

                      // Watchdog zurücksetzen
                      esp_task_wdt_reset();
                  }
              }
          }

   */

        

      //-----------------------------------------------------------------


      //-----------------------------------------------------------------
      void queueNotification_task(const char* message) {
          size_t message_length = strlen(message);
          if (message_length >= sizeof(notificationMessage) - 4) { // -4 für die Längenangabe
              Serial.println("Fehler a: Nachricht zu lang für Puffer");
              return;
          }
          // Puffer leeren und sicherstellen, dass die Nachricht korrekt formatiert ist
          memset(notificationMessage, 0, sizeof(notificationMessage));
          strncpy(notificationMessage, message, sizeof(notificationMessage) - 1);
          esp_task_wdt_reset();

          // Debug-Ausgabe
          //Serial.print("Sende: ");
          //Serial.println(notificationMessage);
          

          
          // Benachrichtigung senden
          sendNotification_task = true;
          unsigned long start = millis();
          while(sendNotification_task) {
              if (millis() - start > 2000) {
                  Serial.println("Fehler a: Zeitüberschreitung beim Senden");
                  sendNotification_task = false; // sendNotification zurücksetzen
                  esp_task_wdt_reset();
                  break;
              }
          }
      }

      void queueNotification(const char* message) {
          size_t message_length = strlen(message);
          if (message_length >= sizeof(notificationMessage) - 4) { // -4 für die Längenangabe
              Serial.println(F("Fehler b: Nachricht zu lang für Puffer"));
              return;
          }
          // Puffer leeren und sicherstellen, dass die Nachricht korrekt formatiert ist
          memset(notificationMessage, 0, sizeof(notificationMessage));
          strncpy(notificationMessage, message, sizeof(notificationMessage) - 1);
          esp_task_wdt_reset();

          // Debug-Ausgabe
          //Serial.print("Sende: ");
          //Serial.println(notificationMessage);
          
          // Gesendeten Traffic erfassen

          
          // Benachrichtigung senden
          sendNotification = true;
          unsigned long start = millis();
          while(sendNotification) {
              if (millis() - start > 2000) {
                  Serial.println(F("Fehler b: Zeitüberschreitung beim Senden"));
                  sendNotification = false; // sendNotification zurücksetzen
                  esp_task_wdt_reset();
                  break;
              }
          }
      }




      //-----------------------------------------------------------------




      //-----------------------------------------------------------------
          // Funktion zum Senden eines Werts

          void queueValue(const char* id, int value) {
              char tempstr0[64];
              snprintf(tempstr0, sizeof(tempstr0), "|%s%d;", id, value);
              Serial.print(F("Sende: "));
              Serial.println(tempstr0);
              esp_task_wdt_reset();

              snprintf(notificationMessage, sizeof(notificationMessage), "%s", tempstr0);
              sendNotification = true;
              sendNotification_task = true; // Setze auch das Task-Flag

              unsigned long start = millis();
              while (sendNotification) {
                  if (millis() - start > 5000) { // Timeout auf 5 Sekunden erhöhen
                      Serial.println(F("Fehler c: Zeitüberschreitung beim Senden"));
                      sendNotification = false;  // sendNotification zurücksetzen
                      esp_task_wdt_reset();
                      break;
                  }
                  // Füge eine kurze Verzögerung hinzu, um eine Race Condition zu vermeiden
                  delay(10);
              }
          }

          void queueStringValue(const char* id, const char* value) {
              char tempstr0[64];
              snprintf(tempstr0, sizeof(tempstr0), "|%s%s;", id, value);
              Serial.print(F("Sende: "));
              Serial.println(tempstr0);
              esp_task_wdt_reset();

              snprintf(notificationMessage, sizeof(notificationMessage), "%s", tempstr0);
              sendNotification = true;
              sendNotification_task = true; // Setze auch das Task-Flag

              unsigned long start = millis();
              while (sendNotification) {
                  if (millis() - start > 5000) { // Timeout auf 5 Sekunden erhöhen
                      Serial.println(F("Fehler d: Zeitüberschreitung beim Senden"));
                      sendNotification = false;  // sendNotification zurücksetzen
                      esp_task_wdt_reset();
                      break;
                  }
                  // Füge eine kurze Verzögerung hinzu, um eine Race Condition zu vermeiden
                  delay(10);
              }
          }



   
      

      //-----------------------------------------------------------------





        // Werte einzeln senden
      void sendValuesIndividually() {
          queueValue("A01", g_unit_ist);
          while (sendNotification); // Warten bis gesendet

          queueValue("A02", g_LEDT_T_ist);
          while (sendNotification);

          queueValue("A03", g_LEDT_F_ist);
          while (sendNotification);

          queueValue("A04", g_LEDT_FB_ist);
          while (sendNotification);

          queueValue("A05", g_LEDT_TB_ist);
          while (sendNotification);

          queueValue("A06", g_LEDT_TF_ist);
          while (sendNotification);

          queueValue("A07", g_Range_T_ist);
          while (sendNotification);

          queueValue("A08", g_Range_M_ist);
          while (sendNotification);

          queueValue("A09", g_Range_U_ist);
          while (sendNotification);

          queueValue("A10", g_u_clock_ist);
          while (sendNotification);

          queueValue("A11", g_u_view_switch_ist);
          while (sendNotification);

          queueValue("A12", g_u_beacon_ist);
          while (sendNotification);

          queueValue("A13", g_u_buzzer_ea);
          while (sendNotification);

          queueValue("A14", g_Buzzer_ist);
          while (sendNotification);

          queueValue("A15", g_u_mez_ea_ist);
          while (sendNotification);

          queueStringValue("A16", wIFI_SSID_c);
          while (sendNotification);

          queueStringValue("A17", g_u_ntp3_ist);
          while (sendNotification);

          queueStringValue("A18", g_u_timezone_ist.c_str());
          while (sendNotification);

          queueStringValue("A19", "0");
          while (sendNotification);
      }
//-----------------------------------------------------------------





     //-----------------------------------------------------------------
    void sendValuesKNXIndividually() {


    }
    //-----------------------------------------------------------------




   
      //-----------------------------------------------------------------
      void sendValuesIndividually2() {

            String tempstr = "";
          
              
            if (WiFi_status == WL_CONNECTED) {
                tempstr = "WIFI Status OK\r\n";
                queueNotification(tempstr.c_str());
                while (sendNotification);
            } else {
                tempstr = "WIFI Status ERROR\r\n";
                queueNotification(tempstr.c_str());
                while (sendNotification);
            }

   


            if(g_TB_connect_Status == false) {
                tempstr = "TB Disconnect\r\n";
                queueNotification_task(tempstr.c_str());
                while (sendNotification);
            } else {
                tempstr = "TB Connect\r\n";
                queueNotification(tempstr.c_str());
                while (sendNotification);
            }

   

            if(g_sensor_online > 2) {
                tempstr = "Sensor ERROR\r\n";
                queueNotification(tempstr.c_str());
                while (sendNotification);
            } else {
                tempstr = "Sensor Connect OK\r\n";
                queueNotification(tempstr.c_str());
                while (sendNotification);
            }


            if(requestedShared_fail == true) {
                tempstr = "Requested Shared 0 ERROR\r\n";
                queueNotification(tempstr.c_str());
                while (sendNotification);
            } else {
                tempstr = "Requested Shared 0 OK\r\n";
                queueNotification(tempstr.c_str());
                while (sendNotification);
            }
  

            if(requestedShared1_fail == true) {
                tempstr = "Requested Shared 1 ERROR\r\n";
                queueNotification(tempstr.c_str());
                while (sendNotification);
            } else {
                tempstr = "Requested Shared 1 OK\r\n";
                queueNotification(tempstr.c_str());
                while (sendNotification);
            }


            if(requestedShared2_fail == true) {
                tempstr = "Requested Shared 2 ERROR\r\n";
                queueNotification(tempstr.c_str());
                while (sendNotification);
            } else {
                tempstr = "Requested Shared 2 OK\r\n";
                queueNotification(tempstr.c_str());
                while (sendNotification);
            }

            if(requestedShared3_fail == true) {
                tempstr = "Requested Shared 3 ERROR\r\n";
                queueNotification(tempstr.c_str());
            } else {
                tempstr = "Requested Shared 3 OK\r\n";
                queueNotification(tempstr.c_str());
                while (sendNotification);
            }


            if(requestedShared4_fail == true) {
                tempstr = "Requested Shared 4 ERROR\r\n";
                queueNotification(tempstr.c_str());
                while (sendNotification);
            } else {
                tempstr = "Requested Shared 4 OK\r\n";
                queueNotification(tempstr.c_str());
                while (sendNotification);
            }


            if(sendRequestedShared6_ok == false) {
                tempstr = "Requested Shared 6 ERROR\r\n";
                queueNotification(tempstr.c_str());
                while (sendNotification);
            } else {
                tempstr = "Requested Shared 6 OK\r\n";
                queueNotification(tempstr.c_str());
                while (sendNotification);
            }
  

            if(sendRequestedShared7_ok == false) {
                tempstr = "Requested Shared 7 ERROR\r\n";
                queueNotification(tempstr.c_str());
                while (sendNotification);
            } else {
                tempstr = "Requested Shared 7 OK\r\n";
                queueNotification(tempstr.c_str());
                while (sendNotification);
            }
    

            if(sendRequestedShared8_ok == false) {
                tempstr = "Requested Shared 8 ERROR\r\n";
                queueNotification(tempstr.c_str());
                while (sendNotification);
            } else {
                tempstr = "Requested Shared 8 OK\r\n";
                queueNotification(tempstr.c_str());
                while (sendNotification);
            }
 


            if(sendAttributes11_ok == false) {
                tempstr = "Send Attributes 11 ERROR\r\n";
                queueNotification(tempstr.c_str());
                while (sendNotification);
            } else {
                tempstr = "Send Attributes 11 OK\r\n";
                queueNotification(tempstr.c_str());
                while (sendNotification);
            }
    

            if(sendAttributes12_ok == false) {
                tempstr = "Send Attributes 12 ERROR\r\n";
                queueNotification(tempstr.c_str());
                while (sendNotification);
            } else {
                tempstr = "Send Attributes 12 OK\r\n";
                queueNotification(tempstr.c_str());
                while (sendNotification);
            }


            if(sendAttributes13_ok == false) {
                tempstr = "Send Attributes 13 ERROR\r\n";
                queueNotification(tempstr.c_str());
                while (sendNotification);
            } else {
                tempstr = "Send Attributes 13 OK\r\n";
                queueNotification(tempstr.c_str());
                while (sendNotification);
            }
   

            if(sendAttributes14_ok == false) {
                tempstr = "Send Attributes 14 ERROR\r\n";
                queueNotification(tempstr.c_str());
                while (sendNotification);
            } else {
                tempstr = "Send Attributes 14 OK\r\n";
                queueNotification(tempstr.c_str());
                while (sendNotification);
            }


            if(sendAttributes15_ok == false) {
                tempstr = "Send Attributes 15 ERROR\r\n";
                queueNotification(tempstr.c_str());
                while (sendNotification);
            } else {
                tempstr = "Send Attributes 15 OK\r\n";
                queueNotification(tempstr.c_str());
                while (sendNotification);
            }

            if(sendAttributes16_ok == false) {
                tempstr = "Send Attributes 16 ERROR\r\n";
                queueNotification(tempstr.c_str());
                while (sendNotification);
            } else {
                tempstr = "Send Attributes 16 OK\r\n";
                queueNotification(tempstr.c_str());
                while (sendNotification);
            }

            if(sendAttributes17_ok == false) {
                tempstr = "Send Attributes 17 ERROR\r\n";
                queueNotification(tempstr.c_str());
                while (sendNotification);
            } else {
                tempstr = "Send Attributes 17 OK\r\n";
                queueNotification(tempstr.c_str());
                while (sendNotification);
            }
   

            if(sendAttributes19_ok == false) {
                tempstr = "Send Attributes 19 ERROR\r\n";
                queueNotification(tempstr.c_str());
                while (sendNotification);
            } else {
                tempstr = "Send Attributes 19 OK\r\n";
                queueNotification(tempstr.c_str());
                while (sendNotification);
            }
       

            if(sendAttributes25_ok == false) {
                tempstr = "Send Attributes 25 ERROR\r\n";
                queueNotification(tempstr.c_str());
                while (sendNotification);
            } else {
                tempstr = "Send Attributes 25 OK\r\n";
                queueNotification(tempstr.c_str());
                while (sendNotification);
            }


            if(sendAttributes26_ok == false) {
                tempstr = "Send Attributes 26 ERROR\r\n";
                queueNotification(tempstr.c_str());
                while (sendNotification);
            } else {
                tempstr = "Send Attributes 26 OK\r\n";
                queueNotification(tempstr.c_str());
                while (sendNotification);
            }




            if(sendAttributes27_ok == false) {
              tempstr = "Send Attributes 27 ERROR\r\n";
              queueNotification(tempstr.c_str());
              while (sendNotification);
            } else {
                tempstr = "Send Attributes 27 OK\r\n";
                queueNotification(tempstr.c_str());
                while (sendNotification);
            }


            if(sendAttributes28_ok == false) {
                tempstr = "Send Attributes 28 ERROR\r\n";
                queueNotification(tempstr.c_str());
                while (sendNotification);
            } else {
                tempstr = "Send Attributes 28 OK\r\n";
                queueNotification(tempstr.c_str());
                while (sendNotification);
            }
  

            if(sendAttributes29_ok == false) {
                tempstr = "Send Attributes 29 ERROR\r\n";
                queueNotification(tempstr.c_str());
                while (sendNotification);
            } else {
                tempstr = "Send Attributes 29 OK\r\n";
                queueNotification(tempstr.c_str());
                while (sendNotification);
            }
     

            if(sendAttributes30_ok == false) {
                tempstr = "Send Attributes 30 ERROR\r\n";
                queueNotification(tempstr.c_str());
                while (sendNotification);
            } else {
                tempstr = "Send Attributes 30 OK\r\n";
                queueNotification(tempstr.c_str());
                while (sendNotification);
            }
 

            if(sendAttributes31_ok == false) {
                tempstr = "Send Attributes 31 ERROR\r\n";
                queueNotification(tempstr.c_str());
                while (sendNotification);
            } else {
                tempstr = "Send Attributes 31 OK\r\n";
                queueNotification(tempstr.c_str());
                while (sendNotification);
            }


            if(sendAttributes32_ok == false) {
                tempstr = "Send Attributes 32 ERROR\r\n";
                queueNotification(tempstr.c_str());
                while (sendNotification);
            } else {
                tempstr = "Send Attributes 32 OK\r\n";
                queueNotification(tempstr.c_str());
                while (sendNotification);
            }
     

            if(sendAttributes33_ok == false) {
                tempstr = "Send Attributes 33 ERROR\r\n";
                queueNotification(tempstr.c_str());
                while (sendNotification);
            } else {
                tempstr = "Send Attributes 33 OK\r\n";
                queueNotification(tempstr.c_str());
                while (sendNotification);
            }

            if(requestedSharedx_fail == true) {
                tempstr = "Not all Requested Shared read\r\n";
                queueNotification(tempstr.c_str());
                while (sendNotification);
            } else {
                tempstr = "All Requested Shared read OK\r\n";
                queueNotification(tempstr.c_str());
                while (sendNotification);
            }
            

            if(Shared_Attributes_Subscribe_fail == true) {
                tempstr = "All Shared Attributes Subscribe ERROR\r\n";
                queueNotification(tempstr.c_str());
                while (sendNotification);
            } else {
                tempstr = "All Shared Attributes Subscribe OK\r\n";
                queueNotification(tempstr.c_str());
                while (sendNotification);
            }
            

  

              // WiFi Connect Status
              tempstr = "WIFI Connect ERROR\t\t| : "; 
              tempstr += String(count_InitWiFi); 
              tempstr += "\r\n";
              if(count_InitWiFi >= 1){
                  queueNotification(tempstr.c_str());
                  while (sendNotification);
              } else {
                  queueNotification("WIFI Connect OK\r\n");
                  while (sendNotification);
              }
        

              // TB Connect Status
              tempstr = "TB Connect ERROR\t\t| : "; 
              tempstr += String(count_InitTB); 
              tempstr += "\r\n";
              if(count_InitTB >= 1){
                  queueNotification(tempstr.c_str());
                  while (sendNotification);
              } else {
                  queueNotification("TB Connect OK\r\n");
                  while (sendNotification);
              }
         

              // TB Shared Status
              tempstr = "TB Shared ERROR\t\t| : "; 
              tempstr += String(count_subscribedSHARED); 
              tempstr += "\r\n";
              if(count_subscribedSHARED >= 1){
                  queueNotification(tempstr.c_str());
                  while (sendNotification);
              } else {
                  queueNotification("TB Shared OK\r\n");
                  while (sendNotification);
              }
               
           

              if(update_ntp_ready == 0) {
                  tempstr = "NTP Update ERROR\r\n";
                  queueNotification(tempstr.c_str());
                  while (sendNotification);
              } else {
                  tempstr = "NTP Update OK\r\n";
                  queueNotification(tempstr.c_str());
                  while (sendNotification);
              }
        

              if(update_rtc_ready == 0) {
                  tempstr = "RTC nicht gestellt\r\n";
                  queueNotification(tempstr.c_str());
                  while (sendNotification);
              } else {
                  tempstr = "RTC gestellt OK\r\n";
                  queueNotification(tempstr.c_str());
                  while (sendNotification);
              }
           

              if(g_u_mez_ea_ist == 1) {
                  if(Set_mesz == true) {
                      tempstr = "Es ist Sommer | MESZ\r\n";
                      queueNotification(tempstr.c_str());
                      while (sendNotification);
                  } else {
                      tempstr = "Es ist Winter | MEZ\r\n";
                      queueNotification(tempstr.c_str());
                      while (sendNotification);
                  }
              }
    
    

              if(g_u_mez_ea_ist == 1) {
                  tempstr = "Zeitumstellung aktiviert\r\n";
                  queueNotification(tempstr.c_str());
                  while (sendNotification);
              } else {
                  tempstr = "Zeitumstellung deaktiviert\r\n";
                  queueNotification(tempstr.c_str());
                  while (sendNotification);
              }
          

              if(rtc_oszi == true) {
                  tempstr = "RTC Clock OK\r\n";
                  queueNotification(tempstr.c_str());
                  while (sendNotification);
              } else {
                  tempstr = "RTC Clock inaccurate\r\n";
                  queueNotification(tempstr.c_str());
                  while (sendNotification);
              }

      }
      
      //-----------------------------------------------------------------




    //-------------------------------------------------------------------------------------------
      void debugVariables() {
          

          Serial.print(F("v_currenthour: "));
          Serial.println(v_currenthour);
          Serial.print(F("currentmin: "));
          Serial.println(currentmin);

          
          Serial.print(F("clock_start: "));
          Serial.println(clock_start);
          Serial.print(F("gFW_Update_start: "));
          Serial.println(gFW_Update_start);
          Serial.print(F("g_identify: "));
          Serial.println(g_identify);
          Serial.print(F("akt_fw_load: "));
          Serial.println(akt_fw_load);
          Serial.print(F("g_kalibrieren_ist: "));
          Serial.println(g_kalibrieren_ist);
          Serial.print(F("g_checken_ist: "));
          Serial.println(g_checken_ist);
          Serial.print(F("g_kal_write_ist: "));
          Serial.println(g_kal_write_ist);
          Serial.print(F("set_bit_wait_front_view: "));
          Serial.println(set_bit_wait_front_view);
          Serial.print(F("g_view_fw: "));
          Serial.println(g_view_fw);
          Serial.print(F("g_LEDT_F_ist: "));
          Serial.println(g_LEDT_F_ist);
          Serial.print(F("g_Seg__boot_ani: "));
          Serial.println(g_Seg__boot_ani);
          Serial.print(F("g_sensor_online: "));
          Serial.println(g_sensor_online);
          Serial.print(F("Segment_task: "));
          Serial.println(Segment_task);
          Serial.print(F("g_radon_new_seg: "));
          Serial.println(g_radon_new_seg);
          Serial.print(F("g_LEDT_T_ist: "));
          Serial.println(g_LEDT_T_ist);
          Serial.print(F("g_wlan_read: "));
          Serial.println(g_wlan_read);
      }
    //-------------------------------------------------------------------------------------------






// See the following for generating UUIDs:
// https://www.uuidgenerator.net/


#define SERVICE_UUID           "6E400001-B5A3-F393-E0A9-E50E24DCCA9E" // UART service UUID
#define CHARACTERISTIC_UUID_RX "6E400002-B5A3-F393-E0A9-E50E24DCCA9E"
#define CHARACTERISTIC_UUID_TX "6E400003-B5A3-F393-E0A9-E50E24DCCA9E"




//#ifdef BLEbeacon_space

class MyServerCallbacks: public BLEServerCallbacks {
    void onConnect(BLEServer* pServer) {
      deviceConnected = true;
      connected_users++;
         //printf("[AP] iFREE HEAP: now: %u, contiguous: %u, lowest: %u\n",xPortGetFreeHeapSize(),heap_caps_get_largest_free_block(MALLOC_CAP_DEFAULT),xPortGetMinimumEverFreeHeapSize());
        //stopBeacon();
 
         //printf("[AP] jFREE HEAP: now: %u, contiguous: %u, lowest: %u\n",xPortGetFreeHeapSize(),heap_caps_get_largest_free_block(MALLOC_CAP_DEFAULT),xPortGetMinimumEverFreeHeapSize());
   
      Serial.println(F("[BT] Client connected"));
      //debugVariables(); // Rufe die Funktion zur Debug-Ausgabe auf
   
    };

    void onDisconnect(BLEServer* pServer) {
      deviceConnected = false;
      if(connected_users > 0){connected_users--;}
         //printf("[AP] kFREE HEAP: now: %u, contiguous: %u, lowest: %u\n",xPortGetFreeHeapSize(),heap_caps_get_largest_free_block(MALLOC_CAP_DEFAULT),xPortGetMinimumEverFreeHeapSize());
         //startBeacon();
         //printf("[AP] lFREE HEAP: now: %u, contiguous: %u, lowest: %u\n",xPortGetFreeHeapSize(),heap_caps_get_largest_free_block(MALLOC_CAP_DEFAULT),xPortGetMinimumEverFreeHeapSize());
   
      Serial.println(F("[BT] Client disconnected"));
    }
};

//#endif



class MyCallbacks: public BLECharacteristicCallbacks {
    void onWrite(BLECharacteristic *pCharacteristic) {

      Serial.println(F("[BT] BT Connect"));
      String tempstr;

      std::string rxValue = pCharacteristic->getValue();

      // Diese Zeile zählt die empfangenen Bytes
      //traffic += rxValue.length(); 
      receivedTraffic += rxValue.length();


      
      
      if (rxValue.length() > 0) {
        //Serial.println("*********");
        //Serial.print("Received Value: ");
        
        g_bl_connect = true;
        //g_showani = true;  // LED Animation aktivieren
        
        bufferReceive = "";
        for (int i = 0; i < rxValue.length(); i++){
          //Serial.print(rxValue[i]);
          bufferReceive += String(rxValue[i]);
        }

        //Serial.println();
        //Serial.print("|");Serial.print(bufferReceive);Serial.println("|");


        if (strstr(bufferReceive.c_str(), buff_pwd) != NULL) {
            Serial.println("[BT] LOGIN ok");
            bufferReceive = "";

            tempstr = "LOGIN OK\r\n";
            queueNotification(tempstr.c_str());
            while (sendNotification);

            g_login = true;
        }



        if (strstr(bufferReceive.c_str(), buff_pwdt) != NULL) {
            Serial.println(F("[BT] LOGIN ok"));
            bufferReceive = "";

            tempstr = "LOGIN OK\r\n";
            queueNotification(tempstr.c_str());
            while (sendNotification);

            g_login = true;
        }




        if(g_login == true){

            if (strstr(bufferReceive.c_str(), "G36") != NULL)
            {
                    
                bufferReceive = "";
                Serial.println(F("[BT] Aktion FW IST"));

                queueNotification(TB_currFwVersion.c_str());
                while (sendNotification);

                tb_FW_update = true;
                tb_task = true;

                fw_myString = TB_currFwVersion;
              
                g_view_fw = true;
                time_view_fw = 10;
                delay(100);
                esp_task_wdt_reset();

            }


            if (strstr(bufferReceive.c_str(), "fastBOOT") != NULL) {
                bufferReceive = "";
                Serial.println("[BT] Aktion Reboot");

                tempstr = "Reboot\r\n";
                queueNotification(tempstr.c_str());
                while (sendNotification);

                g__boot_restart = true;
            }



            if (strstr(bufferReceive.c_str(), "S30") != NULL) {
                Serial.println("[BT] Aktion Reboot");
                bufferReceive = "";

                tempstr = "Reboot\r\n";
                queueNotification(tempstr.c_str());
                while (sendNotification);
                g_esp_restsrt = true;
                lc.setIntensity(15); // 5=Standard Helligkeit vorne
                lc.setChar(0,0,'b',false);
                lc.setChar(0,1,'o',false);
                lc.setChar(0,2,'o',false);
                lc.setChar(0,3,'t',false);
                delay(300);
            }






            if (strstr(bufferReceive.c_str(), "KALREAD") != NULL) {
                Serial.println("[BT] Kalibrierung lesen aktivieren");
                tempstr = "Kal Read...\r\n";
                queueNotification(tempstr.c_str());
                while (sendNotification);
                g_start_kalibireung = 1;  //1-12
            }

            


            if (strstr(bufferReceive.c_str(), "KALDATA") != NULL) {
                Serial.println("[BT] Kalibrierungs Daten lesen");
                bufferReceive = "";
                tempstr = "Kal Data...\r\n";
                queueNotification(tempstr.c_str());
                while (sendNotification);
                g_start_kalibireung = 8;
            }





            if (strstr(bufferReceive.c_str(), "RREAD") != NULL) {
                Serial.println("[BT] Radon read");
                bufferReceive = "";
                mb_read_radon();  // Ruft die Radon-Lesefunktion auf

                tempstr = "Read Radon\r\n";
                queueNotification(tempstr.c_str());
                while (sendNotification);
                g_requestedShared_x = true;
                requestedShared = false;
                requestedShared1 = false;
                requestedShared2 = false;
                requestedShared3 = false;
                requestedShared4 = false;
                g_bl_radon_read = true;
            }




          if (strstr(bufferReceive.c_str(), "S29") != NULL) {
              Serial.println("[BT] SOUND");
              alarm_sound = !alarm_sound;
              if(alarm_sound == true){
                  g_u_buzzer_ea = 1;
                  g_Buzzer_ist = 0;

                  std::string tempstr = "S29:" + std::to_string(g_Buzzer_ist) + "\r\n"; 
                  queueNotification(tempstr.c_str());
                  while (sendNotification);
              } else {
                  g_u_buzzer_ea = 0;
                  g_Buzzer_ist = g_Buzzer_soll;
                  startplayer = false;

                  std::string tempstr = "S29:" + std::to_string(g_Buzzer_ist) + "\r\n"; 
                  queueNotification(tempstr.c_str());
                  while (sendNotification);
              }

          }



            //-----------------------------------------------
            // Aufruf der Funktion bei bestimmten Bedingungen
            if (strstr(bufferReceive.c_str(), "ValsRead") != NULL || strstr(bufferReceive.c_str(), "G30") != NULL) {
                Serial.println(F("[BT] Vals Read"));
            
               sendValuesIndividually();

            }
            //-----------------------------------------------



            //-----------------------------------------------
            // Aufruf der Funktion bei bestimmten Bedingungen
            if (strstr(bufferReceive.c_str(), "KNXRead") != NULL || strstr(bufferReceive.c_str(), "G35") != NULL) {
                Serial.println(F("[BT] KNX Read"));
            
               sendValuesKNXIndividually();

            }
            //-----------------------------------------------


            //-----------------------------------------------
            if (strstr(bufferReceive.c_str(), "S01") != NULL) {
                Serial.println(bufferReceive.c_str());
                String t_string = bufferReceive.c_str();
                int Laenge = bufferReceive.length();
                int Suche = bufferReceive.indexOf("S01:");
                Suche = Suche + 4;
                t_string = bufferReceive.substring(Suche, Laenge);
                g_unit_ist = t_string.toInt();
                Serial.print("[BT] S01: ");Serial.println(g_unit_ist);

                std::string tempstr = "S01:" + std::to_string(g_unit_ist) + "\r\n"; 
                queueNotification(tempstr.c_str());
                while (sendNotification);

                g_save_attribut = true;
            }

            //-----------------------------------------------

            //-----------------------------------------------
            if (strstr(bufferReceive.c_str(), "S02") != NULL) {
                Serial.println(bufferReceive.c_str());
                String t_string = bufferReceive.c_str();
                int Laenge = bufferReceive.length();
                int Suche = bufferReceive.indexOf("S02:");
                Suche = Suche + 4;
                t_string = bufferReceive.substring(Suche, Laenge);
                g_LEDT_T_ist = t_string.toInt();
                Serial.print("[BT] S02: ");
                Serial.println(g_LEDT_T_ist);

                std::string tempstr = "S02:" + std::to_string(g_LEDT_T_ist) + "\r\n"; 
                queueNotification(tempstr.c_str());
                g_t_led_change = true;
                g_save_attribut = true;
            }

            //-----------------------------------------------

            //-----------------------------------------------
            if (strstr(bufferReceive.c_str(), "S03") != NULL) {
                Serial.println(bufferReceive.c_str());
                String t_string = bufferReceive.c_str();
                int Laenge = bufferReceive.length();
                int Suche = bufferReceive.indexOf("S03:");
                Suche = Suche + 4;
                t_string = bufferReceive.substring(Suche, Laenge);
                g_LEDT_F_ist = t_string.toInt();
                Serial.print("[BT] S03: ");
                Serial.println(g_LEDT_F_ist);

                std::string tempstr = "S03:" + std::to_string(g_LEDT_F_ist) + "\r\n"; 
                queueNotification(tempstr.c_str());
                g_t_led_change = true;
                g_save_attribut = true;
            }
            //-----------------------------------------------

            //-----------------------------------------------
            if (strstr(bufferReceive.c_str(), "S04") != NULL) {
                Serial.println(bufferReceive.c_str());
                String t_string = bufferReceive.c_str();
                int Laenge = bufferReceive.length();
                int Suche = bufferReceive.indexOf("S04:");
                Suche = Suche + 4;
                t_string = bufferReceive.substring(Suche, Laenge);
                g_LEDT_FB_ist = t_string.toInt();
                Serial.print("[BT] S04: ");
                Serial.println(g_LEDT_FB_ist);

                std::string tempstr = "S04:" + std::to_string(g_LEDT_FB_ist) + "\r\n"; 
                queueNotification(tempstr.c_str());
                g_t_led_change = true;
                g_save_attribut = true;
            }
            //-----------------------------------------------

            //-----------------------------------------------
            if (strstr(bufferReceive.c_str(), "S05") != NULL) {
                Serial.println(bufferReceive.c_str());
                String t_string = bufferReceive.c_str();
                int Laenge = bufferReceive.length();
                int Suche = bufferReceive.indexOf("S05:");
                Suche = Suche + 4;
                t_string = bufferReceive.substring(Suche, Laenge);
                g_LEDT_TB_ist = t_string.toInt();
                Serial.print("[BT] S05: ");
                Serial.println(g_LEDT_TB_ist);

                std::string tempstr = "S05:" + std::to_string(g_LEDT_TB_ist) + "\r\n"; 
                queueNotification(tempstr.c_str());
                g_t_led_change = true;
                g_save_attribut = true;
            }

            //-----------------------------------------------

            //-----------------------------------------------
            if (strstr(bufferReceive.c_str(), "S06") != NULL) { 
                Serial.println(bufferReceive.c_str());
                String t_string = bufferReceive.c_str();
                int Laenge = bufferReceive.length();
                int Suche = bufferReceive.indexOf("S06:");
                Suche = Suche + 4;
                t_string = bufferReceive.substring(Suche, Laenge);
                g_LEDT_TF_ist = t_string.toInt();
                Serial.print("[BT] S06: ");
                Serial.println(g_LEDT_TF_ist);

                std::string tempstr = "S06:" + std::to_string(g_LEDT_TF_ist) + "\r\n"; 
                queueNotification(tempstr.c_str());
                g_t_led_change = true;
                g_save_attribut = true;
            }

            //-----------------------------------------------

            //-----------------------------------------------
            if (strstr(bufferReceive.c_str(), "S07") != NULL) {
              Serial.println(bufferReceive.c_str());
              String t_string = bufferReceive.c_str();
              int Laenge = bufferReceive.length();
              int Suche = bufferReceive.indexOf("S07:");
              Suche = Suche + 4;
              t_string = bufferReceive.substring(Suche, Laenge);
              g_Range_T_ist = t_string.toInt();
              Serial.print("[BT] S07: ");
              Serial.println(g_Range_T_ist);

              std::string tempstr = "S07:" + std::to_string(g_Range_T_ist) + "\r\n"; 
              queueNotification(tempstr.c_str());
              g_t_led_change = true;
              g_save_attribut = true;
            }

            //-----------------------------------------------

            //-----------------------------------------------
            if (strstr(bufferReceive.c_str(), "S08") != NULL) {
                Serial.println(bufferReceive.c_str());
                String t_string = bufferReceive.c_str();
                int Laenge = bufferReceive.length();
                int Suche = bufferReceive.indexOf("S08:");
                Suche = Suche + 4;
                t_string = bufferReceive.substring(Suche, Laenge);
                g_Range_M_ist = t_string.toInt();
                Serial.print("[BT] S08: ");
                Serial.println(g_Range_M_ist);
                std::string tempstr = "S08:" + std::to_string(g_Range_M_ist) + "\r\n";
                queueNotification(tempstr.c_str());
                g_t_led_change = true;
                g_save_attribut = true;
            }


            //-----------------------------------------------

            //-----------------------------------------------
            if (strstr(bufferReceive.c_str(), "S09") != NULL) {
                Serial.println(bufferReceive.c_str());
                String t_string = bufferReceive.c_str();
                int Laenge = bufferReceive.length();
                int Suche = bufferReceive.indexOf("S09:");
                Suche = Suche + 4;
                t_string = bufferReceive.substring(Suche, Laenge);
                g_Range_U_ist = t_string.toInt();
                Serial.print("[BT] S09: ");
                Serial.println(g_Range_U_ist);
                std::string tempstr = "S09:" + std::to_string(g_Range_U_ist) + "\r\n";
                queueNotification(tempstr.c_str());
                g_t_led_change = true;
                g_save_attribut = true;
            }


            //-----------------------------------------------

            //-----------------------------------------------
            if (strstr(bufferReceive.c_str(), "S10") != NULL) {
                Serial.println(bufferReceive.c_str());
                String t_string = bufferReceive.c_str();
                int Laenge = bufferReceive.length();
                int Suche = bufferReceive.indexOf("S10:");
                Suche = Suche + 4;
                t_string = bufferReceive.substring(Suche, Laenge);
                g_u_clock_ist = t_string.toInt();
                Serial.print("[BT] S10: ");
                Serial.println(g_u_clock_ist);
                std::string tempstr = "S10:" + std::to_string(g_u_clock_ist) + "\r\n";
                queueNotification(tempstr.c_str());
                g_save_attribut = true;
            }


            //-----------------------------------------------

            //-----------------------------------------------
            if (strstr(bufferReceive.c_str(), "S11") != NULL) {
                Serial.println(bufferReceive.c_str());
                String t_string = bufferReceive.c_str();
                int Laenge = bufferReceive.length();
                int Suche = bufferReceive.indexOf("S11:");
                Suche = Suche + 4;
                t_string = bufferReceive.substring(Suche, Laenge);
                g_u_view_switch_ist = t_string.toInt();
                Serial.print("[BT] S11: ");
                Serial.println(g_u_view_switch_ist);
                std::string tempstr = "S11:" + std::to_string(g_u_view_switch_ist) + "\r\n";
                queueNotification(tempstr.c_str());
                g_save_attribut = true;
            }


            //-----------------------------------------------

            //-----------------------------------------------
            if (strstr(bufferReceive.c_str(), "S12") != NULL) {
                Serial.println(bufferReceive.c_str());
                String t_string = bufferReceive.c_str();
                int Laenge = bufferReceive.length();
                int Suche = bufferReceive.indexOf("S12:");
                Suche = Suche + 4;
                t_string = bufferReceive.substring(Suche, Laenge);
                g_u_beacon_ist = t_string.toInt();
                Serial.print("[BT] S12: ");
                Serial.println(g_u_beacon_ist);
                std::string tempstr = "S12:" + std::to_string(g_u_beacon_ist) + "\r\n";
                queueNotification(tempstr.c_str());
                g_save_attribut = true;
            }


            //-----------------------------------------------

            //-----------------------------------------------
            if (strstr(bufferReceive.c_str(), "S13") != NULL) {
                Serial.println(bufferReceive.c_str());
                String t_string = bufferReceive.c_str();
                int Laenge = bufferReceive.length();
                int Suche = bufferReceive.indexOf("S13:");
                Suche = Suche + 4;
                t_string = bufferReceive.substring(Suche, Laenge);
                g_u_buzzer_ea = t_string.toInt();
                Serial.print("[BT] S13: ");
                Serial.println(g_u_buzzer_ea);
                std::string tempstr = "S13:" + std::to_string(g_u_buzzer_ea) + "\r\n";
                queueNotification(tempstr.c_str());
                g_save_attribut = true;
            }


            //-----------------------------------------------

            //-----------------------------------------------
            if (strstr(bufferReceive.c_str(), "S14") != NULL) {
                Serial.println(bufferReceive.c_str());
                String t_string = bufferReceive.c_str();
                int Laenge = bufferReceive.length();
                int Suche = bufferReceive.indexOf("S14:");
                Suche = Suche + 4;
                t_string = bufferReceive.substring(Suche, Laenge);
                g_Buzzer_ist = t_string.toInt();
                Serial.print("[BT] S14: ");
                Serial.println(g_Buzzer_ist);
                std::string tempstr = "S14:" + std::to_string(g_Buzzer_ist) + "\r\n";
                queueNotification(tempstr.c_str());
                g_save_attribut = true;
            }


            //-----------------------------------------------

            //-----------------------------------------------
            if (strstr(bufferReceive.c_str(), "S15") != NULL) {
                Serial.println(bufferReceive.c_str());
                String t_string = bufferReceive.c_str();
                int Laenge = bufferReceive.length();
                int Suche = bufferReceive.indexOf("S15:");
                Suche = Suche + 4;
                t_string = bufferReceive.substring(Suche, Laenge);
                g_u_mez_ea_ist = t_string.toInt();
                Serial.print("[BT] S15: ");
                Serial.println(g_u_mez_ea_ist);
                std::string tempstr = "S15:" + std::to_string(g_u_mez_ea_ist) + "\r\n";
                queueNotification(tempstr.c_str());
                g_save_attribut = true;
            }
            //-----------------------------------------------




            //-----------------------------------------------
            if (strstr(bufferReceive.c_str(), "G40") != NULL) {
                Serial.println(bufferReceive.c_str());
                String t_string = bufferReceive.c_str();
                int Laenge = bufferReceive.length();
                int Suche = bufferReceive.indexOf("G40:");
                Suche = Suche + 4;
                t_string = bufferReceive.substring(Suche, Laenge);
                // read_log_entry_by_index(t_vars);
                set_g40 = true;
                std::string tempstr = "G40:" + std::string(t_string.c_str()) + "\r\n";
                queueNotification(tempstr.c_str());

            }




            //-----------------------------------------------


            //-----------------------------------------------
            if (strstr(bufferReceive.c_str(), "G41") != NULL) {
                Serial.println(bufferReceive.c_str());
                String t_string = bufferReceive.c_str();
                int Laenge = bufferReceive.length();
                int Suche = bufferReceive.indexOf("G41:");
                Suche = Suche + 4;
                t_string = bufferReceive.substring(Suche, Laenge);
                uint8_t t_vars = t_string.toInt();
                set_g41 = true;
                Serial.print("[BT] G41: ");
                Serial.println(t_vars);
                std::string tempstr = "G41:" + std::to_string(t_vars) + "\r\n";
                queueNotification(tempstr.c_str());
            }


            //-----------------------------------------------



            //-----------------------------------------------
            if (strstr(bufferReceive.c_str(), "G42") != NULL) {
                Serial.println(bufferReceive.c_str());
                String t_string = bufferReceive.c_str();
                int Laenge = bufferReceive.length();
                int Suche = bufferReceive.indexOf("G42:");
                Suche = Suche + 4;
                t_string = bufferReceive.substring(Suche, Laenge);
                uint8_t t_vars = t_string.toInt();
                set_g42 = true;
                Serial.print("[BT] G42: ");
                Serial.println(t_vars);
                std::string tempstr = "G42:" + std::to_string(t_vars) + "\r\n";
                queueNotification(tempstr.c_str());
            }


            //-----------------------------------------------




            //-----------------------------------------------
            if (strstr(bufferReceive.c_str(), "G43") != NULL) {
                Serial.println(bufferReceive.c_str());
                String t_string = bufferReceive.c_str();
                int Laenge = bufferReceive.length();
                int Suche = bufferReceive.indexOf("G43:");
                Suche = Suche + 4;
                t_string = bufferReceive.substring(Suche, Laenge);
                set_g43 = true;
                std::string tempstr = "G43:" + std::string(t_string.c_str()) + "\r\n";
                queueNotification(tempstr.c_str());
            }


            //-----------------------------------------------








            // GET
            //-----------------------------------------------
            if (strstr(bufferReceive.c_str(), "G01") != NULL) {
                Serial.print("[BT] G01: ");
                Serial.println(radon_mittelwert_24h);
                std::string tempstr = "G01:" + std::to_string(radon_mittelwert_24h) + "\r\n";
                queueNotification(tempstr.c_str());
            }



            //-----------------------------------------------

          //-----------------------------------------------
            if (strstr(bufferReceive.c_str(), "G02") != NULL) {
                Serial.print("[BT] G02: ");
                Serial.println(radon_jahr);
                std::string tempstr = "G02:" + std::to_string(radon_jahr) + "\r\n";
                queueNotification(tempstr.c_str());
            }


            //-----------------------------------------------

            if (strstr(bufferReceive.c_str(), "G03") != NULL) {
                Serial.print("[BT] G03: ");
                Serial.println(mittelwert_jahr);
                std::string tempstr = "G03:" + std::to_string(mittelwert_jahr) + "\r\n";
                queueNotification(tempstr.c_str());
            }


            //-----------------------------------------------

            if (strstr(bufferReceive.c_str(), "G04") != NULL) {
                Serial.print("[BT] G04: ");
                Serial.println(radon_mittelwert_long);
                std::string tempstr = "G04:" + std::to_string(radon_mittelwert_long) + "\r\n";
                queueNotification(tempstr.c_str());
            }


            //-----------------------------------------------
            if (strstr(bufferReceive.c_str(), "G05") != NULL) {
                Serial.print("[BT] G05: ");
                Serial.println(radon_zaehler_long);
                std::string tempstr = "G05:" + std::to_string(radon_zaehler_long) + "\r\n";
                queueNotification(tempstr.c_str());
            }


            //-----------------------------------------------

            if (strstr(bufferReceive.c_str(), "G06") != NULL) {
                Serial.print("[BT] G06: ");
                Serial.println(mb_radon_save_eintrarge);
                std::string tempstr = "G06:" + std::to_string(mb_radon_save_eintrarge) + "\r\n";
                queueNotification(tempstr.c_str());
            }


            //-----------------------------------------------

            if (strstr(bufferReceive.c_str(), "G07") != NULL) {
                Serial.print("[BT] G07: ");
                Serial.println(radon_mittelwert_24_2h);
                std::string tempstr = "G07:" + std::to_string(radon_mittelwert_24_2h) + "\r\n";
                queueNotification(tempstr.c_str());
            }


            //-----------------------------------------------
            if (strstr(bufferReceive.c_str(), "G08") != NULL) {
                Serial.print("[BT] G08: ");
                Serial.println(timeDifferenceStr_c);
                std::string tempstr = "G08:" + std::string(timeDifferenceStr_c) + "\r\n";
                queueNotification(tempstr.c_str());
            }


            //-----------------------------------------------



            //-----------------------------------------------
            // "G10" - "G21"
            for (int i = 0; i < 12; ++i) {
                char searchStr[4];
                snprintf(searchStr, sizeof(searchStr), "G%d", 10 + i);
                if (strstr(bufferReceive.c_str(), searchStr) != NULL) {
                    Serial.print("[BT] B");
                    Serial.print(10 + i);
                    Serial.print(": ");
                    Serial.println(radon_mittelwert_monat[i]);
                    std::string tempstr = "G" + std::to_string(10 + i) + ":" + std::to_string(radon_mittelwert_monat[i]) + "\r\n";
                    queueNotification(tempstr.c_str());
                }
            }
            //-----------------------------------------------




            //-----------------------------------------------

            if (strstr(bufferReceive.c_str(), "G25") != NULL) {
                Serial.print("[BT] G25: ");
                Serial.println(lora_change_bt);
                std::string tempstr = "G25:" + std::to_string(lora_change_bt) + "\r\n";
                queueNotification(tempstr.c_str());
            }

            //-----------------------------------------------



            //-----------------------------------------------
            if (strstr(bufferReceive.c_str(), "SRESET") != NULL)
            {
              Serial.println("[BT] RESET ask");

                mb_read_reset(); 
                mb_read_byte = 1;
               
            }
            //-----------------------------------------------



            //-----------------------------------------------
            if (strstr(bufferReceive.c_str(), "LISTGRAPH") != NULL || strstr(bufferReceive.c_str(), "G37") != NULL)
            {
              Serial.println("[TM] LISTGRAPH");

                //---------------- länge -------------------------
         
                if(g1415_full == 1){
                  g1415_Sum_Counter = v_count_gh;
                }else{
                  g1415_Sum_Counter = g14Filewrite;
                }

                bl_send_init2();
                //---------------------------------------------
                  
   

            }

            if (strstr(bufferReceive.c_str(), "newinstanz") != NULL) {
                Serial.println("[TM] New Instanz");
                std::string tempstr = "New Instanz:" + std::string(bufferReceive.c_str()) + "\r\n";
                queueNotification(tempstr.c_str());
                restartWiFiAndClients();
            }


            if (strstr(bufferReceive.c_str(), "newwlan") != NULL)
            {
              Serial.println("[TM] New WLAN");
                std::string tempstr = "New WLAN:" + std::string(bufferReceive.c_str()) + "\r\n";
                queueNotification(tempstr.c_str());
                restartWiFi();
            }



            if (strstr(bufferReceive.c_str(), "newwtb") != NULL)
            {
               Serial.println("[TM] New TB");
               std::string tempstr = "newwtb:" + std::string(bufferReceive.c_str()) + "\r\n";
               queueNotification(tempstr.c_str());
               restarttb();
            }



            if (strstr(bufferReceive.c_str(), "readfw") != NULL)
            {
              Serial.println("[TM] New FW");

                 //Shared_Attribute_Data data;
                 //tb.Firmware_Shared_Attribute_Received(data);
            }

                



            //---------------------------------------------------------------------
            if (strstr(bufferReceive.c_str(), "changePINSold") != NULL) {
                Serial.println("[TM] Change PINS old");
                std::string tempstr = "Change Pins Old Version\t|  \r\n";
                queueNotification(tempstr.c_str());
                // Beispiel: Setze neue Pin-Nummern
                // setLedPins(26, 27); // Hier kannst du die gewünschten neuen Pin-Nummern eingeben
            }

            if (strstr(bufferReceive.c_str(), "changePINSnew") != NULL) {
                Serial.println("[TM] Change PINS new");
                std::string tempstr = "Change Pins New Version\t|  \r\n";
                queueNotification(tempstr.c_str());
                // Beispiel: Setze neue Pin-Nummern
                // setLedPins(27, 26); // Hier kannst du die gewünschten neuen Pin-Nummern eingeben
            }
            //---------------------------------------------------------------------


            //----- START Zeit -----  
            if (strstr(bufferReceive.c_str(), "S16") != NULL) {
                // Serial.println(bufferReceive.c_str());
                String t_string = bufferReceive.c_str();
                int Laenge = bufferReceive.length();
                int Suche = bufferReceive.indexOf("S16:");
                Suche = Suche + 4;
                t_string = bufferReceive.substring(Suche, Laenge);
                newNightStartHour = t_string.toInt();
                newNightEndHour = nightEndHour;
                Preferences preferences;
                preferences.begin("eenvs", false); // Ordner eenvs anlegen/verwenden
                if ((newNightEndHour > newNightStartHour) || (newNightEndHour < newNightStartHour && newNightEndHour < 12)) {
                    nightStartHour = newNightStartHour;
                    preferences.putInt("nightStartHour", nightStartHour);
                    preferences.end();
                    // Serial.println("Neue Werte gespeichert.");
                } else {
                    Serial.println("Fehler: Night End Hour muss größer als Night Start Hour sein oder in den frühen Morgenstunden liegen.");
                }
                Serial.print("Neue Night Start Hour: ");
                Serial.println(nightStartHour);
                Serial.print("[BT] S16: ");
                Serial.println(nightStartHour);
                std::string tempstr = "S16:" + std::to_string(nightStartHour) + "\r\n";
                queueNotification(tempstr.c_str());
            }




            //----- END Zeit -----
            if (strstr(bufferReceive.c_str(), "S17") != NULL) {
                Serial.println(bufferReceive.c_str());
                String t_string = bufferReceive.c_str();
                int Laenge = bufferReceive.length();
                int Suche = bufferReceive.indexOf("S17:");
                Suche = Suche + 4;
                t_string = bufferReceive.substring(Suche, Laenge);
                newNightEndHour = t_string.toInt();
                newNightStartHour = nightStartHour;
                Preferences preferences;
                preferences.begin("eenvs", false); // Ordner eenvs anlegen/verwenden
                if ((newNightEndHour > newNightStartHour) || (newNightEndHour < newNightStartHour && newNightEndHour < 12)) {
                    nightEndHour = newNightEndHour;
                    preferences.putInt("nightEndHour", nightEndHour);
                    preferences.end();
                    // Serial.println("Neue Werte gespeichert.");
                } else {
                    Serial.println("Fehler: Night End Hour muss größer als Night Start Hour sein oder in den frühen Morgenstunden liegen.");
                }
                Serial.print("Neue Night END Hour: ");
                Serial.println(nightEndHour);
                Serial.print("[BT] S17: ");
                Serial.println(nightEndHour);
                std::string tempstr = "S17:" + std::to_string(nightEndHour) + "\r\n";
                queueNotification(tempstr.c_str());
            }




            if (strstr(bufferReceive.c_str(), "READGRAPH") != NULL || strstr(bufferReceive.c_str(), "G38") != NULL) {
                Serial.println("[TM] READGRAPH");
                b_file_read14 = true;
                std::string tempstr = "READGRAPH:" + std::string(bufferReceive.c_str()) + "\r\n";
                queueNotification(tempstr.c_str());
            }


            if (strstr(bufferReceive.c_str(), "S28") != NULL) {
                Serial.println("[TM] DELGRAPH");
                b_file_delete = true;
                std::string tempstr = "DELGRAPH:" + std::string(bufferReceive.c_str()) + "\r\n";
                queueNotification(tempstr.c_str());
            }


            if (strstr(bufferReceive.c_str(), "WRITEEGRAPH") != NULL) {
                Serial.println("[TM] WRITEEGRAPH");
                


                // Formatiere den Datensatz in das char Array things_list_t_14
                snprintf(things_list_t_14, sizeof(things_list_t_14), "%s %s,%u", p_date_YYMMDD, formattedDateHH, radon_1h_ist);


                                
                
                
                write_to_file = true;

                std::string tempstr = "WRITEEGRAPH:" + std::string(bufferReceive.c_str()) + "\r\n";
                queueNotification(tempstr.c_str());
            }






            //------------------------------------------------------------
            if (strstr(bufferReceive.c_str(), "S63") != NULL) {
                Serial.println("[BT] Lora Server");
                String t_string = bufferReceive.c_str();
                int Laenge = bufferReceive.length();
                int Suche = bufferReceive.indexOf("S63:");
                Suche = Suche + 4;
                t_string = bufferReceive.substring(Suche, Laenge);
                t_string.trim();  // Entfernt führende und nachfolgende Leerzeichen
                p_inputcloudserver = t_string;  
                Preferences preferences;
                preferences.begin("eenvs", false); // Ordner eenvs anlegen/verwenden
                preferences.putString("p_clserv", p_inputcloudserver); // loragate2.de
                lora_change_bt = 1;
                preferences.putUChar("g_cloud_bttb", 1);
                p_inputcloudserver.toCharArray(p_inputcloudserverc, CLOUD_SERVER_LEN);
                lora_change_bt = preferences.getUChar("g_cloud_bttb", 0);
                preferences.end();
                if (lora_change_bt == 1) {
                    // Wenn über BT geändert wurde, wird Thingsboard ignoriert
                    Serial.println("[BT] Cloud wird über BT Daten geladen");
                } else {
                    Serial.println("[BT] Cloud wird über TB Daten geladen");
                }
                Serial.println(t_string);
                std::string tempstr = "S63:" + std::string(t_string.c_str()) + "\r\n";
                queueNotification(tempstr.c_str());
            }
            if (strstr(bufferReceive.c_str(), "G63") != NULL) {
                Serial.println("[BT] Lora Server Statusabfrage");

                // Abrufen des aktuellen Werts von p_inputcloudserver
                Preferences preferences;
                preferences.begin("eenvs", true);  // Nur lesen
                p_inputcloudserver = preferences.getString("p_clserv", "radoncloud.com");
                preferences.end();

                // Statusnachricht erstellen
                std::string tempstr = "G63:" + std::string(p_inputcloudserver.c_str()) + "\r\n";

                // Status senden
                queueNotification(tempstr.c_str());
            }
            //------------------------------------------------------------

            //------------------------------------------------------------
            if (strstr(bufferReceive.c_str(), "S64") != NULL) {
                Serial.println("[BT] Lora Page");
                String t_string = bufferReceive.c_str();
                int Laenge = bufferReceive.length();
                int Suche = bufferReceive.indexOf("S64:");
                Suche = Suche + 4;
                t_string = bufferReceive.substring(Suche, Laenge);
                t_string.trim();  // Entfernt führende und nachfolgende Leerzeichen
                p_inputcloudpage = t_string;
                Preferences preferences;
                preferences.begin("eenvs", false);  // Ordner eenvs anlegen/verwenden
                preferences.putString("p_clpage", p_inputcloudpage);  // Variable speichern
                lora_change_bt = 1;
                preferences.putUChar("g_cloud_bttb", 1);
                preferences.end();
                Serial.println(t_string);
                std::string tempstr = "S64:" + std::string(t_string.c_str()) + "\r\n";
                queueNotification(tempstr.c_str());
            }
            if (strstr(bufferReceive.c_str(), "G64") != NULL) {
                Serial.println("[BT] Lora Page Statusabfrage");

                // Abrufen des aktuellen Werts von p_inputcloudpage
                Preferences preferences;
                preferences.begin("eenvs", true);  // Nur lesen
                p_inputcloudpage = preferences.getString("p_clpage", "LoRaWAN-Live-Link-K1-W33rt22bd11np00L/lora_radon.php");
                preferences.end();

                // Statusnachricht erstellen
                std::string tempstr = "G64:" + std::string(p_inputcloudpage.c_str()) + "\r\n";

                // Status senden
                queueNotification(tempstr.c_str());
            }
            //------------------------------------------------------------

            //------------------------------------------------------------
            if (strstr(bufferReceive.c_str(), "S65") != NULL) {
                Serial.println("[BT] Lora Page");
                String t_string = bufferReceive.c_str();
                int Laenge = bufferReceive.length();
                int Suche = bufferReceive.indexOf("S65:");
                Suche = Suche + 4;
                t_string = bufferReceive.substring(Suche, Laenge);
                t_string.trim();  // Entfernt führende und nachfolgende Leerzeichen
                p_inputcloudchain = t_string;
                Preferences preferences;
                preferences.begin("eenvs", false);  // Ordner eenvs anlegen/verwenden
                preferences.putString("p_clchain", p_inputcloudchain);  // Variable speichern
                lora_change_bt = 1;
                preferences.putUChar("g_cloud_bttb", 1);
                preferences.end();
                Serial.println(t_string);
                std::string tempstr = "S65:" + std::string(t_string.c_str()) + "\r\n";
                queueNotification(tempstr.c_str());
            }
            if (strstr(bufferReceive.c_str(), "G65") != NULL) {
                Serial.println("[BT] Lora Chain Statusabfrage");

                // Abrufen des aktuellen Werts von p_inputcloudchain
                Preferences preferences;
                preferences.begin("eenvs", true);  // Nur lesen
                p_inputcloudchain = preferences.getString("p_clchain", "&p");   // p_inputcloudchain
                preferences.end();

                // Statusnachricht erstellen
                std::string tempstr = "G65:" + std::string(p_inputcloudchain.c_str()) + "\r\n";

                // Status senden
                queueNotification(tempstr.c_str());
            }
            //------------------------------------------------------------




            //------------------------------------------------------------
            if (strstr(bufferReceive.c_str(), "S66") != NULL) {
                Serial.println("[BT] Lora E/A");
                String t_string = bufferReceive.c_str();
                int Laenge = bufferReceive.length();
                int Suche = bufferReceive.indexOf("S66:");
                Suche = Suche + 4;
                t_string = bufferReceive.substring(Suche, Laenge);
                t_string.trim();  // Entfernt führende und nachfolgende Leerzeichen
                g_Cloud_ea_ist = t_string.toInt();
                g_Cloud_ea_soll = g_Cloud_ea_ist;
                Preferences preferences;
                preferences.begin("eenvs", false);  // Ordner eenvs anlegen/verwenden
                preferences.putUChar("g_cloud_ea", g_Cloud_ea_ist);
                if (g_Cloud_ea_ist == 1) {
                    lora_change_bt = 1;
                } else {
                    lora_change_bt = 0;
                }
                // wenn über BT Cloud aktiviert wird, wird Thingsboard ignoriert
                preferences.putUChar("g_cloud_bttb", 1);
                lora_change_bt = preferences.getUChar("g_cloud_bttb", 0);
                preferences.end();
                if (lora_change_bt == 1) {
                    // Wenn über BT geändert wurde, wird Thingsboard ignoriert
                    Serial.println("[BT] Cloud wird über BT Daten geladen");
                } else {
                    Serial.println("[BT] Cloud wird nicht mehr TB Daten geladen");
                }
                Serial.println(t_string);
                std::string tempstr = "S66:" + std::string(t_string.c_str()) + "\r\n";
                queueNotification(tempstr.c_str());
            }
            if (strstr(bufferReceive.c_str(), "G66") != NULL) {
                Serial.println("[BT] Lora E/A Statusabfrage");

                // Abrufen des aktuellen Werts von g_Cloud_ea_ist
                Preferences preferences;
                preferences.begin("eenvs", true);  // Nur lesen
                g_Cloud_ea_ist = preferences.getUChar("g_cloud_ea", 0);  // Standardwert auf 0 setzen
                preferences.end();

                // Wert in String umwandeln
                String t_string = String(g_Cloud_ea_ist);
                std::string tempstr = "G66:" + std::string(t_string.c_str()) + "\r\n";

                // Status senden
                queueNotification(tempstr.c_str());
            }
            //------------------------------------------------------------

  




            //------------------------------------------------------------
            if (strstr(bufferReceive.c_str(), "S67") != NULL) {
                Serial.println("[BT] Lora Pre");
                String t_string = bufferReceive.c_str();
                int Laenge = bufferReceive.length();
                int Suche = bufferReceive.indexOf("S67:");
                Suche = Suche + 4;
                t_string = bufferReceive.substring(Suche, Laenge);
                t_string.trim();  // Entfernt führende und nachfolgende Leerzeichen
                
                // Kopiere den String in das char Array
                strncpy(p_inputcloudprec, t_string.c_str(), sizeof(p_inputcloudprec) - 1);
                p_inputcloudprec[sizeof(p_inputcloudprec) - 1] = '\0';

                Preferences preferences;
                preferences.begin("eenvs", false);  // Ordner eenvs anlegen/verwenden
                preferences.putString("p_clpre", t_string);  // Variable speichern
                lora_change_bt = 1;
                preferences.putUChar("g_cloud_bttb", 1);
                preferences.end();

                Serial.println(t_string);
                std::string tempstr = "S67:" + std::string(t_string.c_str()) + "\r\n";
                queueNotification(tempstr.c_str());
            }

            if (strstr(bufferReceive.c_str(), "G67") != NULL) {
                Serial.println("[BT] Lora Pre Statusabfrage");

                // Abrufen des aktuellen Werts von p_inputcloudpre
                Preferences preferences;
                preferences.begin("eenvs", true);  // Nur lesen
                String storedValue = preferences.getString("p_clpre", "submit=Daten");
                preferences.end();
                
                // Kopiere den gespeicherten Wert in das char Array
                strncpy(p_inputcloudprec, storedValue.c_str(), sizeof(p_inputcloudprec) - 1);
                p_inputcloudprec[sizeof(p_inputcloudprec) - 1] = '\0';

                // Statusnachricht erstellen
                std::string tempstr = "G67:" + std::string(p_inputcloudprec) + "\r\n";

                // Status senden
                queueNotification(tempstr.c_str());
            }

            //------------------------------------------------------------

  







                       //  g_Cloud_ea_ist   p_mqonoff
            //------------------------------------------------------------
            if (strstr(bufferReceive.c_str(), "S70") != NULL) {
                Serial.println("[BT] MQTT E/A");
                String t_string = bufferReceive.c_str();
                int Laenge = bufferReceive.length();
                int Suche = bufferReceive.indexOf("S70:");
                Suche = Suche + 4;
                t_string = bufferReceive.substring(Suche, Laenge);
                t_string.trim();  // Entfernt führende und nachfolgende Leerzeichen
                p_mqonoff = t_string.toInt();
                Preferences preferences;
                preferences.begin("eenvs", false);  // Ordner eenvs anlegen/verwenden
                preferences.putBool("p_mqon", p_mqonoff);
                preferences.end();
                Serial.println(t_string);
                std::string tempstr = "S70:" + std::string(t_string.c_str()) + "\r\n";
                Serial.println(tempstr.c_str());
                queueNotification(tempstr.c_str());
                Serial.println(F("Done, Reboot now"));
                // Warten Sie 1 Sekunde, bevor Sie neu starten
                unsigned long startTime = millis();
                while (millis() - startTime < 1000) {
                    // Sie können hier auch andere Aufgaben ausführen, wenn nötig
                    delay(10); // Kurze Verzögerung, um die Schleife nicht zu blockieren
                }
                delay(2000);
                esp_restart();
            }
            if (strstr(bufferReceive.c_str(), "G70") != NULL) {
                Serial.println(F("[BT] MQTT E/A Statusabfrage"));

                // Abrufen des aktuellen Zustands von p_mqonoff
                Preferences preferences;
                preferences.begin("eenvs", false);  // Ordner eenvs anlegen/verwenden
                p_mqonoff = preferences.getBool("p_mqon", false);  // Standardwert auf false setzen
                preferences.end();
                // Wert in String umwandeln
                String t_string = p_mqonoff ? "1" : "0";
                std::string tempstr = "G70:" + std::string(t_string.c_str()) + "\r\n";
                Serial.println(tempstr.c_str());
           

                // Status senden
                queueNotification(tempstr.c_str());
            }
            //------------------------------------------------------------


            //------------------------------------------------------------
            if (strstr(bufferReceive.c_str(), "S71") != NULL) {
                Serial.println("[BT] MQTT Client");
                String t_string = bufferReceive.c_str();
                int Laenge = bufferReceive.length();
                int Suche = bufferReceive.indexOf("S71:");
                Suche = Suche + 4;
                t_string = bufferReceive.substring(Suche, Laenge);
                t_string.trim();  // Entfernt führende und nachfolgende Leerzeichen
                p_inputmqclient = t_string;

                Preferences preferences;
                preferences.begin("eenvs", false);  // Ordner eenvs anlegen/verwenden
                preferences.putString("p_mqclie", p_inputmqclient);  // Variable speichern
                preferences.end();

                Serial.println(t_string);
                std::string tempstr = "S71:" + std::string(t_string.c_str()) + "\r\n";
                queueNotification(tempstr.c_str());
            }
            if (strstr(bufferReceive.c_str(), "G71") != NULL) {
                Serial.println("[BT] MQTT Client Statusabfrage");

                // Abrufen des aktuellen Werts von p_inputmqclient
                Preferences preferences;
                preferences.begin("eenvs", true);  // Nur lesen
                p_inputmqclient = preferences.getString("p_mqclie", "");
                preferences.end();

                // Statusnachricht erstellen
                std::string tempstr = "G71:" + std::string(p_inputmqclient.c_str()) + "\r\n";
                Serial.println(tempstr.c_str());

                // Status senden
                queueNotification(tempstr.c_str());
            }
            //------------------------------------------------------------
            if (strstr(bufferReceive.c_str(), "S72") != NULL) {
                Serial.println("[BT] MQTT Server");
                String t_string = bufferReceive.c_str();
                int Laenge = bufferReceive.length();
                int Suche = bufferReceive.indexOf("S72:");
                Suche = Suche + 4;
                t_string = bufferReceive.substring(Suche, Laenge);
                t_string.trim();  // Entfernt führende und nachfolgende Leerzeichen
                p_inputmqserver = t_string;

                Preferences preferences;
                preferences.begin("eenvs", false);  // Ordner eenvs anlegen/verwenden
                preferences.putString("p_mqserv", p_inputmqserver);  // Variable speichern
                preferences.end();

                Serial.println(t_string);
                std::string tempstr = "S72:" + std::string(t_string.c_str()) + "\r\n";
                Serial.println(tempstr.c_str());
                queueNotification(tempstr.c_str());
            }
            if (strstr(bufferReceive.c_str(), "G72") != NULL) {
                Serial.println("[BT] MQTT Server Statusabfrage");

                // Abrufen des aktuellen Werts von p_inputmqserver
                Preferences preferences;
                preferences.begin("eenvs", true);  // Nur lesen
                p_inputmqserver = preferences.getString("p_mqserv", "io.adafruit.com");
                preferences.end();

                // Statusnachricht erstellen
                std::string tempstr = "G72:" + std::string(p_inputmqserver.c_str()) + "\r\n";
                Serial.println(tempstr.c_str());

                // Status senden
                queueNotification(tempstr.c_str());
            }

            //------------------------------------------------------------
            if (strstr(bufferReceive.c_str(), "S73") != NULL) {
                Serial.println("[BT] MQTT User");
                String t_string = bufferReceive.c_str();
                int Laenge = bufferReceive.length();
                int Suche = bufferReceive.indexOf("S73:");
                Suche = Suche + 4;
                t_string = bufferReceive.substring(Suche, Laenge);
                t_string.trim();  // Entfernt führende und nachfolgende Leerzeichen
                p_inputmquser = t_string;

                Preferences preferences;
                preferences.begin("eenvs", false);  // Ordner eenvs anlegen/verwenden
                preferences.putString("p_mquser", p_inputmquser);  // Variable speichern
                preferences.end();

                Serial.println(t_string);
                std::string tempstr = "S73:" + std::string(t_string.c_str()) + "\r\n";
                Serial.println(tempstr.c_str());
                queueNotification(tempstr.c_str());
            }
            if (strstr(bufferReceive.c_str(), "G73") != NULL) {
                Serial.println("[BT] MQTT User Statusabfrage");

                // Abrufen des aktuellen Werts von p_inputmquser
                Preferences preferences;
                preferences.begin("eenvs", true);  // Nur lesen
                p_inputmquser = preferences.getString("p_mquser", "radonvalue");
                preferences.end();

                // Statusnachricht erstellen
                std::string tempstr = "G73:" + std::string(p_inputmquser.c_str()) + "\r\n";
                Serial.println(tempstr.c_str());

                // Status senden
                queueNotification(tempstr.c_str());
            }
            //------------------------------------------------------------


            //------------------------------------------------------------
            if (strstr(bufferReceive.c_str(), "S74") != NULL) {
                Serial.println("[BT] MQTT Port");
                String t_string = bufferReceive.c_str();
                int Laenge = bufferReceive.length();
                int Suche = bufferReceive.indexOf("S74:");
                Suche = Suche + 4;
                t_string = bufferReceive.substring(Suche, Laenge);
                t_string.trim();  // Entfernt führende und nachfolgende Leerzeichen
                p_inputmqport = t_string;

                // Port in Integer umwandeln
                p_inputmqporti = p_inputmqport.toInt();

                Preferences preferences;
                preferences.begin("eenvs", false);  // Ordner eenvs anlegen/verwenden
                preferences.putString("p_mqport", p_inputmqport);  // Variable speichern
                preferences.end();

                Serial.println(t_string);
                std::string tempstr = "S74:" + std::string(t_string.c_str()) + "\r\n";
                Serial.println(tempstr.c_str());
                queueNotification(tempstr.c_str());
            }
            if (strstr(bufferReceive.c_str(), "G74") != NULL) {
                Serial.println("[BT] MQTT Port Statusabfrage");

                // Abrufen des aktuellen Werts von p_inputmqport
                Preferences preferences;
                preferences.begin("eenvs", true);  // Nur lesen
                p_inputmqport = preferences.getString("p_mqport", "1883");
                preferences.end();

                // Port in Integer umwandeln
                p_inputmqporti = p_inputmqport.toInt();

                // Statusnachricht erstellen
                std::string tempstr = "G74:" + std::string(p_inputmqport.c_str()) + "\r\n";
                Serial.println(tempstr.c_str());

                // Status senden
                queueNotification(tempstr.c_str());
            }
            //------------------------------------------------------------


            //------------------------------------------------------------
            if (strstr(bufferReceive.c_str(), "S75") != NULL) {
                Serial.println("[BT] MQTT Topic");
                String t_string = bufferReceive.c_str();
                int Laenge = bufferReceive.length();
                int Suche = bufferReceive.indexOf("S75:");
                Suche = Suche + 4;
                t_string = bufferReceive.substring(Suche, Laenge);
                t_string.trim();  // Entfernt führende und nachfolgende Leerzeichen
                p_inputmqtopic = t_string;

                Preferences preferences;
                preferences.begin("eenvs", false);  // Ordner eenvs anlegen/verwenden
                preferences.putString("p_mqtopic", p_inputmqtopic);  // Variable speichern
                preferences.end();

                Serial.println(t_string);
                std::string tempstr = "S75:" + std::string(t_string.c_str()) + "\r\n";
                Serial.println(tempstr.c_str());
                queueNotification(tempstr.c_str());
            }
            if (strstr(bufferReceive.c_str(), "G75") != NULL) {
                Serial.println("[BT] MQTT Topic Statusabfrage");

                // Abrufen des aktuellen Werts von p_inputmqtopic
                Preferences preferences;
                preferences.begin("eenvs", true);  // Nur lesen
                p_inputmqtopic = preferences.getString("p_mqtopic", "radonvalue/feeds/radon.radon");
                preferences.end();

                // Statusnachricht erstellen
                std::string tempstr = "G75:" + std::string(p_inputmqtopic.c_str()) + "\r\n";
                Serial.println(tempstr.c_str());

                // Status senden
                queueNotification(tempstr.c_str());
            }
            //------------------------------------------------------------



            //------------------------------------------------------------
            // Passwort speichern
            if (strstr(bufferReceive.c_str(), "S76") != NULL) {
                Serial.println("[BT] MQTT Passwort");
                String t_string = bufferReceive.c_str();
                int Laenge = bufferReceive.length();
                int Suche = bufferReceive.indexOf("S76:");
                Suche = Suche + 4;
                t_string = bufferReceive.substring(Suche, Laenge);
                t_string.trim();  // Entfernt führende und nachfolgende Leerzeichen
                p_inputmqpass = t_string;

                Preferences preferences;
                preferences.begin("eenvs", false);  // Ordner eenvs anlegen/verwenden
                preferences.putString("p_mqpass", p_inputmqpass);  // Variable speichern
                preferences.end();

                Serial.println(t_string);
                std::string tempstr = "S76:" + std::string(t_string.c_str()) + "\r\n";
                Serial.println(tempstr.c_str());
                queueNotification(tempstr.c_str());
            }
            // Passwort lesen
            if (strstr(bufferReceive.c_str(), "G76") != NULL) {
                Serial.println("[BT] MQTT Passwort Statusabfrage");

                // Abrufen des aktuellen Werts von p_inputmqpass
                Preferences preferences;
                preferences.begin("eenvs", true);  // Nur lesen
                p_inputmqpass = preferences.getString("p_mqpass", "4056e40b03b14156ab7d701f5104255e");  // 0056e40b03b14156ab7d707f5104256e
                preferences.end();

                // Statusnachricht erstellen
                std::string tempstr = "G76:********\r\n";  // Passwort nicht im Klartext senden
                Serial.println(tempstr.c_str());

                // Status senden
                queueNotification(tempstr.c_str());
            }
            //------------------------------------------------------------






            //------------------------------------------------------------
            // Anpassung für S80 und G80
            if (strstr(bufferReceive.c_str(), "S80") != NULL) {
                Serial.println("[BT] Intern_online setzen");
            }

            if (strstr(bufferReceive.c_str(), "G80") != NULL) {
                Serial.println("[BT] Intern_online Statusabfrage");
                // Abrufen des aktuellen Werts von Intern_online
                // Statusnachricht erstellen
                std::string tempstr = "G80:" + std::string(Internt_online ? "1" : "0") + "\r\n";
                // Status senden
                queueNotification(tempstr.c_str());
            }
            //------------------------------------------------------------



            //------------------------------------------------------------
            // Anpassung 
            if (strstr(bufferReceive.c_str(), "G99") != NULL) {
                Serial.println("[BT] Firmwareupdate");
            }

            if (strstr(bufferReceive.c_str(), "S99") != NULL) {
                Serial.println("[BT] Set Firmwareupdate");
                String t_string = bufferReceive.c_str();
                int Laenge = bufferReceive.length();
                int Suche = bufferReceive.indexOf("S99:");
                Suche = Suche + 4;
                t_string = bufferReceive.substring(Suche, Laenge);
                t_string.trim();  // Entfernt führende und nachfolgende Leerzeichen
                if(t_string == "5948fU"){
                  factoryResetBit = true; 
                }
                // Statusnachricht erstellen
                std::string tempstr = "S99:" + std::string(factoryResetBit ? "1" : "0") + "\r\n";
                // Status senden
                queueNotification(tempstr.c_str());
            }
            //------------------------------------------------------------





            if (strstr(bufferReceive.c_str(), "testsommer1") != NULL)
            {

              sommerzeit = summertime_EU(2000 +currentYearTwoDigits, v_currentmonth, v_currentdate, v_currenthour, 1); //(0=UTC, 1=MEZ)  //0 = Winterzeit in Jan, Feb, Nov, Dez      1= Sommerzeit in Apr, Mai, Jun, Jul, Aug, Sep
                 if(sommerzeit == 1){  
                        Serial.println("[TM] 1 ESP Es ist Sommer | MESZ ");
                 }else{
                        Serial.println("[TM] 1 ESP Es ist Winter | MEZ  ");
                 } 

            }

          
            if (strstr(bufferReceive.c_str(), "testsommer0") != NULL)
            {

              sommerzeit = summertime_EU(2000 +currentYearTwoDigits, v_currentmonth, v_currentdate, v_currenthour, 0); //(0=UTC, 1=MEZ)  //0 = Winterzeit in Jan, Feb, Nov, Dez      1= Sommerzeit in Apr, Mai, Jun, Jul, Aug, Sep
                 if(sommerzeit == 1){  
                        Serial.println("[TM] 0 ESP Es ist Sommer | MESZ ");
                 }else{
                        Serial.println("[TM] 0 ESP Es ist Winter | MEZ  ");
                 } 

            }



      

               // [IF] Local time:

            if (strstr(bufferReceive.c_str(), "G29") != NULL) {
                struct timespec walltime2;
                clock_gettime(CLOCK_REALTIME, &walltime2);
                // printf("[IF] Get Setting ESP time: %s", ctime(&walltime2.tv_sec));
                // Serial.print("[IF] Get ESP time "); Serial.println(walltime2.tv_sec);
                Serial.print("[IF] Get timeClient ");
                Serial.print(timeClient.getEpochTime());
                Serial.print(" | ");
                Serial.print(timeClient.getHours());
                Serial.print(":");
                Serial.println(timeClient.getMinutes());
                std::string tempstr = "G29:" + std::to_string(timeClient.getEpochTime()) + "\r\n";
                queueNotification(tempstr.c_str());


                    //currentSec = myRTC.getSecond();
                    //currentmin = myRTC.getMinute();
                    //currenthour = myRTC.getHour2();
                    Serial.print("Hour: ");
                    Serial.println(myRTC.getHour2());
                    Serial.print("Minute: ");
                    Serial.println(myRTC.getMinute());
                    Serial.print("Second: ");
                    Serial.println(myRTC.getSecond());
                


                    //currentSec = timeClient.getSeconds();
                    //currentmin = timeClient.getMinutes();
                    //currenthour = currenthour; // Stunden mit Sommer Winter

                    //sprintf(uhrzeit_c,"%02d:%02d:%02d",currenthour,currentmin,currentSec);
                    //p_uhrzeit = String(uhrzeit_c);

                    struct tm timeinfo;
                    time_t now;
                    if (WiFi.status() == WL_CONNECTED) {
                      if (!getLocalTime(&timeinfo)) {
                        #if TM_DEBUG_LEVEL >= TM_DEBUG_MAX
                          Serial.println("[TM] Failed to obtain time");
                        #endif
                      }else{
                        Serial.print(F("[TM] 9: "));
                        Serial.println(&timeinfo, "%A, %B %d %Y %H:%M:%S");
                      }
                    } else {
                      #if TM_DEBUG_LEVEL >= TM_DEBUG_MAX
                        Serial.println("[TM] WiFi nicht verbunden. Zeit wird vom ESP abgerufen.");
                      #endif
                      time(&now);
                      localtime_r(&now, &timeinfo);
                    }

                      //esp_second = timeinfo.tm_sec;
                      //esp_minute = timeinfo.tm_min;
                      currenthour = timeinfo.tm_hour;


                    Serial.print("Hour: ");
                    Serial.println(currenthour);
                    Serial.print("Minute: ");
                    Serial.println(timeClient.getMinutes());
                    Serial.print("Second: ");
                    Serial.println(timeClient.getSeconds());



            }





            if (strstr(bufferReceive.c_str(), "subscribe") != NULL) {
                Serial.println("[TB] subscribe");
                if (WiFi.status() == WL_CONNECTED) {
                TB_connect();
                }
                if (g_TB_connect_Status == true) {
                    tb.Shared_Attributes_Unsubscribe();
                    Serial.println("[IF] Shared Attributes Unsubscribe done 0");
                    start_Shared_Attributes();
                }
                std::string tempstr = "subscribe\t| : \r\n";
                queueNotification(tempstr.c_str());
            }




          
            if (strstr(bufferReceive.c_str(), "STUFEN") != NULL) {
                mb_stufen_start = !mb_stufen_start;
                if (mb_stufen_start == true) {
                    Serial.println("[MB] STUFEN Read Start");
                    mb_stufen_read = true;
                } else {
                    Serial.println("[MB] STUFEN Read Stop");
                }
                std::string tempstr = "STUFEN:" + std::string(bufferReceive.c_str()) + "\r\n";
                queueNotification(tempstr.c_str());
            }





          //-------------------------------------------------------------------------------
            if (strstr(bufferReceive.c_str(), "S31") != NULL) {
                Serial.println(bufferReceive.c_str());
                String t_string = bufferReceive.c_str();
                int Laenge = bufferReceive.length();
                int Suche = bufferReceive.indexOf("S31:");
                Suche = Suche + 4;
                t_string = bufferReceive.substring(Suche, Laenge);
                t_string.trim();  // Entfernt führende und nachfolgende Leerzeichen
                g_u_timezone_ist = t_string;
                Preferences preferences;
                preferences.begin("eenvs", false); // Ordner eenvs anlegen/verwenden
                preferences.putString("g_u_timezone", g_u_timezone_ist);
                preferences.end();
                std::string tempstr = "S31:" + std::string(t_string.c_str()) + "\r\n";
                queueNotification(tempstr.c_str());
                
                //-------------------------------------------------------------
                time_t now;
                char strftime_buf[64];
                struct tm timeinfo;
                time(&now);
                v_timezone = g_u_timezone_ist;
                setenv("TZ", v_timezone.c_str(), 1); // Now adjust the TZ. Clock settings are adjusted to show the new local time
                tzset();
                localtime_r(&now, &timeinfo);
                //---------------------
                // Setze tm_isdst auf -1, um die Sommerzeit automatisch zu ermitteln
                // Setze tm_isdst auf  1, um die Sommerzeit manuell zu aktivieren
                // Setze tm_isdst auf 0, um die Sommerzeit manuell zu deaktivieren
                // timeinfot.tm_isdst = -1;
                // Aktualisiere die Zeitinfo mit mktime, um tm_isdst zu setzen
                // mktime(&timeinfot);
                //---------------------
                strftime(strftime_buf, sizeof(strftime_buf), "%c", &timeinfo);
                printf("[IF] The current date/time is: %s\n", strftime_buf);
                //-------------------------------------------------------------
            }


          //-------------------------------------------------------------------------------



          //-------------------------------------------------------------------------------
            // STIME:1719133822
          if (strstr(bufferReceive.c_str(), "S32") != NULL)
          {
              
              // hier muss die Zeit kommen von BL inl oder minus 3600 wegen Sommerzeit
              epochTime_bl = 0;
              
              Serial.println("[TM] Set TIME");
              //Serial.println(bufferReceive.c_str());

              
                String t_string = bufferReceive.c_str(); 
                // Länge bestimmen
                int Laenge = bufferReceive.length(); 
                int Suche = bufferReceive.indexOf("S32:"); 
                Suche = Suche + 4;
                t_string = bufferReceive.substring(Suche, Laenge);    
                epochTime_bl = t_string.toInt();
               
                timeClient.setTimeOffset(0);

                Serial.print("[TM] set Epoch Time from BT:  ");Serial.println(epochTime_bl);
                timeClient.setEpochTime(epochTime_bl);

                
                  //+++++++++++++++
                  struct timespec tp;
                  tp.tv_sec = epochTime_bl;  //hier die Uhrzeit stellen
                  clock_settime(CLOCK_REALTIME, &tp);
                  Serial.print("[IF] ESP32 Uhr Stellen von RTC Uhr | ");Serial.println(epochTime_bl);
                  time_t nowt;
                  char strftime_buf[64];
                  struct tm timeinfot;
                  time(&nowt);
                  Serial.print("[TM] Load Timezone: ");Serial.println(g_u_timezone_ist);
                  setenv("TZ",g_u_timezone_ist.c_str(),1); 
                  tzset();
                  localtime_r(&nowt, &timeinfot);
                   esp_task_wdt_reset(); 

                  strftime(strftime_buf, sizeof(strftime_buf), "%c", &timeinfot);
                  //ESP_LOGI(TAG, "The current date/time in Germany is: %s", strftime_buf);
                  printf("[IF] The current date/time is: %s\n", strftime_buf);
                //+++++++++++++++


                time_t rtc = epochTime_bl;
                timeval tv = { rtc, 0 };
                settimeofday(&tv, nullptr);




              struct tm timeinfo;
              time_t now;

              if (WiFi.status() == WL_CONNECTED) {
                if (!getLocalTime(&timeinfo)) {
                  #if TM_DEBUG_LEVEL >= TM_DEBUG_MAX
                    Serial.println("[TM] Failed to obtain time");
                  #endif
                }else{
                  Serial.print(F("[TM] 2: "));
                  Serial.println(&timeinfo, "%A, %B %d %Y %H:%M:%S");
                }
              } else {
                #if TM_DEBUG_LEVEL >= TM_DEBUG_MAX
                  Serial.println("[TM] WiFi nicht verbunden. Zeit wird vom ESP abgerufen.");
                #endif
                time(&now);
                localtime_r(&now, &timeinfo);
              }

                
                //timeClient.update();
                TM_DEBUG_MAX_PRINT("[TM] get Stunde     from ESP: "); 
                TM_DEBUG_MAX_PRINTLN(timeClient.getHours());
                TM_DEBUG_MAX_PRINT("[TM] get minute     from ESP: "); 
                TM_DEBUG_MAX_PRINTLN(timeClient.getMinutes());
                TM_DEBUG_MAX_PRINT("[TM] get Sekunde    from ESP: "); 
                TM_DEBUG_MAX_PRINTLN(timeClient.getSeconds());
                TM_DEBUG_MAX_PRINT("[TM] get Epoch Time from ESP: "); 
                TM_DEBUG_MAX_PRINTLN(timeClient.getEpochTime());



                  second = timeinfo.tm_sec;
                  minute = timeinfo.tm_min;
                  hour = timeinfo.tm_hour;
                  day = timeinfo.tm_mday;
                  month = timeinfo.tm_mon + 1;
                  year = timeinfo.tm_year + 1900;
                  weekday = timeinfo.tm_wday;
                  yday = timeinfo.tm_yday;
                  hour12h = timeinfo.tm_hour;
                  istdst = timeinfo.tm_isdst;


                  currentSec = second;
                  currentmin = minute;
                  currenthour = hour;
                  currentdate = day;
                  currentmonth = month;
                  esp_year_t = timeinfo.tm_year + 1900-2000;
                  currentyear = esp_year_t;
                  currentYearTwoDigits = esp_year_t % 100;
                  
                  esp_dOW = weekday;

                  currenthour12 = currenthour;

                  if(g_u_clock_ist == 1){ 
                    currenthourAM_PM = false;
                  }
                  if(g_u_clock_ist == 2){ 
                    currenthour12 = currenthour; 
                    currenthourAM_PM = false; 
                    if( currenthour12 == 0 ){currenthour12 = 12;currenthourAM_PM = true;}
                    if( currenthour12 > 12 ){currenthour12 = currenthour12 - 12;currenthourAM_PM = true;}
                  }  

                    TM_DEBUG_MAX_PRINT("[TM] get Stunde  from ESP: "); 
                    TM_DEBUG_MAX_PRINTLN(currenthour);
                    TM_DEBUG_MAX_PRINT("[TM] get Minute  from ESP: "); 
                    TM_DEBUG_MAX_PRINTLN(currentmin);
                    TM_DEBUG_MAX_PRINT("[TM] get Sekunde from ESP: "); 
                    TM_DEBUG_MAX_PRINTLN(currentSec);
                    TM_DEBUG_MAX_PRINT("[TM] get DST from ESP (1=Sommer): "); 
                    TM_DEBUG_MAX_PRINTLN(istdst);

                  

                 sommerzeit = summertime_EU(2000 +currentYearTwoDigits, currentmonth, currentdate, currenthour, 1); //(0=UTC, 1=MEZ)  //0 = Winterzeit in Jan, Feb, Nov, Dez      1= Sommerzeit in Apr, Mai, Jun, Jul, Aug, Sep
                 if(sommerzeit == 1){  
                        Set_mesz = true;
                        g_Set_mesz = 0;
                        Serial.println("[TM] ESP Es ist Sommer | MESZ ");
                 }else{
                        Set_mesz = false;
                        g_Set_mesz = 1;
                        Serial.println("[TM] ESP Es ist Winter | MEZ  ");
                 } 
                    
                      Serial.print("g_Set_mesz b: ");Serial.println(g_Set_mesz);
                      Preferences preferences;
                      preferences.begin("eenvs", false);                         //Ordner eenvs anlegen/verwenden
                      preferences.putUInt("g_Set_mesz", g_Set_mesz);             //Variable speichern  
                      preferences.end();
                //---------------------------------------------------------------

                  std::string tempstr = "S32:" + std::to_string(epochTime_bl) + "\r\n";
                  queueNotification(tempstr.c_str());
               



                  if(epochTime_bl >= 1704067200){
                    update_bl_clock = 1; // damit ohne NTP ok die Uhr gestellt werden kann
                    set_manual_time = true;
                    set_BT_time = true;
                    set_BT_RTC_Time = true;
                  }
    
                

          }
          //-------------------------------------------------------------------------------






          //-------------------------------------------------------------------------------
          if (strstr(bufferReceive.c_str(), "S33") != NULL) {
               
                Serial.println(bufferReceive.c_str());
                String t_string = bufferReceive.c_str();
                int Laenge = bufferReceive.length();
                int Suche = bufferReceive.indexOf("S33:");
                Suche = Suche + 4;
                t_string = bufferReceive.substring(Suche, Laenge);
                t_string.trim();  // Entfernt führende und nachfolgende Leerzeichen
                std::string tempstr = "S33:" + std::string(t_string.c_str()) + "\r\n";
                queueNotification(tempstr.c_str());
                //-------------------------------------------------------------
                if(t_string == "1"){

                    ntp_update_start = true;
         
                }
          }
          //-------------------------------------------------------------------------------





          //-------------------------------------------------------------------------------
          if (strstr(bufferReceive.c_str(), "S34") != NULL) {
               
                Serial.println(bufferReceive.c_str());
                String t_string = bufferReceive.c_str();
                int Laenge = bufferReceive.length();
                int Suche = bufferReceive.indexOf("S34:");
                Suche = Suche + 4;
                t_string = bufferReceive.substring(Suche, Laenge);
                t_string.trim();  // Entfernt führende und nachfolgende Leerzeichen
                std::string tempstr = "S34:" + std::string(t_string.c_str()) + "\r\n";
                queueNotification(tempstr.c_str());
                //-------------------------------------------------------------
                if (t_string == "1") {
                    g_identify = true;
                    g_u_identify_soll = 1;
                    g_u_identify_ist = 1;
                    g_identify_byte = 0;
                } else {
                    g_identify = false;
                    g_u_identify_soll = 0;
                    g_u_identify_ist = 0;
                    g_identify_byte = 0;
                }


          }
          //-------------------------------------------------------------------------------




          //-------------------------------------------------------------------------------
            if (strstr(bufferReceive.c_str(), "PROV") != NULL) {
                Serial.println("[BT] PROV new");
                esp_task_wdt_reset();
                lc.setIntensity(15); // 5=Standard Helligkeit vorne
                lc.setChar(0,0, 'b', false);
                lc.setChar(0,1, 'o', false);
                lc.setChar(0,2, 'o', false);
                lc.setChar(0,3, 't', false);
                delay(100);
                delete_prov_id();
                Preferences preferences;
                preferences.begin("eenvs", false);  // Ordner eenvs anlegen/verwenden
                g_kalibriert = 0;
                preferences.putUChar("s_kalibriert", g_kalibriert);  // kalibrierter Sensor
                g_checked = 0;
                preferences.putUChar("s_checked", g_checked);  // checked Sensor
                preferences.end();
                
                // Attribute senden
                Attribute attributes[2] = {
                    { C_s_kalibriert_KEY,  g_kalibriert },
                    { C_s_checked_KEY,  g_checked }
                };
                tb.sendAttributes(attributes, 2);
                delay(200);
                std::string tempstr = "PROV:" + std::string(device_id_c) + "\r\n";
                queueNotification(tempstr.c_str());
                
                Serial.println("[BT] Done, Reboot now");
                g_esp_restsrt = true;
            }
          //-------------------------------------------------------------------------------




            //-------------------------------------------------
            if (strstr(bufferReceive.c_str(), "S53") != NULL) {
                Serial.println("[BT] KNX ETS Programmieren");
                String t_string = bufferReceive.c_str();
                knx_program_mode = !knx_program_mode;
                t_string = "KNX ETS Programmieren";
                Serial.println(t_string);

                std::string tempstr = std::string(t_string.c_str()) + "\r\n";
                queueNotification(tempstr.c_str());

                // Setze das Programm Mode Bit und speichere es in den Preferences
                Preferences preferences;
                preferences.begin("eenvs", false);  // Ordner eenvs anlegen/verwenden

                preferences.putBool("p_KNX_ets", knx_program_mode);  // KNX Program Mode aktivieren
                
                g_KNX_S_ist = 1;  // Hauptfunktion aktivieren
                preferences.putUShort("p_KNX_S", g_KNX_S_ist);  // Wert speichern

                preferences.end();


                // ESP neu starten
                Serial.println("ESP wird neu gestartet, um die Änderungen zu übernehmen...");
                delay(2000); // Kurze Verzögerung vor dem Neustart
                ESP.restart();
            }

            if (strstr(bufferReceive.c_str(), "G53") != NULL) {
                Serial.println("[BT] KNX Status Anfrage Programmiermodus");
                
                // Abrufen des aktuellen KNX Program Mode Status
                Preferences preferences;
                preferences.begin("eenvs", true);  // Nur lesen
                bool knx_program_modet = preferences.getBool("p_KNX_ets", false);
                preferences.end();
                
                // Statusnachricht erstellen
                String t_string = knx_program_modet ? "1" : "0";
                std::string tempstr = "G53:" + std::string(t_string.c_str()) + "\r\n";
                
                // Status senden
                queueNotification(tempstr.c_str());
            }
            //-------------------------------------------------





          //-------------------------------------------------
            if (strstr(bufferReceive.c_str(), "S54") != NULL) {
                Serial.println("[BT] KNX E/A");
                String t_string = bufferReceive.c_str();
                int Laenge = bufferReceive.length();
                int Suche = bufferReceive.indexOf("S54:");
                Suche = Suche + 4;
                t_string = bufferReceive.substring(Suche, Laenge);
                t_string.trim();  // Entfernt führende und nachfolgende Leerzeichen
                g_KNX_S_soll = t_string.toInt();
                g_KNX_S_ist = g_KNX_S_soll;
                
                
                Preferences preferences;
                preferences.begin("eenvs", false);  // Ordner eenvs anlegen/verwenden

                preferences.putUShort("p_KNX_S", g_KNX_S_ist);

                if(g_KNX_S_ist == 0){knx_program_mode = false;}
                preferences.putBool("p_KNX_ets", knx_program_mode);  // KNX Program Mode aktivieren

                preferences.end();
                std::string tempstr = "S54:" + std::string(t_string.c_str()) + "\r\n";
                queueNotification(tempstr.c_str());

                // ESP neu starten
                Serial.println("ESP wird neu gestartet, um die Änderungen zu übernehmen...");
                delay(2000); // Kurze Verzögerung vor dem Neustart
                ESP.restart();

            }


            if (strstr(bufferReceive.c_str(), "G54") != NULL) {
                Serial.println("[BT] KNX Status Anfrage E/A");

                // Abrufen des aktuellen g_KNX_S_ist Werts
                Preferences preferences;
                preferences.begin("eenvs", true);  // Nur lesen
                uint8_t knx_s_istt = preferences.getUShort("p_KNX_S", 0);  // Standardwert 0
                preferences.end();

                // Statusnachricht erstellen
                String t_string = String(knx_s_istt);
                std::string tempstr = "G54:" + std::string(t_string.c_str()) + "\r\n";

                // Status senden
                queueNotification(tempstr.c_str());
            }

            //-------------------------------------------------


          //-------------------------------------------------
            if (strstr(bufferReceive.c_str(), "S55") != NULL) {
                Serial.println("[BT] KNX toggle Prog Mode");
                String t_string = bufferReceive.c_str();
                int Laenge = bufferReceive.length();
                int Suche = bufferReceive.indexOf("S55:");
                Suche = Suche + 4;
                t_string = bufferReceive.substring(Suche, Laenge);
                t_string.trim();  // Entfernt führende und nachfolgende Leerzeichen
                knx.toggleProgMode();

                Preferences preferences;
                preferences.begin("eenvs", false);  // Ordner eenvs anlegen/verwenden
                //int currentPinState = digitalRead(20); // Lese den Zustand von Pin 20
                currentPinStateknx = !currentPinStateknx;
                   if (currentPinStateknx == HIGH) {
                     knx_program_mode = true;
                     preferences.putBool("p_KNX_ets", knx_program_mode);  // KNX Program Mode aktiviert
                  }else{
                     knx_program_mode = false;
                     preferences.putBool("p_KNX_ets", knx_program_mode);  // KNX Program Mode deaktiviert
                     g_t_led_change = true;
                  }
                preferences.end();
                t_string = String(knx_program_mode);

                std::string tempstr = "S55:" + std::string(t_string.c_str()) + "\r\n";
                queueNotification(tempstr.c_str());
            }
            if (strstr(bufferReceive.c_str(), "G55") != NULL) {
                Serial.println("[BT] KNX Status Anfrage (Pin 20)");

                // Abrufen des aktuellen Zustands von Pin 20
                //int currentPinStatet = digitalRead(20);

                // Statusnachricht erstellen
                String t_string = currentPinStateknx == HIGH ? "1" : "0";
                std::string tempstr = "G55:" + std::string(t_string.c_str()) + "\r\n";

                // Status senden
                queueNotification(tempstr.c_str());
            }

          //-------------------------------------------------


          //-------------------------------------------------
            // knxid:1.3.7
            if (strstr(bufferReceive.c_str(), "S56") != NULL) {
                KNX_DEBUG_MED_PRINTLN(F("[BT] KNX Adresse"));
                String t_string = bufferReceive.c_str();
                int Laenge = bufferReceive.length();
                int Suche = bufferReceive.indexOf("S56:");
                Suche = Suche + 4;
                t_string = bufferReceive.substring(Suche, Laenge);
                t_string.trim();  // Entfernt führende und nachfolgende Leerzeichen
                KNX_DEBUG_MED_PRINTLN(t_string);
                
                // Puffer auftrennen und den Variablen zuweisen
                int tempArea, tempLine, tempDevice;
                int result = sscanf(t_string.c_str(), "%d.%d.%d", &tempArea, &tempLine, &tempDevice);
                
                if (result == 3 && tempArea >= 0 && tempArea <= 255 && tempLine >= 0 && tempLine <= 255 && tempDevice >= 0 && tempDevice <= 255) {
                    uint8_t area = static_cast<uint8_t>(tempArea);
                    uint8_t line = static_cast<uint8_t>(tempLine);
                    uint8_t device = static_cast<uint8_t>(tempDevice);
                    
                    // Werte speichern
                    saveKNXAddress(area, line, device);
                    
                    std::string tempstr = "S56:" + std::string(t_string.c_str()) + "\r\n";
                    queueNotification(tempstr.c_str());
                } else {
                    KNX_DEBUG_MED_PRINTLN(F("Ungültige KNX-Adresse"));
                }
            }

            if (strstr(bufferReceive.c_str(), "G56") != NULL) {
                Serial.println("[BT] KNX Adressabfrage");


                // Adresse in String umwandeln
                char addressBuffer[16];
                snprintf(addressBuffer, sizeof(addressBuffer), "%d.%d.%d", area, line, device);
                
                // Statusnachricht erstellen
                String t_string = String(addressBuffer);
                std::string tempstr = "G56:" + std::string(t_string.c_str()) + "\r\n";

                // Status senden
                queueNotification(tempstr.c_str());
            }


            //-------------------------------------------------



          //-------------------------------------------------
            // knxgroup:12/0/1&12/0/1&12/0/2&12/0/1
            if (strstr(bufferReceive.c_str(), "S57") != NULL) {
                KNX_DEBUG_MED_PRINTLN(F("[BT] KNX Gruppenadressen"));
                String t_string = bufferReceive.c_str();
                int Laenge = bufferReceive.length();
                int Suche = bufferReceive.indexOf("S57:");
                Suche = Suche + 4;
                t_string = bufferReceive.substring(Suche, Laenge);
                t_string.trim();  // Entfernt führende und nachfolgende Leerzeichen
                KNX_DEBUG_MED_PRINTLN(t_string);
                
                // Puffer auftrennen und den Variablen zuweisen
                int numAddressest = 0;
                char tempString[110];
                t_string.toCharArray(tempString, sizeof(tempString));
                char* token = strtok(tempString, "&");
                while (token != NULL && numAddressest < 4) {
                    int mainGroup, middleGroup, subGroup;
                    int result = sscanf(token, "%d/%d/%d", &mainGroup, &middleGroup, &subGroup);
                    
                    // Überprüfen, ob die Werte im gültigen Bereich liegen (0-255)
                    if (result == 3 && mainGroup >= 0 && mainGroup <= 255 && middleGroup >= 0 && middleGroup <= 255 && subGroup >= 0 && subGroup <= 255) {
                        groupAddresses[numAddressest][0] = mainGroup;
                        groupAddresses[numAddressest][1] = middleGroup;
                        groupAddresses[numAddressest][2] = subGroup;
                        // Debug-Ausgabe der zerlegten Gruppenadresse
                        KNX_DEBUG_MED_PRINT(F("Gruppenadresse "));
                        KNX_DEBUG_MED_PRINT(numAddressest + 1);
                        KNX_DEBUG_MED_PRINT(F(": "));
                        KNX_DEBUG_MED_PRINT(mainGroup);
                        KNX_DEBUG_MED_PRINT(F("/"));
                        KNX_DEBUG_MED_PRINT(middleGroup);
                        KNX_DEBUG_MED_PRINT(F("/"));
                        KNX_DEBUG_MED_PRINTLN(subGroup);
                        numAddressest++;
                    } else {
                        KNX_DEBUG_MED_PRINTLN(F("Ungültige Gruppenadresse"));
                    }

                    token = strtok(NULL, "&");
                }
                numAddresses = numAddressest;
                saveGroupAddresses(groupAddresses, numAddresses);
                std::string tempstr = "S57:" + std::string(t_string.c_str()) + "\r\n";
                queueNotification(tempstr.c_str());
            }


            if (strstr(bufferReceive.c_str(), "G57") != NULL) {
                Serial.println("[BT] KNX Gruppenadressenabfrage");

                // Abrufen der aktuellen Gruppenadressen
                String addressesString = "";
                for (int i = 0; i < 4; i++) {
                    if (i != 0) {
                        addressesString += ",";  // Komma als Trennzeichen
                    }
                    addressesString += String(groupAddresses[i][0]) + "." + 
                                      String(groupAddresses[i][1]) + "." + 
                                      String(groupAddresses[i][2]);
                }

                // Statusnachricht erstellen
                std::string tempstr = "G57:" + std::string(addressesString.c_str()) + "\r\n";

                // Status senden
                queueNotification(tempstr.c_str());
            }

            //-------------------------------------------------



          //-------------------------------------------------
            // 
            if (strstr(bufferReceive.c_str(), "S58") != NULL) {
                Serial.println("[BT] KNX Parameter 0");
                String t_string = bufferReceive.c_str();
                int Laenge = bufferReceive.length();
                int Suche = bufferReceive.indexOf("S58:");
                Suche = Suche + 4;
                t_string = bufferReceive.substring(Suche, Laenge);
                t_string.trim();  // Entfernt führende und nachfolgende Leerzeichen
                Serial.println(t_string);
                
                // paramByte(0) speichern
                uint8_t paramByte0Value = t_string.toInt();
                saveParamByte0(paramByte0Value);
                
                std::string tempstr = "S58:" + std::string(t_string.c_str()) + "\r\n";
                queueNotification(tempstr.c_str());
            }
            if (strstr(bufferReceive.c_str(), "G58") != NULL) {
                Serial.println("[BT] KNX Parameter 0 Abfrage");

                // Abrufen des aktuellen Werts von paramByte(0)
                uint8_t paramByte0Value = knx.paramByte(0);

                // Wert in String umwandeln
                String t_string = String(paramByte0Value);
                std::string tempstr = "G58:" + std::string(t_string.c_str()) + "\r\n";

                // Status senden
                queueNotification(tempstr.c_str());
            }

            //-------------------------------------------------

          //-------------------------------------------------
            // 
            if (strstr(bufferReceive.c_str(), "S59") != NULL) {
                Serial.println("[BT] KNX Parameter 1");
                String t_string = bufferReceive.c_str();
                int Laenge = bufferReceive.length();
                int Suche = bufferReceive.indexOf("S59:");
                Suche = Suche + 4;
                t_string = bufferReceive.substring(Suche, Laenge);
                t_string.trim();  // Entfernt führende und nachfolgende Leerzeichen
                Serial.println(t_string);
                
                // paramByte(1) speichern
                uint8_t paramByte1Value = t_string.toInt();
                saveParamByte1(paramByte1Value);
                
                std::string tempstr = "S59:" + std::string(t_string.c_str()) + "\r\n";
                queueNotification(tempstr.c_str());
            }
            if (strstr(bufferReceive.c_str(), "G59") != NULL) {
                Serial.println("[BT] KNX Parameter 1 Abfrage");

                // Abrufen des aktuellen Werts von paramByte(1)
                uint8_t paramByte1Value = knx.paramByte(1);

                // Wert in String umwandeln
                String t_string = String(paramByte1Value);
                std::string tempstr = "G59:" + std::string(t_string.c_str()) + "\r\n";

                // Status senden
                queueNotification(tempstr.c_str());
            }
            //-------------------------------------------------


            //-------------------------------------------------
              if (strstr(bufferReceive.c_str(), "S60") != NULL) {
                  KNX_DEBUG_MED_PRINTLN(F("[BT] KNX Multicast-Adresse"));
                  String t_string = bufferReceive.c_str();
                  int Laenge = bufferReceive.length();
                  int Suche = bufferReceive.indexOf("S60:");
                  Suche = Suche + 4;
                  t_string = bufferReceive.substring(Suche, Laenge);
                  t_string.trim();  // Entfernt führende und nachfolgende Leerzeichen
                  KNX_DEBUG_MED_PRINTLN(t_string);

                  // Nur Punkte als Trennzeichen akzeptieren
                  if (t_string.indexOf('/') != -1 || t_string.indexOf(':') != -1 || t_string.indexOf(' ') != -1) {
                      KNX_DEBUG_MED_PRINTLN(F("Ungültige Multicast-Adresse: Nur Punkte sind als Trennzeichen erlaubt"));
                      return;
                  }

                  // Multicast-Adresse speichern
                  uint8_t multicast[4];
                  int result = sscanf(t_string.c_str(), "%hhu.%hhu.%hhu.%hhu", &multicast[0], &multicast[1], &multicast[2], &multicast[3]);

                  if (result == 4) {
                      saveMulticastAddress(multicast);
                      std::string tempstr = "S60:" + std::string(t_string.c_str()) + "\r\n";
                      queueNotification(tempstr.c_str());
                  } else {
                      KNX_DEBUG_MED_PRINTLN(F("Ungültige Multicast-Adresse"));
                  }


              }



              if (strstr(bufferReceive.c_str(), "G60") != NULL) {
                  KNX_DEBUG_MED_PRINTLN(F("[BT] KNX Multicast-Adresse Abfrage"));

                  uint32_t flashPos = 57; // Startadresse für die Multicast-Adresse
                  uint8_t multicast[4];
                  uint8_t data[6];

                  // Daten aus storedData lesen
                  for (int i = 0; i < sizeof(data); i++) {
                      data[i] = storedData[flashPos + i];
                      Serial.print(F("Gelesene Daten["));
                      Serial.print(i);
                      Serial.print(F("]: "));
                      Serial.println(data[i]);
                  }

                  // Multicast-Adresse extrahieren
                  memcpy(multicast, data, 4);

                  // Debug-Ausgabe der gelesenen Multicast-Adresse
                  Serial.print(F("[KX] Gelesene Multicast-Adresse: "));
                  for (int i = 0; i < 4; i++) {
                      Serial.print(multicast[i]);
                      if (i < 3) Serial.print(F("."));
                  }
                  Serial.println();

                  // Überprüfen der Kontrollbytes
                  if (data[4] == 0 && data[5] == 1) {
                      Serial.println(F("[KX] Multicast-Adresse erfolgreich gelesen."));

                      // Multicast-Adresse in String umwandeln
                      String t_string = String(multicast[0]) + "." + String(multicast[1]) + "." + String(multicast[2]) + "." + String(multicast[3]);
                      KNX_DEBUG_MED_PRINT(F("Umgewandelte Multicast-Adresse: "));
                      KNX_DEBUG_MED_PRINTLN(t_string);

                      std::string tempstr = "G60:" + std::string(t_string.c_str()) + "\r\n";
                      queueNotification(tempstr.c_str());
                  } else {
                      Serial.println(F("[KX] Fehler beim Lesen der Multicast-Adresse."));
                  }
              }

            //-------------------------------------------------


            //-------------------------------------------------
            if (strstr(bufferReceive.c_str(), "S61") != NULL) {
                KNX_DEBUG_MED_PRINTLN(F("[BT] KNX Gateway"));
                String t_string = bufferReceive.c_str();
                int Laenge = bufferReceive.length();
                int Suche = bufferReceive.indexOf("S61:");
                Suche = Suche + 4;
                t_string = bufferReceive.substring(Suche, Laenge);
                t_string.trim();  // Entfernt führende und nachfolgende Leerzeichen
                KNX_DEBUG_MED_PRINTLN(t_string);

                // Nur Punkte als Trennzeichen akzeptieren
                if (t_string.indexOf('/') != -1 || t_string.indexOf(':') != -1 || t_string.indexOf(' ') != -1) {
                    KNX_DEBUG_MED_PRINTLN(F("Ungültige Gateway-Adresse: Nur Punkte sind als Trennzeichen erlaubt"));
                    return;
                }

                // Gateway speichern
                uint8_t gateway[4];
                int result = sscanf(t_string.c_str(), "%hhu.%hhu.%hhu.%hhu", &gateway[0], &gateway[1], &gateway[2], &gateway[3]);

                if (result == 4) {
                    saveGateway(gateway);
                    std::string tempstr = "S61:" + std::string(t_string.c_str()) + "\r\n";
                    queueNotification(tempstr.c_str());
                } else {
                    KNX_DEBUG_MED_PRINTLN(F("Ungültige Gateway-Adresse"));
                }


            }



            if (strstr(bufferReceive.c_str(), "G61") != NULL) {
                KNX_DEBUG_MED_PRINTLN(F("[BT] KNX Gateway Abfrage"));

                uint32_t flashPos = 51; // Startadresse für das Gateway
                uint8_t gateway[4];
                uint8_t data[6];

                // Daten aus storedData lesen
                for (int i = 0; i < sizeof(data); i++) {
                    data[i] = storedData[flashPos + i];
                    Serial.print(F("Gelesene Daten["));
                    Serial.print(i);
                    Serial.print(F("]: "));
                    Serial.println(data[i]);
                }

                // Gateway extrahieren
                memcpy(gateway, data, 4);

                // Debug-Ausgabe der gelesenen Gateway-Adresse
                Serial.print(F("[KX] Gelesene Gateway-Adresse: "));
                for (int i = 0; i < 4; i++) {
                    Serial.print(gateway[i]);
                    if (i < 3) Serial.print(F("."));
                }
                Serial.println();

                // Überprüfen der Kontrollbytes
                if (data[4] == 0 && data[5] == 1) {
                    Serial.println(F("[KX] Gateway-Adresse erfolgreich gelesen."));

                    // Gateway in String umwandeln
                    String t_string = String(gateway[0]) + "." + String(gateway[1]) + "." + String(gateway[2]) + "." + String(gateway[3]);
                    KNX_DEBUG_MED_PRINT(F("Umgewandelte Gateway-Adresse: "));
                    KNX_DEBUG_MED_PRINTLN(t_string);

                    std::string tempstr = "G61:" + std::string(t_string.c_str()) + "\r\n";
                    queueNotification(tempstr.c_str());
                } else {
                    Serial.println(F("[KX] Fehler beim Lesen der Gateway-Adresse."));
                }
            }

            //-----------------------------------------------------------------


            //-----------------------------------------------------------------
            if (strstr(bufferReceive.c_str(), "S62") != NULL) {
                KNX_DEBUG_MED_PRINTLN(F("[BT] KNX Subnetzmaske"));
                String t_string = bufferReceive.c_str();
                int Laenge = bufferReceive.length();
                int Suche = bufferReceive.indexOf("S62:");
                Suche = Suche + 4;
                t_string = bufferReceive.substring(Suche, Laenge);
                t_string.trim();  // Entfernt führende und nachfolgende Leerzeichen
                KNX_DEBUG_MED_PRINTLN(t_string);

                // Nur Punkte als Trennzeichen akzeptieren
                if (t_string.indexOf('/') != -1 || t_string.indexOf(':') != -1 || t_string.indexOf(' ') != -1) {
                    KNX_DEBUG_MED_PRINTLN(F("Ungültige Subnetzmaske: Nur Punkte sind als Trennzeichen erlaubt"));
                    return;
                }

                // Subnetzmaske speichern
                uint8_t subnet[4];
                int result = sscanf(t_string.c_str(), "%hhu.%hhu.%hhu.%hhu", &subnet[0], &subnet[1], &subnet[2], &subnet[3]);
                if (result == 4) {
                    saveSubnetMask(subnet);
                    std::string tempstr = "S62:" + std::string(t_string.c_str()) + "\r\n";
                    queueNotification(tempstr.c_str());
                } else {
                    KNX_DEBUG_MED_PRINTLN(F("Ungültige Subnetzmaske"));
                }


            }


            if (strstr(bufferReceive.c_str(), "G62") != NULL) {
                KNX_DEBUG_MED_PRINTLN(F("[BT] KNX Subnetzmaske Abfrage"));

                uint32_t flashPos = 45; // Startadresse für die Subnetzmaske
                uint8_t subnet[4];
                uint8_t data[6];

                // Daten aus storedData lesen
                for (int i = 0; i < sizeof(data); i++) {
                    data[i] = storedData[flashPos + i];
                    Serial.print(F("Gelesene Daten["));
                    Serial.print(i);
                    Serial.print(F("]: "));
                    Serial.println(data[i]);
                }

                // Subnetzmaske extrahieren
                memcpy(subnet, data, 4);

                // Debug-Ausgabe der gelesenen Subnetzmaske
                Serial.print(F("[KX] Gelesene Subnetzmaske: "));
                for (int i = 0; i < 4; i++) {
                    Serial.print(subnet[i]);
                    if (i < 3) Serial.print(F("."));
                }
                Serial.println();

                // Überprüfen der Kontrollbytes
                if (data[4] == 0 && data[5] == 1) {
                    Serial.println(F("[KX] Subnetzmaske erfolgreich gelesen."));

                    // Subnetzmaske in String umwandeln
                    String t_string = String(subnet[0]) + "." + String(subnet[1]) + "." + String(subnet[2]) + "." + String(subnet[3]);
                    KNX_DEBUG_MED_PRINT(F("Umgewandelte Subnetzmaske: "));
                    KNX_DEBUG_MED_PRINTLN(t_string);

                    std::string tempstr = "G62:" + std::string(t_string.c_str()) + "\r\n";
                    queueNotification(tempstr.c_str());
                } else {
                    Serial.println(F("[KX] Fehler beim Lesen der Subnetzmaske."));
                }
            }

            //-----------------------------------------------------------------


            //-----------------------------------------------------------------
            if (strstr(bufferReceive.c_str(), "S52") != NULL) {
                KNX_DEBUG_MED_PRINTLN(F("[BT] KNX IP-Adresse"));
                String t_string = bufferReceive.c_str();
                int Laenge = bufferReceive.length();
                int Suche = bufferReceive.indexOf("S63:");
                Suche = Suche + 4;
                t_string = bufferReceive.substring(Suche, Laenge);
                t_string.trim();  // Entfernt führende und nachfolgende Leerzeichen
                KNX_DEBUG_MED_PRINTLN(t_string);

                // Nur Punkte als Trennzeichen akzeptieren
                if (t_string.indexOf('/') != -1 || t_string.indexOf(':') != -1 || t_string.indexOf(' ') != -1) {
                    KNX_DEBUG_MED_PRINTLN(F("Ungültige IP-Adresse: Nur Punkte sind als Trennzeichen erlaubt"));
                    return;
                }

                // IP-Adresse speichern
                uint8_t ip[4];
                int result = sscanf(t_string.c_str(), "%hhu.%hhu.%hhu.%hhu", &ip[0], &ip[1], &ip[2], &ip[3]);

                if (result == 4) {
                    saveIPAddress(ip);
                    std::string tempstr = "S63:" + std::string(t_string.c_str()) + "\r\n";
                    queueNotification(tempstr.c_str());
                } else {
                    KNX_DEBUG_MED_PRINTLN(F("Ungültige IP-Adresse"));
                }


            }



            if (strstr(bufferReceive.c_str(), "G52") != NULL) {
                KNX_DEBUG_MED_PRINTLN(F("[BT] KNX IP-Adresse Abfrage"));

                uint32_t flashPos = 39; // Startadresse für die IP-Adresse
                uint8_t ip[4];
                uint8_t data[6];

                // Daten aus storedData lesen
                for (int i = 0; i < sizeof(data); i++) {
                    data[i] = storedData[flashPos + i];
                    Serial.print(F("Gelesene Daten["));
                    Serial.print(i);
                    Serial.print(F("]: "));
                    Serial.println(data[i]);
                }

                // IP-Adresse extrahieren
                memcpy(ip, data, 4);

                // Debug-Ausgabe der gelesenen IP-Adresse
                Serial.print(F("[KX] Gelesene IP-Adresse: "));
                for (int i = 0; i < 4; i++) {
                    Serial.print(ip[i]);
                    if (i < 3) Serial.print(F("."));
                }
                Serial.println();

                // Überprüfen der Kontrollbytes
                if (data[4] == 0 && data[5] == 1) {
                    Serial.println(F("[KX] IP-Adresse erfolgreich gelesen."));

                    // IP-Adresse in String umwandeln
                    String t_string = String(ip[0]) + "." + String(ip[1]) + "." + String(ip[2]) + "." + String(ip[3]);
                    KNX_DEBUG_MED_PRINT(F("Umgewandelte IP-Adresse: "));
                    KNX_DEBUG_MED_PRINTLN(t_string);

                    std::string tempstr = "G63:" + std::string(t_string.c_str()) + "\r\n";
                    queueNotification(tempstr.c_str());
                } else {
                    Serial.println(F("[KX] Fehler beim Lesen der IP-Adresse."));
                }
            }

            //-----------------------------------------------------------------





            //if(bufferReceive == buff_scan)
            if (strstr(bufferReceive.c_str(), "SEARCH") != NULL) {
                bufferReceive = "";
                Serial.println("[BT] Aktion Modbus Sensor SEARCH Start");
                std::string tempstr = "Start Modbus Sensor search...   please Wait!\r\n";
                queueNotification(tempstr.c_str());
                lc.setIntensity(15); // 5=Standard Helligkeit vorne
                lc.setChar(0,0,'S',false);
                lc.setChar(0,1,'E',false);
                lc.setChar(0,2,'C',false);
                lc.setChar(0,3,'H',false);
                delay(100);
                esp_task_wdt_reset();
                g_search_start = true;
            }

            if (strstr(bufferReceive.c_str(), "CENTER") != NULL) {
                bufferReceive = "";
                Serial.println("[BT] Aktion Display Center Position");
                std::string tempstr = "Aktion Display Center Position\r\n";
                queueNotification(tempstr.c_str());
                tick4 = !tick4;
                if (tick4 == true) {
                    g_unitpos_ist = 1;
                } else {
                    g_unitpos_ist = 0;
                }
            }








               //---------- NUR Gespeicherte Ausgeben ------------
            if (strstr(bufferReceive.c_str(), "SCAN2") != NULL) {
                bufferReceive = "";
                Serial.println("[BT] Aktion SCAN 2 Start");
                std::string tempstr = "Start Scan 2\r\n";
                queueNotification(tempstr.c_str());
                lc.setIntensity(15); // 5=Standard Helligkeit vorne
                lc.setChar(0,0,'S',false);
                lc.setChar(0,1,'c',false);
                lc.setChar(0,2,'a',false);
                lc.setChar(0,3,'n',false);
                delay(100);
                esp_task_wdt_reset();
                g_scan_start2 = true;
            }

            //------ Neu WLAN suchen und nur Speichern --------
            if (strstr(bufferReceive.c_str(), "SCAN3") != NULL) {
                bufferReceive = "";
                Serial.println("[BT] Aktion SCAN 3 Start");
                std::string tempstr = "Start Scan 3\r\n";
                queueNotification(tempstr.c_str());
                lc.setIntensity(15); // 5=Standard Helligkeit vorne
                lc.setChar(0,0,'S',false);
                lc.setChar(0,1,'c',false);
                lc.setChar(0,2,'a',false);
                lc.setChar(0,3,'n',false);
                delay(100);
                esp_task_wdt_reset();
                previous_wlan_count = 0;
                g_wlan_read = false;
            }






            //-------------------------------------------------
             //---- Neu WLAN Suchen und direkt übertragen ------
            if (strstr(bufferReceive.c_str(), "SCAN") != NULL || strstr(bufferReceive.c_str(), "G34") != NULL) { // nach SCAN2u3, weil sonst das erst ausgeführt wird
                bufferReceive = "";
                Serial.println("[BT] Aktion SCAN Start");
                std::string tempstr = "Start Scan\r\n";
                queueNotification(tempstr.c_str());
                lc.setIntensity(15); // 5=Standard Helligkeit vorne
                lc.setChar(0,0,'S',false);
                lc.setChar(0,1,'c',false);
                lc.setChar(0,2,'a',false);
                lc.setChar(0,3,'n',false);
                delay(100);
                esp_task_wdt_reset();
                if (heap_caps_get_largest_free_block(MALLOC_CAP_DEFAULT) > 5500) {
                    g_scan_start = true;
                    g_scan_alternative = false;
                } else {
                    Serial.print(F("[BT] Nicht genug Speicher !! Aktuell: "));
                    Serial.println(heap_caps_get_largest_free_block(MALLOC_CAP_DEFAULT));
                    Serial.println(F("[BT] Alternative !!"));
                    g_scan_start2 = true;
                    // !!! normal hier restart ausführen !!!
                }
            }
            //-------------------------------------------------



            //-------------------------------------------------
            //if(bufferReceive == buff_wifistatus)
            if (strstr(bufferReceive.c_str(), "STATUS") != NULL)
            {
              bufferReceive = "";
              Serial.println("[BT] Aktion Status");

              send_bl_status = true;

              sendValuesIndividually2();

            }        



            if (strstr(bufferReceive.c_str(), "CONNECT:") != NULL)
            {
              g_connect_start = true;

              //  g_scan_alternative = true
              
                Serial.println(F("[BT] WLAN Change"));

                //String bufferReceive = "Programmieren finde ich toll ;-)";    

                // Länge bestimmen
                int Laenge = bufferReceive.length(); 
                //Serial.print("L\u00e4nge des Strings: "); 
                //Serial.println(Laenge);  
                
                // das t suchen  
                int Suche = bufferReceive.indexOf("CONNECT:"); 
                //Serial.print("Position CONNECT:: "); 
                Suche = Suche + 8;
                //Serial.println(Suche); 

                // oder, weil Laenge schon bestimmt wurde:  
                // bufferReceive.substring(suche + 1, Laenge); 
                //Serial.print("String vom CONNECT: bis zum Ende: ");  
                bufferReceive = bufferReceive.substring(Suche, Laenge);    
                //Serial.println(bufferReceive); 
                //Serial.println("-------------------"); 
            
            
            
                char tempchar[80];
                int length = bufferReceive.length();
                bufferReceive.toCharArray(tempchar, length+1); 



                char *name = NULL;
              
                    name = strtok(tempchar, ",|");
          
                    int posval = 0;

                    while(name != NULL)
                    {
                      
                        //Serial.println(name);
                        if(posval == 0){
                          Serial.print("WLAN Nr. ");
                          ist_wlan = atoi(name); 
                          Serial.print(ist_wlan);
                          Serial.print(" | PW: ");
                        }
                        if(posval == 1){
                          ist_pw = String(name);
                          Serial.print(ist_pw);
                          Serial.println("");
                        }

                        // Serial.println(wlan_ssids[i]);
                        // p_find_wlani = atoi(p_find_wlan.c_str()); 
                        name = strtok(NULL, ",|"); 
                        posval ++;

                    }
            
                Serial.println("****g_connect_WLAN*****");
                g_connect_WLAN = true;
                //if (wlan_found == 0){ wlan_found= 1;}
 
                Serial.println("Found: " + String(wlan_found));

              bufferReceive = "";
            } // CONNECT:

        }//login
        
        //Serial.println();
        //Serial.println("*********");
      }
    }
};




  //------------------------------------------------------------

  #ifdef BLEbeacon_space

    void startBeacon() {
      Serial.println("[BT] Enable Beacon");
      BLEDevice::setPower(ESP_PWR_LVL_N12);
      pAdvertising = BLEDevice::getAdvertising();
      pAdvertising->start();

    }
  #endif 



    //-----------------------------------
    void startBLEserver() {
        
      
        if(BLE_Server_enabled == false){

          BT_DEBUG_MIN_PRINTLN(F("[BT] Enable BLE-Server"));
          if (!BLEDevice::getInitialized()) {
            BLEDevice::init(p_APname_p.c_str());
          }    
          // Erstelle den BLE-Server
          BLEServer *pServer = BLEDevice::createServer(); // <-- no longer required to instantiate BLEServer, less flash and ram usage 
          //pServer = BLEDevice::createServer();
          // Definiere eine Klasse für die Server-Callbacks
          pServer->setCallbacks(new MyServerCallbacks());
          // Erstelle den BLE-Service
          BLEService *pService = pServer->createService(SERVICE_UUID);
          // Create a BLE Characteristic
          pTxCharacteristic = pService->createCharacteristic(
                            CHARACTERISTIC_UUID_TX,
                            BLECharacteristic::PROPERTY_NOTIFY
                          );
          // Füge den BLE2902-Descriptor hinzu                   
          pTxCharacteristic->addDescriptor(new BLE2902());

          BLECharacteristic * pRxCharacteristic = pService->createCharacteristic(
                              CHARACTERISTIC_UUID_RX,
                              BLECharacteristic::PROPERTY_WRITE
                            );
        // Setze die Callbacks für die Charakteristik
          pRxCharacteristic->setCallbacks(new MyCallbacks());

          // Starte den Service
          pService->start();
          BT_DEBUG_MIN_PRINTLN(F("[BT] Advertizing Service started"));

          BLE_Server_enabled = true;
          
          esp_task_wdt_reset();

        }

    }
    //-----------------------------------





      void checkMemory() {
          #if BT_DEBUG_LEVEL == BT_DEBUG_MAX
            size_t free8bit = heap_caps_get_free_size(MALLOC_CAP_8BIT);
            BT_DEBUG_MAX_PRINT(F("Freier 8-Bit-Speicher: "));
            BT_DEBUG_MAX_PRINTLN(free8bit);
          #endif
      }







    //-----------------------------------
      void startBeacon2() {

          if(BLE_Beacon_enabled == false){
              
              BT_DEBUG_MIN_PRINTLN(F("[BT] Enable Beacon"));

              if (!BLEDevice::getInitialized()) {
                  // BT_DEBUG_MIN_PRINTLN(F("[BT] BLEDevice::init(p_APname_c)"));
                  BLEDevice::init(p_APname_p.c_str());
              }
                
              if (BLEDevice::getInitialized()) {
                  // BT_DEBUG_MIN_PRINTLN("pAdvertising = BLEDevice::getAdvertising()");
                  pAdvertising = BLEDevice::getAdvertising();
                  BLEDevice::startAdvertising();
                  pAdvertising->start();
                  BT_DEBUG_MIN_PRINTLN(F("[BT] Advertizing Beacon started"));
                  BLE_Beacon_enabled = true;
              }
          
          }

      }

    //-----------------------------------


    //-----------------------------------
      void stopBeacon() {

          if (BLE_Beacon_enabled) {
              BT_DEBUG_MED_PRINTLN(F("[BT] BLE stoppen"));

              if (BLEDevice::getInitialized()) {
                  BT_DEBUG_MED_PRINTLN(F("[BT] Disable BLE"));

                  // Stoppe die Werbung
                  pAdvertising->stop();
                  BT_DEBUG_MED_PRINTLN(F("[BT] Werbung gestoppt"));
                  BLEDevice::stopAdvertising();
                  BT_DEBUG_MED_PRINTLN(F("[BT] Werbung deaktiviert"));

                  /*
                  // Lösche die BLE-Objekte
                  delete pAdvertising;
                  pAdvertising = NULL;
                  // Deinitialisiere BLE
                  BLEDevice::deinit();
                  */
                  
                  if (pAdvertising != NULL) {
                      pAdvertising->stop();
                      delete pAdvertising;
                      pAdvertising = NULL;
                  }
                  // Deinitialisiere BLE
                  //BLEDevice::deinit();
                
                  BLE_Server_enabled = false;
                  //BLE_Beacon_enabled = false;

                  BT_DEBUG_MAX_PRINTLN(F("BLE deaktiviert und Speicher freigegeben."));
                  //checkMemory();  // Überprüfe den Speicherstatus nach dem Stoppen
              }
          } else {
              BT_DEBUG_MAX_PRINTLN(F("[BT] BLE schon gestoppt"));
          }
      }

    //-----------------------------------

    //-----------------------------------
      void stopBLEserver() {
          if (BLEDevice::getInitialized()) {
              BT_DEBUG_MED_PRINTLN(F("[BT] Disable BLE Server"));

              // Stoppe die Werbung
              if (pAdvertising != NULL) {
                  pAdvertising->stop();
                  BLEDevice::stopAdvertising();
                  // pAdvertising nicht löschen
                  delete pAdvertising;
                  pAdvertising = NULL;
              }

              // BLE-Charakteristiken nicht löschen
              if (pTxCharacteristic != NULL) {
                  delete pTxCharacteristic;
                  pTxCharacteristic = NULL;
              }

              // BLE-Server nicht löschen
              if (pServer != NULL) {
                  delete pServer;
                  pServer = NULL;
              }

              // BLE nicht deinitialisieren
              //BLEDevice::deinit();

              BLE_Server_enabled = false;
              //BLE_Beacon_enabled = false;

              BT_DEBUG_MED_PRINTLN(F("BLE deaktiviert."));
          }
      }

    //-----------------------------------



      void stopBLEserver_not_Beacon() {

          if (BLEDevice::getInitialized()) {
              BT_DEBUG_MED_PRINTLN(F("[BT] Disable BLE Server, not Beacon"));

              // Stoppe die Werbung des Servers
              if (pAdvertising != NULL) {
                  pAdvertising->stop();
                  BLEDevice::stopAdvertising();
                  // pAdvertising nicht löschen, da es vom Beacon verwendet wird
              }

              // Lösche die BLE-Charakteristiken
              if (pTxCharacteristic != NULL) {
                  delete pTxCharacteristic;
                  pTxCharacteristic = NULL;
              }

              // Lösche den BLE-Server
              if (pServer != NULL) {
                  delete pServer;
                  pServer = NULL;
              }

              BT_DEBUG_MAX_PRINTLN(F("BLE Server deaktiviert und Speicher freigegeben."));
          }
      }

  //------------------------------------------------------------





void checkMemory2() {
    Serial.print(F("[DBG] Free heap: "));
    Serial.println(esp_get_free_heap_size());
    Serial.print(F("[DBG] Largest free block: "));
    Serial.println(heap_caps_get_largest_free_block(MALLOC_CAP_DEFAULT));
}

void setBeacon2() {
    static uint8_t counter = 0; // Initialisiere den Counter

    if (!ble_delayCompleted) {
        unsigned long ble_currentMillis = millis();

        // Überprüfen, ob 10 Sekunden vergangen sind
        if (ble_currentMillis - ble_startMillis >= ble_delayTime) {
            ble_delayCompleted = true;  // Verzögerung abgeschlossen
            //Serial.println(F("[DBG] BLE-Verzögerung abgeschlossen"));
        }
    } else {   // Verzögerung abgeschlossen
        //Serial.println(F("[DBG] Betrete setBeacon2()"));

        char beacon_data[27];

        BLEBeacon oBeacon = BLEBeacon();
        oBeacon.setManufacturerId(0x4C00); // fake Apple 0x004C LSB (ENDIAN_CHANGE_U16!)
        oBeacon.setProximityUUID(BLEUUID(BEACON_UUID));
        oBeacon.setMajor((bootcount & 0xFFFF0000) >> 16);
        oBeacon.setMinor(bootcount & 0xFFFF);

        BLEAdvertisementData oAdvertisementData = BLEAdvertisementData(); // Deklaration beibehalten

        #define TRACER_FORMAT 0xD5

        oAdvertisementData.setFlags(0x06); // GENERAL_DISC_MODE 0x02 | BR_EDR_NOT_SUPPORTED 0x04

        beacon_data[0] = 0xAF;
        beacon_data[1] = 0x0D;
        beacon_data[2] = TRACER_FORMAT;  //D5     Eddystone Frame Type (Eddystone-UID)

        // Kopiere die Byte-Daten direkt ohne Umwandlung in Hex und zurück
        memcpy(&beacon_data[3], &mb_radon_live_32bit, 4);
        memcpy(&beacon_data[7], &radon_mittelwert_24h, 4);
        memcpy(&beacon_data[11], &radon_mittelwert_long, 4);
        memcpy(&beacon_data[15], &mb_radon_save_eintrarge, 2);

        // Manuelles Kopieren der Zeichen aus device_id_c in beacon_data
        for (int i = 0; i < 8; i++) {
            beacon_data[17 + i] = device_id_c[i];
        }

        beacon_data[25] = counter;

        oAdvertisementData.setManufacturerData(std::string(beacon_data, 26));

        // Ausgabe der Werbedaten zur Überprüfung
        /*
        Serial.print(F("[DBG] Werbedaten vor dem Setzen, Counter: "));
        for (int i = 0; i < 26; i++) {
            Serial.print(beacon_data[i], HEX);
            Serial.print(" ");
        }
        Serial.println();
        */

        //if (counter % 20 == 0) {
          //Serial.println(F("[DBG] Werbung neu gestartet bei Counter 20"));
        if (counter == 0) {  
            //Serial.println(F("[DBG] Werbung gestartet bei Counter 0"));
            pAdvertising->stop();
            delay(200); // Kurze Verzögerung einfügen, um sicherzustellen, dass die Werbung vollständig gestoppt wird

            // Initialisiere die Werbung neu
            BLEDevice::startAdvertising();
            pAdvertising = BLEDevice::getAdvertising();

            // Setze die Werbedaten erneut
            pAdvertising->setAdvertisementData(oAdvertisementData);
            pAdvertising->start();
            //Serial.println(F("[DBG] Werbung neu initialisiert und gestartet"));
        } else {
            // Setze die Werbedaten bei jeder Iteration
            pAdvertising->setAdvertisementData(oAdvertisementData);
            //Serial.println(F("[DBG] Werbedaten aktualisiert"));
        }

        //Serial.print(F("[DBG] Beacon-Daten gesendet, Counter: "));
        //Serial.println(counter);

        counter = (counter + 1) % 256;
        //Serial.print(F("[DBG] Neuer Counter-Wert nach Inkrementierung: "));
        //Serial.println(counter);
    }
}







// callback 2 sec.
void Callback_2s(){
	//Serial.print("2sec...: ");
	  //Serial.println(millis());
   
     



//------ WLAN Überwachung ------------------------------
      // Timer aktualisieren
      previousSeconds += 2;  // alle 2 Sekunden
      if (WiFi.status() == WL_CONNECTED) {
        connectedTime += 2;
      } else {
        offlineTime += 2;
        internetTransferComplete = true;  // BL aktivieren
      }
      start_wlan_auswertung = true;
      //                                       0                                                 1                                                       1
      //Serial.print("[WL] "); Serial.print(g_Seg__boot_ani); Serial.print(" ");Serial.print(g_wlan_check_start); Serial.print(" ");Serial.println(start_wlan_auswertung);
//---------------------------------------------------------





    //float totalRAM = ESP.getHeapSize() / (1024.0 * 1024.0);
    float usedRAM = (ESP.getHeapSize() - ESP.getFreeHeap()) / (1024.0 * 1024.0);
    //float usedPercentageRAM = (usedRAM * 100) / totalRAM;

    // Überprüfen, ob sich die zweite Nachkommastelle des verwendeten RAMs geändert hat
    if ((int)(usedRAM * 100) != (int)(previousUsedRAM * 100)) {
       
        float totalRAM = ESP.getHeapSize() / (1024.0 * 1024.0);
        //float usedRAM = (ESP.getHeapSize() - ESP.getFreeHeap()) / (1024.0 * 1024.0);
        float usedPercentageRAM = (usedRAM * 100) / totalRAM;
       
          
          Serial.println(F(" "));
          Serial.println(F("=========================================================="));
          Serial.println(p_uhrzeit);
          Serial.print(F("Total RAM: "));
          Serial.print(totalRAM, 3);
          Serial.println(F(" MB"));

          Serial.print(F("Used RAM: "));
          Serial.print(usedRAM, 3);
          Serial.println(F(" MB"));

          Serial.print(F("Used RAM Percentage: "));
          Serial.print(usedPercentageRAM, 2); // Ausgabe mit 1 Dezimalstelle
          Serial.println(F(" %"));

          // Aktualisiere den vorherigen `usedRAM`-Wert
          previousUsedRAM = usedRAM;
          Serial.println(F("=========================================================="));
          Serial.println(F(" "));

    }




  //---------------------------------------------------------
    if (!pre_ble_counterDisabled) {
      if (millis() - pre_ble_timer >= 2000) {
        pre_ble_counter++;
        // Serial.print("pre_ble_Counter: ");
        // Serial.println(pre_ble_counter);

        if (pre_ble_counter >= 6) {
          internetTransferComplete = true;
          pre_ble_counterDisabled = true;  // Funktion deaktivieren
          // Serial.println("Internet transfer complete.");
        }

        pre_ble_timer = millis();
      }
    }
  //---------------------------------------------------------




      tick_radon = !tick_radon; 



  //---------------------------------------------------------
   if (verzoegerung_fw_update >= 1) {
    if (printCounter <= 3 && g_bit_fw_load == true) {
    
      FW_tick = !FW_tick;
      wait_counter_fw_failbit ++;
      

      if(FW_tick == true){
         
         ledcWrite(ledChannel26, dutyCycle_t215);  //   GPIO38  NTP
         lc.setChar(0,0,' ',FW_tick);

      }else{
        
        ledcWrite(ledChannel26, 0);  //   GPIO38  NTP
        lc.setChar(0,0,' ',FW_tick);

      }



     

      if(wait_counter_fw_failbit >= 30 && verzoegerung_fw_update == 1){  // bei fehler

          verzoegerung_fw_update = 2;
          Preferences preferences;
          preferences.begin("eenvs", false);                         //Ordner eenvs anlegen/verwenden
          preferences.putUChar("fw_verz_update", verzoegerung_fw_update);    //  0=Standard  aus 
          preferences.end();   
          Serial.println(F("Done1, Reboot now for FW"));
          delay(2000);
          esp_restart();

      }
     
    }
   }
  //---------------------------------------------------------



    esp_task_wdt_reset();

    digitalWrite(WTD_Set, HIGH);      //   Watchdog Set Pin       0 = Disable   1 = Enable
    //digitalWrite(WTD_Set, LOW); 
    WTD_tick = !WTD_tick; digitalWrite(WTD_toggle, WTD_tick);
  
  
    ms2_set = true;


    cal_lcd = true;


      charInts[48] = mb_radon_live_32bit;
      //strcpy(chartime16, formattedDateHHMM);


    //---------------------------------------------------------
      if(g_Buzzer_time > 0){g_Buzzer_time --;}
      if(g_Buzzer_boot_time > 0){g_Buzzer_boot_time --;}

      if(g_Buzzer_boot_time > 0){
        alarm_sound_sperre = true;
        g_Buzzer_time = 0;
      }
      
      if(mb_radon_live_32bit <= g_Buzzer_ist){
        alarm_sound_sperre = false;
        g_Buzzer_time = g_Buzzer_time_ist;
      }

      if(g_u_buzzer_ea >= 1){
      
        if(mb_radon_live_32bit > g_Buzzer_ist && g_Buzzer_time > 0){

            startplayer = true;

            //Serial.println("Buzzer");
            alarm_sound = true;

            String notes[3] = {"A5","SILENCE","A5"};
            timeUnit0 = 180;
            Melody melody0 = MelodyFactory.load("Melody", timeUnit0, notes, nNotes0);
            player.play(melody0);


        }else{
            //player.stop();

            if(alarm_sound_sperre == false){
              alarm_sound_sperre = true;
              g_Buzzer_time = g_Buzzer_time_ist;
            }

            pinMode(buzzerPin, OUTPUT);
            digitalWrite(buzzerPin, LOW);  
            startplayer = false;
            alarm_sound = false;
        }

      }
    //---------------------------------------------------------


   //---------------------------
    if(g_fw_dl_fail == true && count_fw <= 2){
    
      
      tb_FW_update = true;
      tb_task = true;

      count_fw ++;  
      g_fw_dl_fail = false;
      Serial.println(F("[TB] Start, FW. Count: ")); Serial.println(F(count_fw));


    }
   //---------------------------



    //---------------------------------------------------------
        if (verzoegerung_fw_update == 0) {
            // Debug-Ausgabe für den Start des If-Blocks
            //debugLog(F("[DBG] Betrete Haupt-If-Block"));

            // Debugging für den Aufruf von setBeacon2()
            //debugLog(F("[DBG] Überprüfe Bedingungen für setBeacon2-Aufruf"));
            if (disable_server >= 1 && TB_currFwVersion == TB_newFwVersion && deviceConnected == false && g_u_beacon_ist > 0 && BLE_Beacon_enabled == true) {
                if (g_view_fw == false) {
                    if (user_on_webside == false) {
                        if (BLE_Beacon_enabled == true) {
                            //debugLog(F("[DBG] Rufe setBeacon2() auf"));
                            setBeacon2();
                        } else {
                            //debugLog(F("[DBG] BLE_Beacon_enabled ist false"));
                        }
                    } else {
                        //debugLog(F("[DBG] user_on_webside ist true"));
                    }
                } else {
                    //debugLog(F("[DBG] g_view_fw ist true"));
                }
            } else {
                //if (disable_server < 1) debugLog(F("[DBG] disable_server < 1"));
                //if (TB_currFwVersion != TB_newFwVersion) debugLog(F("[DBG] TB_currFwVersion != TB_newFwVersion"));
                //if (deviceConnected != false) debugLog(F("[DBG] deviceConnected != false"));
                //if (g_u_beacon_ist <= 0) debugLog(F("[DBG] g_u_beacon_ist <= 0"));
                //if (BLE_Beacon_enabled == false) debugLog(F("[DBG] BLE_Beacon_enabled == false"));
            }

            if (g_u_beacon_ist > 0 && BLE_Beacon_enabled == true) {
                // Start advertising
                g_end_pAdvertising = true;
            }

            end_pAdvertising = millis() + 100;

            // Debug-Ausgabe für das Ende des If-Blocks
            //debugLog(F("[DBG] Verlasse Haupt-If-Block"));
        }
  //---------------------------------------------------------


}













void sendNonBleStatus(const String& type, const String& value) {
    DynamicJsonDocument json(1024);
    json["type"] = type;
    json["value"] = value;

    String jsonString;
    serializeJson(json, jsonString);
    webSocket.broadcastTXT(jsonString);
}







//  void webSocketEvent(    sendData()    const char sensor_html_template[]   handle_sensor()
//------------------------------------------------------------


void sendData() {

    // Dein bestehender Code zur Datenübertragung
    wifiSStatus = (ledcRead(ledChannel14) > 0);
    ntpStatus = (ledcRead(ledChannel26) > 0);
    unitDEStatus = (ledcRead(ledChannel2) > 0);
    unitENStatus = (ledcRead(ledChannel15) > 0);
    amStatus = (ledcRead(ledChannel27) > 0);
    pmStatus = (ledcRead(ledChannel25) > 0);
    dpStatus = (ledcRead(ledChannel) > 0); // Status des Doppelpunktes setzen

    //---------- kein BT -------------------- 
    if(deviceConnected == false){

        //---------- KNX --------------------  
        if (g_LEDT_T_KNX == 1) {

              if (digitalRead(20)) {
                  webSocket.broadcastTXT("imageStatus:0"); // Rot
              } else {
                  webSocket.broadcastTXT("imageStatus:4"); // grau
              }
              

              // displayKNXAddress
              Serial.print(area);Serial.print(".");Serial.print(line);Serial.print(".");Serial.println(device);
              String knxData = "knx:" + String(area) + "/" + String(line) + "/" + String(device);
              webSocket.broadcastTXT(knxData);
              delay(5);

              // Immer den Status der 6 Elemente senden
              String statusMessage = String("0") + ";" + String("0") + ";" +
                                    String("0") + ";" + String("0") + ";" +
                                    String("0") + ";" + String("0");
              webSocket.broadcastTXT("status:" + statusMessage);
              lastLEDStatus = false; // Aktualisiere den letzten Status

        }else{ 
          //---------- kein KNX -  Uhr Radon --------------------   
          
            webSocket.broadcastTXT("dpStatus:" + String(dpStatus));
            
            if (g_LEDT_F_ist == 0) {
                // Sende leere Werte, weil das Display aus ist
                String emptyTimeData = "time:     ";
                String emptyRadonData = "radon:    ";
                webSocket.broadcastTXT(emptyTimeData);
                delay(10); // Kurzes Delay zwischen den Nachrichten
                webSocket.broadcastTXT(emptyRadonData);
            } else {
                if (g_switch_anzeige == 0) {
                    // Sende Radonwert
                    String data = "radon:" + String(mb_radon_live_32bit);
                    webSocket.broadcastTXT(data);
                } else if (g_switch_anzeige == 1) {
                    byte valuet = v_currenthour;

                    if (g_u_clock_ist == 1) { 
                        valuet = v_currenthour;
                        currenthourAM_PM = false;
                    }
                    if (g_u_clock_ist == 2) { 
                        currenthour12 = v_currenthour;  
                        currenthourAM_PM = false;
                        if (currenthour12 == 0) {
                            currenthour12 = 12;
                            currenthourAM_PM = true;
                        }
                        if (currenthour12 > 12) {
                            currenthour12 = currenthour12 - 12;
                            currenthourAM_PM = true;
                        }
                        valuet = currenthour12;  // hour12h  
                    }  
                    
                    // Sende Uhrzeit
                    String timeData = "time:" + String(valuet) + ";" + String(currentmin);
                    webSocket.broadcastTXT(timeData);
                }
            }

              String statusMessage = String(wifiSStatus) + ";" + String(ntpStatus) + ";" +
                                    String(unitDEStatus) + ";" + String(unitENStatus) + ";" +
                                    String(amStatus) + ";" + String(pmStatus);
              webSocket.broadcastTXT("status:" + statusMessage);
              webSocket.broadcastTXT("imageStatus:" + String(imageStatus));

            if (g_LEDT_T_ist == 0 && lastLEDStatus) {
                webSocket.broadcastTXT("imageStatus:3"); // Weiße Grafik anzeigen
                lastLEDStatus = false; // Aktualisiere den letzten Status
                imageStatus = 3;
                lastImageStatus = imageStatus;
            } else if (!lastLEDStatus && g_LEDT_T_ist == 1) {
                // Sende den letzten bekannten Status nur einmal
                if (lastImageStatus != imageStatus) {
                    webSocket.broadcastTXT("imageStatus:" + String(imageStatus));
                    lastImageStatus = imageStatus; // Aktualisiere den letzten Bildstatus
                }
                lastLEDStatus = true; // Aktualisiere den letzten Status
            }

        }
        //--------------------------------------------

    }else{
     //----------  BT --------------------  
               
              String emptyblueData = "blue:     ";
              webSocket.broadcastTXT(emptyblueData);
              
              webSocket.broadcastTXT("imageStatus:5"); // blaue Grafik anzeigen

              // Immer den Status der 6 Elemente senden
              String statusMessage = String("0") + ";" + String("0") + ";" +
                                    String("0") + ";" + String("0") + ";" +
                                    String("0") + ";" + String("0");
              webSocket.broadcastTXT("status:" + statusMessage);
              lastLEDStatus = false; // Aktualisiere den letzten Status


    }
    //--------------------------------------------


}

//------------------------------------------------------------



/*
bool isLeapYear(int year) {
  if (year % 4 != 0) return false;
  if (year % 100 != 0) return true;
  if (year % 400 != 0) return false;
  return true;
}


int daysInMonth(int month, int year) {
  if (month == 2) {
    return (isLeapYear(year)) ? 29 : 28;
  } else if (month == 4 || month == 6 || month == 9 || month == 11) {
    return 30;
  } else {
    return 31;
  }
}


int day(unsigned long t) {
  return ((t / 86400L + 4) % 7);
}

int month(unsigned long t) {
  int year = year(t);
  unsigned long days = t / 86400L;

  int month = 1;
  while (days >= daysInMonth(month, year)) {
    days -= daysInMonth(month, year);
    month++;
  }

  return month;
}

int year(unsigned long t) {
  return 1970 + t / (365 * 86400L); 
}
*/













  //--------------------
  void WriteTimeValue()
  {

    Preferences preferences;
    preferences.begin("eenvs", false);                         //Ordner eenvs anlegen/verwenden
    preferences.putULong64("epochstart", epochTime_start);                         //Variable speichern
    preferences.putULong64("epochTime", epochTime_esp);   //Variable speichern
    p_timeon = 1;
    preferences.putInt("p_timeon", p_timeon);                         //Variable speichern
    preferences.end();

     #ifdef NVS_DEBUG
     //Serial.println(F(" "));
     //Serial.println("__ Write Time. Value __");
     #endif

  }

    void WriteepochTime()
  {

    Preferences preferences;
    preferences.begin("eenvs", false);                         //Ordner eenvs anlegen/verwenden
    preferences.putULong64("epochTime", epochTime_esp);   //Variable speichern
    preferences.end();


  }



     #define LENGTHWORKBUFFER 512
      char workBuffer [LENGTHWORKBUFFER + 1]  ;
      char answer[LENGTHWORKBUFFER + 1]  ;



//------------------------------------------------------------------------------------------
  #ifdef ea_webserver

   //#define day 86400

     //-------------------------------------------------------------------
      void w_setTime(long t) {  // sets the time of day
        //Serial.print("workBuffer: ");Serial.println(t);
        incoming_data = t;
        ag_Clock = ag_Clock - (ag_Clock % 86400) + t - millis()/1000; // new time
      }
     //-------------------------------------------------------------------


     //-------------------------------------------------------------------
      void w_setData(long t) {  // sets the time of day
        Serial.print("workBuffer: ");Serial.println(t);
        raw_data = t;
        if(raw_data>0){
        incoming_data = raw_data - 1;      //Schreibe in Datei Nr     
        }

      }
     //-------------------------------------------------------------------


     //-------------------------------------------------------------------
      char * w_getTime() {

        static char timeOfDay[12] = "";

        //  unsigned long d = secs/day;
        sprintf(timeOfDay,"%02d:%02d:%02d",v_currenthour,v_currentmin,v_currentSec);
        return timeOfDay;
      }
     //-------------------------------------------------------------------




     //-------------------------------------------------------------------
      void getTemperature() {
        float h = 52.41;
        float t = 28.12;         
        sprintf(workBuffer,"Humidity: %.1f %%. Temperature: %-.1f C",h,t);
        Serial.println(workBuffer);
        //delay(100);
    }
     //-------------------------------------------------------------------


     //-------------------------------------------------------------------
      void getRadon() {
        uint32_t h = radon_1h_ist;  
        //float t = 28.12;     
        sprintf(workBuffer,"Radon: %d Bq/m³",h);
        Serial.println(workBuffer);
        //delay(100);
    }
     //-------------------------------------------------------------------


     //-------------------------------------------------------------------
      void get_system() {
        Serial.print("answer_s "); Serial.println(answer_s);     
                 
                        answer_s = "Heap now   : ";
                        answer_s += String(xPortGetFreeHeapSize());

            
                        answer_s += "<br>         Heap block : ";
                        answer_s += String(heap_caps_get_largest_free_block(MALLOC_CAP_DEFAULT));

           
                        answer_s += "<br>         He Size low: ";
                        answer_s += String(xPortGetMinimumEverFreeHeapSize());


                        runMillis= millis();
                        allSeconds=millis()/1000;
                        runHours= allSeconds/3600;
                        secsRemaining=allSeconds%3600;
                        runMinutes=secsRemaining/60;
                        runSeconds=secsRemaining%60;
                        if(runHours == 0){
                        answer_s += "<br>         Uptime [h] : ";
                        answer_s += String(runHours);
                        }else{
                        answer_s += "<br>         Uptime [s] : ";
                        answer_s += String(allSeconds);
                        }

                        String tempstr = "      ";
                        tempstr = String(rtc_temperatur,2);
                        Serial.print("rtc_temperatur "); Serial.println(tempstr); 

                        answer_s += "<br>         Temperature: ";
                        answer_s += String(tempstr);
                        answer_s += " °C";



        Serial.print("answer_s: "); Serial.println(answer_s);    
     }
     //-------------------------------------------------------------------
     
 


     //-------------------------------------------------------------------
      void get_ID() {
        Serial.print("answer_s "); Serial.println(answer_s);     
                 
                        //answer_s = "           ";
                        answer_s = p_APname_p;

        Serial.print("answer_s: "); Serial.println(answer_s);    
     }
     //-------------------------------------------------------------------
   



     //-------------------------------------------------------------------
      void get_error() {

         
       // read_from_log();


                        /*  
                          json += "\"err\":\""+String(workBuffer);                                                   
                          json += "\"wz\":\""+String(charcountweb_w);
                          json += "\"sz\":\""+String(charcountweb_l);
                         */
        
 
        
         Serial.println("[FI] Letzer    LOG read  Zeilen Zähler: " + String(gFileread));  
         Serial.println("[FI] Aktueller LOG gesamt Eintr. Zähler1: " + String(logCount_sum));
            
         Serial.println("----------------------- "); 
         //Serial.println("[FI] Aktueller LOG 17    Zeilen Zähler: " + String(g17Filewrite)); 
         //Serial.println("[FI] Aktueller LOG 18    Zeilen Zähler: " + String(g18Filewrite)); 

         //Serial.println("[FI] Aktueller LOG 17l   Zeilen Zähler: " + String(charcount17_l)); 
         //Serial.println("[FI] Aktueller LOG 18l   Zeilen Zähler: " + String(charcount18_l));
         //Serial.println("[FI] Aktueller LOG full  Zeilen Zähler: " + String(g1718_full));

         

              
             print_log_info();
            
             

            /*
               String fifthLog;
              if(gFileread <= totalEntries){
                set_g40_var = gFileread; // weil Der Modulo-Operator % in der funktion
                fifthLog = read_log_entry_by_index2(gFileread);
              }
             */

            // update_web_server();   //Aktueller Eintrag Index
//-----------------------------------------
    Serial.println("  "); // Debug
    Serial.println("---------------------------------------"); // Debug
    Serial.println("Web-Server wird aktualisiert..."); // Debug
    String fifthLog;
    
    if (isLogFull) {
        // Falls das Log voll ist, beginne mit logFileName2 (älteste Einträge)
        Serial.println("Log ist voll"); // Debug
        if (gFileread < count_log_entries(logFileName2) && useFirstLog == false) {
            fifthLog = read_log_entry_by_index2(gFileread);
            useFirstLog = false;
            Serial.println("Beginne mit logFileName2."); // Debug
        } else {
            if(gFileread >= maxLogs){gFileread = 1;} // setze auf 1 für logFileName1
            useFirstLog = true;
            Serial.println("Wechsle zu logFileName1."); // Debug
            fifthLog = read_log_entry_by_index2(gFileread);
        }
    } else {
        // Falls das Log nicht voll ist, lies nur aus logFileName1
        Serial.println("Log ist nicht voll, lese nur aus logFileName1."); // Debug
        fifthLog = read_log_entry_by_index2(gFileread);
    }
    Serial.println("Gelesener Log-Eintr.: " + String(fifthLog)); // Debug
    Serial.println("globalLogIndex: " + String(globalLogIndex)); // Debug
    Serial.println("gFileread: " + String(gFileread)); // Debug
    Serial.println("currentEntryIndex: " + String(currentEntryIndex)); // Debug

    bool read_log_1 = false;
    if(useFirstLog == true && currentEntryIndex != gFileread && totalEntriesFile1t > 0) {
        read_log_1 = true;
        Serial.println("---------read_log_1 = true"); // Debug
    }  
    if(useFirstLog == false) { 
        read_log_1 = true;    //log2 lesen immer freigeben
        Serial.println("---------read_log_2 = true"); // Debug
    } 

    if (fifthLog != "" && read_log_1 == true) {
        answer_s = fifthLog;
              //gFileread ++;
              //if (gFileread >= maxLogs){gFileread = 1;}
              Serial.println("(fifthLog != "" && read_log_1 == true)"); // Debug
              gFileread++;
              new_entr_log = false;
              charcountweb_w ++;
              charcountweb_l = charcountweb_w;
              g_search_start_count = 0 ;
              without_time = true;
    } else {
        answer_s = "";
        tick21 = false;
    }
    
    // Sende den Log-Eintrag an den Web-Server
    if (answer_s != "") {
        Serial.println("Sende Log-Eintrag an den Web-Server: " + answer_s);
    } else {
        Serial.println("Kein weiterer Log-Eintrag vorhanden.");
    }


    Serial.println("next gFileread: " + String(gFileread)); // Debug

//-----------------------------------------

              Serial.println("[FI] Aktueller gFileread: " + String(gFileread));  
              Serial.println("[FI] Aktueller globalLogIndex: " + String(globalLogIndex)); 


            //if(fifthLog != "" && globalLogIndex != gFileread && gFileread <= globalLogIndex){
            //if(fifthLog != "" && gFileread <= totalEntries){
            /*
            if(answer_s != ""){  

              //answer_s = fifthLog; 
              gFileread ++;
              //if (gFileread >= maxLogs){gFileread = 1;}
              new_entr_log = false;
              charcountweb_w ++;
              charcountweb_l = charcountweb_w;
              g_search_start_count = 0 ;
              without_time = true;

            }else{
              answer_s = "";
              tick21 = false;
            }
            */

          /*
          if(g1718_full == 1){
            g1718_Sum_Counter = v_count_gh1718;
          }else{
            g1718_Sum_Counter = g17Filewrite;
          }
          */



       


        if (answer_s == ""){tick21 = false;}
        

     
                      
     }
     //-------------------------------------------------------------------


     //-------------------------------------------------------------------
      char * w_getLine() {

        static char time_line[12] = "";
        unsigned long w = charcountweb_w;
        unsigned long l = gFileread;
        
        if(w>0){w --;}
        w ++;

        if(w>=1000){
          w = w - 1000;
        }
        if(l>=1000){
          l = l - 1000;
        }

        sprintf(time_line,"%04lu %04lu",w,l);

        return time_line;
      }
     //-------------------------------------------------------------------
     
     //-------------------------------------------------------------------
      char * w_getLine3() {

        static char time_line[12] = "";
        unsigned long w = charcountweb_w;
        unsigned long l = gFileread;
        
        if(w>0){w --;}

        if(w>=1000){
          w = w - 1000;
        }
        if(l>=1000){
          l = l - 1000;
        }

        //sprintf(time_line,"%04lu %04lu",w,l);
        sprintf(time_line,"%04lu",l);
        return time_line;
      }
     //-------------------------------------------------------------------






      char* allocateHtmlInPSRAM(const char* templateInFlash) {
          size_t length = strlen_P(templateInFlash) + 1; // Länge +1 für Nullterminierung
          char* psramHtml = (char*)heap_caps_malloc(length, MALLOC_CAP_SPIRAM);
          if (psramHtml) {
              strcpy_P(psramHtml, templateInFlash);
          }
          return psramHtml;
      }





     //-------------------------------------------------------------------
    uint32_t get_time_v;


   // http://file.auto-steuerung.de/tracer/graph/AlphaTracer.html
   
 
     /*
    const char index_html8[] PROGMEM = R"rawliteral(  

    <!DOCTYPE html><html><head><meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate"><meta http-equiv="Pragma" content="no-cache"><meta name="viewport"content="width=device-width,initial-scale=1"/><meta name="author"content="Holger Gebauer">
    <link rel="stylesheet" href="http://file.auto-steuerung.de/tracer/graph/styles.css"> 
    <script src="http://file.auto-steuerung.de/tracer/graph/jsthree.js"></script>	</head><body onLoad="onBodyLoad()"><div id="injava"></div><div id="injava2"></div><div id="chartOuter"><div id="chartInnert">	
    <div id="parent1"><div class="chartjs-size-monitor"><div class="chartjs-size-monitor-expand"></div><div class="chartjs-size-monitor-shrink"></div></div> <canvas id="myChart" height="500" width="1270" style="display: block; width: 886px; height: 346px;" class="chartjs-render-monitor"></canvas></div> 
    </div></div><script src="http://file.auto-steuerung.de/tracer/graph/zonehead.js"></script> <script src="http://file.auto-steuerung.de/tracer/graph/chartdiv.js"></script></body></html><script id='ace' src="http://file.auto-steuerung.de/tracer/graph/tracg.js" type="text/javascript" charset="utf-8"></script> 
      
    )rawliteral";


              
      const char index_html8a[] PROGMEM = R"rawliteral(
      <!DOCTYPE html>
      <html>
      <head>
        <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
        <meta http-equiv="Pragma" content="no-cache">
        <meta name="viewport" content="width=device-width, initial-scale=1"/>
        <meta name="author" content="Holger Gebauer">
        <link rel="stylesheet" href="http://file.auto-steuerung.de/tracer/graph/styles.css">
        <script src="http://file.auto-steuerung.de/tracer/graph/jsthree.js"></script>
        <style>
          h1 { color: #fff; }
          p { color: #ccc; }
          a { display: block; margin: 10px auto; color: #007BFF; text-decoration: none; font-weight: bold; font-size: 1.2em; border: 2px solid #007BFF; padding: 10px; border-radius: 5px; width: 230px; }
          a:hover { text-decoration: underline; background-color: #007BFF; color: white; }
          .back-button { background-color: black; color: white; display: flex; align-items: center; justify-content: center; height: 50px; position: absolute; left: 0; top: 360px; }
          #chartOuter { overflow-x: hidden; overflow-y: hidden; } 
        </style>
      </head>
      <body onLoad="onBodyLoad()">
        <div id="chartOuter">
          <div id="chartInnert">
            <div id="parent1">
              <canvas id='myChart' style="height:337px"></canvas>
            </div>
          </div>
        </div>
        <a href="/index" class="back-button">Zur&uuml;ck zur Startseite</a>
      )rawliteral";

      */



      const char index_html8[] PROGMEM = R"rawliteral(
        <!DOCTYPE html>
        <html>
        <head>
          <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
          <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
          <meta http-equiv="Pragma" content="no-cache">
          <meta name="viewport" content="width=device-width,initial-scale=1"/>
          <meta name="author" content="Holger Gebauer">
          <link rel="stylesheet" href="/styles.css">
          <script src="/jsthree.js"></script>
        </head>
        <body onLoad="onBodyLoad()">
          <div id="injava"></div>
          <div id="injava2"></div>
          <div id="chartOuter">
            <div id="chartInnert">
              <div id="parent1">
                <div class="chartjs-size-monitor">
                  <div class="chartjs-size-monitor-expand"></div>
                  <div class="chartjs-size-monitor-shrink"></div>
                </div>
                <canvas id="myChart" height="500" width="1270" style="display: block; width: 886px; height: 346px;" class="chartjs-render-monitor"></canvas>
              </div>
            </div>
          </div>
          <script src="/zonehead.js"></script>
          <script src="/chartdiv.js"></script>
        </body>
        </html>
        <script id='ace' src="/tracg.js" type="text/javascript" charset="utf-8"></script>
      )rawliteral";

   const char index_html8a[] PROGMEM = R"rawliteral(
        <!DOCTYPE html>
        <html>
        <head>
          <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
          <meta http-equiv="Pragma" content="no-cache">
          <meta name="viewport" content="width=device-width, initial-scale=1"/>
          <meta name="author" content="Holger Gebauer">
          <link rel="stylesheet" href="/styles.css">
          <script src="/jsthree.js"></script>
          <style>
            h1 { color: #fff; }
            p { color: #ccc; }
            a { display: block; margin: 10px auto; color: #007BFF; text-decoration: none; font-weight: bold; font-size: 1.2em; border: 2px solid #007BFF; padding: 10px; border-radius: 5px; width: 230px; }
            a:hover { text-decoration: underline; background-color: #007BFF; color: white; }
            .back-button { background-color: black; color: white; display: flex; align-items: center; justify-content: center; height: 50px; position: fixed; left: 20px; top: 349px; } /* Hier die left-Eigenschaft angepasst */
            #chartOuter { overflow-x: hidden; overflow-y: hidden; } 
          </style>
        </head>
        <body onLoad="onBodyLoad()">
          <div id="chartOuter">
            <div id="chartInnert">
              <div id="parent1">
                <canvas id='myChart' style="height:337px"></canvas>
              </div>
            </div>
          </div>
          <a href="/index" class="back-button">Zur&uuml;ck zur Startseite</a>
        </body>
        </html>
      )rawliteral";







      const char index_html8c[] PROGMEM = R"rawliteral(  
        </body></html>
        )rawliteral";



          
                
                
                      
          #ifndef Firmware_backup            
            const char combined_chart_html[] PROGMEM = R"rawliteral(
              <!DOCTYPE html>
              <html>
              <head>
                <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
                <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
                <meta http-equiv="Pragma" content="no-cache">
                <meta name='viewport' content='width=device-width, initial-scale=1'/>
                <meta name="author" content="Gebauer Holger, https://www.auto-steuerung.de/">
                <title>Chart {device_id}</title>
              <style>
                  #status-bar {
                    width: 100%;
                    height: 10px;
                    position: fixed; /* Beibehalten von fixed */
                    top: 0;
                    left: 0;
                    z-index: 1000; /* Höherer Z-Index um sicherzustellen, dass es über dem restlichen Inhalt liegt */
                  }
                  .green {
                    background-color: #28a745; /* Grün */
                  }
                  .red {
                    background-color: #dc3545; /* Rot */
                  } 

                  body { 
                    font-family: Arial, sans-serif; 
                    text-align: center; 
                    padding: 20px; 
                    margin: 0; /* Entferne margin-top, da wir es zur .content hinzufügen */
                    background-color: black; 
                    color: white; 
                    overflow: hidden; 
                  }

                  .content {
                    padding-top: 5px; 
                    margin-bottom: 30px; 
                    overflow-y: auto; /* Ermögliche vertikales Scrollen */
                    height: 100vh; 
                  }

                      h1 { color: #fff; }
                      #container1 { 
                        width: 99%; 
                        height: 400px; /* Höhe für Balkendiagramm */
                        margin: 0 auto; 
                        background-color: #222; 
                        border: 1px solid #888; /* Grauer Rand */
                        box-shadow: 0 8px 16px rgba(0, 0, 0, 0.8); /* Mehr Schatten für bessere Abhebung */
                        border-radius: 10px; 
                      }
                      #container2 { 
                        width: 99%; 
                        height: 420px; /* Höhe für Liniendiagramm */
                        margin: 0 auto; 
                        background-color: #222; 
                        border: 1px solid #888; /* Grauer Rand */
                        box-shadow: 0 8px 16px rgba(0, 0, 0, 0.8); /* Mehr Schatten für bessere Abhebung */
                        border-radius: 10px; 
                      }
                      .spacer { height: 20px; } 
                      .button {
                        display: block;
                        margin: 10px auto; 
                        color: #007BFF;
                        text-decoration: none;
                        font-weight: bold;
                        font-size: 1.2em; 
                        border: 2px solid #007BFF;
                        padding: 10px; 
                        border-radius: 5px;
                        width: 200px; 
                        background-color: #222;
                        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.4);
                      }
                      .button:hover {
                        text-decoration: underline;
                        background-color: #007BFF;
                        color: white;
                        box-shadow: 0 8px 16px rgba(0, 0, 0, 0.8);
                      }

                    /* Media Query für kleinere Bildschirme */
                    @media (max-width: 600px) {
                      body { padding: 10px; }
                      #container1, #container2 { height: 250px; }
                      .button { font-size: 1em; width: 150px; padding: 8px; }
                    }

                    /* Media Query für Querformat */
                    @media (max-width: 600px) and (orientation: landscape) {
                      #container1, #container2 { height: 300px; } /* Höher für Querformat */
                    }

                    /* Media Query für Bildschirmbreite < 900 Pixel */
                    @media (max-width: 800px) {
                      #container1, #container2 { height: 350px; } /* Setzt Höhe auf 350 Pixel */
                    }

                    </style>



                <script src="{highcharts.js}"></script>
                <script>
                  document.addEventListener('DOMContentLoaded', function () {
                    let chartType = 'column';

                    const currentMonth = new Date().getMonth();
                    const monthlyData = [{radon_mittelwert_monat[0]}, {radon_mittelwert_monat[1]}, {radon_mittelwert_monat[2]}, {radon_mittelwert_monat[3]}, {radon_mittelwert_monat[4]}, {radon_mittelwert_monat[5]}, {radon_mittelwert_monat[6]}, {radon_mittelwert_monat[7]}, {radon_mittelwert_monat[8]}, {radon_mittelwert_monat[9]}, {radon_mittelwert_monat[10]}, {radon_mittelwert_monat[11]}];
                    const hourlyData = {stringdata};
                    const monthNames = ['Jan', 'Feb', 'Mar', 'Apr', 'Mai', 'Jun', 'Jul', 'Aug', 'Sep', 'Okt', 'Nov', 'Dez'];

                    function renderChart() {
                      Highcharts.setOptions({
                        chart: {
                          reflow: true // sorgt dafür, dass die Charts auf die Bildschirmgröße reagieren
                        }
                      });

                      Highcharts.chart('container1', {
                        accessibility: {
                          enabled: false
                        },
                        chart: {
                          type: chartType,
                          backgroundColor: '#111'
                        },
                        title: {
                          text: 'Monatliche Radonwerte',
                          style: { color: '#fff' }
                        },
                        xAxis: {
                          categories: monthNames,
                          labels: { style: { color: '#fff' } }
                        },
                        yAxis: {
                          title: {
                            text: 'Radonwert (Bq/m&sup3;)',
                            style: { color: '#fff' }
                          },
                          labels: { style: { color: '#fff' } },
                          gridLineWidth: 0.5,
                          gridLineColor: '#444'
                        },
                        tooltip: {
                          useHTML: true,
                          formatter: function() {
                            if (this.series.type === 'pie') {
                              return '<b>' + this.key + '</b><br/>Radonwert: <b>' + this.y + ' Bq/m&sup3;</b>';
                            } else {
                              return '<b>' + this.x + '</b><br/>Radonwert: <b>' + this.y + ' Bq/m&sup3;</b>';
                            }
                          }
                        },
                        plotOptions: {
                          column: {
                            colorByPoint: true,
                            colors: monthlyData.map((value, index) => '#007BFF'),
                            borderColor: '#007BFF',
                            borderWidth: 0,
                            states: {
                              hover: {
                                borderColor: '#00FF00',
                                borderWidth: 2
                              }
                            },
                            dataLabels: {
                              enabled: true,
                              color: '#fff',
                              style: {
                                textOutline: 'none'
                              }
                            }
                          },
                          pie: {
                            colors: [
                              '#0066cc', // Dez
                              '#3399ff', // Nov
                              '#66b3ff', // Okt
                              '#ff9933', // Sep
                              '#ff6600', // Aug
                              '#ff0000', // Jul
                              '#ff3300', // Jun
                              '#ff6600', // Mai
                              '#ff9933', // Apr
                              '#66b3ff', // Mär
                              '#3399ff', // Feb
                              '#0066cc'  // Jan 
                            ],
                            dataLabels: {
                              enabled: true,
                              color: '#fff',
                              style: {
                                textOutline: 'none'
                              }
                            }
                          }
                        },
                        series: [{
                          name: 'Radonwert',
                          data: chartType === 'column'
                            ? monthlyData.map((value, index) => ({
                                y: value,
                                borderColor: index === currentMonth ? '#00FF00' : '#007BFF',
                                borderWidth: index === currentMonth ? 4 : 0,
                                name: monthNames[index] // füge den Monat hinzu
                              }))
                            : monthlyData.map((value, index) => ({
                                name: monthNames[index],
                                y: value
                              }))
                        }],
                        responsive: {
                          rules: [{
                            condition: {
                              maxWidth: 600
                            },
                            chartOptions: {
                              legend: {
                                enabled: false
                              },
                              yAxis: {
                                title: {
                                  text: ''
                                }
                              }
                            }
                          }]
                        }
                      });

                    }

                    document.getElementById('toggleButton').addEventListener('click', function () {
                      chartType = chartType === 'column' ? 'pie' : 'column';
                      renderChart();
                    });

                renderChart();

                Highcharts.chart('container2', {
                  accessibility: {
                    enabled: false
                  },
                  chart: {
                    type: 'areaspline',
                    backgroundColor: '#111'
                  },
                  title: {
                    text: 'Radonwerte',
                    style: { color: '#fff' }
                  },
                  xAxis: {
                    categories: {stringtime},
                    labels: { style: { color: '#fff' } },
                    gridLineWidth: 0.5,
                    gridLineColor: '#444',
                    crosshair: {
                      color: '#FFFFFF', // Vertikale Linie
                      width: 1 // Breite der Linie
                    }
                  },
                  yAxis: {
                    title: {
                      text: 'Radonwert (Bq/m&sup3;)',
                      style: { color: '#fff' }
                    },
                    labels: { style: { color: '#fff' } },
                    gridLineWidth: 0.5,
                    gridLineColor: '#444'
                  },
                  tooltip: {
                    useHTML: true,
                    positioner: function () { return { x: 75, y: 10 }; }, // Tooltip nach rechts verschoben
                    backgroundColor: 'rgba(255, 255, 255, 0.1)', // Hintergrundfarbe transparent
                    borderColor: 'rgba(102, 102, 102, 0.5)', // Randfarbe transparent
                    shadow: false, // Keine Schatten
                    style: {
                      color: '#fff' // Textfarbe weiß
                    },
                    formatter: function() {
                      return '<b>' + this.x + '</b><br/>Radonwert: <b>' + this.y + ' Bq/m&sup3;</b>';
                    }
                  },
                  plotOptions: {
                    areaspline: {
                      fillOpacity: 0.3,
                      marker: {
                        enabled: false,
                        fillColor: hourlyData.every(value => value < 50) ? '#007BFF' : '#006400', // Dunkleres Grün
                        lineColor: '#006400', // Dunkleres Grün
                        lineWidth: 2,
                        radius: 4
                      },
                      states: {
                        hover: {
                          enabled: true,
                          fillColor: hourlyData.every(value => value < 50) ? '#007BFF' : '#006400', // Dunkleres Grün
                          lineColor: '#006400', // Dunkleres Grün
                          lineWidth: 4,
                          radius: 6
                        }
                      },
                      zones: [
                        { value: 150, color: hourlyData.every(value => value < 50) ? '#007BFF' : '#006400' }, // Bereich bis 150 bleibt blau oder grün
                        { value: 300, color: '#FFA500', fillColor: 'rgba(255, 165, 0, 0.2)' }, // Orange für >150
                        { color: '#FF0000', fillColor: 'rgba(255, 0, 0, 0.2)' } // Rot für >300
                      ]
                    }
                  },
                  series: [{
                    name: 'Radonwert',
                    data: hourlyData,
                    color: hourlyData.every(value => value < 50) ? '#007BFF' : '#006400' // Linienfarbe basierend auf den Werten
                  }],
                  responsive: {
                    rules: [{
                      condition: {
                        maxWidth: 600
                      },
                      chartOptions: {
                        legend: {
                          enabled: false
                        },
                        yAxis: {
                          title: {
                            text: ''
                          }
                        }
                      }
                    }]
                  }
                });



                  });

                    let checkCounter = 0;

                    function checkServerStatus() {
                      fetch('/serverStatus')
                        .then(response => response.json())
                        .then(data => {
                          const statusBar = document.getElementById('status-bar');
                          if (data.serverRunning) {
                            statusBar.classList.add('green');
                            statusBar.classList.remove('red');
                            checkCounter = 0; // Reset the counter if the server is running
                          } else {
                            checkCounter++;
                            if (checkCounter >= 3) {
                              statusBar.classList.add('red');
                              statusBar.classList.remove('green');
                            }
                          }
                        })
                        .catch(error => {
                          checkCounter++;
                          const statusBar = document.getElementById('status-bar');
                          if (checkCounter >= 3) {
                            statusBar.classList.add('red');
                            statusBar.classList.remove('green');
                          }
                        });
                    }


                  var ws = new WebSocket('ws://' + window.location.hostname + ':81/');
                            var isConnected = false;

                            ws.onopen = function() {
                                isConnected = true;
                                console.log('WebSocket connection established');
                            };

                            ws.onclose = function() {
                                isConnected = false;
                                console.log('WebSocket connection closed');
                            };

                            // Optional: Event listener für Fehlersituationen hinzufügen
                            ws.onerror = function(error) {
                                isConnected = false;
                                console.log('WebSocket error:', error);
                            };


                  window.onload = function() {
                    checkServerStatus();
                    setInterval(checkServerStatus, 5000); // Überprüft den Serverstatus alle 5 Sekunden
                  }

                </script>
              </head>
                <body>
                  <div id="status-bar" class="green"></div>
                  <div class="content">
                    <h1>Radonwerte</h1>
                    <div id="container1"></div>
                    <button id="toggleButton" class="button">Diagramm wechseln</button>
                    <div class="spacer"></div> <!-- Abstand zwischen den Grafiken -->
                    <div id="container2"></div>
                    <br>
                    <a href="/index" class="button">Zur&uuml;ck zur Startseite</a>
                    <br>
                  </div>
                </body>

              </html>
            )rawliteral";

          #endif

          #ifndef Firmware_backup
          const char ble_html_template[] PROGMEM = R"rawliteral(
          <!DOCTYPE html>
          <html lang="de">
          <head>
              <meta charset="UTF-8">
              <meta name="viewport" content="width=device-width, initial-scale=1.0">
              <title>BLE Informationen {device_id}</title>
              <style>
                  #status-bar {
                      width: 100%;
                      height: 10px;
                      position: fixed;
                      top: 0;
                      left: 0;
                  }
                  .green {
                      background-color: #28a745; /* Grün */
                  }
                  .red {
                      background-color: #dc3545; /* Rot */
                  }
                  html, body { 
                      font-family: Arial, sans-serif; 
                      text-align: center; 
                      padding: 15px 6px; 
                      background-color: black; 
                      color: white; 
                      width: 94%;
                  }
                  h1 { color: #fff; }
                  p { color: #ccc; }
                  .container {
                      display: flex;
                      justify-content: center;
                      align-items: flex-start;
                      min-height: 100vh;
                      padding: 10px;
                      margin: 0 auto;
                  }
                  .form-container {
                      width: 100%;
                      max-width: 800px; /* Du kannst die Breite anpassen */
                      padding: 20px;
                      background-color: #222;
                      border: 1px solid #ddd;
                      border-radius: 8px;
                      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
                      margin: 0 auto;
                  }


                    .signal-container {
                        display: flex;
                        align-items: center;
                    }
                    .signal-bar {
                        width: 100%;
                        background-color: #444;
                        border-radius: 5px;
                        margin: 10px 0;
                        position: relative;
                    }

                    .signal-strength {
                        height: 30px;
                        background-color: #007BFF; /* Blau */
                        width: {signal_strength}%;
                        border-radius: 5px;
                        position: relative;
                    }

                    .signal-text {
                        position: absolute;
                        width: 100%;
                        text-align: center;
                        line-height: 30px;
                        color: white;
                        z-index: 1; /* Stellt sicher, dass der Text über dem Balken liegt */
                    }

                    .label {
                        display: inline-block;
                        width: 10%;
                        text-align: center;
                        color: white;
                    }

                    .label-container {
                        display: flex;
                        justify-content: space-between;
                        width: 100%;
                        position: relative;
                    }

                    .middle-label {
                        position: absolute;
                        left: 50%;
                        transform: translateX(-50%);
                        color: white;
                    }




                  a {
                      display: block;
                      margin: 10px auto;
                      color: #007BFF;
                      text-decoration: none;
                      font-weight: bold;
                      font-size: 1.2em;
                      border: 2px solid #007BFF;
                      padding: 10px;
                      border-radius: 5px;
                      width: 300px;
                      background-color: #222;
                      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.4);
                  }
                  a:hover {
                      text-decoration: underline;
                      background-color: #007BFF;
                      color: white;
                      box-shadow: 0 8px 16px rgba(0, 0, 0, 0.8);
                  }
                  table {
                      margin: 20px auto;
                      border-collapse: collapse;
                      width: 80%;
                      background-color: #222;
                      color: white;
                  }
                  th, td {
                      border: 1px solid #777;
                      padding: 10px;
                      text-align: center;
                  }
                  th {
                      background-color: #0056b3;
                  }
              </style>

          <script>
              let isNavigating = false;

              // Setze den Indikator beim Seitenwechsel innerhalb der Anwendung
              document.querySelectorAll('a').forEach(function(anchor) {
                  anchor.addEventListener('click', function(event) {
                      isNavigating = true;
                  });
              });

              // Überprüfe Sichtbarkeitswechsel des Dokuments
              document.addEventListener('visibilitychange', function() {
                  if (document.visibilityState === 'hidden' && !isNavigating && isConnected) {
                      console.log('Sending browser_closed message via visibilitychange');
                      ws.send('browser_closed');
                      setTimeout(() => ws.close(), 100);  // Verzögerung hinzugefügt
                  }
              });

              window.addEventListener('beforeunload', function(event) {
                  if (!isNavigating && isConnected) {
                      console.log('Sending browser_closed message via beforeunload');
                      ws.send('browser_closed');
                  }
              });

              let checkCounter = 0;

              function checkServerStatus() {
                  fetch('/serverStatus')
                      .then(response => response.json())
                      .then(data => {
                          const statusBar = document.getElementById('status-bar');
                          if (data.serverRunning) {
                              statusBar.classList.add('green');
                              statusBar.classList.remove('red');
                              checkCounter = 0; // Reset the counter if the server is running
                          } else {
                              checkCounter++;
                              if (checkCounter >= 3) {
                                  statusBar.classList.add('red');
                                  statusBar.classList.remove('green');
                              }
                          }
                      })
                      .catch(error => {
                          checkCounter++;
                          const statusBar = document.getElementById('status-bar');
                          if (checkCounter >= 3) {
                              statusBar.classList.add('red');
                              statusBar.classList.remove('green');
                          }
                      });
              }

              var ws = new WebSocket('ws://' + window.location.hostname + ':81/');
              var isConnected = false;

              ws.onopen = function() {
                  isConnected = true;
                  console.log('WebSocket connection established');
              };

              ws.onclose = function(event) {
                  isConnected = false;
                  console.log('WebSocket connection closed');
              };

              ws.onerror = function(error) {
                  isConnected = false;
                  console.log('WebSocket error:', error);
              };

              function updateSignalStrength(rssi) {
                  const signalStrength = document.querySelector('.signal-strength');
                  if (signalStrength) {
                      // Map RSSI von -100 bis -40 auf 0 bis 100
                      let signalPercentage = map(rssi, -100, -40, 0, 100);
                      signalPercentage = Math.min(Math.max(signalPercentage, 0), 100); // Begrenze den Wert auf 0 bis 100

                      signalStrength.style.width = signalPercentage + '%';
                      signalStrength.querySelector('.signal-text').textContent = rssi + ' dBm';
                  }
              }

                function map(value, in_min, in_max, out_min, out_max) {
                    return (value - in_min) * (out_max - out_min) / (in_max - in_min) + out_min;
                }


              function formatTraffic(traffic) {
                  if (traffic >= 1024) {
                      return (traffic / 1024).toFixed(2) + ' MB';
                  } else {
                      return traffic + ' KB';
                  }
              }

              ws.onmessage = function(event) {
                  try {
                      var data = JSON.parse(event.data);

                      if (data.bleStatus) {
                          const rssi = data.bleStatus.rssi;

                          const connectedUsers = data.bleStatus.connectedUsers;
                          const bestRssi = data.bleStatus.bestRssi;
                          const worstRssi = data.bleStatus.worstRssi;
                          const receivedTraffic = data.bleStatus.receivedTraffic;
                          const sentTraffic = data.bleStatus.sentTraffic;

                          const connectedUsersElement = document.querySelector('.info-connected-users');
                          if (connectedUsersElement) {
                              connectedUsersElement.textContent = 'Verbundene Benutzer: ' + connectedUsers;
                          }

                          const bestRssiElement = document.querySelector('.info-best-rssi');
                          if (bestRssiElement) {
                              bestRssiElement.textContent = 'Bester RSSI: ' + bestRssi + ' dBm';
                          }

                          const worstRssiElement = document.querySelector('.info-worst-rssi');
                          if (worstRssiElement) {
                              worstRssiElement.textContent = 'Schlechtester RSSI: ' + worstRssi + ' dBm';
                          }

                          const receivedTrafficElement = document.querySelector('.info-received-traffic');
                          if (receivedTrafficElement) {
                              receivedTrafficElement.textContent = 'Empfangener Traffic: ' + formatTraffic(receivedTraffic);
                          }

                          const sentTrafficElement = document.querySelector('.info-sent-traffic');
                          if (sentTrafficElement) {
                              sentTrafficElement.textContent = 'Gesendeter Traffic: ' + formatTraffic(sentTraffic);
                          }

                          updateSignalStrength(rssi);
                      }

                      // Radon-Geräte auflisten wenn live ausgewertete werden soll
                      const radonDevices = data.radonDevices || [];
                      const radonDevicesList = document.getElementById('radon-devices');
                      if (radonDevicesList) {
                          radonDevicesList.innerHTML = radonDevices.map(device => `<li>${device}</li>`).join('');
                      }

                      // Geräte mit Namen auflisten wenn live ausgewertete werden soll
                      const namedDevices = data.namedDevices || [];
                      const namedDevicesList = document.getElementById('named-devices');
                      if (namedDevicesList) {
                          namedDevicesList.innerHTML = namedDevices.map(device => `<li>${device}</li>`).join('');
                      }

                  } catch (e) {
                      console.error('Fehler beim Verarbeiten der WebSocket-Nachricht:', e);
                  }
              };

              window.onload = function() {
                  checkServerStatus();
                  setInterval(checkServerStatus, 5000); // Überprüft den Serverstatus alle 5 Sekunden
              };
          </script>






          </head>
          <body>
              <div id="status-bar" class="green"></div>
              <div class="container">
                  <div class="form-container">
                      <h1>BLE Informationen {ble_device_name}</h1>
                      <div class="info">Gerätename: {ble_device_name}</div>
                      <div class="info">BLE-Status: {ble_status}</div>
                      <div class="info">AVG RSSI: {ble_rssi} dBm</div>
                      <div class="info">Bester RSSI: {best_rssi} dBm</div> 
                      <div class="info">Schlechtester RSSI: {worst_rssi} dBm</div>
                      <div class="info">UUID: {ble_uuid}</div>
                      <div class="info info-connected-users">Verbundene Benutzer: {connected_users}</div>
                      <div class="info info-received-traffic">Empfangener Traffic: {received_traffic}</div>
                      <div class="info info-sent-traffic">Gesendeter Traffic: {sent_traffic}</div>
                      <br>
                      <hr>
                      <div class="signal-container">
                          <div class="label">-100</div>
                          <div class="signal-bar">
                              <div class="signal-strength">
                                  <div class="signal-text">{ble_rssi} dBm</div>
                              </div>
                          </div>
                          <div class="label">-40</div>
                      </div>
                      <div class="label-container">
                          <div class="label">schlecht</div>
                          <div class="label">gut</div>
                          <div class="middle-label">ok</div>
                      </div>

                      <br><hr><br>
                      <h2>BT Radon-Geräte im Umfeld</h2>
                      <ul>
                          {radon_devices}
                      </ul>
                      <ul id="radon-devices">
                        
                      </ul>
                      <hr>
                      <h2>Weitere BT Geräte</h2>
                      <ul>
                          {named_devices}
                      </ul>
                      <ul id="named-devices">
                        
                      </ul>
                      <hr>
                      <br>
                      <br>
                      <a href="/index" class="back-link">Zurück</a>
                  </div>
              </div>
          </body>
          </html>
          )rawliteral";
          #endif


      // HTML Template für die Restart-Seite
      const char restart_html_template[] PROGMEM = R"rawliteral(
      <!DOCTYPE html>
      <html lang="de">
      <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Neustart</title>
        <style>
          body {
            background-color: black;
            color: white;
            font-family: Arial, sans-serif;
            text-align: center;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
          }
          .container {
            width: 80%;
            margin: 0 auto; 
          }
          p {
            font-size: 1.5em;
          }
        </style>
        <script>
          // Warte 5 Sekunden und leite dann zur Indexseite weiter
          setTimeout(function(){
            window.location.href = '/';
          }, 5000); // 5000 Millisekunden = 5 Sekunden
        </script>
      </head>
      <body>
        <div class="container">
          <p>Der ESP wird neu gestartet...</p>
        </div>
      </body>
      </html>
      )rawliteral";







      const char start_html_template[] PROGMEM = R"rawliteral(
      <!DOCTYPE html>
      <html lang="de">
      <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Alpha Home Tracer {device_id}</title>
        <style>
          body {
            background-color: black;
            color: white;
            font-family: Arial, sans-serif;
            text-align: center;
          }
          .container {
            width: 80%;
            margin: 0 auto; 
          }
          table {
            margin: 10px auto;
            border-collapse: collapse;
            width: 90%;
            background-color: rgba(255, 255, 255, 0.1);
          }
          td {
            padding: 10px;
            border: 1px solid white;
            color: white;
          }
          .info-text {
            font-weight: normal;
            text-align: left; /* Linksbündige Ausrichtung */
          }
          .info-box {
            margin-top: 20px;
            padding: 10px;
            border: 1px solid white;
            color: lightgrey;
            width: 100%;
            text-align: left;
          }
          button {
            padding: 10px 20px;
            background-color: transparent;
            color: white;
            border: 2px solid white; 
            border-radius: 5px;
            cursor: pointer;
            margin-top: 20px;
          }
          button:hover {
            background-color: white;
            color: black;
          }
          .restart-button {
            color: red;
          }
        </style>
        <script>
          function restartDevice() {
            var password = prompt('Bitte Passwort eingeben:');
            var xhr = new XMLHttpRequest();
            xhr.open("POST", "/restart", true);
            xhr.setRequestHeader("Content-Type", "application/x-www-form-urlencoded");
            xhr.onreadystatechange = function() {
              if (xhr.readyState === 4 && xhr.status === 200) {
                if (xhr.responseText === "OK") {
                  window.location.href = "/restarting";
                } else {
                  alert('Falsches Passwort!');
                }
              }
            };
            xhr.send("password=" + encodeURIComponent(password));
          }
        </script>
      </head>
      <body>
        <h1>Alpha Home Tracer {device_id}</h1>
        <div class="container">
          <table>
            <tr>
              <td id="currentDateTime">{current_datetime}</td>
            </tr>
            <tr>
              <td id="currentRadon">{mb_radon_live_32bit}</td>
            </tr>
            <tr>
              <td id="currentRadon" class="info-text">
                <p>Die Webseite ist optimiert für den PC Browser.</p>
                <p>Empfohlene Browser: Chrome, Firefox, Edge</p>
                <p>Stellen Sie sicher, dass JavaScript aktiviert ist, um alle Funktionen nutzen zu können.</p>
                <p>Diese Webseite wird dynamisch aktualisiert. Leeren Sie immer den Browser-Cache, um die aktuellsten Funktionen nutzen zu können.</p>
              </td>
            </tr>
          </table>
          <button onclick="location.href='/index'">Weiter zum Sensor</button>  
          <br>
          <button class="restart-button" onclick="restartDevice()">Neustart</button>
        </div>
      </body>
      </html>
      )rawliteral";



          

          //  handle_root2
              
          #ifndef Firmware_backup     
          const char index_html_template[] PROGMEM = R"rawliteral(
            <!DOCTYPE html>
            <html>
            <head>
              <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
              <meta charset="UTF-8">
              <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
              <meta http-equiv="Pragma" content="no-cache">
              <meta name='viewport' content='width=device-width, initial-scale=1'/>
              <meta name="author" content="Gebauer Holger, https://www.auto-steuerung.de/">
              <title>Alpha Home Tracer {device_id}</title>
              <style>
                #status-bar {
                  width: 100%;
                  height: 10px;
                  position: fixed;
                  top: 0;
                  left: 0;
                }
                .green {
                  background-color: #28a745; /* Grün */
                }
                .red {
                  background-color: #dc3545; /* Rot */
                }
                

                  .status-dot {
                    width: 10px;
                    height: 10px;
                    border-radius: 50%;
                    background-color: #28a745; /* Grün */
                    position: absolute; /* Ändere zu absolute */
                    top: 0px;
                    left: 0px;
                  }
                  .dot-green {
                    background-color: #28a745; /* Grün */
                  }
                  .dot-red {
                    background-color: #dc3545; /* Rot */
                  }

                  .header-with-dot {
                    display: flex;
                    align-items: center; /* Zentriert den Inhalt vertikal */
                    justify-content: center; /* Zentriert den Inhalt horizontal */
                    position: relative; /* Positioniert den Container relativ */
                  }

                  .header-with-dot div {
                    margin-right: 5px; /* Abstand zwischen Punkt und Text */
                  }


                body { font-family: Arial, sans-serif; text-align: center; padding: 10px 50px; background-color: black; color: white; }
                h1 { color: #fff; }
                p { color: #ccc; }
                a {
                  display: block;
                  margin: 10px auto;
                  color: #007BFF;
                  text-decoration: none;
                  font-weight: bold;
                  font-size: 1.2em;
                  border: 2px solid #007BFF;
                  padding: 10px;
                  border-radius: 5px;
                  width: 300px;
                  background-color: #222; /* Dunklere Hintergrundfarbe */
                  box-shadow: 0 4px 8px rgba(0, 0, 0, 0.4); /* 3D-Effekt */
                }

                a:hover {
                  text-decoration: underline;
                  background-color: #007BFF;
                  color: white;
                  box-shadow: 0 8px 16px rgba(0, 0, 0, 0.8); /* Stärkerer 3D-Effekt beim Hover */
                }
                      
                /* Allgemeine Button-Stile */
                .status-button { 
                  display: inline-block; 
                  margin: 10px; 
                  padding: 10px 20px; 
                  border-radius: 5px; 
                  color: white; 
                  text-decoration: none; 
                  width: 300px; 
                  border: 2px solid transparent; 
                }

                  /* Button-Typen mit Hintergrundfarbe */
                  .status-button-background {
                    background-color: #333; /* Hintergrundfarbe auf Grau gesetzt */
                  }

                  .current-month {
                    border: 4px solid #28a745; /* Grüne Umrandung */
                  }

                  .current-month-top {
                    border-top: 4px solid #28a745; /* Grüne obere Umrandung */
                    border-left: 4px solid #28a745; /* Grüne linke Umrandung */
                    border-right: 4px solid #28a745; /* Grüne rechte Umrandung */
                  }
                  .current-month-bottom {
                    border-bottom: 4px solid #28a745; /* Grüne untere Umrandung */
                    border-left: 4px solid #28a745; /* Grüne linke Umrandung */
                    border-right: 4px solid #28a745; /* Grüne rechte Umrandung */
                  }



                  .status-button.ok { background-color: #28a745; } /* Hintergrundfarbe grün */
                  .status-button.nok { background-color: #dc3545; } /* Hintergrundfarbe rot */

                  .status-button.time { background-color: #28a745; } 
                  .status-button.utc-diff { background-color: #28a745; }

                  /* Button-Typen mit Rahmenfarbe */
                  .status-button-border {
                    background-color: #333; /* Hintergrundfarbe auf Grau gesetzt */
                    }

                .status-button.wlan-ok { border-color: #28a745; } 
                .status-button.wlan-nok { border-color: #808080; } 
                .status-button.ble-ok { border-color: #28a745; } 
                .status-button.ble-nok { border-color: #808080; }  
                .status-button.ntp-ok { border-color: #28a745; } 
                .status-button.ntp-nok { border-color: #808080; } 
                .status-button.tb-ok { border-color: #28a745; } 
                .status-button.tb-nok { border-color: #808080; } 

                .status-button.utc-ok { border-color: #28a745; } 
                .status-button.utc-nok { border-color: #808080; } 
                .status-button.tme-ok { border-color: #28a745; } 
                .status-button.tme-nok { border-color: #808080; } 

                .status-button.modbus-ok { border-color: #28a745; } 
                .status-button.modbus-nok { border-color: #808080; } 
                .status-button.cloud-ok { border-color: #28a745; } 
                .status-button.cloud-nok { border-color: #808080; } 
                .status-button.knx-ok { border-color: #28a745; } 
                .status-button.knx-nok { border-color: #808080; } 
                .status-button.json-ok { border-color: #28a745; } 
                .status-button.json-nok { border-color: #808080; } 
                .status-button.xml-ok { border-color: #28a745; } 
                .status-button.xml-nok { border-color: #808080; } 
                .status-button.ble2-ok { border-color: #28a745; } 
                .status-button.ble2-nok { border-color: #808080; } 
                .status-button.beacon-ok { border-color: #28a745; } 
                .status-button.beacon-nok { border-color: #808080; } 
                .status-button.mqtt-ok { border-color: #28a745; } 
                .status-button.mqtt-nok { border-color: #808080; } 
                .status-button.web-ok { border-color: #28a745; } 
                .status-button.web-nok { border-color: #808080; }

              .function-section { margin-top: 50px; border: 2px solid white; padding: 20px; position: relative; width: 90%; margin-left: auto; margin-right: auto; text-align: center; }
              .function-section .title { position: absolute; top: -20px; left: 50%; transform: translateX(-50%); background-color: black; padding: 0 10px; } 
                table {
                  margin: 20px auto;
                  border-collapse: collapse;
                  width: 100%;
                  table-layout: auto;
                  box-shadow: 0 8px 16px rgba(0, 0, 0, 0.2); /* Stärkerer 3D-Effekt */
                  background-color: #111; /* Dunklere Hintergrundfarbe der Tabelle */
                }

                th, td {
                  border: 1px solid #777; /* #444 Dunklere Rahmenfarbe */
                  padding: 10px;
                  text-align: center;
                  background-color: #222; /* Dunklere Hintergrundfarbe der Zellen */
                  color: white; /* Schriftfarbe */
                }

                th {
                  background-color: #0056b3; /* Dunkleres Blau für die Kopfzeilen */
                  color: white;
                  box-shadow: inset 0 -3px 0 rgba(0, 0, 0, 0.6); /* Stärkerer 3D-Effekt */
                }

                td {
                  box-shadow: inset 0 -1px 0 rgba(0, 0, 0, 0.6); /* Stärkerer 3D-Effekt */
                }
                @media (max-width: 600px) {
                  .status-dot {
                    width: 5px;
                    height: 5px;
                    top: 2px;
                    left: 2px;
                  }
                  table, th, td { font-size: 0.8em; }
                  th, td { padding: 5px; }
                  .month-table { display: flex; flex-wrap: wrap; }
                  .month-table th, .month-table td { flex: 1 0 50%; }
                  .function-section { width: 100%; margin-left: auto; margin-right: auto; text-align: center; padding-top: 10px; padding-right: 2px; padding-bottom: 3px; padding-left: 0px; }
                  .status-button { width: 150px; margin-left: auto; margin-right: auto; }
                  a { width: 150px; margin-left: auto; margin-right: auto; }
                }
                @media (max-width: 500px) {
                  .function-section { margin-right: 2px; padding-top: 10px; padding-right: 2px; padding-bottom: 3px; padding-left: 0px;}
                }

              </style>


          <script>
              let isNavigating = false;

              // Setze den Indikator beim Seitenwechsel innerhalb der Anwendung
              document.querySelectorAll('a').forEach(function(anchor) {
                  anchor.addEventListener('click', function(event) {
                      isNavigating = true;
                  });
              });

              // Überprüfe Sichtbarkeitswechsel des Dokuments
              document.addEventListener('visibilitychange', function() {
                  if (document.visibilityState === 'hidden' && !isNavigating && isConnected) {
                      console.log('Sending browser_closed message via visibilitychange');
                      ws.send('browser_closed');
                      setTimeout(() => ws.close(), 100);  // Verzögerung hinzugefügt
                  }
              });

              window.addEventListener('unload', function(event) {
                  if (!isNavigating && isConnected) {
                      console.log('Sending browser_closed message via unload');
                      ws.send('browser_closed');
                  }
              });

              // Funktion zur Hervorhebung des aktuellen Monats
              function highlightCurrentMonth() {
                  const currentMonth = new Date().getMonth(); // Holt die aktuelle Monatsnummer (0 = Januar, 11 = Dezember)
                  const monthHeaders = document.querySelectorAll('.month-table th');
                  const monthCells = document.querySelectorAll('.month-table td');

                  // Markiere die Kopfzelle und die Zelle mit dem Radonwert
                  monthHeaders.forEach((header, index) => {
                      if (index === currentMonth) {
                          header.classList.add('current-month-top');
                          if (monthCells[index]) {
                              monthCells[index].classList.add('current-month-bottom');
                          }
                      }
                  });
              }

              // Funktion zur Überprüfung des Serverstatus
              let checkCounter = 0;
              function checkServerStatus() {
                  fetch('/serverStatus')
                      .then(response => response.json())
                      .then(data => {
                          const statusBar = document.getElementById('status-bar');
                          if (data.serverRunning) {
                              statusBar.classList.add('green');
                              statusBar.classList.remove('red');
                              checkCounter = 0; // Reset the counter if the server is running
                          } else {
                              checkCounter++;
                              if (checkCounter >= 3) {
                                  statusBar.classList.add('red');
                                  statusBar.classList.remove('green');
                              }
                          }
                      })
                      .catch(error => {
                          checkCounter++;
                          const statusBar = document.getElementById('status-bar');
                          if (checkCounter >= 3) {
                              statusBar.classList.add('red');
                              statusBar.classList.remove('green');
                          }
                      });
              }

              // WebSocket Setup
              const ws = new WebSocket('ws://' + window.location.hostname + ':81/');
              let isConnected = false;

              ws.onopen = function() {
                  isConnected = true;
                  console.log('WebSocket connection established');
              };

              ws.onclose = function(event) {
                  isConnected = false;
                  console.log('WebSocket connection closed', event);
              };

              ws.onerror = function(error) {
                  isConnected = false;
                  console.log('WebSocket error:', error);
              };

              // Funktion zur Aktualisierung der Radonwerte
              function updateValues() {
                  fetch('/radonValues2')
                      .then(response => response.json())
                      .then(data => {
                          document.getElementById('currentDateTime').innerText = data.currentDateTime;
                          document.getElementById('radonLive').innerText = data.radonLive;
                          document.getElementById('radon24h').innerText = data.radon24h;
                          document.getElementById('radonLong').innerText = data.radonLong;
                          document.getElementById('mittelwertJahr').innerText = data.mittelwertJahr;
                          document.getElementById('runTime').innerText = data.runTime;
                      })
                      .catch(error => console.error('Error fetching values:', error));
              }

              // Initial Checks
              window.onload = function() {
                  highlightCurrentMonth();
                  checkServerStatus();
                  setInterval(checkServerStatus, 5000); // Überprüft den Serverstatus alle 5 Sekunden
                  updateValues();
                  setInterval(updateValues, 5000); // Aktualisiert die Werte alle 5 Sekunden
              };
          </script>







              </head>
              <body>
                <div id="status-bar" class="green"></div>
                <h1>Alpha Home Tracer {device_id}</h1>
              <table>
              <tr>
                <td id="currentDateTime">{current_datetime}
              </tr>
            </table>
            <table>
              <tr>
                <th class="header-with-dot">
                  <div id="radonLive-status-dot" class="status-dot dot-green"></div> 
                  Aktueller Radonwert
                </th>
                <th>Radon 1 Tag</th>
                <th>Radon Long</th>
                <th>Jahr Mittelwert</th>
                <th>Laufzeit</th>
              </tr>
              <tr>
                  <td id="radonLive">{mb_radon_live_32bit}</td>
                  <td id="radon24h">{radon_mittelwert_24h}</td>
                  <td id="radonLong">{radon_mittelwert_long}</td>
                  <td id="mittelwertJahr">{mittelwert_jahr}</td>
                  <td id="runTime">{mb_radon_save_eintrarge}</td>
              </tr>
            </table>
            <table class="month-table">
              <tr>
                <th>Jan</th>
                <th>Feb</th>
                <th>M&auml;r</th>
                <th>Apr</th>
                <th>Mai</th>
                <th>Jun</th>
              </tr>
              <tr>
                <td>{radon_mittelwert_monat[0]}</td>
                <td>{radon_mittelwert_monat[1]}</td>
                <td>{radon_mittelwert_monat[2]}</td>
                <td>{radon_mittelwert_monat[3]}</td>
                <td>{radon_mittelwert_monat[4]}</td>
                <td>{radon_mittelwert_monat[5]}</td>
              </tr>
              <tr>
                <th>Jul</th>
                <th>Aug</th>
                <th>Sep</th>
                <th>Okt</th>
                <th>Nov</th>
                <th>Dez</th>
              </tr>
              <tr>
                <td>{radon_mittelwert_monat[6]}</td>
                <td>{radon_mittelwert_monat[7]}</td>
                <td>{radon_mittelwert_monat[8]}</td>
                <td>{radon_mittelwert_monat[9]}</td>
                <td>{radon_mittelwert_monat[10]}</td>
                <td>{radon_mittelwert_monat[11]}</td>
              </tr>
            </table>
                <a href="/json">JSON</a>
                <a href="/xml">XML</a>
                <a href="/chart">Radon Chart</a>
                <a href="/ble">Bluetooth</a>

                <a href="/esp32">System Informationen</a>
                <a href="/sensor">Sensor</a>
                <a href="/knx">KNX</a> 
                <a href="/cloud">Cloud</a> 
                <a href="/mqtt">MQTT</a> 
                <a href="/modbus">Modbus</a>
                <a href="/time">Time</a> 
                <a href="/user"> User</a> 
                <br>

              <div>
                <div class="status-button status-button-background {rtc_status}">RTC {rtc_text}</div>
              </div>
              <div>
                <div class="status-button status-button-background {sensor_status}">Radon Sensor {sensor_text}</div>
              </div>
              <div class="function-section">
                <div class="title">User Funktionen</div>
                <div class="status-button status-button-border {wlan_status}">WLAN {wlan_text}</div>
                <div class="status-button status-button-border {ble_status}">BLE {ble_text}</div>
                <div class="status-button status-button-border {ntp_status}">NTP {ntp_text}</div>
                <div class="status-button status-button-border {tb_status}">ThingsBoard {tb_text}</div>

                <div class="status-button status-button-border {utc_status}">UTC Differenz {utc_text}</div>
                <div class="status-button status-button-border {tme_status}">{tme_text}</div>

                <div class="status-button status-button-border {modbus_status}">Modbus TCPIP {modbus_text}</div>
                <div class="status-button status-button-border {cloud_status}">Cloud {cloud_text}</div>
                <div class="status-button status-button-border {json_status}">JSON {json_text}</div>
                <div class="status-button status-button-border {xml_status}">XML {xml_text}</div>
                <div class="status-button status-button-border {ble2_status}">Bluetooth {ble2_text}</div>
                <div class="status-button status-button-border {beacon_status}">Bluetooth Beacon {beacon_text}</div>
                <div class="status-button status-button-border {knx_status}">KNX {knx_text}</div>
                <div class="status-button status-button-border {mqtt_status}">MQTT {mqtt_text}</div>
                <div class="status-button status-button-border {web_status}">IoT-Interface {web_text}</div>
              </div>

              </body>
              </html>
          )rawliteral";
      #else
        const char index_html_template[] PROGMEM = R"rawliteral(
            <!DOCTYPE html>
            <html>
            <head>
              <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
              <meta charset="UTF-8">
              <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
              <meta http-equiv="Pragma" content="no-cache">
              <meta name='viewport' content='width=device-width, initial-scale=1'/>
              <meta name="author" content="Gebauer Holger, https://www.auto-steuerung.de/">
              <title>Alpha Home Tracer {device_id}</title>
              <style>
                #status-bar {
                  width: 100%;
                  height: 10px;
                  position: fixed;
                  top: 0;
                  left: 0;
                }
                .green {
                  background-color: #28a745; /* Grün */
                }
                .red {
                  background-color: #dc3545; /* Rot */
                }
                

                  .status-dot {
                    width: 10px;
                    height: 10px;
                    border-radius: 50%;
                    background-color: #28a745; /* Grün */
                    position: absolute; /* Ändere zu absolute */
                    top: 0px;
                    left: 0px;
                  }
                  .dot-green {
                    background-color: #28a745; /* Grün */
                  }
                  .dot-red {
                    background-color: #dc3545; /* Rot */
                  }

                  .header-with-dot {
                    display: flex;
                    align-items: center; /* Zentriert den Inhalt vertikal */
                    justify-content: center; /* Zentriert den Inhalt horizontal */
                    position: relative; /* Positioniert den Container relativ */
                  }

                  .header-with-dot div {
                    margin-right: 5px; /* Abstand zwischen Punkt und Text */
                  }


                body { font-family: Arial, sans-serif; text-align: center; padding: 10px 50px; background-color: black; color: white; }
                h1 { color: #fff; }
                p { color: #ccc; }
                a {
                  display: block;
                  margin: 10px auto;
                  color: #007BFF;
                  text-decoration: none;
                  font-weight: bold;
                  font-size: 1.2em;
                  border: 2px solid #007BFF;
                  padding: 10px;
                  border-radius: 5px;
                  width: 300px;
                  background-color: #222; /* Dunklere Hintergrundfarbe */
                  box-shadow: 0 4px 8px rgba(0, 0, 0, 0.4); /* 3D-Effekt */
                }

                a:hover {
                  text-decoration: underline;
                  background-color: #007BFF;
                  color: white;
                  box-shadow: 0 8px 16px rgba(0, 0, 0, 0.8); /* Stärkerer 3D-Effekt beim Hover */
                }
                      
                /* Allgemeine Button-Stile */
                .status-button { 
                  display: inline-block; 
                  margin: 10px; 
                  padding: 10px 20px; 
                  border-radius: 5px; 
                  color: white; 
                  text-decoration: none; 
                  width: 300px; 
                  border: 2px solid transparent; 
                }

                  /* Button-Typen mit Hintergrundfarbe */
                  .status-button-background {
                    background-color: #333; /* Hintergrundfarbe auf Grau gesetzt */
                  }

                  .current-month {
                    border: 4px solid #28a745; /* Grüne Umrandung */
                  }

                  .current-month-top {
                    border-top: 4px solid #28a745; /* Grüne obere Umrandung */
                    border-left: 4px solid #28a745; /* Grüne linke Umrandung */
                    border-right: 4px solid #28a745; /* Grüne rechte Umrandung */
                  }
                  .current-month-bottom {
                    border-bottom: 4px solid #28a745; /* Grüne untere Umrandung */
                    border-left: 4px solid #28a745; /* Grüne linke Umrandung */
                    border-right: 4px solid #28a745; /* Grüne rechte Umrandung */
                  }



                  .status-button.ok { background-color: #28a745; } /* Hintergrundfarbe grün */
                  .status-button.nok { background-color: #dc3545; } /* Hintergrundfarbe rot */

                  .status-button.time { background-color: #28a745; } 
                  .status-button.utc-diff { background-color: #28a745; }

                  /* Button-Typen mit Rahmenfarbe */
                  .status-button-border {
                    background-color: #333; /* Hintergrundfarbe auf Grau gesetzt */
                    }

                .status-button.wlan-ok { border-color: #28a745; } 
                .status-button.wlan-nok { border-color: #808080; } 
                .status-button.ble-ok { border-color: #28a745; } 
                .status-button.ble-nok { border-color: #808080; }  
                .status-button.ntp-ok { border-color: #28a745; } 
                .status-button.ntp-nok { border-color: #808080; } 
                .status-button.tb-ok { border-color: #28a745; } 
                .status-button.tb-nok { border-color: #808080; } 

                .status-button.utc-ok { border-color: #28a745; } 
                .status-button.utc-nok { border-color: #808080; } 
                .status-button.tme-ok { border-color: #28a745; } 
                .status-button.tme-nok { border-color: #808080; } 

                .status-button.modbus-ok { border-color: #28a745; } 
                .status-button.modbus-nok { border-color: #808080; } 
                .status-button.cloud-ok { border-color: #28a745; } 
                .status-button.cloud-nok { border-color: #808080; } 
                .status-button.knx-ok { border-color: #28a745; } 
                .status-button.knx-nok { border-color: #808080; } 
                .status-button.json-ok { border-color: #28a745; } 
                .status-button.json-nok { border-color: #808080; } 
                .status-button.xml-ok { border-color: #28a745; } 
                .status-button.xml-nok { border-color: #808080; } 
                .status-button.ble2-ok { border-color: #28a745; } 
                .status-button.ble2-nok { border-color: #808080; } 
                .status-button.beacon-ok { border-color: #28a745; } 
                .status-button.beacon-nok { border-color: #808080; } 
                .status-button.mqtt-ok { border-color: #28a745; } 
                .status-button.mqtt-nok { border-color: #808080; } 
                .status-button.web-ok { border-color: #28a745; } 
                .status-button.web-nok { border-color: #808080; }

              .function-section { margin-top: 50px; border: 2px solid white; padding: 20px; position: relative; width: 90%; margin-left: auto; margin-right: auto; text-align: center; }
              .function-section .title { position: absolute; top: -20px; left: 50%; transform: translateX(-50%); background-color: black; padding: 0 10px; } 
                table {
                  margin: 20px auto;
                  border-collapse: collapse;
                  width: 100%;
                  table-layout: auto;
                  box-shadow: 0 8px 16px rgba(0, 0, 0, 0.2); /* Stärkerer 3D-Effekt */
                  background-color: #111; /* Dunklere Hintergrundfarbe der Tabelle */
                }

                th, td {
                  border: 1px solid #777; /* #444 Dunklere Rahmenfarbe */
                  padding: 10px;
                  text-align: center;
                  background-color: #222; /* Dunklere Hintergrundfarbe der Zellen */
                  color: white; /* Schriftfarbe */
                }

                th {
                  background-color: #0056b3; /* Dunkleres Blau für die Kopfzeilen */
                  color: white;
                  box-shadow: inset 0 -3px 0 rgba(0, 0, 0, 0.6); /* Stärkerer 3D-Effekt */
                }

                td {
                  box-shadow: inset 0 -1px 0 rgba(0, 0, 0, 0.6); /* Stärkerer 3D-Effekt */
                }
                @media (max-width: 600px) {
                  .status-dot {
                    width: 5px;
                    height: 5px;
                    top: 2px;
                    left: 2px;
                  }
                  table, th, td { font-size: 0.8em; }
                  th, td { padding: 5px; }
                  .month-table { display: flex; flex-wrap: wrap; }
                  .month-table th, .month-table td { flex: 1 0 50%; }
                  .function-section { width: 100%; margin-left: auto; margin-right: auto; text-align: center; padding-top: 10px; padding-right: 2px; padding-bottom: 3px; padding-left: 0px; }
                  .status-button { width: 150px; margin-left: auto; margin-right: auto; }
                  a { width: 150px; margin-left: auto; margin-right: auto; }
                }
                @media (max-width: 500px) {
                  .function-section { margin-right: 2px; padding-top: 10px; padding-right: 2px; padding-bottom: 3px; padding-left: 0px;}
                }

              </style>


          <script>
              let isNavigating = false;

              // Setze den Indikator beim Seitenwechsel innerhalb der Anwendung
              document.querySelectorAll('a').forEach(function(anchor) {
                  anchor.addEventListener('click', function(event) {
                      isNavigating = true;
                  });
              });

              // Überprüfe Sichtbarkeitswechsel des Dokuments
              document.addEventListener('visibilitychange', function() {
                  if (document.visibilityState === 'hidden' && !isNavigating && isConnected) {
                      console.log('Sending browser_closed message via visibilitychange');
                      ws.send('browser_closed');
                      setTimeout(() => ws.close(), 100);  // Verzögerung hinzugefügt
                  }
              });

              window.addEventListener('unload', function(event) {
                  if (!isNavigating && isConnected) {
                      console.log('Sending browser_closed message via unload');
                      ws.send('browser_closed');
                  }
              });

              // Funktion zur Hervorhebung des aktuellen Monats
              function highlightCurrentMonth() {
                  const currentMonth = new Date().getMonth(); // Holt die aktuelle Monatsnummer (0 = Januar, 11 = Dezember)
                  const monthHeaders = document.querySelectorAll('.month-table th');
                  const monthCells = document.querySelectorAll('.month-table td');

                  // Markiere die Kopfzelle und die Zelle mit dem Radonwert
                  monthHeaders.forEach((header, index) => {
                      if (index === currentMonth) {
                          header.classList.add('current-month-top');
                          if (monthCells[index]) {
                              monthCells[index].classList.add('current-month-bottom');
                          }
                      }
                  });
              }

              // Funktion zur Überprüfung des Serverstatus
              let checkCounter = 0;
              function checkServerStatus() {
                  fetch('/serverStatus')
                      .then(response => response.json())
                      .then(data => {
                          const statusBar = document.getElementById('status-bar');
                          if (data.serverRunning) {
                              statusBar.classList.add('green');
                              statusBar.classList.remove('red');
                              checkCounter = 0; // Reset the counter if the server is running
                          } else {
                              checkCounter++;
                              if (checkCounter >= 3) {
                                  statusBar.classList.add('red');
                                  statusBar.classList.remove('green');
                              }
                          }
                      })
                      .catch(error => {
                          checkCounter++;
                          const statusBar = document.getElementById('status-bar');
                          if (checkCounter >= 3) {
                              statusBar.classList.add('red');
                              statusBar.classList.remove('green');
                          }
                      });
              }

              // WebSocket Setup
              const ws = new WebSocket('ws://' + window.location.hostname + ':81/');
              let isConnected = false;

              ws.onopen = function() {
                  isConnected = true;
                  console.log('WebSocket connection established');
              };

              ws.onclose = function(event) {
                  isConnected = false;
                  console.log('WebSocket connection closed', event);
              };

              ws.onerror = function(error) {
                  isConnected = false;
                  console.log('WebSocket error:', error);
              };

              // Funktion zur Aktualisierung der Radonwerte
              function updateValues() {
                  fetch('/radonValues2')
                      .then(response => response.json())
                      .then(data => {
                          document.getElementById('currentDateTime').innerText = data.currentDateTime;
                          document.getElementById('radonLive').innerText = data.radonLive;
                          document.getElementById('radon24h').innerText = data.radon24h;
                          document.getElementById('radonLong').innerText = data.radonLong;
                          document.getElementById('mittelwertJahr').innerText = data.mittelwertJahr;
                          document.getElementById('runTime').innerText = data.runTime;
                      })
                      .catch(error => console.error('Error fetching values:', error));
              }

              // Initial Checks
              window.onload = function() {
                  highlightCurrentMonth();
                  checkServerStatus();
                  setInterval(checkServerStatus, 5000); // Überprüft den Serverstatus alle 5 Sekunden
                  updateValues();
                  setInterval(updateValues, 5000); // Aktualisiert die Werte alle 5 Sekunden
              };
          </script>







              </head>
              <body>
                <div id="status-bar" class="green"></div>
                <h1>Alpha Home Tracer {device_id}</h1>
              <table>
              <tr>
                <td id="currentDateTime">{current_datetime}
              </tr>
            </table>
          

                <a href="/esp32">System Informationen</a>

                <a href="/user"> User</a> 
                <br>

              <div class="function-section">
                <div class="title">User Funktionen</div>
                <div class="status-button status-button-border {wlan_status}">WLAN {wlan_text}</div>
                <div class="status-button status-button-border {ble_status}">BLE {ble_text}</div>
                <div class="status-button status-button-border {tb_status}">ThingsBoard {tb_text}</div>

                <div class="status-button status-button-border {ble2_status}">Bluetooth {ble2_text}</div>
                <div class="status-button status-button-border {beacon_status}">Bluetooth Beacon {beacon_text}</div>
              </div>

              </body>
              </html>
          )rawliteral";

      #endif





      const char esp32_info_html[] PROGMEM = R"rawliteral(
        <!DOCTYPE html>
        <html>
        <head>
          <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
          <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
          <meta http-equiv="Pragma" content="no-cache">
          <meta name='viewport' content='width=device-width, initial-scale=1'/>
          <meta name="author" content="Gebauer Holger, https://www.auto-steuerung.de/">
          <title>Sensor Informationen {device_id}</title>
          <style>
            body { font-family: Arial, sans-serif; text-align: center; padding: padding: 10px 50px; background-color: black; color: white; }
            .container { display: inline-block; text-align: left; }
            h1 { color: #fff; margin-top: 10px; }
            h2 { color: #fff; margin-top: 15px; }
            h3 { color: #fff; margin-top: 10px; }
            p { color: #ccc; margin: 5px 0; }
            a { display: block; margin: 10px auto; color: #007BFF; text-decoration: none; font-weight: bold; font-size: 1.2em; border: 2px solid #007BFF; padding: 10px; border-radius: 5px; width: 200px; text-align: center; }
            a:hover { text-decoration: underline; background-color: #007BFF; color: white; }
            .bar-container { width: 320px; background-color: #ccc; border-radius: 5px; margin: 10px 0; border: 1px solid #fff; position: relative; }
            .bar { height: 18px; border-radius: 5px; text-align: left; color: white; padding-left: 5px; line-height: 18px; }
            .bar-text-container { width: 320px; margin: 0; text-align: left; }
            .bar-text { color: white; font-weight: bold; margin-bottom: 2px; }
            hr { border: 1px solid #fff; margin: 20px 0; }

            #status-bar {
              width: 100%;
              height: 10px;
              position: fixed;
              top: 0;
              left: 0;
            }
            .green {
              background-color: #28a745; /* Grün */
            }
            .red {
              background-color: #dc3545; /* Rot */
            }
          </style>
          <script>
          let isNavigating = false;

          // Setze den Indikator beim Seitenwechsel innerhalb der Anwendung
          document.querySelectorAll('a').forEach(function(anchor) {
              anchor.addEventListener('click', function(event) {
                  isNavigating = true;
              });
          });

          // Überprüfe Sichtbarkeitswechsel des Dokuments
          document.addEventListener('visibilitychange', function() {
              if (document.visibilityState === 'hidden' && !isNavigating && isConnected) {
                  console.log('Sending browser_closed message via visibilitychange');
                  ws.send('browser_closed');
                  setTimeout(() => ws.close(), 100);  // Verzögerung hinzugefügt
              }
          });

          window.addEventListener('unload', function(event) {
              if (!isNavigating && isConnected) {
                  console.log('Sending browser_closed message via unload');
                  ws.send('browser_closed');
              }
          });

          let checkCounter = 0;

          function checkServerStatus() {
              fetch('/serverStatus')
                  .then(response => response.json())
                  .then(data => {
                      const statusBar = document.getElementById('status-bar');
                      if (data.serverRunning) {
                          statusBar.classList.add('green');
                          statusBar.classList.remove('red');
                          checkCounter = 0; // Reset the counter if the server is running
                      } else {
                          checkCounter++;
                          if (checkCounter >= 3) {
                              statusBar.classList.add('red');
                              statusBar.classList.remove('green');
                          }
                      }
                  })
                  .catch(error => {
                      checkCounter++;
                      const statusBar = document.getElementById('status-bar');
                      if (checkCounter >= 3) {
                          statusBar.classList.add('red');
                          statusBar.classList.remove('green');
                      }
                  });
          }

          var ws = new WebSocket('ws://' + window.location.hostname + ':81/');
          var isConnected = false;

          ws.onopen = function() {
              isConnected = true;
              console.log('WebSocket connection established');
          };

          ws.onclose = function(event) {
              isConnected = false;
              console.log('WebSocket connection closed');
          };

          ws.onerror = function(error) {
              isConnected = false;
              console.log('WebSocket error:', error);
          };

          window.onload = function() {
              checkServerStatus();
              setInterval(checkServerStatus, 5000); // Überprüft den Serverstatus alle 5 Sekunden

              // Setze Balkenfarben basierend auf RAM-Werten
              let usedRAM = parseFloat("{usedRAM}");
              let ramBar = document.querySelector(".ram-bar");
              if (usedRAM <= 0.241) {
                  ramBar.style.backgroundColor = "#007BFF";
              } else if (usedRAM <= 0.245) {
                  ramBar.style.backgroundColor = "orange";
              } else {
                  ramBar.style.backgroundColor = "red";
              }
          };
          </script>
        </head>
        <body>
        <div id="status-bar" class="green"></div>
          <div class="container">
            <h1>Sensor Informationen</h1>
            <hr>
            <h2>System</h2>
            <p>Hardware-Name: {hardware_name}</p>
            <p>Sensor-Name: {device_id}</p>
            <p>Firmware-Version: {fw_version}</p>
            <p>Firmware-Datum: {fw_datum}</p>
            <p>CPU: {chip_revision}</p>
            <p>Taktrate: {cpu_freq} MHz</p>
            <p>Flash-Speicher: {flash_size} MB</p>
            <p>RAM: {ram_size} KB</p>
            <p>SRAM: 512 KB</p>
            <p>PSRAM: {psram_size} MB (Quad SPI)</p>
            <p>Crystal: 40 MHz</p>
            <p>CPU Temperatur: {chip_temperatur} &deg;C</p>
            <hr>
            <h2>WLAN </h2>
            <p>IP-Adresse : {ip_address}</p>
            <p>IP-Gateway : {gateway_address}</p>
            <p>IP-Subnet  : {subnet_address}</p>
            <p>MAC-Adresse: {mac_address}</p>
            <p>Frequenz: {wifi_frequency} GHz (802.11 b/g/n) 150 Mbps</p>
            <p>Verschl&uuml;sselung: {wifi_encryption}</p>
            <hr>
            <h2>Bluetooth </h2>
            <p>BLE Info: {ble_info}</p>
            <p>BLE Info: Speed: 125 Kbps, 500 Kbps, 1 Mbps, 2 Mbps</p>
            <p>BLE MAC-Adresse: {ble_mac_address}</p>
            <hr>
            <h2>Modbus </h2>
            <p>Modbus IP: {modbus_ip}</p>
            <p>Modbus Port: 502</p>
            <hr>
            <h2>KNX </h2>
            <p>Physikalische Adresse: {knx_address}</p>
            <p>Multicast Adresse: {multicast_address}</p>
            <h3>Gruppenadressen</h3>
            <p>Radon live: {address1}</p>
            <p>Radon 24h: {address2}</p>
            <p>Radon Long: {address3}</p>
            <p>Sensor Laufzeit: {address4}</p>
            <hr>
            <h2>MQTT</h2>
            <p>Aktueller Topic: {mqtt_topic}</p>
            <p>Server: {mqtt_server}</p>
            <hr>
            <h2>RTC</h2>
            <p>RTC Temperatur: {rtc_temperatur} &deg;C</p>
            <p>Oszillator: {rtc_oszi}</p>
            <p>Uhrzeit-Modus: {g_u_clock}</p>
            <hr>
            <h2>System Auslastung</h2>
            <div class="bar-text-container">
              <div class="bar-text">RAM: {usedRAM} MB / {totalRAM} MB</div>
              <div class="bar-container">
                <div class="bar ram-bar" style="width: {usedPercentageRAM}%;"></div>
              </div>
            </div>

            <div class="bar-text-container">
              <div class="bar-text">PSRAM: {usedPSRAM} MB / {totalPSRAM} MB</div>
              <div class="bar-container">
                <div class="bar" style="width: {usedPercentagePSRAM}%; background-color: #007BFF;"></div>
              </div>
            </div>

            <div class="bar-text-container">
              <div class="bar-text">Flash: {usedFlash} MB / {totalFlash} MB</div>
              <div class="bar-container">
                <div class="bar" style="width: {usedPercentageFlash}%; background-color: #007BFF;"></div>
              </div>
            </div>
            <div class="bar-text-container">
              <div class="bar-text">NVS: {nvs_used_entries} / {nvs_total_entries} entries</div>
              <div class="bar-container">
                <div class="bar" style="width: {usedPercentageNVS}%; background-color: #007BFF;"></div>
              </div>
            </div>
            <div class="bar-text-container">
              <div class="bar-text">SPIFFS: {usedBytes} MB / {totalBytes} MB</div>
              <div class="bar-container">
                <div class="bar" style="width: {usedPercentageSPIFFS}%; background-color: #007BFF;"></div>
              </div>
            </div>
            <hr>
            <br>
            <a href="/index">Zur&uuml;ck</a>
          </div>
        </body>
        </html>
      )rawliteral";



      #ifndef Firmware_backup
      const char knx_html_template[] PROGMEM = R"rawliteral(
      <!DOCTYPE html>
      <html>
      <head>
        <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
        <meta charset="UTF-8">
        <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
        <meta http-equiv="Pragma" content="no-cache">
        <meta name='viewport' content='width=device-width, initial-scale=1'/>
        <meta name="author" content="Gebauer Holger, https://www.auto-steuerung.de/">
        <title>KNX {device_id}</title>
          <style>
            #status-bar {
              width: 100%;
              height: 10px;
              position: fixed;
              top: 0;
              left: 0;
            }
            .green {
              background-color: #28a745; /* Grün */
            }
            .red {
              background-color: #dc3545; /* Rot */
            }
          html, body { font-family: Arial, sans-serif; text-align: center; padding: 15px 2px; background-color: black; color: white; width: 100%; }
          h1 { color: #fff; }
          h2 { color: #fff; }
          p { color: #ccc; }
          a {
            display: block;
            margin: 10px auto;
            color: #007BFF;
            text-decoration: none;
            font-weight: bold;
            font-size: 1.2em;
            border: 2px solid #007BFF;
            padding: 10px;
            border-radius: 5px;
            width: 300px;
            background-color: #222;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.4);
          }
          a:hover {
            text-decoration: underline;
            background-color: #007BFF;
            color: white;
            box-shadow: 0 8px 16px rgba(0, 0, 0, 0.8);
          }

            .container {
              display: flex;
              justify-content: center;
              align-items: flex-start;
              min-height: 100vh;
              padding: 10px;
              margin: 0 auto;
            }

            .form-container {
              width: 100%;
              max-width: 800px; /* Du kannst die Breite anpassen */
              padding: 20px;
              background-color: #222;
              border: 1px solid #ddd;
              border-radius: 8px;
              box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
              margin: 0 auto;
            }

            .table-container {
              margin: 20px auto;
              width: 100%;
              max-width: 800px;
            }

            .table-container table {
              width: 100%;
              background-color: #222;
              color: white;
              border-collapse: collapse;
            }

            .table-container th,
            .table-container td {
              border: 1px solid #777;
              padding: 10px;
              text-align: center;
            }

            .table-container th {
              background-color: #0056b3;
            }
            .status-table {
              width: 100%; /* Passe die Breite an */
              max-width: 850px; /* Maximale Breite einstellen */
              margin: auto; /* Zentriere die Tabelle */
              background-color: #222; /* Hintergrundfarbe der Tabelle */
              color: white;
              border-collapse: collapse;
            }

            .status-table th,
            .status-table td {
              padding: 10px;
              text-align: center; /* Zentriere den Text */
              border: 1px solid #777; /* Rahmen um die Zellen */
            }

            .status-table th {
              background-color: #0056b3; /* Hintergrundfarbe der Überschriften */
            }

            .status-table td {
              background-color: #333; /* Hintergrundfarbe der Zellen */
            }


            .back-link {
              display: block;
              margin: 10px auto;
              color: #007BFF;
              text-decoration: none;
              font-weight: bold;
              font-size: 1.2em;
              border: 2px solid #007BFF;
              padding: 10px;
              border-radius: 5px;
              width: 110px;  
              background-color: #222;
              box-shadow: 0 4px 8px rgba(0, 0, 0, 0.4);
              text-align: center; 
            }
            .back-link:hover {
              text-decoration: underline;
              background-color: #007BFF;
              color: white;
              box-shadow: 0 8px 16px rgba(0, 0, 0, 0.8);
            }
              button {
                display: block;
                margin: 20px auto;
                color: #fff;
                background-color: #007BFF;
                border: none;
                padding: 10px 20px;
                font-size: 1.2em;
                border-radius: 5px;
                cursor: pointer;
              }
              button:hover {
                background-color: #0056b3;
              }
              .status-ok {
                background-color: #28a745;
              }
              .status-nok {
                background-color: #dc3545;
              }
              table {
                margin: 20px auto;
                border-collapse: collapse;
                width: 80%;
                background-color: #222;
                color: white;
              }
              th, td {
                border: 1px solid #777;
                padding: 10px;
                text-align: center;
              }
              th {
                background-color: #0056b3;
              }
              input[type="text"], input[type="password"] {
                width: 100%;
                padding: 8px;
                margin: 5px 0;
                box-sizing: border-box;
                border: none;
                background-color: #333;
                color: white;
              }
              input[type="submit"] {
                width: auto;
                padding: 8px 16px;
                background-color: #007BFF;
                color: white;
                border: none;
                border-radius: 5px;
                cursor: pointer;
              }
              input[type="submit"]:hover {
                background-color: #0056b3;
              }
                  
              /* Tooltip-Stil */
              .tooltip {
                position: relative;
                display: inline-block;
              }

              .tooltip .tooltiptext {
                visibility: hidden;
                width: 120px;
                background-color: #666;
                color: #fff;
                text-align: center;
                border-radius: 5px;
                padding: 5px;
                position: absolute;
                z-index: 1;
                bottom: 125%; /* Positioniert den Tooltip oberhalb des Textfelds */
                left: 50%;
                margin-left: -60px;
                opacity: 0;
                transition: opacity 0.3s;
              }

          .tooltip:hover .tooltiptext {
            visibility: visible;
            opacity: 1;
          }

                    .switch {
                      position: relative;
                      display: inline-block;
                      width: 60px;
                      height: 30px;
                    }
                    .switch input {
                      opacity: 0;
                      width: 0;
                      height: 0;
                    }
                    .slider {
                      position: absolute;
                      cursor: pointer;
                      top: 0;
                      left: 0;
                      right: 0;
                      bottom: 0;
                      background-color: #ccc;
                      transition: .4s;
                    }
                    .slider:before {
                      position: absolute;
                      content: "";
                      height: 24px;
                      width: 24px;
                      left: 3px;
                      bottom: 3px;
                      background-color: white;
                      transition: .4s;
                    }
                    input:checked + .slider {
                      background-color: #2196F3;
                    }
                    input:checked + .slider:before {
                      transform: translateX(26px);
                    }
                    .slider:after {
                      content: 'OFF';
                      color: white;
                      display: block;
                      position: absolute;
                      transform: translate(-50%,-50%);
                      top: 50%;
                      left: 70%;
                      font-size: 10px;
                      font-family: Verdana, sans-serif;
                    }
                    input:checked + .slider:after {
                      left: 25%;
                      content: 'ON';
                    }

          @media (max-width: 800px) {
            .container {
              width: 100%;
              padding: 0;
              margin: 0;

            }

            .form-container {
              width: 100%;
              max-width: none;
              padding: 10px;
              margin: 0;
            }

            .form-table {
              width: 95%;
              margin: 0;
            }
          }

        </style>
      <script>
          let isNavigating = false;

          // Setze den Indikator beim Seitenwechsel innerhalb der Anwendung
          document.querySelectorAll('a').forEach(function(anchor) {
              anchor.addEventListener('click', function(event) {
                  isNavigating = true;
              });
          });

          // Überprüfe Sichtbarkeitswechsel des Dokuments
          document.addEventListener('visibilitychange', function() {
              if (document.visibilityState === 'hidden' && !isNavigating && isConnected) {
                  console.log('Sending browser_closed message via visibilitychange');
                  ws.send('browser_closed');
                  setTimeout(() => ws.close(), 100);  // Verzögerung hinzugefügt
              }
          });

          window.addEventListener('unload', function(event) {
              if (!isNavigating && isConnected) {
                  console.log('Sending browser_closed message via unload');
                  ws.send('browser_closed');
              }
          });

          var ws = new WebSocket('ws://' + window.location.hostname + ':81/');
          var isConnected = false;

          ws.onopen = function() {
              isConnected = true;
              console.log('WebSocket connection established');
          };

          ws.onclose = function(event) {
              isConnected = false;
              console.log('WebSocket connection closed');
          };

          ws.onerror = function(error) {
              isConnected = false;
              console.log('WebSocket error:', error);
          };

          // Funktion zum Ausführen eines Serverskripts
          function executeFunction() {
              fetch('/executeFunction')
                  .then(() => {
                      location.reload(); // Seite neu laden
                  });
          }

          // Funktion zum Aktualisieren des LED-Status
          function updateLEDStatus() {
              fetch('/getLEDStatus')
                  .then(response => response.json())
                  .then(data => {
                      const ledElement = document.getElementById('ledIndicator');
                      if (data.ledStatus === 1) {
                          ledElement.style.backgroundColor = 'red';
                      } else {
                          ledElement.style.backgroundColor = 'gray';
                      }
                  })
                  .catch(error => console.error('Error fetching LED status:', error));
          }

          function toggleProgramMode() {
              alert('Der Sensor wird neu gestartet');
              document.getElementById('confirmationModal').style.display = 'none';
              document.getElementById('modalOverlay').style.display = 'none';

              const password = prompt('Bitte Passwort eingeben:');
              fetch('/checkPassword', {
                  method: 'POST',
                  headers: {
                      'Content-Type': 'application/json'
                  },
                  body: JSON.stringify({ password: password })
              })
              .then(response => response.json())
              .then(data => {
                  if (data.success) {
                      fetch('/toggleProgramMode')
                          .then(response => response.text())
                          .then(message => alert(message))
                          .catch(error => console.error('Error toggling program mode:', error));
                  } else {
                      alert('Falsches Passwort');
                  }
              })
              .catch(error => console.error('Error checking password:', error));
          }

          function sendDataToKNX() {
              const password = prompt('Bitte Passwort eingeben:');
              fetch('/checkPassword', {
                  method: 'POST',
                  headers: {
                      'Content-Type': 'application/json'
                  },
                  body: JSON.stringify({ password: password })
              })
              .then(response => response.json())
              .then(data => {
                  if (data.success) {
                      fetch('/sendDataToKNX')
                          .then(response => response.text())
                          .then(message => alert(message))
                          .catch(error => console.error('Error sending data to KNX:', error));
                  } else {
                      alert('Falsches Passwort');
                  }
              })
              .catch(error => console.error('Error checking password:', error));
          }

          window.addEventListener('DOMContentLoaded', (event) => {
              document.getElementById('knxForm').addEventListener('submit', function(event) {
                  event.preventDefault(); // Verhindert das Standard-Submit-Verhalten
                  document.getElementById('confirmationModal').style.display = 'block';
                  document.getElementById('modalOverlay').style.display = 'block';
              });

              document.getElementById('confirmButton').addEventListener('click', function() {
                  document.getElementById('confirmationModal').style.display = 'none';
                  document.getElementById('modalOverlay').style.display = 'none';

                  const password = prompt('Bitte Passwort eingeben:');
                  fetch('/checkPassword', {
                      method: 'POST',
                      headers: {
                          'Content-Type': 'application/json'
                      },
                      body: JSON.stringify({ password: password })
                  })
                  .then(response => response.json())
                  .then(data => {
                      if (data.success) {
                          document.getElementById('knxForm').submit();
                      } else {
                          alert('Falsches Passwort');
                      }
                  })
                  .catch(error => console.error('Error checking password:', error));
              });

              document.getElementById('cancelButton').addEventListener('click', function() {
                  document.getElementById('confirmationModal').style.display = 'none';
                  document.getElementById('modalOverlay').style.display = 'none';
              });
          });

          // Intervall, um den LED-Status jede Sekunde zu aktualisieren
          setInterval(updateLEDStatus, 600);

          let checkCounter = 0;

          function checkServerStatus() {
              fetch('/serverStatus')
                  .then(response => response.json())
                  .then(data => {
                      const statusBar = document.getElementById('status-bar');
                      if (data.serverRunning) {
                          statusBar.classList.add('green');
                          statusBar.classList.remove('red');
                          checkCounter = 0; // Reset the counter if the server is running
                      } else {
                          checkCounter++;
                          if (checkCounter >= 3) {
                              statusBar.classList.add('red');
                              statusBar.classList.remove('green');
                          }
                      }
                  })
                  .catch(error => {
                      checkCounter++;
                      const statusBar = document.getElementById('status-bar');
                      if (checkCounter >= 3) {
                          statusBar.classList.add('red');
                          statusBar.classList.remove('green');
                      }
                  });
          }

          function updateRadonValues() {
              fetch('/radonValues')
                  .then(response => response.json())
                  .then(data => {
                      document.getElementById('radonLive').innerText = data.radonLive;
                      document.getElementById('radon24h').innerText = data.radon24h;
                      document.getElementById('radonLong').innerText = data.radonLong;
                      document.getElementById('runTime').innerText = data.runTime;
                  })
                  .catch(error => console.error('Error fetching radon values:', error));
          }

          function validateGroupAddress(input) {
              var pattern = /^(\d{1,3})\/(\d{1,3})\/(\d{1,3})$/;
              if (!pattern.test(input.value)) {
                  alert("Ungültige Gruppenadresse! Bitte gib eine Adresse im Format X/X/X ein, wobei X 1-3 stellige Zahlen sind.");
                  input.value = '';
              }
          }

          function validateKNXAddress(input) {
              var pattern = /^(\d{1,3})\.(\d{1,3})\.(\d{1,3})$/;
              if (!pattern.test(input.value)) {
                  alert("Ungültige KNX-Adresse! Bitte gib eine Adresse im Format X.X.X ein, wobei X 1-3 stellige Zahlen sind.");
                  input.value = '';
              }
          }

          function validateIPAddress(input) {
              var pattern = /^(25[0-5]|2[0-4][0-9]|[0-1]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[0-1]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[0-1]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[0-1]?[0-9][0-9]?)$/;
              if (!pattern.test(input.value)) {
                  alert("Ungültige IP-Adresse! Bitte gib eine gültige IP-Adresse im Format X.X.X.X ein, wobei X eine Zahl zwischen 0 und 255 ist.");
                  input.value = '';
              }
          }

          window.onload = function() {
              checkServerStatus();
              setInterval(checkServerStatus, 5000); // Überprüft den Serverstatus alle 5 Sekunden
              updateRadonValues();
              setInterval(updateRadonValues, 5000); // Aktualisiere die Werte alle 5 Sekunden

              const form = document.querySelector('form');
              form.onsubmit = function(event) {
                  event.preventDefault();
                  document.getElementById('confirmationModal').style.display = 'block';
                  document.getElementById('modalOverlay').style.display = 'block';
              };
          };
      </script>






      </head>


      <body>
        <div id="status-bar" class="green"></div>
        <div class="container">

        <div class="form-container">
        <h2>Funktionen KNX</h2>
        <form id="knxForm" method="POST" action="/save_knx_settings">
        <div class="table-container">
          <table>
            <tr>
              <th>Bez.</th>
              <th>Adresse</th>
              <th>ETS Datentyp</th>
              <th>Einheit</th>
              <th>Wert</th>
            </tr>
            <tr>
              <td>Adresse</td>
              <td><div class="tooltip"><input type="text" name="knx_address" value="{knx_address}" onblur="validateKNXAddress(this)"><span class="tooltiptext">Sample: 1.3.7</span></div></td>
            </tr>
            <tr>
              <td>Radon Live</td>
              <td><div class="tooltip"><input type="text" name="group_address_1" value="{group_address_1}" onblur="validateGroupAddress(this)"><span class="tooltiptext">Sample: 8/0/0</span></div></td>
              <td>12.001</td>
              <td>Bq/m&sup3;</td>
              <td id="radonLive">{tmb_radon_live_32bit}</td>
            </tr>
            <tr>
              <td>Radon 24h</td>
              <td><div class="tooltip"><input type="text" name="group_address_2" value="{group_address_2}" onblur="validateGroupAddress(this)"><span class="tooltiptext">Sample: 8/0/1</span></div></td>
              <td>12.001</td>
              <td>Bq/m&sup3;</td>
              <td id="radon24h">{tradon_mittelwert_24h}</td>
            </tr>
            <tr>
              <td>Radon Long</td>
              <td><div class="tooltip"><input type="text" name="group_address_3" value="{group_address_3}" onblur="validateGroupAddress(this)"><span class="tooltiptext">Sample: 8/0/2</span></div></td>
              <td>12.001</td>
              <td>Bq/m&sup3;</td>
              <td id="radonLong">{tradon_mittelwert_long}</td>
            </tr>
            <tr>
              <td>Laufzeit</td>
              <td><div class="tooltip"><input type="text" name="group_address_4" value="{group_address_4}" onblur="validateGroupAddress(this)"><span class="tooltiptext">Sample: 8/0/3</span></div></td>
              <td>7.001</td>
              <td>h</td>
              <td id="runTime">{tmb_radon_save_eintrarge}</td>
            </tr>
          </table>
          </div>
          <div class="table-container">
          <h2>Parameter</h2>
          <table>
            <tr>
              <th>Parameter</th>
              <th>Wert</th>
            </tr>
              <tr>
                <td>Sensor Bootzeit</td>
                <td>
                  <div class="tooltip">
                    <select name="sensor_boot_time">
                      <option value="0" {sensor_boot_time_0}>5 Sekunden</option>
                      <option value="1" {sensor_boot_time_1}>10 Sekunden</option>
                      <option value="2" {sensor_boot_time_2}>15 Sekunden</option>
                      <option value="3" {sensor_boot_time_3}>20 Sekunden</option>
                      <option value="4" {sensor_boot_time_4}>25 Sekunden</option>
                      <option value="5" {sensor_boot_time_5}>30 Sekunden</option>
                    </select>
                    <span class="tooltiptext">Standard: 20 Sekunden</span>
                  </div>
                </td>
              </tr>
              <tr>
                <td>Automatische &Uuml;bertragung</td>
                <td>
                  <div class="tooltip">
                    <select name="auto_transfer">
                      <option value="0" {auto_transfer_0}>Deaktiviert</option>
                      <option value="1" {auto_transfer_1}>1 Minute</option>
                      <option value="2" {auto_transfer_2}>10 Minuten</option>
                      <option value="3" {auto_transfer_3}>60 Minuten</option>
                    </select>
                    <span class="tooltiptext">Standard: Deaktiviert</span>
                  </div>
                </td>
              </tr>
          </table>
          </div>
          <div class="table-container">
          <h2>Netzwerkeinstellungen</h2>
          <table>
            <tr>
              <th>Bezeichnung</th>
              <th>Wert</th>
            </tr>
            <tr>
              <td>IP-Adresse</td>
              <td><div class="tooltip">  <input type="text" name="ip_address" value="{ip_address}" onblur="validateIPAddress(this)"><span class="tooltiptext">Sample: 192.168.178.194</span></div></td>
            </tr>
            <tr>
              <td>Subnetzmaske</td>
              <td><div class="tooltip">  <input type="text" name="subnet_mask" value="{subnet_mask}" onblur="validateIPAddress(this)"><span class="tooltiptext">Sample: 255.255.255.0</span></div></td>
            </tr>
            <tr>
              <td>Gateway</td>
              <td><div class="tooltip">  <input type="text" name="gateway" value="{gateway}" onblur="validateIPAddress(this)"><span class="tooltiptext">Sample: 192.168.178.1</span></div></td>
            </tr>
            <tr>
              <td>Multicast-Adresse</td>
              <td><div class="tooltip">  <input type="text" name="multicast_address" value="{multicast_address}" onblur="validateIPAddress(this)"><span class="tooltiptext">Standardwert: 224.0.23.12</span></div></td>
            </tr>
            </table>
            </div>

            <table>
              <th> </th>
              <th> </th>
            <tr>
              <td><b>KNX Status</b></td>

              <td><label class="switch">
              <input type="checkbox" name="knx_status" id="knxSwitch" {knx_status_checked}><span class="slider"></span>
              </label></td>
            </tr>
            </table>

                    <br> <br>
            
            <input type="submit" value="Speichern">
            </form>
            <br>
            <hr>
      <div class="table-container">
        <table class="status-table">
          <tr>
            <th>Status</th>
          </tr>
          <tr>
            <td>
              <div id="ledIndicator" style="width: 30px; height: 30px; background-color: gray; border-radius: 50%; margin: 0 auto;"></div>
            </td>
          </tr>
          <tr>
            <th>Programmiermodus</th>
          </tr>
          <tr>
            <td>
              <button type="button" onclick="toggleProgramMode()">Programmiermodus ein/aus</button>
            </td>
          </tr>
          <tr>
            <th>Aktion</th>
          </tr>
          <tr>
            <td>
              <button type="button" id="statusButton" onclick="sendDataToKNX()">Daten an KNX senden</button>
            </td>
          </tr>
        </table>
        <a href="/index" class="back-link">Zur&uuml;ck</a>
      </div>


            
            
            <div id="confirmationModal" style="display:none; position:fixed; top:50%; left:50%; transform:translate(-50%, -50%); background-color:#222; color:#fff; padding:20px; border-radius:5px; box-shadow:0 4px 8px rgba(0, 0, 0, 0.4); z-index:1000;">
              <p>Der Sensor wird neu gestartet. M&ouml;chten Sie fortfahren?</p>
              <button id="confirmButton">Ja</button>
              <button id="cancelButton">Nein</button>
            </div>
            <div id="modalOverlay" style="display:none; position:fixed; top:0; left:0; width:100%; height:100%; background-color:rgba(0, 0, 0, 0.5); z-index:999;"></div>
      </div></div>
            </body>

            </html>
            )rawliteral";

      #endif


      #ifndef Firmware_backup
      //  void webSocketEvent(    sendData()    const char sensor_html_template[]   handle_sensor()
      //  <script type="text/javascript" src="jquery.min.js"></script>
      const char sensor_html_template[] PROGMEM = R"rawliteral(
      <!DOCTYPE html>
      <html lang="de">
      <head>
        
        <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
        <meta charset="UTF-8">

        <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
        <meta http-equiv="Pragma" content="no-cache">
        <meta name='viewport' content='width=device-width, initial-scale=1'/>
        <meta name="author" content="Gebauer Holger, https://www.auto-steuerung.de/">
        <title>Radon Sensor {device_id}</title>
                
            <!--[if IE]>
              <script type="text/javascript" src="excanvas.js"></script>
            <![endif]-->

          


            <script type="text/javascript" src="segment-display.js"></script>
            <script type="text/javascript">

              window.onload = function() {
              // Überprüfe, ob die Seite bereits neu geladen wurde 
              if (!localStorage.getItem('reloaded')) { 
                localStorage.setItem('reloaded', 'true'); 
                location.reload(); 
                return;
              }

              function checkScriptLoaded() {
                if (typeof SegmentDisplay === 'undefined') {
                  console.error('segment-display.js konnte nicht geladen werden.');
                  setTimeout(checkScriptLoaded, 1000); // Erneuter Versuch nach 1 Sekunde
                } else {
                  initializeDisplay();
                }
              }

              var display = new SegmentDisplay("display");
              var radonValue = "0"; 
              display.pattern = "##:##";
              display.cornerType = 3;
              display.displayType = 7;
              display.displayAngle = 9;
              display.segmentCount = 7;
              display.digitHeight = 120; // 30% vergrößerte Höhe
              display.digitWidth = 60; // 30% vergrößerte Breite
              display.digitDistance = 30; // 30% vergrößerter Abstand zwischen den Ziffern
              display.segmentWidth = 14; // 30% vergrößerte Segmentbreite
              display.segmentDistance = 0.65; // 30% vergrößerte Segmentdistanz
              display.colorOn = "rgba(255, 255, 255, 0.9)"; // Weiß
              display.colorOff = "rgba(255, 255, 255, 0.05)"; // Leichtes Weiß

              var ws = new WebSocket('ws://' + window.location.hostname + ':81/');
              var isConnected = false;
              var currentImageStatus = -1; // Status des aktuellen Bildes verfolgen
              var colonVisible = true; // Doppelpunkt anzeigen
              var currentTime = ""; // Variable für die aktuelle Zeit
              var currentDisplayMode = "time"; // Variable zum Verfolgen des aktuellen Anzeigemodus

              // Automatisches Neuladen der Seite nach 20 Minuten
              setTimeout(function() {
                  console.error('-->Reload');
                  //location.reload();
              }, 1200000); // 1200000 Millisekunden = 20 Minuten

              // Funktion zur Überprüfung des Serverstatus
              let checkCounter = 0;

              function checkServerStatus() {
                fetch('/serverStatus')
                  .then(response => response.json())
                  .then(data => {
                    const statusBar = document.getElementById('status-bar');
                    if (data.serverRunning) {
                      statusBar.classList.add('green');
                      statusBar.classList.remove('red');
                      checkCounter = 0; // Setze den Zähler zurück, wenn der Server läuft
                    } else {
                      checkCounter++;
                      if (checkCounter >= 3) {
                        statusBar.classList.add('red');
                        statusBar.classList.remove('green');
                      }
                    }
                  })
                  .catch(error => {
                    checkCounter++;
                    const statusBar = document.getElementById('status-bar');
                    if (checkCounter >= 3) {
                      statusBar.classList.add('red');
                      statusBar.classList.remove('green');
                    }
                  });
              }

            function showNotification() {
              var notificationDiv = document.getElementById('notification');
              if (notificationDiv) {
                notificationDiv.style.display = 'block';
              } 
            }
            function showNotificationnone() {
              var notificationDiv = document.getElementById('notification');
              if (notificationDiv) {
                notificationDiv.style.display = 'none';
              } 
            }

              function updateStatus(status) {
                var statusArray = status.split(";");
                var elements = ["container-wifi", "container-ntp", "container-unit-de", "container-unit-en", "container-am", "container-pm"];
                for (var i = 0; i < elements.length; i++) {
                  var element = document.getElementById(elements[i]);
                  if (statusArray[i] === "1") {
                    element.style.display = "none"; // Element ausblenden 
                  } else {
                    element.style.display = "block"; // Element anzeigen
                  }
                }
              }


            ws.onmessage = function(event) {
              //console.log("Nachricht empfangen: ", event.data); 
              var data = event.data.split(":");
              var type = data[0];
              var value = data[1];

              if (type === "time") {
                if (value.trim() !== "") {
                  var hours = value.split(";")[0];
                  var minutes = value.split(";")[1];
                  currentTime = ((hours < 10) ? '0' : '') + hours + ':' + ((minutes < 10) ? '0' : '') + minutes;
                  currentDisplayMode = "time";
                  display.segmentCount = 7;
                  updateDisplay();
                  showNotificationnone();
                  //console.log("Empfangene Uhrzeit: " + currentTime);
                } else {
                  //console.log("Leerer Zeitwert empfangen, ignorieren.");
                }
              } else if (type === "radon") {
                var formattedValue = formatRadonValue(value);
                display.pattern = "##:##";
                display.segmentCount = 7;
                display.setValue(formattedValue);
                currentDisplayMode = "radon";
                showNotificationnone();
                //console.log("Empfangener Radonwert: " + formattedValue);
              } else if (type === "blue") {
                var formattedValue = formatRadonValue(value);
                display.pattern = "####";
                display.segmentCount = 14;
                display.setValue('-BT-');
                currentDisplayMode = "blue";
                showNotificationnone();
                //console.log("Empfangener Radonwert: " + formattedValue);
              } else if (type === "imageStatus") {
                var newImageStatus = parseInt(value, 10);
                if (newImageStatus !== currentImageStatus) {
                  currentImageStatus = newImageStatus;
                  updateImage(newImageStatus);
                }
              } else if (type === "status") {
                //console.log("Status-Überprüfung erfolgreich"); // Neue Debugging-Nachricht
                updateStatus(value);
              
              } else if (type === "user") {
                //console.log("User-Überprüfung erfolgreich"); // Neue Debugging-Nachricht
                showNotification(); // Rufe die Funktion auf, um das DIV sichtbar zu machen
              
              } else if (type === "dpStatus") {
                colonVisible = (value === "1"); 
                updateDisplay();

              } else if (type === "knx") {
                  //console.log("Empfangene KNX-Adresse: \"" + value + "\"");
                  var addressParts = value.split("/");
                  var area = parseInt(addressParts[0], 10);
                  var line = parseInt(addressParts[1], 10);
                  var device = parseInt(addressParts[2], 10);

                  //area = 5;
                  //line = 12;
                  //device = 4;

                  //console.log("Area: \"" + area + "\"");
                  //console.log("Line: \"" + line + "\"");
                  //console.log("Device: \"" + device + "\"");

                  var combinedLength = area.toString().length + line.toString().length + device.toString().length;
                
                  if (combinedLength > 4) {
                      if (device.toString().length == 1) {
                          formattedAddress = "   ." + device;
                          display.pattern = "###.#";
                      } else if (device.toString().length == 2) {
                          formattedAddress = "  ." + device;
                          display.pattern = "##.##";
                      } else if (device.toString().length == 3) {
                          formattedAddress = " ." + device;
                          display.pattern = "#.###";
                      } else {
                          formattedAddress = "." + device;
                          display.pattern = ".####";
                      }
                  } else {
                      if (combinedLength === 3) {
                          formattedAddress = " " + area + "." + line + "." + device;
                          display.pattern = " ##.#.#";
                      } else {
                          formattedAddress = area + "." + line + "." + device;
                          if (area.toString().length === 2) {
                              display.pattern = "##.#.#";
                          } else if (line.toString().length === 2) {
                              display.pattern = "#.##.#";
                          } else if (device.toString().length === 2) {
                              display.pattern = "#.#.##";
                          }
                      }
                  }

                  //console.log("Formatted Address: \"" + formattedAddress + "\"");
                  //console.log("Display Pattern: \"" + display.pattern + "\"");

                  currentKNXAddress = formattedAddress; // Speichere die KNX-Adresse
                  currentDisplayMode = "knx";
                  //updateDisplay();
                  display.setValue(formattedAddress);
                  showNotificationnone();
                  //console.log("KNX-Adresse im Display: \"" + formattedAddress + "\"");
              } else if (type === "imageStatus") {
                var newImageStatus = parseInt(value, 10);
                if (newImageStatus !== currentImageStatus) {
                  currentImageStatus = newImageStatus;
                  updateImage(newImageStatus);
                }
              } else if (type === "status") {
                //console.log("Status-Überprüfung erfolgreich");
                updateStatus(value);
              } else if (type === "dpStatus") {
                colonVisible = (value === "1");
                updateDisplay();
              } else {
                //console.log("Die Nachricht hat die Bedingung nicht erfüllt");
              }
            };



              function formatRadonValue(value) {
                switch (value.length) {
                  case 1:
                    return "   " + value + " ";
                  case 2:
                    return "   " + value;
                  case 3:
                    return "  " + value.slice(0, 1) + " " + value.slice(1);
                  case 4:
                    return value.slice(0, 2) + " " + value.slice(2);
                  default:
                    return value;
                }
              }

              ws.onopen = function() {
                console.log("WebSocket-Verbindung geöffnet.");
                isConnected = true;
                ws.send("getImageStatus");
              };

              ws.onclose = function() {
                console.log("WebSocket-Verbindung geschlossen.");
                isConnected = false;
              };

              // Optional: Event listener für Fehlersituationen hinzufügen
              ws.onerror = function(error) {
                isConnected = false;
                console.log('WebSocket-Fehler:', error);
              };

              // Funktion, um das Bild basierend auf dem neuen Status zu aktualisieren
              function updateImage(status) {
                var imageUrl;
                switch (status) {
                  case 0:
                    imageUrl = "/Sensor_rot.jpg";
                    break;
                  case 1:
                    imageUrl = "/Sensor_gruen.jpg";
                    break;
                  case 2:
                    imageUrl = "/Sensor_orange.jpg";
                    break;
                  case 3:
                    imageUrl = "/Sensor_weiss.jpg";
                    break;
                  case 4:
                    imageUrl = "/Sensor_grau.jpg";
                    break;
                  case 5:
                    imageUrl = "/Sensor_blau.jpg";
                    break;
                  default:
                    imageUrl = "/Sensor_grau.jpg";
                    break;
                }
                console.log("Lade Bild: " + imageUrl); // Protokolliere das zu ladende Bild
                document.getElementById('sensorImage').src = imageUrl;
              }

              function setPosition(containerId, top, left) {
                var container = document.getElementById(containerId);
                container.style.top = top + "px";
                container.style.left = left + "px";
              }

              function updateDisplay() {
                if (currentDisplayMode === "time") {
                  var displayValue = currentTime;
                  if (!colonVisible) {
                    displayValue = displayValue.replace(':', ' '); // Ersetze ':' durch Leerzeichen
                  }
                  display.setValue(displayValue); // Aktualisiere die Anzeige
                  //console.log("Uhr Anzeige: " + displayValue); 
                }
                

                setPosition("container-wifi", 112, 140);
                setPosition("container-ntp", 112, 162);
                setPosition("container-unit-de", 112, 180);
                
                setPosition("container-am", 132, 145);
                setPosition("container-pm", 132, 163);
                setPosition("container-unit-en", 132, 180);
              }

              // Starte die Überprüfung des Serverstatus und die Aktualisierung der Werte
              checkServerStatus();
              setInterval(checkServerStatus, 5000); // Überprüft den Serverstatus alle 5 Sekunden
              ws.send("getImageStatus");
              setInterval(function() {
                ws.send("getImageStatus");
              }, 30000); // Aktualisiere die Bildwerte alle 30 Sekunden

            };
            </script>



          <style>
            body {
                background-color: black; /* Hintergrund Schwarz */
                display: flex;
                justify-content: center;
                align-items: flex-start; /* Elemente nach oben ausrichten */
                height: 100vh;
                margin: 0;
                padding-top: 10px; /* Abstand vom oberen Rand verringert */
            }
            .container {
                position: relative;
                position: fixed; /* Fixiert den Container */
                max-width: 350px; /* Maximale Breite des Containers */
                height: auto;
            }
            .display-container {
                position: absolute;
                top: 115px; /* Abstand vom oberen Rand */
                left: 50%;
                transform: translateX(-50%);
                width: 250px; 
                height: 120px; /
            }
            .image-container {
                width: 100%;
                height: auto;
            }
            .image-container img {
                width: 100%;
                height: auto;
            }
            #status-bar {
              width: 100%;
              height: 10px;
              position: fixed;
              top: 0;
              left: 0;
            }
            .green {
              background-color: #28a745; /* Grün */
            }
            .red {
              background-color: #dc3545; /* Rot */
            }

            #notification {
              display: none;
              color: black;
              font-weight: bold;
              border: 2px solid red;
              padding: 10px;
              margin: 10px 0;
              text-align: center;
              position: relative;
              z-index: 9999;
              background-color: rgba(255, 0, 0, 0.5); /* Roter, transparenter Hintergrund */
            }



            .back-link {
              display: block;
              margin: 10px auto;
              color: #888; /* Ändere die Textfarbe zu Grau */
              text-decoration: none;
              font-weight: bold;
              font-size: 1.2em;
              border: 2px solid #888; /* Ändere die Rahmenfarbe zu Grau */
              padding: 10px;
              border-radius: 5px;
              width: 110px;  
              background-color: #333; /* Ändere die Hintergrundfarbe zu einem dunkleren Grau */
              box-shadow: 0 4px 8px rgba(0, 0, 0, 0.4);
              text-align: center; 
            }
            .back-link:hover {
              text-decoration: underline;
              background-color: #555; /* Ändere die Hover-Hintergrundfarbe zu einem helleren Grau */
              color: #fff; /* Ändere die Hover-Textfarbe zu Weiß */
              box-shadow: 0 8px 16px rgba(0, 0, 0, 0.8);
            }



              .hidden-container {
                  position: absolute;
                  background-color: black; /* Gelbe Farbe für bessere Sichtbarkeit */
                  z-index: 10; /* Stelle sicher, dass sie über allen anderen Elementen liegen */
                  display: block; /* Container einblenden */
                  opacity: 0.93; /* Leicht transparent */
              }

              /* Individuelle Größen für jede Box */
              #container-wifi {
                  width: 30px;
                  height: 18px;
              }

              #container-ntp {
                  width: 22px;
                  height: 18px;
              }

              #container-unit-de {
                  width: 70px;
                  height: 18px;
              }

              #container-unit-en {
                  width: 70px;
                  height: 25px;
              }

              #container-am {
                  width: 18px;
                  height: 25px;
              }

              #container-pm {
                  width: 20px;
                  height: 25px;
              }



          </style>
          </head>
            <body>
              <div id="status-bar" class="green"></div>
              <div id="notification">Datenübertragung gestoppt: Mehrere Benutzer auf dem Webserver verbunden.</div>
              <div class="container">
                <div class="display-container">
                  <canvas id="display" width="250" height="120"></canvas>
                  <div class="hidden-container" id="container-wifi"></div>
                  <div class="hidden-container" id="container-ntp"></div>
                  <div class="hidden-container" id="container-unit-de"></div>
                  <div class="hidden-container" id="container-unit-en"></div>
                  <div class="hidden-container" id="container-am"></div>
                  <div class="hidden-container" id="container-pm"></div>
                </div>
                <div class="image-container">
                  <img id="sensorImage" src="{sensorImage}" alt="Sensor Vorderansicht">
                </div>
                <br>
                <a href="/index" class="back-link">Zur&uuml;ck</a>
              </div>
            </body>


          </html>


      )rawliteral";
      #endif






      #ifndef Firmware_backup
          const char modbus_html_template[] PROGMEM = R"rawliteral(
              <!DOCTYPE html>
              <html>
              <head>
                <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
                <meta charset="UTF-8">
                <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
                <meta http-equiv="Pragma" content="no-cache">
                <meta name='viewport' content='width=device-width, initial-scale=1'/>
                <meta name="author" content="Gebauer Holger, https://www.auto-steuerung.de/">
                  <title>Modbus Dashboard {device_id}</title>
              <style>
                    #status-bar {
                      width: 100%;
                      height: 10px;
                      position: fixed;
                      top: 0;
                      left: 0;
                    }
                  .led-bar-off {
                      width: 80%;
                      height: 10px;
                      border: 1px solid darkgray; 
                      background-color: transparent; 
                      display: block;
                      margin: 0 auto 10px auto; 
                  }
                    .led-on {
                        border: 1px solid lightgrey;
                        background-color: lightgreen; 
                    }
              .bar {
                  width: 80%;
                  height: 20px; /* Doppelte Höhe */
                  border: 1px solid darkgray; 
                  background-color: transparent; 
                  display: block;
                  margin: 10px auto;
                  position: relative;
                  text-align: center; /* Text zentriert */
                  line-height: 20px; /* Vertikale Zentrierung */
                  font-weight: bold;
                  color: white;
              }

              .bar-green {
                  background-color: green;
              }

              .bar-orange {
                  background-color: orange;
              }

              .bar-red {
                  background-color: red;
              }




                    .green {
                      background-color: #28a745; /* Grün */
                    }
                    .red {
                      background-color: #dc3545; /* Rot */
                    }

                    html, body { 
                      font-family: Arial, sans-serif; 
                      text-align: center; 
                      padding: 15px 6px; 
                      background-color: black; 
                      color: white; 
                      width: 94%;
                    }
                    h1 { color: #fff; }
                    p { color: #ccc; }
                    a {
                      display: block;
                      margin: 10px auto;
                      color: #007BFF;
                      text-decoration: none;
                      font-weight: bold;
                      font-size: 1.2em;
                      border: 2px solid #007BFF;
                      padding: 10px;
                      border-radius: 5px;
                      width: 300px;
                      background-color: #222;
                      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.4);
                    }
                    a:hover {
                      text-decoration: underline;
                      background-color: #007BFF;
                      color: white;
                      box-shadow: 0 8px 16px rgba(0, 0, 0, 0.8);
                    }
                  .container {
                    display: flex;
                    justify-content: center;
                    align-items: flex-start;
                    min-height: 100vh;
                    padding: 10px;
                    margin: 0 auto;
                  }

                  .form-container {
                    width: 100%;
                    max-width: 800px; /* Du kannst die Breite anpassen */
                    padding: 20px;
                    background-color: #222;
                    border: 1px solid #ddd;
                    border-radius: 8px;
                    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
                    margin: 0 auto;
                  }

                    .back-link {
                      display: block;
                      margin: 10px auto;
                      color: #007BFF;
                      text-decoration: none;
                      font-weight: bold;
                      font-size: 1.2em;
                      border: 2px solid #007BFF;
                      padding: 10px;
                      border-radius: 5px;
                      width: 110px; 
                      background-color: #222;
                      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.4);
                      text-align: center; 
                    }
                    .back-link:hover {
                      text-decoration: underline;
                      background-color: #007BFF;
                      color: white;
                      box-shadow: 0 8px 16px rgba(0, 0, 0, 0.8);
                    }

                    table {
                      margin: 20px auto;
                      border-collapse: collapse;
                      width: 80%;
                      background-color: #222;
                      color: white;
                    }
                    th, td {
                      border: 1px solid #777;
                      padding: 10px;
                      text-align: center;
                    }
                    th {
                      background-color: #0056b3;
                    }

                    input[type="text"], input[type="password"] {
                      width: 100%;
                      padding: 8px;
                      margin: 5px 0;
                      box-sizing: border-box;
                      border: none;
                      background-color: #333;
                      color: white;
                    }
                    input[type="submit"] {
                      width: auto;
                      padding: 8px 16px;
                      background-color: #007BFF;
                      color: white;
                      border: none;
                      border-radius: 5px;
                      cursor: pointer;
                    }
                    input[type="submit"]:hover {
                      background-color: #0056b3;
                    }

                    /* Tooltip-Stil */
                    .tooltip {
                      position: relative;
                      display: inline-block;
                    }
                    .tooltip .tooltiptext {
                      visibility: hidden;
                      width: 160px;
                      background-color: #666;
                      color: #fff;
                      text-align: center;
                      border-radius: 5px;
                      padding: 5px;
                      position: absolute;
                      z-index: 1;
                      bottom: 125%; /* Positioniert den Tooltip oberhalb des Textfelds */
                      left: 50%;
                      margin-left: -60px;
                      opacity: 0;
                      transition: opacity 0.3s;
                    }
                    .tooltip:hover .tooltiptext {
                      visibility: visible;
                      opacity: 1;
                    }

                    .switch {
                      position: relative;
                      display: inline-block;
                      width: 60px;
                      height: 30px;
                    }
                    .switch input {
                      opacity: 0;
                      width: 0;
                      height: 0;
                    }
                    .slider {
                      position: absolute;
                      cursor: pointer;
                      top: 0;
                      left: 0;
                      right: 0;
                      bottom: 0;
                      background-color: #ccc;
                      transition: .4s;
                    }
                    .slider:before {
                      position: absolute;
                      content: "";
                      height: 24px;
                      width: 24px;
                      left: 3px;
                      bottom: 3px;
                      background-color: white;
                      transition: .4s;
                    }
                    input:checked + .slider {
                      background-color: #2196F3;
                    }
                    input:checked + .slider:before {
                      transform: translateX(26px);
                    }
                    .slider:after {
                      content: 'OFF';
                      color: white;
                      display: block;
                      position: absolute;
                      transform: translate(-50%,-50%);
                      top: 50%;
                      left: 70%;
                      font-size: 10px;
                      font-family: Verdana, sans-serif;
                    }
                    input:checked + .slider:after {
                      left: 25%;
                      content: 'ON';
                    }
                    .led-off {
                        width: 20px;
                        height: 20px;
                        background-color: grey;
                        border-radius: 50%;
                        display: inline-block;
                    }

                    .led-on {
                        background-color: green;
                    }


                    @media (max-width: 800px) {
                      .container {
                        width: 100%;
                        padding: 0;
                        margin: 0;
                      }

                      .form-container {
                        width: 100%;
                        max-width: none;
                        padding: 10px;
                        margin: 0;
                      }

                      .form-table {
                        width: 95%;
                        margin: 0;
                      }
                    }


                  </style>

      <script>
          let isNavigating = false;

          // Setze den Indikator beim Seitenwechsel innerhalb der Anwendung
          document.querySelectorAll('a').forEach(function(anchor) {
              anchor.addEventListener('click', function(event) {
                  isNavigating = true;
              });
          });

          // Überprüfe Sichtbarkeitswechsel des Dokuments
          document.addEventListener('visibilitychange', function() {
              if (document.visibilityState === 'hidden' && !isNavigating && isConnected) {
                  console.log('Sending browser_closed message via visibilitychange');
                  ws.send('browser_closed');
                  setTimeout(() => ws.close(), 100);  // Verzögerung hinzugefügt
              }
          });

          window.addEventListener('unload', function(event) {
              if (!isNavigating && isConnected) {
                  console.log('Sending browser_closed message via unload');
                  ws.send('browser_closed');
              }
          });

          let checkCounter = 0;

          function checkServerStatus() {
              fetch('/serverStatus')
                  .then(response => response.json())
                  .then(data => {
                      const statusBar = document.getElementById('status-bar');
                      if (data.serverRunning) {
                          statusBar.classList.add('green');
                          statusBar.classList.remove('red');
                          checkCounter = 0; // Reset the counter if the server is running
                      } else {
                          checkCounter++;
                          if (checkCounter >= 3) {
                              statusBar.classList.add('red');
                              statusBar.classList.remove('green');
                          }
                      }
                  })
                  .catch(error => {
                      checkCounter++;
                      const statusBar = document.getElementById('status-bar');
                      if (checkCounter >= 3) {
                          statusBar.classList.add('red');
                          statusBar.classList.remove('green');
                      }
                  });
          }

          function checkPassword() {
              const password = prompt('Bitte Passwort eingeben:');
              return fetch('/checkPassword', {
                  method: 'POST',
                  headers: { 'Content-Type': 'application/json' },
                  body: JSON.stringify({ password: password })
              })
              .then(response => response.json())
              .then(data => {
                  if (!data.success) {
                      alert('Falsches Passwort');
                      return false;
                  }
                  return true;
              })
              .catch(error => {
                  console.error('Error checking password:', error);
                  return false;
              });
          }

          function confirmReboot(confirm) {
              document.getElementById('confirmationModal').style.display = 'none';
              document.getElementById('modalOverlay').style.display = 'none';

              if (confirm) {
                  checkPassword().then(success => {
                      if (success) {
                          document.querySelector('form').submit();  // Führt das Speichern durch, wenn das Passwort korrekt ist
                      }
                  });
              }
          }

          var ws = new WebSocket('ws://' + window.location.hostname + ':81/');
          var isConnected = false;

          ws.onopen = function() {
              isConnected = true;
              console.log('WebSocket connection established');
          };

          ws.onclose = function(event) {
              isConnected = false;
              console.log('WebSocket connection closed', event);
          };

          ws.onerror = function(error) {
              isConnected = false;
              console.log('WebSocket error:', error);
          };

          ws.onmessage = function(event) {
              try {
                  var data = JSON.parse(event.data);

                  if (data.ledOn) {
                      var connectLed = document.getElementById('connectLed');
                      if (connectLed) {
                          connectLed.classList.add('led-on');
                          setTimeout(function() {
                              connectLed.classList.remove('led-on');
                          }, 500); // LED leuchtet für 500ms
                      } else {
                          console.error('connectLed Element nicht gefunden');
                      }
                  }

                  if (data.projectedRequestsTCP !== undefined) {
                      updateTcpDataBar(data.projectedRequestsTCP);
                  }
              } catch (e) {
                  console.error('Fehler beim Verarbeiten der WebSocket-Nachricht:', e);
              }
          };

          function updateTcpDataBar(projectedRequestsTCP) {
              var tcpDataBar = document.getElementById('tcpDataBar');
              if (tcpDataBar) {
                  tcpDataBar.className = 'bar';  // Setze die Basis-Klasse

                  if (projectedRequestsTCP < 360) {  // Weniger als 180=20sec.
                      tcpDataBar.classList.add('bar-green');
                  } else if (projectedRequestsTCP < 720) {  //1860=10sec.     960=20sec.     720=30sec
                      tcpDataBar.classList.add('bar-orange');
                  } else {  // Größer als 5.5 KB
                      tcpDataBar.classList.add('bar-red');
                  }

                  var kbValue = Math.round(projectedRequestsTCP);
                  tcpDataBar.innerHTML = kbValue + ' Requests/h';
              }
          }

          window.onload = function() {
              checkServerStatus();
              setInterval(checkServerStatus, 5000); // Überprüft den Serverstatus alle 5 Sekunden

              const form = document.querySelector('form');
              if (form) {
                  form.onsubmit = function(event) {
                      event.preventDefault();  // Verhindert das Standardverhalten des Formulars
                      document.getElementById('confirmationModal').style.display = 'block';
                      document.getElementById('modalOverlay').style.display = 'block';
                  };
              } else {
                  console.error('Formular nicht gefunden');
              }
          };
      </script>




              </head>
              <body>
                  <div id="status-bar" class="green"></div>
                  <div class="container">
                  <div class="form-container">
                    <h1>Modbus Einstellungen</h1>
          <div id="connectLed" class="led-bar-off"></div>
          <div id="tcpDataBar" class="bar"></div>
                    <table>
                      <tr>
                        <th>Bezeichnung</th>
                        <th>Wert</th>
                      </tr>
                      <tr>
                        <td>Modbus-Adresse</td>
                        <td>1</td>
                      </tr>
                      <tr>
                        <td>Timeout</td>
                        <td>500 ms</td>
                      </tr>
                      <tr>
                        <td>Port</td>
                        <td>502</td>
                      </tr>
                      <tr>
                        <td>IP-Adresse</td>
                        <td>{ip_address}</td>
                      </tr>
                    </table>
                    <br>
                    <h2>Registerwerte</h2>
                    <table>
                      <tr>
                        <th>Adresse</th>
                        <th>Typ [R]</th>
                        <th>Einheit</th>
                        <th>Bez.</th>
                        <th>Wert</th>
                      </tr>
                      <tr>
                        <td>20</td>
                        <td>03</td>
                        <td>32bit</td>
                        <td>Radon live</td>
                        <td>{mb_radon_live_32bit}</td>
                      </tr>
                      <tr>
                        <td>22</td>
                        <td>03</td>
                        <td>32bit</td>
                        <td>Radon 24h</td>
                        <td>{radon_mittelwert_24h}</td>
                      </tr>
                      <tr>
                        <td>24</td>
                        <td>03</td>
                        <td>32bit</td>
                        <td>Radon long</td>
                        <td>{radon_mittelwert_long}</td>
                      </tr>
                    </table>
                    <br>
                    <a href="/index" class="back-link">Zurück</a>

                    <div id="confirmationModal" style="display:none; position:fixed; top:50%; left:50%; transform:translate(-50%, -50%); background-color:#222; color:#fff; padding:20px; border-radius:5px; box-shadow:0 4px 8px rgba(0, 0, 0, 0.4); z-index:1000;">
                      <p>Der Sensor wird neu gestartet. Möchten Sie fortfahren?</p>
                      <button onclick="confirmReboot(true)">Ja</button>
                      <button onclick="confirmReboot(false)">Nein</button>
                    </div>
                    <div id="modalOverlay" style="display:none; position:fixed; top:0; left:0; width:100%; height:100%; background-color:rgba(0, 0, 0, 0.5); z-index:999;"></div>
                </div></div>
              </body>
              </html>
          )rawliteral";
      #endif









      #ifndef Firmware_backup

              const char cloud_html_template[] PROGMEM = R"rawliteral(
              <!DOCTYPE html>
              <html>
              <head>
                <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
                <meta charset="UTF-8">
                <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
                <meta http-equiv="Pragma" content="no-cache">
                <meta name='viewport' content='width=device-width, initial-scale=1'/>
                <meta name="author" content="Gebauer Holger, https://www.auto-steuerung.de/">

                <title>Cloud {device_id}</title>
                
                    
                  <style>
                    #status-bar {
                      width: 100%;
                      height: 10px;
                      position: fixed;
                      top: 0;
                      left: 0;
                    }
                    .green {
                      background-color: #28a745; /* Grün */
                    }
                    .red {
                      background-color: #dc3545; /* Rot */
                    }

                    html, body { 
                      font-family: Arial, sans-serif; 
                      text-align: center; 
                      padding: 15px 6px; 
                      background-color: black; 
                      color: white; 
                      width: 94%;
                    }
                    h1 { color: #fff; }
                    p { color: #ccc; }
                    a {
                      display: block;
                      margin: 10px auto;
                      color: #007BFF;
                      text-decoration: none;
                      font-weight: bold;
                      font-size: 1.2em;
                      border: 2px solid #007BFF;
                      padding: 10px;
                      border-radius: 5px;
                      width: 300px;
                      background-color: #222;
                      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.4);
                    }
                    a:hover {
                      text-decoration: underline;
                      background-color: #007BFF;
                      color: white;
                      box-shadow: 0 8px 16px rgba(0, 0, 0, 0.8);
                    }
                  .container {
                    display: flex;
                    justify-content: center;
                    align-items: flex-start;
                    min-height: 100vh;
                    padding: 10px;
                    margin: 0 auto;
                  }

                  .form-container {
                    width: 100%;
                    max-width: 800px; /* Du kannst die Breite anpassen */
                    padding: 20px;
                    background-color: #222;
                    border: 1px solid #ddd;
                    border-radius: 8px;
                    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
                    margin: 0 auto;
                  }

                    .back-link {
                      display: block;
                      margin: 10px auto;
                      color: #007BFF;
                      text-decoration: none;
                      font-weight: bold;
                      font-size: 1.2em;
                      border: 2px solid #007BFF;
                      padding: 10px;
                      border-radius: 5px;
                      width: 110px; 
                      background-color: #222;
                      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.4);
                      text-align: center; 
                    }
                    .back-link:hover {
                      text-decoration: underline;
                      background-color: #007BFF;
                      color: white;
                      box-shadow: 0 8px 16px rgba(0, 0, 0, 0.8);
                    }

                    table {
                      margin: 20px auto;
                      border-collapse: collapse;
                      width: 80%;
                      background-color: #222;
                      color: white;
                    }
                    th, td {
                      border: 1px solid #777;
                      padding: 10px;
                      text-align: center;
                    }
                    th {
                      background-color: #0056b3;
                    }

              .form-table {
                  width: 96%; 
                  margin: auto; 

                    max-width: 6080px;
                    margin: auto;
                    background-color: #f9f9f9;
                    border: 1px solid #ddd;
                    padding: 20px;
                    border-radius: 8px;
                    color: black; 
                }

                  .form-table td {
                    padding: 10px;
                  }
                  .form-table input[type="date"],
                  .form-table input[type="time"],
                  .form-table select {
                    width: 100%;
                    padding: 10px;
                    border: 1px solid #ccc;
                    border-radius: 4px;
                    box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.1);
                    text-align: center; 
                    font-size: 16px;
                    -webkit-appearance: none; 
                  }
                  .form-table th, .form-table td {
                    text-align: left;
                  }
                  .form-table th {
                    background-color: #f1f1f1;
                    padding: 10px;
                  }

                    input[type="text"], input[type="password"] {
                      width: 100%;
                      padding: 8px;
                      margin: 5px 0;
                      box-sizing: border-box;
                      border: none;
                      background-color: #333;
                      color: white;
                    }
                    input[type="submit"] {
                      width: auto;
                      padding: 8px 16px;
                      background-color: #007BFF;
                      color: white;
                      border: none;
                      border-radius: 5px;
                      cursor: pointer;
                    }
                    input[type="submit"]:hover {
                      background-color: #0056b3;
                    }
                    .wide-input {
                      width: 240px !important;
                    }

                    /* Tooltip-Stil */
                    .tooltip {
                      position: relative;
                      display: inline-block;
                    }
                    .tooltip .tooltiptext {
                      visibility: hidden;
                      width: 160px;
                      background-color: #666;
                      color: #fff;
                      text-align: center;
                      border-radius: 5px;
                      padding: 5px;
                      position: absolute;
                      z-index: 1;
                      bottom: 125%; /* Positioniert den Tooltip oberhalb des Textfelds */
                      left: 50%;
                      margin-left: -60px;
                      opacity: 0;
                      transition: opacity 0.3s;
                    }
                    .tooltip:hover .tooltiptext {
                      visibility: visible;
                      opacity: 1;
                    }

                    .switch {
                      position: relative;
                      display: inline-block;
                      width: 60px;
                      height: 30px;
                    }
                    .switch input {
                      opacity: 0;
                      width: 0;
                      height: 0;
                    }
                    .slider {
                      position: absolute;
                      cursor: pointer;
                      top: 0;
                      left: 0;
                      right: 0;
                      bottom: 0;
                      background-color: #ccc;
                      transition: .4s;
                    }
                    .slider:before {
                      position: absolute;
                      content: "";
                      height: 24px;
                      width: 24px;
                      left: 3px;
                      bottom: 3px;
                      background-color: white;
                      transition: .4s;
                    }
                    input:checked + .slider {
                      background-color: #2196F3;
                    }
                    input:checked + .slider:before {
                      transform: translateX(26px);
                    }
                    .slider:after {
                      content: 'OFF';
                      color: white;
                      display: block;
                      position: absolute;
                      transform: translate(-50%,-50%);
                      top: 50%;
                      left: 70%;
                      font-size: 10px;
                      font-family: Verdana, sans-serif;
                    }
                    input:checked + .slider:after {
                      left: 25%;
                      content: 'ON';
                    }
          @media (max-width: 800px) {
            .container {
              width: 100%;
              padding: 0;
              margin: 0;
            }

            .form-container {
              width: 100%;
              max-width: none;
              padding: 10px;
              margin: 0;
            }

            .form-table {
              width: 95%;
              margin: 0;
            }
          }


                  </style>



      <script>
          let isNavigating = false;

          // Setze den Indikator beim Seitenwechsel innerhalb der Anwendung
          document.querySelectorAll('a').forEach(function(anchor) {
              anchor.addEventListener('click', function(event) {
                  isNavigating = true;
              });
          });

          // Überprüfe Sichtbarkeitswechsel des Dokuments
          document.addEventListener('visibilitychange', function() {
              if (document.visibilityState === 'hidden' && !isNavigating && isConnected) {
                  console.log('Sending browser_closed message via visibilitychange');
                  ws.send('browser_closed');
                  setTimeout(() => ws.close(), 100);  // Verzögerung hinzugefügt
              }
          });

          window.addEventListener('unload', function(event) {
              if (!isNavigating && isConnected) {
                  console.log('Sending browser_closed message via unload');
                  ws.send('browser_closed');
              }
          });

          let checkCounter = 0;

          function checkServerStatus() {
              fetch('/serverStatus')
                  .then(response => response.json())
                  .then(data => {
                      const statusBar = document.getElementById('status-bar');
                      if (data.serverRunning) {
                          statusBar.classList.add('green');
                          statusBar.classList.remove('red');
                          checkCounter = 0; // Reset the counter if the server is running
                      } else {
                          checkCounter++;
                          if (checkCounter >= 3) {
                              statusBar.classList.add('red');
                              statusBar.classList.remove('green');
                          }
                      }
                  })
                  .catch(error => {
                      checkCounter++;
                      const statusBar = document.getElementById('status-bar');
                      if (checkCounter >= 3) {
                          statusBar.classList.add('red');
                          statusBar.classList.remove('green');
                      }
                  });
          }

          function checkPassword() {
              const password = prompt('Bitte Passwort eingeben:');
              return fetch('/checkPassword', {
                  method: 'POST',
                  headers: {
                      'Content-Type': 'application/json'
                  },
                  body: JSON.stringify({ password: password })
              })
              .then(response => response.json())
              .then(data => {
                  if (!data.success) {
                      alert('Falsches Passwort');
                      return false;
                  }
                  return true;
              })
              .catch(error => {
                  console.error('Error checking password:', error);
                  return false;
              });
          }

          function confirmReboot(confirm) {
              document.getElementById('confirmationModal').style.display = 'none';
              document.getElementById('modalOverlay').style.display = 'none';

              if (confirm) {
                  checkPassword().then(success => {
                      if (success) {
                          document.querySelector('form').submit();  // Führt das Speichern durch, wenn das Passwort korrekt ist
                      }
                  });
              }
          }

          var ws = new WebSocket('ws://' + window.location.hostname + ':81/');
          var isConnected = false;

          ws.onopen = function() {
              isConnected = true;
              console.log('WebSocket connection established');
          };

          ws.onclose = function(event) {
              isConnected = false;
              console.log('WebSocket connection closed', event);
          };

          ws.onerror = function(error) {
              isConnected = false;
              console.log('WebSocket error:', error);
          };

          window.onload = function() {
              checkServerStatus();
              setInterval(checkServerStatus, 5000); // Überprüft den Serverstatus alle 5 Sekunden

              const form = document.querySelector('form');
              form.onsubmit = function(event) {
                  event.preventDefault();  // Verhindert das Standardverhalten des Formulars
                  document.getElementById('confirmationModal').style.display = 'block';
                  document.getElementById('modalOverlay').style.display = 'block';
              };
          };
      </script>


              </head>

              <body>
                <div id="status-bar" class="green"></div>
              <div class="container">
              <div class="form-container">
                <h1>Cloud Funktionen</h1>
                <form method="POST" action="/save_cloud_settings">
                  <table class="form-table">

                    <tr>
                      <td><b>Server</b></td>
                      <td><div class="tooltip"><input type="text" name="cloud_server" maxlength="40" value="{cloud_server}" class="wide-input"><span class="tooltiptext">Standardwert: server.example.com</span></div></td>
                    </tr>
                    <tr>
                      <td><b>PHP-Seite</b></td>
                      <td><div class="tooltip"><input type="text" name="cloud_page" maxlength="80" value="{cloud_page}" class="wide-input"><span class="tooltiptext">Standardwert: /path/to/php</span></div></td>
                    </tr>
                    <tr>
                      <td><b>Pr&auml;fix</b></td>
                      <td><div class="tooltip"><input type="text" name="cloud_pre" maxlength="40" value="{cloud_pre}" class="wide-input"><span class="tooltiptext">Standardwert: submit=Daten</span></div></td>
                    </tr>
                    <tr>
                      <td><b>Zeichenkette</b></td>
                      <td><div class="tooltip"><input type="text" name="cloud_chain" maxlength="40" value="{cloud_chain}" class="wide-input"><span class="tooltiptext">Standardwert: &p</span></div></td>
                    </tr>
                    <tr>
                      <td><b>Cloud Status</b></td>
                      <td>
                        <label class="switch">
                          <input type="checkbox" name="cloud_status" id="cloudSwitch" {cloud_status_checked}>
                          <span class="slider"></span>
                        </label>
                      </td>
                    </tr>
                  </table>
                  <br>
                  <input type="submit" value="Speichern">
                </form>
                <br>
                <a href="/index" class="back-link">Zur&uuml;ck</a>

                <div id="confirmationModal" style="display:none; position:fixed; top:50%; left:50%; transform:translate(-50%, -50%); background-color:#222; color:#fff; padding:20px; border-radius:5px; box-shadow:0 4px 8px rgba(0, 0, 0, 0.4); z-index:1000;">
                  <p>Der Sensor wird neu gestartet. M&ouml;chten Sie fortfahren?</p>
                  <button onclick="confirmReboot(true)">Ja</button>
                  <button onclick="confirmReboot(false)">Nein</button>
                </div>
                <div id="modalOverlay" style="display:none; position:fixed; top:0; left:0; width:100%; height:100%; background-color:rgba(0, 0, 0, 0.5); z-index:999;"></div>
            </div></div>
              </body>

              </html>
              )rawliteral";

      #endif


      //  deinPasswort2
      #ifndef Firmware_backup
      String generateHTML() {
        String customZoneOptions = generateCustomZoneOptions();
        String firstDropdownOptions = generateFirstDropdownOptions();
        // String timezoneOptions = generateTimezoneOptions(); // Nicht mehr nötig
        String html = R"rawliteral(
          <!DOCTYPE html>
          <html>
          <head>
            <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
            <meta charset="UTF-8">
            <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
            <meta http-equiv="Pragma" content="no-cache">
            <meta name='viewport' content='width=device-width, initial-scale=1'/>
            <meta name="author" content="Gebauer Holger, https://www.auto-steuerung.de/">
            <title>User Einstellungen {device_id}</title>
            <style>
                #status-bar {
                  width: 100%;
                  height: 10px;
                  position: fixed;
                  top: 0;
                  left: 0;
                }
                .green {
                  background-color: #28a745; /* Grün */
                }
                .red {
                  background-color: #dc3545; /* Rot */
                }  
                .status-indicator {
                  display: inline-block;
                  width: 20px;
                  height: 20px;
                  vertical-align: middle;
                  margin-left: 10px;
                  position: relative;  /* Relative Positionierung */
                  z-index: 1000;         /* Höherer Z-Index */
                  border: 1px solid black; /* Temporäre Randlinie für Debugging */
                }
                .status-ok {
                  background-color: green;
                }
                .status-not-ok {
                  background-color: red;
                }


              .container {
                display: flex;
                justify-content: center;
                align-items: flex-start; 
                min-height: 100vh;
                background-color: #000; 
                padding: 1px;
                margin: 0 auto;
                width: calc(100% - 20px); 
              }

              .form-container {
                width: 100%;
                max-width: 750px;
                padding: 5px;
                background-color: #333; 
                border: 1px solid #ddd;
                border-radius: 8px;
                box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
                margin: 0 auto;
              }


              html, body { font-family: Arial, sans-serif; text-align: center; padding: 15px 6px; background-color: black; color: white; width: 94%; }
              h1, h2 { color: #fff; }
              p { color: #ccc; }
              a, input[type="submit"], select {
                  display: flex;
                  justify-content: center;
                  align-items: center;
                  margin: 10px auto;
                  color: #007BFF;
                  text-decoration: none;
                  font-weight: bold;
                  font-size: 1.2em;
                  border: 2px solid #007BFF;
                  padding: 10px;
                  border-radius: 5px;
                  width: 300px;
                  background-color: #222;
                  box-shadow: 0 4px 8px rgba(0, 0, 0, 0.4);
              }
              a:hover, input[type="submit"]:hover {
                  text-decoration: underline;
                  background-color: #007BFF;
                  color: white;
                  box-shadow: 0 8px 16px rgba(0, 0, 0, 0.8);
              }

              
            .back-link {
                  display: block;
                  margin: 10px auto;
                  color: #007BFF;
                  text-decoration: none;
                  font-weight: bold;
                  font-size: 1.2em;
                  border: 2px solid #007BFF;
                  padding: 10px;
                  border-radius: 5px;
                  width: 110px;  
                  background-color: #222;
                  box-shadow: 0 4px 8px rgba(0, 0, 0, 0.4);
                  text-align: center; 
                }
                .back-link:hover {
                  text-decoration: underline;
                  background-color: #007BFF;
                  color: white;
                  box-shadow: 0 8px 16px rgba(0, 0, 0, 0.8);
                }
                button {
                  display: block;
                  margin: 20px auto;
                  color: #fff;
                  background-color: #007BFF;
                  border: none;
                  padding: 10px 20px;
                  font-size: 1.2em;
                  border-radius: 5px;
                  cursor: pointer;
                }
                button:hover {
                  background-color: #0056b3;
                }
                .status-ok {
                  background-color: #28a745;
                }
                .status-nok {
                  background-color: #dc3545;
                }
              
              table {
                margin: 20px auto;
                border-collapse: collapse;
                width: 80%;
                background-color: #222;
                color: white;
              }
              th, td {
                border: 1px solid #777;
                padding: 10px;
                text-align: center;
              }
              th {
                background-color: #0056b3;
              }
                input[type="text"], input[type="password"], input[type="date"], input[type="time"] {
                  width: 100%;
                  padding: 8px;
                  margin: 5px 0;
                  box-sizing: border-box;
                  border: none;
                  background-color: #333;
                  color: white;
                }
                input[type="submit"] {
                  width: auto;
                  padding: 8px 16px;
                  background-color: #007BFF;
                  color: white;
                  border: none;
                  border-radius: 5px;
                  cursor: pointer;
                }
                input[type="submit"]:hover {
                  background-color: #0056b3;
                }

                .form-table {
                  width: 96%; 
                  margin: auto; 

                    max-width: 6080px;
                    margin: auto;
                    background-color: #f9f9f9;
                    border: 1px solid #ddd;
                    padding: 20px;
                    border-radius: 8px;
                    color: black; 
                }

                  .form-table td {
                    padding: 10px;
                  }
                  .form-table input[type="date"],
                  .form-table input[type="time"],
                  .form-table select {
                    width: 100%;
                    padding: 10px;
                    border: 1px solid #ccc;
                    border-radius: 4px;
                    box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.1);
                    text-align: center; 
                    font-size: 16px;
                    -webkit-appearance: none; 
                  }
                  .form-table th, .form-table td {
                    text-align: left;
                  }
                  .form-table th {
                    background-color: #f1f1f1;
                    padding: 10px;
                  }

                  input[type="date"]::-webkit-calendar-picker-indicator,
                  input[type="time"]::-webkit-calendar-picker-indicator {
                    filter: invert(1); 
                  }
                  .form-separator {
                    margin: 40px 0; 
                    border-top: 2px solid #000; 
                  }

                  .container-separator {
                    margin: 40px 0; 
                  }


                          
                @media (max-width: 800px) {
                  .container {
                    width: 100%;
                    padding: 0;
                    margin: 0;
                  }

                  .form-container {
                    width: 100%;
                    max-width: none;
                    padding: 10px;
                    margin: 0;
                  }

                  .form-table {
                    width: 95%;
                    margin: 0;
                  }
                }

            </style>
      <script>
          let isNavigating = false;

          // Setze den Indikator beim Seitenwechsel innerhalb der Anwendung
          document.querySelectorAll('a').forEach(function(anchor) {
              anchor.addEventListener('click', function(event) {
                  isNavigating = true;
              });
          });

          // Überprüfe Sichtbarkeitswechsel des Dokuments
          document.addEventListener('visibilitychange', function() {
              if (document.visibilityState === 'hidden' && !isNavigating && isConnected) {
                  console.log('Sending browser_closed message via visibilitychange');
                  ws.send('browser_closed');
                  setTimeout(() => ws.close(), 100);  // Verzögerung hinzugefügt
              }
          });

          window.addEventListener('unload', function(event) {
              if (!isNavigating && isConnected) {
                  console.log('Sending browser_closed message via unload');
                  ws.send('browser_closed');
              }
          });

          let checkCounter = 0;

          function checkServerStatus() {
              fetch('/serverStatus')
                  .then(response => response.json())
                  .then(data => {
                      const statusBar = document.getElementById('status-bar');
                      if (data.serverRunning) {
                          statusBar.classList.add('green');
                          statusBar.classList.remove('red');
                          checkCounter = 0; // Reset the counter if the server is running
                      } else {
                          checkCounter++;
                          if (checkCounter >= 3) {
                              statusBar.classList.add('red');
                              statusBar.classList.remove('green');
                          }
                      }
                  })
                  .catch(error => {
                      checkCounter++;
                      const statusBar = document.getElementById('status-bar');
                      if (checkCounter >= 3) {
                          statusBar.classList.add('red');
                          statusBar.classList.remove('green');
                      }
                  });
          }

          let attempts = 0;

          function checkPasswordsMatch() {
              const newPassword = document.getElementById('newPassword').value;
              const confirmPassword = document.getElementById('confirmPassword').value;
              if (newPassword !== confirmPassword) {
                  alert('Passwörter stimmen nicht überein');
                  return false;
              }
              return true;
          }

          function handlePasswordChange(event) {
              event.preventDefault(); // Verhindert das Standard-Submit-Verhalten
              
              const currentPassword = document.getElementById('currentPassword').value;
              const newPassword = document.getElementById('newPassword').value;

              const lockoutTime = localStorage.getItem('lockoutTime');
              if (lockoutTime && new Date().getTime() < lockoutTime) {
                  alert('Zu viele Fehlversuche. Bitte versuchen Sie es später noch einmal.');
                  return;
              }

              if (!checkPasswordsMatch()) {
                  attempts++;
                  if (attempts >= 3) {
                      const lockoutDuration = 15 * 60 * 1000; // 15 Minuten in Millisekunden
                      localStorage.setItem('lockoutTime', new Date().getTime() + lockoutDuration);
                      alert('Zu viele Fehlversuche. Sie können es in 15 Minuten erneut versuchen.');
                      attempts = 0; // Zurücksetzen der Versuche
                  }
                  return;
              }

              fetch('/changePassword', {
                  method: 'POST',
                  headers: {
                      'Content-Type': 'application/json'
                  },
                  body: JSON.stringify({ currentPassword, newPassword })
              })
              .then(response => response.json())
              .then(data => {
                  if (data.success) {
                      alert('Passwort erfolgreich geändert');
                  } else {
                      alert(data.message || 'Fehler beim ändern des Passworts');
                  }
              })
              .catch(error => console.error('Error changing password:', error));
          }

          function handleTimezoneChange() {
              const timezone = document.getElementById('timezone').value;
              if (timezone !== '0') {
                  document.getElementById('customZone').value = '0';
              }
          }

          function handleTimeChange(event) {
              event.preventDefault();

              const timezoneElement = document.getElementById('timezone');
              const dstElement = document.getElementById('dst');
              const firstDropdownElement = document.getElementById('firstDropdown');
              const secondDropdownElement = document.getElementById('secondDropdown');
              const dateElement = document.getElementById('date');
              const timeElement = document.getElementById('time');
              const timeFormatElement = document.getElementById('timeFormat'); // Zeitformat-Element hinzufügen

              if (!timezoneElement || !dstElement || !firstDropdownElement || !secondDropdownElement || !dateElement || !timeElement || !timeFormatElement) {
                  console.error('Ein oder mehrere Elemente wurden nicht gefunden');
                  return;
              }

              const timezone = parseInt(timezoneElement.value, 10);
              const dst = dstElement.value === '1';
              const region = firstDropdownElement.value;
              const city = secondDropdownElement.options[secondDropdownElement.selectedIndex].text; // Verwende den Text der ausgewählten Option für die Stadt
              const customZone = secondDropdownElement.value;
              const date = dateElement.value;
              const time = timeElement.value;
              const timeFormat = parseInt(timeFormatElement.value, 10); // Zeitformat auslesen

              if (dst && customZone === '0') {
                  alert('Wenn Sommer-Winterzeit Umstellung auf "Ja" gesetzt ist, muss eine benutzerdefinierte Zeitzone ausgewählt werden.');
                  return;
              }

              if (!dst && timezone === 99 && customZone === '0') {
                  alert('Wenn Sommer-Winterzeit Umstellung auf "Nein" gesetzt ist, muss entweder eine Zeitzone oder eine benutzerdefinierte Zeitzone ausgewählt werden.');
                  return;
              }

              if (timezone !== 99 && customZone !== '0') {
                  alert('Es darf nur eine Zeitzone oder eine benutzerdefinierte Zeitzone ausgewählt werden.');
                  return;
              }

              // Berechne die UTC-Zeit
              let dateTimeString = `${date}T${time}`;
              if (timezone !== 99) {
                  const offset = timezone * -60; // Zeitzonen-Offset in Minuten umwandeln (negative Werte für östliche Zeitzonen)
                  const dateTime = new Date(dateTimeString);
                  const utcDateTime = new Date(dateTime.getTime() + offset * 60000);
                  dateTimeString = utcDateTime.toISOString().slice(0, -5) + "Z"; // ISO-String ohne Millisekunden
              }

              const dateTime = new Date(dateTimeString);
              const utcTimestamp = Math.floor(dateTime.getTime() / 1000);

              console.log(`timezone: ${timezone}, dst: ${dst}, customZone: ${customZone}, date: ${date}, time: ${time}, utcTimestamp: ${utcTimestamp}, timeFormat: ${timeFormat}`);

              if (confirm('Die Uhrzeit wird gestellt. Möchten Sie fortfahren?')) {
                  const password = prompt('Bitte Passwort eingeben:');
                  fetch('/checkPassword', {
                      method: 'POST',
                      headers: { 'Content-Type': 'application/json' },
                      body: JSON.stringify({ password: password })
                  })
                  .then(response => response.json())
                  .then(data => {
                      if (data.success) {
                          fetch('/setTimestamp', {
                              method: 'POST',
                              headers: { 'Content-Type': 'application/json' },
                              body: JSON.stringify({ timestamp: utcTimestamp, timezone: timezone, dst: dst, customZone: customZone, region: region, city: city, bit: true, timeFormat: timeFormat })
                          })
                          .then(response => response.json())
                          .then(data => {
                              if (data.success) {
                                  alert('Datum und Uhrzeit erfolgreich gespeichert.');
                              } else {
                                  alert(data.message || 'Fehler beim Speichern von Datum und Uhrzeit.');
                              }
                          })
                          .catch(error => console.error('Error setting timestamp:', error));
                      } else {
                          alert('Falsches Passwort');
                      }
                  })
                  .catch(error => {
                      console.error('Error checking password:', error);
                      alert('Fehler beim Überprüfen des Passworts.');
                  });
              }
          }

          document.addEventListener("DOMContentLoaded", function() {
              setDefaultValue("dst");
              setDefaultValue("firstDropdown");
              updateSecondDropdown();
              
              // Überprüfe und setze die Zeitzone, wenn DST auf "Ja" steht
              const dstElement = document.getElementById('dst');
              const timezoneElement = document.getElementById('timezone');
              if (dstElement && dstElement.value === '1' && timezoneElement) {
                  timezoneElement.value = '99'; // Zeitzone auf "keine" setzen
              }
              
              // Lade den gespeicherten NTP-Server
              fetch('/getNTPServer')
                  .then(response => response.json())
                  .then(data => {
                      if (data.success) {
                          const ntpServerElement = document.getElementById('ntpServer');
                          ntpServerElement.value = data.ntpServer;
                      } else {
                          console.error('Fehler beim Laden des NTP Servers:', data.message);
                      }
                  })
                  .catch(error => console.error('Fehler beim Laden des NTP Servers:', error));
              
              // Initialisierung der 12/24 Stunden Uhrzeitanzeige
              const timeFormatElement = document.getElementById('timeFormat');
              if (timeFormatElement) {
                  timeFormatElement.addEventListener('change', handleTimeFormatChange);
              }
              updateTimeInputFormat();
          });

          function setDefaultValue(id) {
              const element = document.getElementById(id);
              if (element && element.dataset.defaultValue) {
                  console.log(`Setting default value for ${id}: ${element.dataset.defaultValue}`);
                  
                  // Überprüfen, ob die Option im Dropdown existiert
                  const options = element.options;
                  for (let i = 0; i < options.length; i++) {
                      if (options[i].text === element.dataset.defaultValue || options[i].value === element.dataset.defaultValue) {
                          element.selectedIndex = i;
                          break;
                      }
                  }
              } else {
                  console.error(`Element with id ${id} not found or has no default value`);
              }
          }

          function updateSecondDropdown() {
              const selectedRegion = document.getElementById('firstDropdown').value;
              console.log("Selected Region: " + selectedRegion);
              fetch(`/get-second-dropdown-options?region=${selectedRegion}`)
                  .then(response => response.text())
                  .then(data => {
                      document.getElementById('secondDropdown').innerHTML = data;
                      setDefaultValue('secondDropdown'); // Setze den Standardwert für das zweite Dropdown
                  });
          }

          function handleDSTChange() {
              const dstElement = document.getElementById('dst');
              const timezoneElement = document.getElementById('timezone');
              if (dstElement && timezoneElement) {
                  if (dstElement.value === '1') {
                      timezoneElement.value = '99';
                  }
              }
          }

          function updateStatusIndicator() {
              var updateNtpReady = %UPDATE_NTP_READY%;
              console.log("updateNtpReady:", updateNtpReady);
              var statusIndicator = document.getElementById('statusIndicator');
              if (updateNtpReady) {
                  statusIndicator.classList.add('status-ok');
                  statusIndicator.classList.remove('status-not-ok');
              } else {
                  statusIndicator.classList.add('status-not-ok');
                  statusIndicator.classList.remove('status-ok');
              }
              console.log("Status Indicator Klassen:", statusIndicator.classList);
          }

          function validateNTPServer(ntpServer) {
              // Regex für gültige Domains und IP-Adressen
              var ntpServerPattern = /^(default|([a-zA-Z0-9\-]+\.)+[a-zA-Z]{2,})$/;
              var ipPattern = /^(\d{1,3}\.){3}\d{1,3}$/;
              console.log("Validating NTP Server: " + ntpServer);
              console.log("Regex Match (Domain): " + ntpServerPattern.test(ntpServer));
              console.log("Regex Match (IP): " + (ipPattern.test(ntpServer) && isValidIPAddress(ntpServer)));
              return ntpServerPattern.test(ntpServer) || (ipPattern.test(ntpServer) && isValidIPAddress(ntpServer));
          }

          function isValidIPAddress(ip) {
              var ipParts = ip.split('.');
              if (ipParts.length !== 4) return false;
              return ipParts.every(function(part) {
                  var num = parseInt(part, 10);
                  return num >= 0 && num <= 255;
              });
          }

          function handleNTPChange(event) {
              event.preventDefault();

              const ntpServerElement = document.getElementById('ntpServer');
              const ntpServer = ntpServerElement.value;

              const statusIndicator = document.getElementById('statusIndicator');
              if (!validateNTPServer(ntpServer)) {
                  alert("Bitte einen gültigen NTP Server oder 'default' eingeben.");
                  statusIndicator.classList.remove('status-ok');
                  statusIndicator.classList.add('status-not-ok');
                  return;
              }

              fetch('/validateNTPServer', {
                  method: 'POST',
                  headers: {
                      'Content-Type': 'application/json'
                  },
                  body: JSON.stringify({ ntpServer: ntpServer })
              })
              .then(response => response.json())
              .then(data => {
                  if (data.valid) {
                      statusIndicator.classList.remove('status-not-ok');
                      statusIndicator.classList.add('status-ok');

                      const password = prompt('Bitte Passwort eingeben:');
                      fetch('/checkPassword', {
                          method: 'POST',
                          headers: { 'Content-Type': 'application/json' },
                          body: JSON.stringify({ password: password })
                      })
                      .then(response => response.json())
                      .then(data => {
                          if (data.success) {
                              fetch('/setNTPServer', {
                                  method: 'POST',
                                  headers: { 'Content-Type': 'application/json' },
                                  body: JSON.stringify({ ntpServer: ntpServer })
                              })
                              .then(response => response.json())
                              .then(data => {
                                  if (data.success) {
                                      alert('NTP Server erfolgreich gespeichert.');
                                  } else {
                                      alert(data.message || 'Fehler beim Speichern des NTP Servers.');
                                  }
                              })
                              .catch(error => {
                                  console.error('Error setting NTP server:', error);
                                  alert('Fehler beim Speichern des NTP Servers.');
                              });
                          } else {
                              alert('Falsches Passwort');
                          }
                      })
                      .catch(error => {
                          console.error('Error checking password:', error);
                          alert('Fehler beim Überprüfen des Passworts.');
                      });
                  } else {
                      statusIndicator.classList.remove('status-ok');
                      statusIndicator.classList.add('status-not-ok');
                  }
              })
              .catch(error => {
                  console.error('Error validating NTP server:', error);
                  alert('Fehler bei der Validierung des NTP Servers.');
              });
          }

          function handleTimeFormatChange(event) {
              event.preventDefault();

              const timeFormatElement = document.getElementById('timeFormat');

              if (!timeFormatElement) {
                  console.error('Zeitformat-Element wurde nicht gefunden');
                  return;
              }

              const timeFormat = parseInt(timeFormatElement.value, 10);

              fetch('/setTimeFormat', {
                  method: 'POST',
                  headers: { 'Content-Type': 'application/json' },
                  body: JSON.stringify({ timeFormat: timeFormat })
              })
              .then(response => response.json())
              .then(data => {
                  if (data.success) {
                      alert('Zeitformat erfolgreich geändert.');
                  } else {
                      alert(data.message || 'Fehler beim Ändern des Zeitformats.');
                  }
              })
              .catch(error => console.error('Fehler beim Ändern des Zeitformats:', error));
          }

          function updateTimeInputFormat() {
              const timeFormatElement = document.getElementById('timeFormat');
              const timeInputElement = document.getElementById('time');

              if (timeFormatElement && timeInputElement) {
                  if (timeFormatElement.value === '12') {
                      timeInputElement.setAttribute('type', 'text');
                      timeInputElement.setAttribute('placeholder', 'hh:mm AM/PM');
                  } else {
                      timeInputElement.setAttribute('type', 'time');
                      timeInputElement.removeAttribute('placeholder');
                  }
              }
          }

          var ws = new WebSocket('ws://' + window.location.hostname + ':81/');
          var isConnected = false;

          ws.onopen = function() {
              isConnected = true;
              console.log('WebSocket connection established');
          };

          ws.onclose = function(event) {
              isConnected = false;
              console.log('WebSocket connection closed');
              if (!event.wasClean) {
                  // Sende eine Nachricht an den Server, dass der Browser geschlossen wurde
                  ws.send('browser_closed');
              }
          };

          ws.onerror = function(error) {
              isConnected = false;
              console.log('WebSocket error:', error);
          };

          window.onload = function() {
              updateStatusIndicator();
              checkServerStatus();
              setInterval(checkServerStatus, 5000); // Überprüft den Serverstatus alle 5 Sekunden
          };
      </script>




          </head>
          <body>
        <div id="status-bar" class="green"></div>

          <div class="container">
            <div class="form-container">
              <h2>Datum und Uhrzeit &auml;ndern</h2>
              <form id="timeForm" onsubmit="handleTimeChange(event)">
                <table class="form-table">
                  <tr>
                    <th colspan="2">Sommer-Winterzeit Umstellung</th>
                  </tr>
                  <tr>
                    <td colspan="2">
                    <select id="dst" name="dst" data-default-value="1" required onchange="handleDSTChange()">
                      <option value="1">Ja</option>
                      <option value="0">Nein</option>
                    </select>
                    </td>
                  </tr>
                  <tr>
                    <th colspan="2">Zeitzone</th>
                  </tr>
                  <tr>
                    <td colspan="2">
                      <select id="timezone" name="timezone" required>
                        <option value="99" selected>keine</option>
                        <option value="-12">UTC-12</option>
                        <option value="-11">UTC-11</option>
                        <option value="-10">UTC-10</option>
                        <option value="-9">UTC-9</option>
                        <option value="-8">UTC-8</option>
                        <option value="-7">UTC-7</option>
                        <option value="-6">UTC-6</option>
                        <option value="-5">UTC-5</option>
                        <option value="-4">UTC-4</option>
                        <option value="-3">UTC-3</option>
                        <option value="-2">UTC-2</option>
                        <option value="-1">UTC-1</option>
                        <option value="0">UTC+0</option>
                        <option value="1">UTC+1</option>
                        <option value="2">UTC+2</option>
                        <option value="3">UTC+3</option>
                        <option value="4">UTC+4</option>
                        <option value="5">UTC+5</option>
                        <option value="6">UTC+6</option>
                        <option value="7">UTC+7</option>
                        <option value="8">UTC+8</option>
                        <option value="9">UTC+9</option>
                        <option value="10">UTC+10</option>
                        <option value="11">UTC+11</option>
                        <option value="12">UTC+12</option>
                      </select>
                    </td>
                  </tr>
                  <tr>
                    <th colspan="2">Benutzerdefinierte Zeitzone</th>
                  </tr>
                  <tr>
                    <td colspan="2">
                    <select id="firstDropdown" name="firstDropdown" data-default-value="Europe" onchange="updateSecondDropdown()">
                      <!-- Optionen für das erste Dropdown-Menü -->
                      )rawliteral" + generateFirstDropdownOptions() + R"rawliteral(
                    </select>
                                  </td>
                                </tr>
                                <tr>
                                  <td colspan="2">
                    <select id="secondDropdown" name="secondDropdown" data-default-value="Berlin">
                      <!-- Optionen für das zweite Dropdown-Menü -->
                      <option value="0" selected>W&auml;hle eine Stadt</option>
                    </select>

                  </td>
              </tr>
              <tr>
                  <th colspan="2">Zeitanzeigeformat</th>
              </tr>
              <tr>
                  <td colspan="2">
                    <select id="timeFormat">
                      <option value="24" selected>24-Stunden</option>
                      <option value="12">12-Stunden</option>
                    </select>


                    </td>
                  </tr>
                  <tr>
                    <th colspan="2">Datum</th>
                  </tr>
                  <tr>
                    <td colspan="2">
                      <input type="date" id="date" name="date" required>
                    </td>
                  </tr>
                  <tr>
                    <th colspan="2">Uhrzeit</th>
                  </tr>
                  <tr>
                    <td colspan="2">
                      <input type="time" id="time" name="time" required>
                    </td>
                  </tr>
                </table>
                <input type="submit" value="Datum und Zeit Speichern">
              </form>
              <br>
              <hr>
              <h2>NTP Server einstellen</h2>
              <form id="ntpForm" onsubmit="handleNTPChange(event)">
                <table class="form-table">
                  <tr>
                    <th>NTP Server</th>
                    <td>
                <input type="text" id="ntpServer" name="ntpServer" required title="Hier den alternativen NTP Server eintragen, oder mit 'default' den Standardwert laden" style="width: 200px;">
                <div id="statusIndicator" class="status-indicator"></div>
                    </td>
                  </tr>
                </table>
                <input type="submit" value="NTP Server Speichern">
              </form>
              <br>

            <a href="/index" class="back-link">Zur&uuml;ck</a>
            </div>
          </div>

          </body>

          </html>
        )rawliteral";
        html.replace("%UPDATE_NTP_READY%", update_ntp_ready ? "true" : "false");
        return html;
      }
      #endif




    const char user_html_template[] PROGMEM = R"rawliteral(
    <!DOCTYPE html>
    <html lang="de">
    <head>

      <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
      <meta charset="UTF-8">

      <meta http-equiv="Pragma" content="no-cache">
      <meta name='viewport' content='width=device-width, initial-scale=1'/>
      <meta name="author" content="Gebauer Holger, https://www.auto-steuerung.de/">
      <title>User Settings {device_id}</title>
      <style>
          #status-bar {
            width: 100%;
            height: 10px;
            position: fixed;
            top: 0;
            left: 0;
          }
          .green {
            background-color: #28a745; /* Grün */
          }
          .red {
            background-color: #dc3545; /* Rot */
          }  
        .container {
          display: flex;
          justify-content: center;
          align-items: flex-start; 
          min-height: 100vh;
          background-color: #000; 
          padding: 1px;
          margin: 0 auto;
          width: calc(100% - 20px); 
        }

        .form-container {
          width: 100%;
          max-width: 750px;
          padding: 5px;
          background-color: #333; 
          border: 1px solid #ddd;
          border-radius: 8px;
          box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
          margin: 0 auto;
        }


        html, body { font-family: Arial, sans-serif; text-align: center; padding: 15px 6px; background-color: black; color: white; width: 94%; }
        h1, h2 { color: #fff; }
        p { color: #ccc; }
        a, input[type="submit"], select {
            display: flex;
            justify-content: center;
            align-items: center;
            margin: 10px auto;
            color: #007BFF;
            text-decoration: none;
            font-weight: bold;
            font-size: 1.2em;
            border: 2px solid #007BFF;
            padding: 10px;
            border-radius: 5px;
            width: 300px;
            background-color: #222;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.4);
        }
        a:hover, input[type="submit"]:hover {
            text-decoration: underline;
            background-color: #007BFF;
            color: white;
            box-shadow: 0 8px 16px rgba(0, 0, 0, 0.8);
        }

        
       .back-link {
            display: block;
            margin: 10px auto;
            color: #007BFF;
            text-decoration: none;
            font-weight: bold;
            font-size: 1.2em;
            border: 2px solid #007BFF;
            padding: 10px;
            border-radius: 5px;
            width: 110px;  
            background-color: #222;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.4);
            text-align: center; 
          }
          .back-link:hover {
            text-decoration: underline;
            background-color: #007BFF;
            color: white;
            box-shadow: 0 8px 16px rgba(0, 0, 0, 0.8);
          }
          button {
            display: block;
            margin: 20px auto;
            color: #fff;
            background-color: #007BFF;
            border: none;
            padding: 10px 20px;
            font-size: 1.2em;
            border-radius: 5px;
            cursor: pointer;
          }
          button:hover {
            background-color: #0056b3;
          }
          .status-ok {
            background-color: #28a745;
          }
          .status-nok {
            background-color: #dc3545;
          }
        
        table {
          margin: 20px auto;
          border-collapse: collapse;
          width: 80%;
          background-color: #222;
          color: white;
        }
        th, td {
          border: 1px solid #777;
          padding: 10px;
          text-align: center;
        }
        th {
          background-color: #0056b3;
        }
          input[type="text"], input[type="password"], input[type="date"], input[type="time"] {
            width: 100%;
            padding: 8px;
            margin: 5px 0;
            box-sizing: border-box;
            border: none;
            background-color: #333;
            color: white;
          }
          input[type="submit"] {
            width: auto;
            padding: 8px 16px;
            background-color: #007BFF;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
          }
          input[type="submit"]:hover {
            background-color: #0056b3;
          }

          .form-table {
            width: 96%; 
            margin: auto; 

              max-width: 6080px;
              margin: auto;
              background-color: #f9f9f9;
              border: 1px solid #ddd;
              padding: 20px;
              border-radius: 8px;
              color: black; 
          }

            .form-table td {
              padding: 10px;
            }
            .form-table input[type="date"],
            .form-table input[type="time"],
            .form-table select {
              width: 100%;
              padding: 10px;
              border: 1px solid #ccc;
              border-radius: 4px;
              box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.1);
              text-align: center; 
              font-size: 16px;
              -webkit-appearance: none; 
            }
            .form-table th, .form-table td {
              text-align: left;
            }
            .form-table th {
              background-color: #f1f1f1;
              padding: 10px;
            }

            input[type="date"]::-webkit-calendar-picker-indicator,
            input[type="time"]::-webkit-calendar-picker-indicator {
              filter: invert(1); 
            }
            .form-separator {
              margin: 40px 0; 
              border-top: 2px solid #000; 
            }

            .container-separator {
              margin: 40px 0; 
            }
        .password-container {
            position: relative;
            display: flex;
        }
        .password-container input[type="password"], .password-container input[type="text"] {
            width: 100%;
            padding-right: 30px;
        }
        .toggle-password {
            position: absolute;
            right: 5px;
            top: 50%;
            transform: translateY(-50%);
            cursor: pointer;
        }


                    
          @media (max-width: 800px) {
            .container {
              width: 100%;
              padding: 0;
              margin: 0;
            }

            .form-container {
              width: 100%;
              max-width: none;
              padding: 10px;
              margin: 0;
            }

            .form-table {
              width: 95%;
              margin: 0;
            }
          }

      </style>

      <script>
    let isNavigating = false;

    // Setze den Indikator beim Seitenwechsel innerhalb der Anwendung
    document.querySelectorAll('a').forEach(function(anchor) {
        anchor.addEventListener('click', function(event) {
            isNavigating = true;
        });
    });

    // Überprüfe Sichtbarkeitswechsel des Dokuments
    document.addEventListener('visibilitychange', function() {
        if (document.visibilityState === 'hidden' && !isNavigating && isConnected) {
            console.log('Sending browser_closed message via visibilitychange');
            ws.send('browser_closed');
            setTimeout(() => ws.close(), 100);  // Verzögerung hinzugefügt
        }
    });

    window.addEventListener('unload', function(event) {
        if (!isNavigating && isConnected) {
            console.log('Sending browser_closed message via unload');
            ws.send('browser_closed');
        }
    });

    let checkCounter = 0;

    function checkServerStatus() {
        fetch('/serverStatus')
            .then(response => response.json())
            .then(data => {
                const statusBar = document.getElementById('status-bar');
                if (data.serverRunning) {
                    statusBar.classList.add('green');
                    statusBar.classList.remove('red');
                    checkCounter = 0; // Reset the counter if the server is running
                } else {
                    checkCounter++;
                    if (checkCounter >= 3) {
                        statusBar.classList.add('red');
                        statusBar.classList.remove('green');
                    }
                }
            })
            .catch(error => {
                checkCounter++;
                const statusBar = document.getElementById('status-bar');
                if (checkCounter >= 3) {
                    statusBar.classList.add('red');
                    statusBar.classList.remove('green');
                }
            });
    }

    let attempts = 0;

    function checkPasswordsMatch() {
        const newPassword = document.getElementById('newPassword').value;
        const confirmPassword = document.getElementById('confirmPassword').value;
        if (newPassword !== confirmPassword) {
            alert('Passwörter stimmen nicht überein');
            return false;
        }
        return true;
    }

    function handlePasswordChange(event) {
        event.preventDefault(); // Verhindert das Standard-Submit-Verhalten
        
        const currentPassword = document.getElementById('currentPassword').value;
        const newPassword = document.getElementById('newPassword').value;

        const lockoutTime = localStorage.getItem('lockoutTime');
        if (lockoutTime && new Date().getTime() < lockoutTime) {
            alert('Zu viele Fehlversuche. Bitte versuchen Sie es später noch einmal.');
            return;
        }

        if (!checkPasswordsMatch()) {
            attempts++;
            if (attempts >= 3) {
                const lockoutDuration = 15 * 60 * 1000; // 15 Minuten in Millisekunden
                localStorage.setItem('lockoutTime', new Date().getTime() + lockoutDuration);
                alert('Zu viele Fehlversuche. Sie können es in 15 Minuten erneut versuchen.');
                attempts = 0; // Zurücksetzen der Versuche
            }
            return;
        }

        fetch('/changePassword', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({ currentPassword, newPassword })
        })
        .then(response => response.json())
        .then(data => {
            if (data.success) {
                alert('Passwort erfolgreich geändert');
            } else {
                alert(data.message || 'Fehler beim ändern des Passworts');
            }
        })
        .catch(error => console.error('Error changing password:', error));
    }

    document.addEventListener("DOMContentLoaded", function() {
        setDefaultValue("dst");
        setDefaultValue("firstDropdown");
        updateSecondDropdown();

        // Überprüfe und setze die Zeitzone, wenn DST auf "Ja" steht
        const dstElement = document.getElementById('dst');
        const timezoneElement = document.getElementById('timezone');
        if (dstElement && dstElement.value === '1' && timezoneElement) {
            timezoneElement.value = '99'; // Zeitzone auf "keine" setzen
        }

        // Lade den gespeicherten NTP-Server
        fetch('/getNTPServer')
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    const ntpServerElement = document.getElementById('ntpServer');
                    ntpServerElement.value = data.ntpServer;
                } else {
                    console.error('Fehler beim Laden des NTP Servers:', data.message);
                }
            })
            .catch(error => console.error('Fehler beim Laden des NTP Servers:', error));

        // Initialisierung der 12/24 Stunden Uhrzeitanzeige
        const timeFormatElement = document.getElementById('timeFormat');
        if (timeFormatElement) {
            timeFormatElement.addEventListener('change', handleTimeFormatChange);
        }
        updateTimeInputFormat();
    });

    function handleTimeFormatChange(event) {
        event.preventDefault();

        const timeFormatElement = document.getElementById('timeFormat');

        if (!timeFormatElement) {
            console.error('Zeitformat-Element wurde nicht gefunden');
            return;
        }

        const timeFormat = parseInt(timeFormatElement.value, 10);

        fetch('/setTimeFormat', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ timeFormat: timeFormat })
        })
        .then(response => response.json())
        .then(data => {
            if (data.success) {
                alert('Zeitformat erfolgreich geändert.');
            } else {
                alert(data.message || 'Fehler beim Ändern des Zeitformats.');
            }
        })
        .catch(error => console.error('Fehler beim Ändern des Zeitformats:', error));
    }

    function updateTimeInputFormat() {
        const timeFormatElement = document.getElementById('timeFormat');
        const timeInputElement = document.getElementById('time');

        if (timeFormatElement && timeInputElement) {
            if (timeFormatElement.value === '12') {
                timeInputElement.setAttribute('type', 'text');
                timeInputElement.setAttribute('placeholder', 'hh:mm AM/PM');
            } else {
                timeInputElement.setAttribute('type', 'time');
                timeInputElement.removeAttribute('placeholder');
            }
        }
    }

    var ws = new WebSocket('ws://' + window.location.hostname + ':81/');
    var isConnected = false;

    ws.onopen = function() {
        isConnected = true;
        console.log('WebSocket connection established');
    };

    ws.onclose = function(event) {
        isConnected = false;
        console.log('WebSocket connection closed', event);
    };

    ws.onerror = function(error) {
        isConnected = false;
        console.log('WebSocket error:', error);
    };

    window.onload = function() {
        checkServerStatus();
        setInterval(checkServerStatus, 5000); // Überprüft den Serverstatus alle 5 Sekunden
    };
</script>



    </head>
    <body>
   <div id="status-bar" class="green"></div>

  

  <!-- Zweiter Container für Passwortänderung -->
  <div class="container">
    <div class="form-container">

        <h2>Passwort &auml;ndern</h2>
        <form id="passwordForm" onsubmit="handlePasswordChange(event)">
          <table class="form-table">
            <tr>
        <tr>
            <th>Aktuelles Passwort</th>
            <td>
                <div class="password-container">
                    <input type="password" id="currentPassword" name="currentPassword" required>
                    <span class="toggle-password" onclick="togglePassword('currentPassword')">👁️</span>
                </div>
            </td>
        </tr>
        <tr>
            <th>Neues Passwort</th>
            <td>
                <div class="password-container">
                    <input type="password" id="newPassword" name="newPassword" required>
                    <span class="toggle-password" onclick="togglePassword('newPassword')">👁️</span>
                </div>
            </td>
        </tr>
        <tr>
            <th>Neues Passwort best&auml;tigen</th>
            <td>
                <div class="password-container">
                    <input type="password" id="confirmPassword" name="confirmPassword" required>
                    <span class="toggle-password" onclick="togglePassword('confirmPassword')">👁️</span>
                </div>
            </td>
        </tr>
          </table>
          <input type="submit" value="Kennwort Speichern">
        </form>

        
    <script>
        function togglePassword(id) {
            const input = document.getElementById(id);
            const type = input.getAttribute('type') === 'password' ? 'text' : 'password';
            input.setAttribute('type', type);
        }
    </script>

        <br>
        <hr>
        <h2>Update</h2>

          <table class="form-table">
            <tr>
              <th>Filesystem Update</th>
              <td><a href="/updateFileSystem" class="back-link">Update</a></td>
            </tr>
          </table>
          
        <br>

        <a href="/index" class="back-link">Zur&uuml;ck</a>


      </div>
    </div>

    </body>



    </html>
        )rawliteral";








  //  deinPasswort2  

        const char spiffs_html_template[] PROGMEM = R"rawliteral(
        <!DOCTYPE html>
        <html lang="de">
        <head>
          <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
          <meta charset="UTF-8">

          <meta http-equiv="Pragma" content="no-cache">
          <meta name='viewport' content='width=device-width, initial-scale=1'/>
          <meta name="author" content="Gebauer Holger, https://www.auto-steuerung.de/">
          <title>Filesystem Upload {device_id}</title>
          <style>
            body {
              font-family: Arial, sans-serif;
              background-color: #000000; 
              margin: 0;
              padding: 0;
              display: flex;
              justify-content: flex-start;
              align-items: center;
              height: 100vh;
              flex-direction: column; 
            }
            .container {
              background-color: #333333; 
              padding: 20px;
              border-radius: 8px;
              box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
              width: 100%;
              max-width: 550px;
              border: 1px solid #ff0000; 
              text-align: center; 
              margin-top: 20px; 
            }
        a, input[type="submit"], select {
            display: flex;
            justify-content: center;
            align-items: center;
            margin: 10px auto;
            color: #007BFF;
            text-decoration: none;
            font-weight: bold;
            font-size: 1.2em;
            border: 2px solid #007BFF;
            padding: 10px;
            border-radius: 5px;
            width: 300px;
            background-color: #222;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.4);
        }
        a:hover, input[type="submit"]:hover {
            text-decoration: underline;
            background-color: #007BFF;
            color: white;
            box-shadow: 0 8px 16px rgba(0, 0, 0, 0.8);
        }
        .hidden {
            display: none !important;
        }


            h1 {
              font-size: 24px;
              margin-bottom: 20px;
              color: #FFFFFF; /* Weiß */
            }
            h2 {
              font-size: 20px;
              color: #FFFFFF; /* Weiß */
              margin-bottom: 20px;
            }
            input[type="file"] {
              margin-bottom: 10px;
              padding: 10px; /* Größerer Button */
              font-size: 16px; /* Größerer Text */
              border: 1px solid #ccc;
              border-radius: 4px;
              cursor: pointer;
              background-color: #4CAF50;
              color: white;
            }
            input[type="submit"], input[type="button"] {
              background-color: #4CAF50;
              color: white;
              padding: 10px 20px;
              border: none;
              border-radius: 4px;
              cursor: pointer;
              margin-top: 10px; /* Abstand nach oben */
              font-size: 16px; /* Größerer Text */
            }
            input[type="submit"]:hover, input[type="button"]:hover {
              background-color: #45a049;
            }
            input[type="password"] {
              padding: 10px;
              margin-bottom: 10px;
              border: 1px solid #ccc;
              border-radius: 4px;
            }
            .tooltip {
              position: relative;
              display: inline-block;
            }
            .tooltip .tooltiptext {
              visibility: hidden;
              width: 220px;
              background-color: #666;
              color: #fff;
              text-align: center;
              border-radius: 5px;
              padding: 5px 0;
              position: absolute;
              z-index: 1;
              bottom: 125%;
              left: 50%;
              margin-left: -110px;
              opacity: 0;
              transition: opacity 0.3s;
            }
            .tooltip:hover .tooltiptext {
              visibility: visible;
              opacity: 1;
            }
            #errorMessage {
              color: #FFFFFF; /* Weiß */
              font-weight: bold; /* Fett */
              display: none;
              margin-top: 10px; /* Abstand nach oben */
              font-size: 16px; /* Größere Schrift */
            }
            .hidden {
              display: none;
            }
            .progress-container {
              width: 100%;
              background-color: #f3f3f3;
              border-radius: 25px;
              margin-top: 20px;
            }
            .progress-bar {
              width: 0%;
              height: 30px;
              background-color: #4CAF50;
              text-align: center;
              line-height: 30px;
              color: white;
              border-radius: 25px;
            }
            #successMessage {
              color: green;
              display: none;
              margin-top: 20px;
            }

          #internetErrorContainer h2 {
            color: red; /* Text "Internetverbindung erforderlich" in Rot */
          }
          #internetErrorContainer p {
            color: white; /* Text "Es wird eine Internetverbindung benötigt..." in Weiß */
          }


          </style>
          <script src="{sha256_script_url}"></script> 
          <script>
            const expectedChecksum = "{spiffs_checksum}"; // Von ESP32 geladen
            const searchText = "{spiffs_text}"; // Von ESP32 geladen
          </script>
        </head>
        <body>
          <h1>Filesystem</h1>
            <div class="container hidden" id="internetErrorContainer">
              <h2>Internetverbindung erforderlich</h2>
              <p>Es wird eine Internetverbindung benötigt, um das Update durchzuführen. Bitte stellen Sie sicher, dass Ihr Gerät mit dem Internet verbunden ist.</p>
            </div>


          <div class="container" id="passwordContainer">
            <h2>Filesystem Upload</h2>
            <h3>Passwort erforderlich</h3>
            <input type="password" id="passwordInput" placeholder="Passwort eingeben">
            <input type="button" value="Bestätigen" onclick="checkPassword()">
            <p id="passwordError" style="color: red; display: none;">Falsches Passwort, bitte erneut versuchen.</p>

          </div>
          <div class="container hidden" id="updateContainer">
            <h2>SPIFFS Update</h2>
            

          <form id="updateForm" method="POST" action="/updateSPIFFS" enctype="multipart/form-data" onsubmit="return validateFile()">
              <input type="file" id="updateFile" name="update" required>
              <input type="button" value="Datei überprüfen" onclick="validateChecksumAndContent()">
              <p id="errorMessage">Bitte wählen Sie die richtige Datei aus.</p>
              <p id="validationMessage" style="display: none; color: red;"></p> 
              <input type="submit" value="Update" class="hidden" id="uploadButton">
          </form>



            <div class="progress-container hidden" id="progressContainer">
              <div class="progress-bar" id="progressBar">0%</div>
            </div>
            <p id="successMessage">Update erfolgreich! Sie werden nach Update automatisch weitergeleitet...</p>
          </div>
          <div class="container">
            <h2>File Upload</h2>
            <input type="button" value="Zur Dateiliste" onclick="window.location.href='/filelist'">
          </div>
        <script>
            function checkPassword() {
              const passwordInput = document.getElementById('passwordInput').value;
              const passwordError = document.getElementById('passwordError');
              const passwordContainer = document.getElementById('passwordContainer');
              const updateContainer = document.getElementById('updateContainer');
              
              fetch('/checkPasswordSPIFFS', {
                method: 'POST',
                headers: {
                  'Content-Type': 'application/json'
                },
                body: JSON.stringify({ password: passwordInput })
              })
              .then(response => response.json())
              .then(data => {
                if (data.success) {
                  passwordContainer.classList.add('hidden');
                  updateContainer.classList.remove('hidden');
                } else {
                  passwordError.style.display = 'block';
                  if (data.message) {
                    passwordError.textContent = data.message; // Zeigt die Warnung oder Sperrmeldung an
                  } else {
                    passwordError.textContent = "Falsches Passwort, bitte erneut versuchen.";
                  }
                }
              })
              .catch(error => {
                console.error('Fehler beim Überprüfen des Passworts:', error);
              });
            }


            document.addEventListener('DOMContentLoaded', function() {
                const uploadButton = document.getElementById('uploadButton');
                uploadButton.classList.add('hidden');
            });



            function validateChecksumAndContent() {
                const fileInput = document.getElementById('updateFile');
                const errorMessage = document.getElementById('errorMessage');
                const validationMessage = document.getElementById('validationMessage');
                const uploadButton = document.getElementById('uploadButton');
                const file = fileInput.files[0];

                const reader = new FileReader();
                reader.onload = function(event) {
                    const fileContent = event.target.result;

                    // Checksumme überprüfen
                    const shaObj = new jsSHA("SHA-256", "ARRAYBUFFER");
                    shaObj.update(fileContent);
                    const fileChecksum = shaObj.getHash("HEX");

                    if (fileChecksum !== expectedChecksum) {
                        errorMessage.textContent = "Die Datei ist nicht zugelassen.";
                        errorMessage.style.display = 'block';
                        validationMessage.textContent = "Checksumme stimmt nicht überein";
                        validationMessage.style.display = 'block';
                        validationMessage.style.color = 'red'; // Deutliche Farbe
                        uploadButton.classList.add('hidden');
                        console.log("Checksumme stimmt nicht überein");
                        return;
                    }

                    // Dateiinhalt überprüfen
                    const fileText = new TextDecoder().decode(fileContent);
                    if (!fileText.includes(searchText)) {
                        errorMessage.textContent = "Die Datei enthält nicht den erwarteten Text.";
                        errorMessage.style.display = 'block';
                        validationMessage.textContent = "Text nicht gefunden";
                        validationMessage.style.display = 'block';
                        validationMessage.style.color = 'red'; // Deutliche Farbe
                        uploadButton.classList.add('hidden');
                        console.log("Text nicht gefunden");
                        return;
                    }

                    errorMessage.style.display = 'none';
                    validationMessage.textContent = "Checksumme und Inhalt stimmen überein";
                    validationMessage.style.display = 'block';
                    validationMessage.style.color = 'green'; // Erfolgsanzeige
                    uploadButton.classList.remove('hidden');
                    console.log("Checksumme und Inhalt stimmt überein");
                };
                reader.readAsArrayBuffer(file);
            }



            const form = document.getElementById('updateForm');
            form.addEventListener('submit', function(event) {
              event.preventDefault();
              const formData = new FormData(form);
              const xhr = new XMLHttpRequest();
              const progressBar = document.getElementById('progressBar');
              const progressContainer = document.getElementById('progressContainer');
              const successMessage = document.getElementById('successMessage');
              progressContainer.classList.remove('hidden');

              xhr.upload.addEventListener('progress', function(e) {
                if (e.lengthComputable) {
                  const percentComplete = (e.loaded / e.total) * 100;
                  progressBar.style.width = percentComplete + '%';
                  progressBar.textContent = Math.round(percentComplete) + '%';
                }
              });

              xhr.addEventListener('load', function() {
                if (xhr.status == 200) {
                  successMessage.style.display = 'block';
                  setTimeout(function() {
                    window.location.href = '/';
                  }, 3000);
                } else {
                  alert('Update fehlgeschlagen!');
                }
              });

              xhr.open('POST', '/updateSPIFFS');
              xhr.send(formData);
              setTimeout(function() {
                window.location.href = '/';
              }, 3000);
            });
          </script>
          <br>
          <a href="/index" class="back-link">Zur&uuml;ck</a>
        </body>

        </html>
                
            )rawliteral";










     // void handle_mqtt()       mqtt_html_template[] PROGMEM          server3.on("/save_mqtt_settings
 const char mqtt_html_template[] PROGMEM = R"rawliteral(
    <!DOCTYPE html>
    <html>
    <head>
      <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
       <meta charset="UTF-8">
      <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
      <meta http-equiv="Pragma" content="no-cache">
      <meta name='viewport' content='width=device-width, initial-scale=1'/>
      <meta name="author" content="Gebauer Holger, https://www.auto-steuerung.de/">
      <title>MQTT {device_id}</title>

      <style>
        #status-bar {
          width: 100%;
          height: 10px;
          position: fixed;
          top: 0;
          left: 0;
        }
        .green {
          background-color: #28a745; /* Grün */
        }
        .red {
          background-color: #dc3545; /* Rot */
        }

        html, body { 
                font-family: Arial, sans-serif; 
                text-align: center; 
                padding: 15px 6px; 
                background-color: black; 
                color: white; 
                width: 94%;
              }
        h1 { color: #fff; }
        p { color: #ccc; }
        a {
          display: block;
          margin: 10px auto;
          color: #007BFF;
          text-decoration: none;
          font-weight: bold;
          font-size: 1.2em;
          border: 2px solid #007BFF;
          padding: 10px;
          border-radius: 5px;
          width: 300px;
          background-color: #222;
          box-shadow: 0 4px 8px rgba(0, 0, 0, 0.4);
        }
        a:hover {
          text-decoration: underline;
          background-color: #007BFF;
          color: white;
          box-shadow: 0 8px 16px rgba(0, 0, 0, 0.8);
        }
            .container {
              display: flex;
              justify-content: center;
              align-items: flex-start;
              min-height: 100vh;
              padding: 10px;
              margin: 0 auto;

            }

        .form-container {
          width: 100%;
          max-width: 800px; 
          padding: 20px;
          background-color: #222;
          border: 1px solid #ddd;
          border-radius: 8px;
          box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
          margin: 0 auto; 
        }

        .back-link {
          display: block;
          margin: 10px auto;
          color: #007BFF;
          text-decoration: none;
          font-weight: bold;
          font-size: 1.2em;
          border: 2px solid #007BFF;
          padding: 10px;
          border-radius: 5px;
          width: 150px; 
          background-color: #222;
          box-shadow: 0 4px 8px rgba(0, 0, 0, 0.4);
          text-align: center; 
        }
        .back-link:hover {
          text-decoration: underline;
          background-color: #007BFF;
          color: white;
          box-shadow: 0 8px 16px rgba(0, 0, 0, 0.8);
        }

        table {
          margin: 20px auto;
          border-collapse: collapse;
          width: 80%;
          background-color: #222;
          color: white;
        }
        th, td {
          border: 1px solid #777;
          padding: 10px;
          text-align: center;
        }
        th {
          background-color: #0056b3;
          text-align: center;
        }

         .form-table {
            width: 96%; 
            margin: auto; 

              max-width: 6080px;
              margin: auto;
              background-color: #f9f9f9;
              border: 1px solid #ddd;
              padding: 20px;
              border-radius: 8px;
              color: black; 
          }

            .form-table td {
              padding: 10px;
            }
            .form-table input[type="date"],
            .form-table input[type="time"],
            .form-table select {
              width: 100%;
              padding: 10px;
              border: 1px solid #ccc;
              border-radius: 4px;
              box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.1);
              text-align: center; 
              font-size: 16px;
              -webkit-appearance: none; 
            }
            .form-table th, .form-table td {
              text-align: left;
            }
            .form-table th {
              background-color: #f1f1f1;
              padding: 10px;
            }

        input[type="text"], input[type="password"], input[type="number"] {
          width: 100%;
          padding: 8px;
          margin: 5px 0;
          box-sizing: border-box;
          border: none;
          background-color: #333;
          color: white;
        }
        input[type="submit"] {
          width: auto;
          padding: 8px 16px;
          background-color: #007BFF;
          color: white;
          border: none;
          border-radius: 5px;
          cursor: pointer;
        }
        input[type="submit"]:hover {
          background-color: #0056b3;
        }

        .wide-input {
          width: 240px !important;
        }


    /* Tooltip-Stil */
.tooltip {
  position: relative;
  display: inline-block;
}
.tooltip .tooltiptext {
  visibility: hidden;
  width: 220px;
  background-color: #666;
  color: #fff;
  text-align: center;
  border-radius: 5px;
  padding: 5px;
  position: absolute;
  z-index: 1;
  bottom: 125%; /* Positioniert den Tooltip oberhalb des Textfelds */
  left: 50%;
  margin-left: -60px;
  opacity: 0;
  transition: opacity 0.3s;
}
.tooltip:hover .tooltiptext {
  visibility: visible;
  opacity: 1;
}
.password-container {
    position: relative;
    display: inline-block;
}
.password-container input[type="password"], .password-container input[type="text"] {
    width: 100%;
    padding-right: 30px; /* Platz für das Auge-Symbol */
    box-sizing: border-box; /* Beinhaltet Padding in der Breite */
}
.toggle-password {
    position: absolute;
    right: 10px;
    top: 50%;
    transform: translateY(-50%);
    cursor: pointer;
}

        .switch {
          position: relative;
          display: inline-block;
          width: 60px;
          height: 30px;
        }
        .switch input {
          opacity: 0;
          width: 0;
          height: 0;
        }
        .slider {
          position: absolute;
          cursor: pointer;
          top: 0;
          left: 0;
          right: 0;
          bottom: 0;
          background-color: #ccc;
          transition: .4s;
        }
        .slider:before {
          position: absolute;
          content: "";
          height: 24px;
          width: 24px;
          left: 3px;
          bottom: 3px;
          background-color: white;
          transition: .4s;
        }
        input:checked + .slider {
          background-color: #2196F3;
        }
        input:checked + .slider:before {
          transform: translateX(26px);
        }
        .slider:after {
          content: 'OFF';
          color: white;
          display: block;
          position: absolute;
          transform: translate(-50%,-50%);
          top: 50%;
          left: 70%;
          font-size: 10px;
          font-family: Verdana, sans-serif;
        }
        input:checked + .slider:after {
          left: 25%;
          content: 'ON';
        }
    @media (max-width: 800px) {
      .container {
        width: 100%;
        padding: 0;
        margin: 0;
      }

      .form-container {
        width: 100%;
        max-width: none;
        padding: 10px;
        margin: 0;
      }

      .form-table {
        width: 95%;
        margin: 0;
      }
    }
      /* Erweitere Eingabefelder nur auf größeren Bildschirmen */
      @media (min-width: 600px) {
        .wide-input {
          width: 300px; /* Breite für größere Bildschirme */
        }
      }


      </style>
<script>

        function togglePassword(id) {
            var input = document.getElementById(id);
            if (input.type === "password") {
                input.type = "text";
            } else {
                input.type = "password";
            }
        }

    let isNavigating = false;

    // Setze den Indikator beim Seitenwechsel innerhalb der Anwendung
    document.querySelectorAll('a').forEach(function(anchor) {
        anchor.addEventListener('click', function(event) {
            isNavigating = true;
        });
    });

    // Überprüfe Sichtbarkeitswechsel des Dokuments
    document.addEventListener('visibilitychange', function() {
        if (document.visibilityState === 'hidden' && !isNavigating && isConnected) {
            console.log('Sending browser_closed message via visibilitychange');
            ws.send('browser_closed');
            setTimeout(() => ws.close(), 100);  // Verzögerung hinzugefügt
        }
    });

    window.addEventListener('unload', function(event) {
        if (!isNavigating && isConnected) {
            console.log('Sending browser_closed message via unload');
            ws.send('browser_closed');
        }
    });

    let checkCounter = 0;

    function checkServerStatus() {
        fetch('/serverStatus')
            .then(response => response.json())
            .then(data => {
                const statusBar = document.getElementById('status-bar');
                if (data.serverRunning) {
                    statusBar.classList.add('green');
                    statusBar.classList.remove('red');
                    checkCounter = 0; // Reset the counter if the server is running
                } else {
                    checkCounter++;
                    if (checkCounter >= 3) {
                        statusBar.classList.add('red');
                        statusBar.classList.remove('green');
                    }
                }
            })
            .catch(error => {
                checkCounter++;
                const statusBar = document.getElementById('status-bar');
                if (checkCounter >= 3) {
                    statusBar.classList.add('red');
                    statusBar.classList.remove('green');
                }
            });
    }

    function checkPassword() {
        const password = prompt('Bitte Passwort eingeben:');
        return fetch('/checkPassword', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({ password: password })
        })
        .then(response => response.json())
        .then(data => {
            if (!data.success) {
                alert('Falsches Passwort');
                return false;
            }
            return true;
        })
        .catch(error => {
            console.error('Error checking password:', error);
            return false;
        });
    }

    function confirmReboot(confirm) {
        document.getElementById('confirmationModal').style.display = 'none';
        document.getElementById('modalOverlay').style.display = 'none';

        if (confirm) {
            checkPassword().then(success => {
                if (success) {
                    document.querySelector('form').submit();  // Führt das Speichern durch, wenn das Passwort korrekt ist
                }
            });
        }
    }

    // WebSocket Setup
    var ws = new WebSocket('ws://' + window.location.hostname + ':81/');
    var isConnected = false;

    ws.onopen = function() {
        isConnected = true;
        console.log('WebSocket connection established');
    };

    ws.onclose = function(event) {
        isConnected = false;
        console.log('WebSocket connection closed', event);
    };

    ws.onerror = function(error) {
        isConnected = false;
        console.log('WebSocket error:', error);
    };

    // Initial Checks
    window.onload = function() {
        checkServerStatus();
        setInterval(checkServerStatus, 5000); // Überprüft den Serverstatus alle 5 Sekunden
        const form = document.querySelector('form');
        form.onsubmit = function(event) {
            event.preventDefault();  // Verhindert das Standardverhalten des Formulars
            document.getElementById('confirmationModal').style.display = 'block';
            document.getElementById('modalOverlay').style.display = 'block';
        };
    };
</script>



    </head>
    <body>
      <div id="status-bar" class="green"></div>
  <div class="container">
  <div class="form-container">
      <h1>MQTT Funktionen</h1>
      <form method="POST" action="/save_mqtt_settings">
        <table class="form-table">

          <tr>
            <td><b>Aktueller Topic</b></td>
            <td><div class="tooltip"><input type="text" name="mqtt_topic" maxlength="50" value="{mqtt_topic}" class="wide-input"><span class="tooltiptext">Radon Topic Beispiel: radonvalue/feeds/radon.radon</span></div> </td>
          </tr>
          <tr>
            <td><b>Server</b></td>
            <td><div class="tooltip"><input type="text" name="mqtt_server" maxlength="40" value="{mqtt_server}" class="wide-input"><span class="tooltiptext">MQTT Server Beispiel: io.adafruit.com</span></div></td>
          </tr>
        <tr>
            <td><b>Client</b></td>
            <td>
                <div class="tooltip">
                    <input type="text" name="mqtt_client" maxlength="48" value="{mqtt_client}" class="wide-input">
                    <span class="tooltiptext">Client/Think Key Beispiel: hg7645DwOKn48f4s10drTzl3</span>
                </div>
            </td>
        </tr>
            <td><b>Benutzer</b></td>
            <td><div class="tooltip"><input type="text" name="mqtt_user" maxlength="40" value="{mqtt_user}" class="wide-input"><span class="tooltiptext">User/Token Beispiel: radonvalue</span></div></td>
          </tr>
          <tr>
              <td><b>Passwort</b></td>
              <td>
                  <div class="password-container tooltip">
                      <input type="password" id="mqtt_pass" name="mqtt_pass" maxlength="40" value="{mqtt_pass}" class="wide-input">
                      <span class="toggle-password" onclick="togglePassword('mqtt_pass')">👁️</span>
                  </div>
              </td>
          </tr>
          <tr>
            <td><b>Port</td>
            <td><div class="tooltip"><input type="number" name="mqtt_port" maxlength="4" value="{mqtt_port}" class="wide-input"><span class="tooltiptext">Port Beispiel: 1883</span></div></td>
          </tr>
          <tr>
            <td><b>MQTT Status</b></td>
            <td>
              <label class="switch">
                <input type="checkbox" name="mqtt_status" id="mqttSwitch" {mqtt_status_checked}>
                <span class="slider"></span>
              </label>
            </td>
          </tr>
        </table>
        <br>
        <input type="submit" value="Speichern">
      </form>
      <br>
      <a href="/index" class="back-link">Zur&uuml;ck</a>
      
      <div id="confirmationModal" style="display:none; position:fixed; top:50%; left:50%; transform:translate(-50%, -50%); background-color:#222; color:#fff; padding:20px; border-radius:5px; box-shadow:0 4px 8px rgba(0, 0, 0, 0.4); z-index:1000;">
        <p>Das Gerät wird neu gestartet. Möchten Sie fortfahren?</p>
        <button onclick="confirmReboot(true)">Ja</button>
        <button onclick="confirmReboot(false)">Nein</button>
      </div>
      <div id="modalOverlay" style="display:none; position:fixed; top:0; left:0; width:100%; height:100%; background-color:rgba(0, 0, 0, 0.5); z-index:999;"></div>
    </div>
  </div>
    </body>

          </html>
      )rawliteral";









void handleFileUpload() {
    HTTPUpload& upload = server3.upload();

    if (upload.status == UPLOAD_FILE_START) {
        String filename = "/" + upload.filename;
        if (filename == "/") {
            // Keine Datei ausgewählt
            server3.send(400, "text/plain", "Keine Datei ausgew&auml;hlt. Bitte w&auml;hlen Sie eine Datei aus und versuchen Sie es erneut.");
            Serial.println("Keine Datei ausgew&auml;hlt. Upload abgebrochen.");
            return;
        }
        if (!filename.startsWith("/")) filename = "/" + filename;
        Serial.print("Hochladen von Datei: ");
        Serial.println(filename);
        fsUploadFile = SPIFFS.open(filename, FILE_WRITE);
        if (!fsUploadFile) {
            Serial.println("Fehler beim &Ouml;ffnen der Datei zum Schreiben");
        }
    } else if (upload.status == UPLOAD_FILE_WRITE) {
        if (fsUploadFile) fsUploadFile.write(upload.buf, upload.currentSize);
    } else if (upload.status == UPLOAD_FILE_END) {
        if (fsUploadFile) {
            fsUploadFile.close();
            Serial.print("Datei hochgeladen: ");
            Serial.println(upload.filename);
        }
    } else if (upload.status == UPLOAD_FILE_ABORTED) {
        if (fsUploadFile) {
            fsUploadFile.close();
            Serial.println("Datei-Upload abgebrochen");
        }
    }
}










    //----------------------------------------------------------------------
      // Funktion zum Auflisten der Dateien im SPIFFS
      String listFiles() {
          String html = "<table><tr><th>Dateiname</th><th>Gr&ouml;&szlig;e</th><th>Dateityp</th></tr>";
          File root = SPIFFS.open("/");
          if (!root) {
              Serial.println("Fehler beim Öffnen des Root-Verzeichnisses");
              return "";
          }
          if (!root.isDirectory()) {
              Serial.println("Root ist kein Verzeichnis");
              return "";
          }
          File file = root.openNextFile();
          int fileCount = 0;
          float totalSizeKB = 0.0;
          const float totalSizeMB = 5.06; // Gesamtgröße des SPIFFS-Partitions in MB

          Serial.println("Dateien im SPIFFS:");

          while (file) {
              String fileName = file.name();
              size_t fileSize = file.size();
              String fileType = "Unbekannt";

              if (fileName.endsWith(".txt")) fileType = "Textdatei";
              else if (fileName.endsWith(".html")) fileType = "HTML-Datei";
              else if (fileName.endsWith(".jpg") || fileName.endsWith(".jpeg")) fileType = "JPEG-Bild";
              else if (fileName.endsWith(".png")) fileType = "PNG-Bild";
              else if (fileName.endsWith(".js")) fileType = "JavaScript-Datei";
              else if (fileName.endsWith(".css")) fileType = "Style-Sheets";
              else if (fileName.endsWith(".ico")) fileType = "Favoriten-Icon";
              else if (fileName.endsWith(".csv")) fileType = "CSV-Datei";
              else if (fileName.endsWith(".bin")) fileType = "Firmware-Datei";

              float fileSizeKB = fileSize / 1024.0; // Größe in Kilobyte berechnen
              totalSizeKB += fileSizeKB;
              fileCount++;
              
              Serial.print("Dateiname: ");
              Serial.println(fileName);
              Serial.print("Größe: ");
              Serial.print(fileSizeKB, 2);
              Serial.println(" KB");
              Serial.print("Dateityp: ");
              Serial.println(fileType);
              
              html += "<tr><td>" + fileName + "</td><td>" + String(fileSizeKB, 2) + " KB</td><td>" + fileType + "</td></tr>";
              file = root.openNextFile();
          }

          float totalSizeMBUsed = totalSizeKB / 1024.0; // Gesamtgröße in MB berechnen
          float freeSpaceMB = totalSizeMB - totalSizeMBUsed; // Freier Speicherplatz in MB
          float freeSpacePercent = (freeSpaceMB / totalSizeMB) * 100; // Freier Speicherplatz in %

          html += "</table>";
          html += "<p>Anzahl der Dateien: " + String(fileCount) + "</p>";
          html += "<p>Gesamtgr&ouml;&szlig;e: " + String(totalSizeMBUsed, 2) + " MB</p>";
          html += "<p>Freier Speicherplatz: " + String(freeSpacePercent, 2) + "%</p>";

          Serial.print("Anzahl der Dateien: ");
          Serial.println(fileCount);
          Serial.print("Gesamtgröße: ");
          Serial.print(totalSizeMBUsed, 2);
          Serial.println(" MB");
          Serial.print("Freier Speicherplatz: ");
          Serial.print(freeSpacePercent, 2);
          Serial.println("%");

          return html;
      }

   //----------------------------------------


void handleFileList() {
  if (!isAuthenticated()) {
    return;
  }
  server3.sendHeader("Cache-Control", "no-cache, no-store, must-revalidate");
  server3.sendHeader("Pragma", "no-cache");
  server3.sendHeader("Expires", "-1");
  String html = R"rawliteral(
    <!DOCTYPE html>
    <html>
    <head>
      <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
      <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
      <meta http-equiv="Pragma" content="no-cache">
      <meta name='viewport' content='width=device-width, initial-scale=1'/>
      <meta name="author" content="Gebauer Holger, https://www.auto-steuerung.de/">
      <title>Dateibrowser {device_id}</title>
      <style>
        body { font-family: Arial, sans-serif; text-align: center; padding: 10px 50px; background-color: black; color: white; }
        h1 { color: #fff; border: 2px solid white; padding: 10px; }
        h2 { color: #fff; }
        p { color: #ccc; }
        a {
          display: block;
          margin: 10px auto;
          color: #007BFF;
          text-decoration: none;
          font-weight: bold;
          font-size: 1.2em;
          border: 2px solid #007BFF;
          padding: 10px;
          border-radius: 5px;
          width: 300px;
          background-color: #222;
          box-shadow: 0 4px 8px rgba(0, 0, 0, 0.4);
        }
        a:hover {
          text-decoration: underline;
          background-color: #007BFF;
          color: white;
          box-shadow: 0 8px 16px rgba(0, 0, 0, 0.8);
        }

        .status-ok {
          background-color: #28a745;
        }
        .status-nok {
          background-color: #dc3545;
        }
        table {
          margin: 20px auto;
          border-collapse: collapse;
          width: 80%;
          background-color: #222;
          color: white;
        }
        th, td {
          border: 1px solid #777;
          padding: 10px;
          text-align: center;
        }
        th {
          background-color: #0056b3;
        }
        .upload-container {
          border: 2px solid white;
          padding: 20px;
          border-radius: 10px;
          display: inline-block;
        }
      </style>
    </head>
    <body>
      <div class="upload-container">
        <h1>Datei hochladen</h1>
        <form method="POST" action="/upload" enctype="multipart/form-data">
          <input type="file" name="file">
          <input type="submit" value="Hochladen">
        </form>
      </div>
      <h1>Dateiliste</h1>
      )rawliteral";
  html += listFiles();
  html += R"rawliteral(
       <a href="/index">Zur&uuml;ck</a>
    </body>
    </html>
  )rawliteral";
  server3.send(200, "text/html", html);
}


//----------------------------------------------------------------------



void replacePlaceholder(const char* source, char* dest, const char* placeholder, const char* value, size_t destSize) {
    const char* pos = strstr(source, placeholder);
    if (pos == nullptr) {
        strncpy(dest, source, destSize);
        return;
    }

    size_t prefixLen = pos - source;
    size_t valueLen = strlen(value);
    size_t placeholderLen = strlen(placeholder);
    size_t totalLen = prefixLen + valueLen + strlen(pos + placeholderLen);

    if (totalLen >= destSize) {
        // Fallback: Puffer nicht groß genug, um den ersetzten String aufzunehmen
        strncpy(dest, source, destSize - 1);
        dest[destSize - 1] = '\0';
        return;
    }

    strncpy(dest, source, prefixLen);
    strncpy(dest + prefixLen, value, valueLen);
    strcpy(dest + prefixLen + valueLen, pos + placeholderLen);
}






  
      //-------------------------------
     void handleNotFound() {
        
        isUserOnModbusPage = false;
        isUserOnKNXPage = false;
        isUserOnSensorPage = false;
        isBleOnSensorPage = false;
        
        Serial.println("handleNotFound -> ");
        String message = "File Not Found\n\n";
        message += "URI: ";
        message += server3.uri();
        message += "\nMethod: ";
        message += (server3.method() == HTTP_GET) ? "GET" : "POST";
        message += "\nArguments: ";
        message += server3.args();
        message += "\n";

        for (uint8_t i = 0; i < server3.args(); i++) {
          message += " " + server3.argName(i) + ": " + server3.arg(i) + "\n";
        }
        
          server3.send(404, "text/plain", message);

     }
      //-------------------------------


        //-------------------------------------------------------------------
        // Funktion zur Umwandlung des Wochentags in einen String
        /*
        String getDayOfWeek(int day) {
          switch (day) {
            case 0: return "Sonntag";
            case 1: return "Montag";
            case 2: return "Dienstag";
            case 3: return "Mittwoch";
            case 4: return "Donnerstag";
            case 5: return "Freitag";
            case 6: return "Samstag";
            default: return "";
          }
        }
         */
        // Funktion zur Umwandlung des Wochentags in einen char-Array (String)
        const char* getDayOfWeek(int day) {
            static const char* daysOfWeek[] = {
                "Sonntag", "Montag", "Dienstag", "Mittwoch", "Donnerstag", "Freitag", "Samstag"
            };
            if (day >= 0 && day < 7) {
                return daysOfWeek[day];
            }
            return "";
        }

        //------------------------------------------------------------------





#ifndef Firmware_backup
void handle_cloud() {
    

    isUserOnModbusPage = false;
    isUserOnKNXPage = false;
    isUserOnSensorPage = false;
    isBleOnSensorPage = false;

    #ifndef use_psram_flash
    String html = FPSTR(cloud_html_template);
    Preferences preferences;
    preferences.begin("eenvs", false);                         //Ordner eenvs anlegen/verwenden
    html.replace("{cloud_server}", preferences.getString("p_clserv", "radoncloud.com"));
    html.replace("{cloud_page}", preferences.getString("p_clpage", "LoRaWAN-Live-Link-K1-W33rt22bd11np00L/lora_radon.php"));
    html.replace("{cloud_pre}", preferences.getString("p_clpre", "submit=Daten"));
    html.replace("{cloud_chain}", preferences.getString("p_clchain", "&p"));
    html.replace("{cloud_status_checked}", preferences.getUChar("g_cloud_ea", 0) ? "checked" : "");
    html.replace("{device_id}", String(device_id_c));
    preferences.end();
    server3.send(200, "text/html", html);
    #endif

   #ifdef use_psram_flash
    char* html = allocateHtmlInPSRAM(cloud_html_template);
    if (!html) {
        Serial.println("Fehler beim Zuordnen von PSRAM");
        server3.send(500, "text/plain", "Serverfehler");
        return;
    }

    
    // Werte aus preferences ersetzen
    Preferences preferences;
    preferences.begin("eenvs", false);  // Ordner eenvs anlegen/verwenden
    String htmlString = String(html);
    htmlString.replace("{cloud_server}", preferences.getString("p_clserv", "radoncloud.com"));
    htmlString.replace("{cloud_page}", preferences.getString("p_clpage", "LoRaWAN-Live-Link-K1-W33rt22bd11np00L/lora_radon.php"));
    htmlString.replace("{cloud_pre}", preferences.getString("p_clpre", "submit=Daten"));
    htmlString.replace("{cloud_chain}", preferences.getString("p_clchain", "&p"));
    htmlString.replace("{cloud_status_checked}", preferences.getUChar("g_cloud_ea", 0) ? "checked" : "");
    htmlString.replace("{device_id}", String(device_id_c));
    preferences.end();

    server3.send(200, "text/html", htmlString);

    free(html); // PSRAM freigeben
    #endif
}
#endif

#ifndef Firmware_backup
void handle_modbus() {
   
    isUserOnModbusPage = true;
    isUserOnKNXPage = false;
    isUserOnSensorPage = false;
    isBleOnSensorPage = false;
   
    #ifndef use_psram_flash
    String html = modbus_html_template;

    // Werte aus Variablen ersetzen
    html.replace("{mb_radon_live_32bit}", String(mb_radon_live_32bit) + " Bq/m&sup3;");
    html.replace("{radon_mittelwert_24h}", String(radon_mittelwert_24h) + " Bq/m&sup3;");
    html.replace("{radon_mittelwert_long}", String(radon_mittelwert_long) + " Bq/m&sup3;");
    html.replace("{mb_radon_save_eintrarge}", String(mb_radon_save_eintrarge));
    html.replace("{device_id}", String(device_id_c));
    
    // Netzwerkdetails ersetzen
    html.replace("{ip_address}", WiFi.localIP().toString());

    server3.send(200, "text/html", html);
   
    #endif


    #ifdef use_psram_flash
    char* html = allocateHtmlInPSRAM(modbus_html_template);
    if (!html) {
        Serial.println("Fehler beim Zuordnen von PSRAM");
        server3.send(500, "text/plain", "Serverfehler");
        return;
    }



    // Werte aus Variablen ersetzen
    String htmlString = String(html);
    htmlString.replace("{mb_radon_live_32bit}", String(mb_radon_live_32bit) + " Bq/m&sup3;");
    htmlString.replace("{radon_mittelwert_24h}", String(radon_mittelwert_24h) + " Bq/m&sup3;");
    htmlString.replace("{radon_mittelwert_long}", String(radon_mittelwert_long) + " Bq/m&sup3;");
    htmlString.replace("{mb_radon_save_eintrarge}", String(mb_radon_save_eintrarge));
    htmlString.replace("{device_id}", String(device_id_c));
    htmlString.replace("{ip_address}", WiFi.localIP().toString());

    server3.send(200, "text/html", htmlString);
   
    free(html); // PSRAM freigeben
 
   #endif


}
#endif


  //  void webSocketEvent(    sendData()    const char sensor_html_template[]   handle_sensor()
#ifndef aktivate_psram_flash

  #ifndef Firmware_backup  
  void handle_sensor() {
      
      isUserOnSensorPage = true;
      isUserOnModbusPage = false;
      isUserOnKNXPage = false;
      isBleOnSensorPage = false;

      String html = FPSTR(sensor_html_template);

      // Basierend auf s_Color den imageStatus setzen
      switch (s_Color) {
          case 2:
              imageStatus = 1; // Grün
              break;
          case 5:
              imageStatus = 2; // Orange
              break;
          case 1:
              imageStatus = 0; // Rot
              break;
          case 4:
              imageStatus = 3; // weiss
              break;
          case 0:
              imageStatus = 4; // grau
              break;
          case 3:
              imageStatus = 5; // blau
              break;
          case 6:
              imageStatus = 4; // lila  6
              break;
          default:
              imageStatus = 4; // grau
              break;
      }

      esp_task_wdt_reset();
      // Ermitteln des aktuellen Bildpfads
      String imagePath;
      switch (imageStatus) {
          case 0:
              imagePath = "/Sensor_rot.jpg";
              break;
          case 1:
              imagePath = "/Sensor_gruen.jpg";
              break;
          case 2:
              imagePath = "/Sensor_orange.jpg";
              break;
          case 3:
              imagePath = "/Sensor_weiss.jpg";
              break;
          case 4:
              imagePath = "/Sensor_grau.jpg";
              break;
          case 5:
              imagePath = "/Sensor_blau.jpg";
              break;
          default:
              imagePath = "/Sensor_grau.jpg";
              break;
      }
      esp_task_wdt_reset();

      // Wenn KNX aktiviert ist, setze das Bild basierend auf dem digitalen Lesen
      if (g_LEDT_T_KNX == 1) {
          if (digitalRead(20)) {
              imagePath = "/Sensor_rot.jpg";
          } else {
              imagePath = "/Sensor_grau.jpg";
          }
      }

      // Debugging: Serielle Ausgabe des aktuellen Bildpfads
      //Serial.println("Aktuelles Bild: " + imagePath);

      // HTML-Vorlage mit aktuellem Bildpfad und Zeitvariablen ersetzen
      html.replace("{sensorImage}", imagePath);
      html.replace("{currentSec}", String(currentSec));
      html.replace("{currentMin}", String(currentmin));
      html.replace("{currentHour}", String(v_currenthour));
      html.replace("{device_id}", String(device_id_c));

      // Senden der HTML-Seite
      server3.send(200, "text/html", html);

  }
  #endif

#else
 

  //#ifndef use_psram_flash
    void handle_sensor() {
        char* html = allocateHtmlInPSRAM(sensor_html_template);
        if (!html) {
            Serial.println(F("Fehler beim Zuordnen von PSRAM"));
            server3.send(500, F("text/plain"), F("Serverfehler"));
            return;
        }

        isUserOnSensorPage = true;
        isUserOnModbusPage = false;
        isUserOnKNXPage = false;
        isBleOnSensorPage = false;

        // Basierend auf s_Color den imageStatus setzen
        switch (s_Color) {
            case 2:
                imageStatus = 1; // Grün
                break;
            case 5:
                imageStatus = 2; // Orange
                break;
            case 1:
                imageStatus = 0; // Rot
                break;
            case 4:
                imageStatus = 3; // weiss
                break;
            case 0:
                imageStatus = 4; // grau
                break;
            case 3:
                imageStatus = 5; // blau
                break;
            case 6:
                imageStatus = 4; // lila
                break;
            default:
                imageStatus = 4; // grau
                break;
        }

        esp_task_wdt_reset();
        // Ermitteln des aktuellen Bildpfads
        const char* imagePath;
        switch (imageStatus) {
            case 0:
                imagePath = "/Sensor_rot.jpg";
                break;
            case 1:
                imagePath = "/Sensor_gruen.jpg";
                break;
            case 2:
                imagePath = "/Sensor_orange.jpg";
                break;
            case 3:
                imagePath = "/Sensor_weiss.jpg";
                break;
            case 4:
                imagePath = "/Sensor_grau.jpg";
                break;
            case 5:
                imagePath = "/Sensor_blau.jpg";
                break;
            default:
                imagePath = "/Sensor_grau.jpg";
                break;
        }
        esp_task_wdt_reset();

        // Wenn KNX aktiviert ist, setze das Bild basierend auf dem digitalen Lesen
        if (g_LEDT_T_KNX == 1) {
            if (digitalRead(20)) {
                imagePath = "/Sensor_rot.jpg";
            } else {
                imagePath = "/Sensor_grau.jpg";
            }
        }

        // Debugging: Serielle Ausgabe des aktuellen Bildpfads
        Serial.print(F("Aktuelles Bild: "));
        Serial.println(imagePath);

        // HTML-Vorlage mit aktuellem Bildpfad und Zeitvariablen ersetzen
        String htmlString = String(html);
        htmlString.replace(F("{sensorImage}"), imagePath);
        htmlString.replace(F("{currentSec}"), String(currentSec));
        htmlString.replace(F("{currentMin}"), String(currentmin));
        htmlString.replace(F("{currentHour}"), String(v_currenthour));
        htmlString.replace(F("{device_id}"), String(device_id_c));

        // Senden der HTML-Seite
        server3.send(200, F("text/html"), htmlString);

        free(html); // PSRAM freigeben
    }

  #endif











    // void handle_mqtt()       mqtt_html_template[] PROGMEM          server3.on("/save_mqtt_settings
    #ifndef use_psram_flash
      #ifndef Firmware_backup
      void handle_mqtt() {
          String html = FPSTR(mqtt_html_template);

          // Werte aus preferences ersetzen
          Preferences preferences;
          preferences.begin("eenvs", false);                         //Ordner eenvs anlegen/verwenden
          bool p_mqonoff = preferences.getBool("p_mqon", false);
          html.replace("{mqtt_topic}", preferences.getString("p_mqtopic", "radonvalue/feeds/radon.radon"));
          html.replace("{mqtt_server}", preferences.getString("p_mqserv", "io.adafruit.com"));
          html.replace("{mqtt_client}", preferences.getString("p_mqclie", ""));
          html.replace("{mqtt_user}", preferences.getString("p_mquser", "radonvalue"));
          html.replace("{mqtt_port}", preferences.getString("p_mqport", "1883"));
          html.replace("{mqtt_pass}", ""); 
          html.replace("{device_id}", String(device_id_c));
          //html.replace("{mqtt_pass}", preferences.getString("p_mqpass", "0056e40b03b14156ab7d707f5104256e")); 
          html.replace("{mqtt_status_checked}", p_mqonoff ? "checked" : "");
          preferences.end();

          server3.send(200, "text/html", html);
      }
      #endif

    #endif


  #ifdef use_psram_flash
  void handle_mqtt() {
      
      
      char* html = allocateHtmlInPSRAM(mqtt_html_template);
      if (!html) {
          Serial.println("Fehler beim Zuordnen von PSRAM");
          server3.send(500, "text/plain", "Serverfehler");
          return;
      }

      // Werte aus preferences ersetzen
      Preferences preferences;
      preferences.begin("eenvs", false);  // Ordner eenvs anlegen/verwenden
      bool p_mqonoff = preferences.getBool("p_mqon", false);
      String htmlString = String(html);
      htmlString.replace("{mqtt_topic}", preferences.getString("p_mqtopic", "radonvalue/feeds/radon.radon"));
      htmlString.replace("{mqtt_server}", preferences.getString("p_mqserv", "io.adafruit.com"));
      htmlString.replace("{mqtt_client}", preferences.getString("p_mqclie", ""));
      htmlString.replace("{mqtt_user}", preferences.getString("p_mquser", "radonvalue"));
      htmlString.replace("{mqtt_port}", preferences.getString("p_mqport", "1883"));
      htmlString.replace("{mqtt_pass}", ""); 
      htmlString.replace("{device_id}", String(device_id_c));
      htmlString.replace("{mqtt_status_checked}", p_mqonoff ? "checked" : "");
      preferences.end();

      server3.send(200, "text/html", htmlString);

      free(html); // PSRAM freigeben
  }

    #endif





  //  deinPasswort2  
void handle_spiffs() {
    
    bool check_file = true;
    String sha256_script_url = "/sha256.js";

    /*
    // Überprüfen, ob die lokale Datei existiert und lesbar ist
    if (!SPIFFS.exists(sha256_script_url)) {
        Serial.println("Local file /sha256.js not found, using CDN.");
        sha256_script_url = "https://cdnjs.cloudflare.com/ajax/libs/js-sha256/0.11.0/sha256.min.js";
        check_file = false;
    } else {
        // Datei existiert, öffnen und überprüfen
        File file = SPIFFS.open(sha256_script_url, "r");
        if (!file) {
            Serial.println("Error: Unable to open /sha256.js, using CDN.");
            sha256_script_url = "https://cdnjs.cloudflare.com/ajax/libs/js-sha256/0.11.0/sha256.min.js";
            check_file = false;
        } else {
            size_t fileSize = file.size();
            if (fileSize != 9998) { // Akzeptiere Größe 9998 Bytes
                Serial.print("Error: /sha256.js has incorrect size (");
                Serial.print(fileSize);
                Serial.println(" bytes), using CDN.");
                sha256_script_url = "https://cdnjs.cloudflare.com/ajax/libs/js-sha256/0.11.0/sha256.min.js";
                check_file = false;
            } else {
                Serial.println("Local file /sha256.js is valid and will be used.");
            }
            file.close();
        }
    }
   */
    String html = FPSTR(spiffs_html_template);
    html.replace("{sha256_script_url}", sha256_script_url);
    html.replace("{spiffs_checksum}", U_sw_checksum_read);
    html.replace("{spiffs_text}", spiffs_text);
    html.replace("{device_id}", String(device_id_c));

    // Überprüfen der Internetverbindung
    //  kein Internet  und   Datei defekt
    if (!Internt_online && check_file == false) {
        html.replace("<div class=\"container hidden\" id=\"internetErrorContainer\">", "<div class=\"container\" id=\"internetErrorContainer\">");
        html.replace("<div class=\"container hidden\" id=\"updateContainer\">", "<div class=\"container hidden\" id=\"updateContainer\" style=\"display: none;\">");
    } else {
        html.replace("<div class=\"container hidden\" id=\"internetErrorContainer\">", "<div class=\"container hidden\" id=\"internetErrorContainer\" style=\"display: none;\">");
    }

    server3.send(200, "text/html", html);
}






    #ifndef Firmware_backup
    void handle_time() {
        String html = generateHTML();
        html.replace(F("{device_id}"), String(device_id_c));
        server3.send(200, F("text/html"), html);
    }
    #endif



  #ifndef use_psram_flash

      void handle_user() {
          String html = FPSTR(user_html_template);
          html.replace(F("{device_id}"), String(device_id_c));
          server3.send(200, F("text/html"), html);
      }

  #endif

 #ifdef use_psram_flash
  void handle_user() {
      char* html = allocateHtmlInPSRAM(user_html_template);
      if (!html) {
          Serial.println("Fehler beim Zuordnen von PSRAM");
          server3.send(500, "text/plain", "Serverfehler");
          return;
      }

      String htmlString = String(html);
      htmlString.replace("{device_id}", String(device_id_c));

      server3.send(200, "text/html", htmlString);

      free(html); // PSRAM freigeben
  }

 #endif





     #ifndef use_psram_flash
     #ifndef Firmware_backup
    void handle_knx() {
        
        
        isUserOnKNXPage = true;
        isUserOnModbusPage = false;
        isUserOnSensorPage = false;
        
        String html = FPSTR(knx_html_template);

        // KNX-Adresse lesen
        uint8_t areaLine = storedData[12];
        uint8_t device = storedData[13];
        uint8_t areat = areaLine >> 4;
        uint8_t linet = areaLine & 0x0F;
        String knx_address = String(areat) + "." + String(linet) + "." + String(device);

        // Gruppenadressen lesen
        uint8_t numAddressest = storedData[173];
        String group_addresses[4];
        for (uint8_t i = 0; i < numAddressest && i < 4; i++) {
            uint8_t highByte = storedData[174 + i * 2];
            uint8_t lowByte = storedData[175 + i * 2];
            uint8_t mainGroup = highByte >> 3;
            uint8_t middleGroup = ((highByte & 0x07) << 3) | (lowByte >> 5);
            uint8_t subGroup = lowByte & 0x1F;
            group_addresses[i] = String(mainGroup) + "/" + String(middleGroup) + "/" + String(subGroup);
        }

        // Parameter lesen
        uint8_t sensor_boot_time = knx.paramByte(0);
        uint8_t auto_transfer_unit = knx.paramByte(1);

        // IP-Einstellungen lesen
        uint8_t ip[4] = { storedData[39], storedData[40], storedData[41], storedData[42] };
        String ip_address = String(ip[0]) + "." + String(ip[1]) + "." + String(ip[2]) + "." + String(ip[3]);

        uint8_t subnet[4] = { storedData[45], storedData[46], storedData[47], storedData[48] };
        String subnet_mask = String(subnet[0]) + "." + String(subnet[1]) + "." + String(subnet[2]) + "." + String(subnet[3]);

        uint8_t gateway[4] = { storedData[51], storedData[52], storedData[53], storedData[54] };
        String gateway_str = String(gateway[0]) + "." + String(gateway[1]) + "." + String(gateway[2]) + "." + String(gateway[3]);

        // Multicast-Adresse lesen
        uint8_t multicast[4] = { storedData[57], storedData[58], storedData[59], storedData[60] };
        String multicast_address = String(multicast[0]) + "." + String(multicast[1]) + "." + String(multicast[2]) + "." + String(multicast[3]);


        // Platzhalter ersetzen
        html.replace("{knx_address}", knx_address);
        html.replace("{group_address_1}", group_addresses[0]);
        html.replace("{group_address_2}", group_addresses[1]);
        html.replace("{group_address_3}", group_addresses[2]);
        html.replace("{group_address_4}", group_addresses[3]);
        html.replace("{mb_radon_live_32bit}", String(mb_radon_live_32bit) + " Bq/m&sup3;");
        html.replace("{radon_mittelwert_24h}", String(radon_mittelwert_24h) + " Bq/m&sup3;");
        html.replace("{radon_mittelwert_long}", String(radon_mittelwert_long) + " Bq/m&sup3;");
        html.replace("{mb_radon_save_eintrarge}", String(mb_radon_save_eintrarge));

        html.replace("{tmb_radon_live_32bit}", String(mb_radon_live_32bit) );
        html.replace("{tradon_mittelwert_24h}", String(radon_mittelwert_24h) );
        html.replace("{tradon_mittelwert_long}", String(radon_mittelwert_long) );
        html.replace("{tmb_radon_save_eintrarge}", String(mb_radon_save_eintrarge));

        // Platzhalter für vorausgewählte Optionen setzen
        html.replace("{sensor_boot_time_" + String(sensor_boot_time) + "}", "selected");
        html.replace("{auto_transfer_" + String(auto_transfer_unit) + "}", "selected");

        html.replace("{ip_address}", ip_address);
        html.replace("{subnet_mask}", subnet_mask);
        html.replace("{gateway}", gateway_str);
        html.replace("{multicast_address}", multicast_address);
        html.replace("{device_id}", String(device_id_c));

        html.replace(F("{knx_status}"), g_KNX_S_ist == 1 ? F("knx-ok") : F("knx-nok"));  // KNX_enabled
        html.replace(F("{knx_text}"), g_KNX_S_ist == 1 ? F("aktiv") : F("deaktiviert"));  
        Serial.print("g_KNX_S_ist"); Serial.println(g_KNX_S_ist);
        html.replace("{knx_status_checked}", g_KNX_S_ist ? "checked" : "");

        server3.send(200, "text/html", html);
    }
    #endif
    #endif
    
    #ifdef use_psram_flash
    void handle_knx() {
        char* html = allocateHtmlInPSRAM(knx_html_template);
        if (!html) {
            Serial.println("Fehler beim Zuordnen von PSRAM");
            server3.send(500, "text/plain", "Serverfehler");
            return;
        }

        isUserOnKNXPage = true;
        isUserOnModbusPage = false;
        isUserOnSensorPage = false;
        isBleOnSensorPage = false;

        // KNX-Adresse lesen
        uint8_t areaLine = storedData[12];
        uint8_t device = storedData[13];
        uint8_t areat = areaLine >> 4;
        uint8_t linet = areaLine & 0x0F;
        String knx_address = String(areat) + "." + String(linet) + "." + String(device);

        // Gruppenadressen lesen
        uint8_t numAddressest = storedData[173];
        String group_addresses[4];
        for (uint8_t i = 0; i < numAddressest && i < 4; i++) {
            uint8_t highByte = storedData[174 + i * 2];
            uint8_t lowByte = storedData[175 + i * 2];
            uint8_t mainGroup = highByte >> 3;
            uint8_t middleGroup = ((highByte & 0x07) << 3) | (lowByte >> 5);
            uint8_t subGroup = lowByte & 0x1F;
            group_addresses[i] = String(mainGroup) + "/" + String(middleGroup) + "/" + String(subGroup);
        }

        // Parameter lesen
        uint8_t sensor_boot_time = knx.paramByte(0);
        uint8_t auto_transfer_unit = knx.paramByte(1);

        // IP-Einstellungen lesen
        uint8_t ip[4] = { storedData[39], storedData[40], storedData[41], storedData[42] };
        String ip_address = String(ip[0]) + "." + String(ip[1]) + "." + String(ip[2]) + "." + String(ip[3]);

        uint8_t subnet[4] = { storedData[45], storedData[46], storedData[47], storedData[48] };
        String subnet_mask = String(subnet[0]) + "." + String(subnet[1]) + "." + String(subnet[2]) + "." + String(subnet[3]);

        uint8_t gateway[4] = { storedData[51], storedData[52], storedData[53], storedData[54] };
        String gateway_str = String(gateway[0]) + "." + String(gateway[1]) + "." + String(gateway[2]) + "." + String(gateway[3]);

        // Multicast-Adresse lesen
        uint8_t multicast[4] = { storedData[57], storedData[58], storedData[59], storedData[60] };
        String multicast_address = String(multicast[0]) + "." + String(multicast[1]) + "." + String(multicast[2]) + "." + String(multicast[3]);

        // Platzhalter ersetzen
        String htmlString = String(html);
        htmlString.replace("{knx_address}", knx_address);
        htmlString.replace("{group_address_1}", group_addresses[0]);
        htmlString.replace("{group_address_2}", group_addresses[1]);
        htmlString.replace("{group_address_3}", group_addresses[2]);
        htmlString.replace("{group_address_4}", group_addresses[3]);
        htmlString.replace("{mb_radon_live_32bit}", String(mb_radon_live_32bit) + " Bq/m&sup3;");
        htmlString.replace("{radon_mittelwert_24h}", String(radon_mittelwert_24h) + " Bq/m&sup3;");
        htmlString.replace("{radon_mittelwert_long}", String(radon_mittelwert_long) + " Bq/m&sup3;");
        htmlString.replace("{mb_radon_save_eintrarge}", String(mb_radon_save_eintrarge));

        htmlString.replace("{tmb_radon_live_32bit}", String(mb_radon_live_32bit));
        htmlString.replace("{tradon_mittelwert_24h}", String(radon_mittelwert_24h));
        htmlString.replace("{tradon_mittelwert_long}", String(radon_mittelwert_long));
        htmlString.replace("{tmb_radon_save_eintrarge}", String(mb_radon_save_eintrarge));

        // Platzhalter für vorausgewählte Optionen setzen
        htmlString.replace("{sensor_boot_time_" + String(sensor_boot_time) + "}", "selected");
        htmlString.replace("{auto_transfer_" + String(auto_transfer_unit) + "}", "selected");

        htmlString.replace("{ip_address}", ip_address);
        htmlString.replace("{subnet_mask}", subnet_mask);
        htmlString.replace("{gateway}", gateway_str);
        htmlString.replace("{multicast_address}", multicast_address);
        htmlString.replace("{device_id}", String(device_id_c));

        htmlString.replace(F("{knx_status}"), g_KNX_S_ist == 1 ? F("knx-ok") : F("knx-nok"));  // KNX_enabled
        htmlString.replace(F("{knx_text}"), g_KNX_S_ist == 1 ? F("aktiv") : F("deaktiviert")); 

        server3.send(200, "text/html", htmlString);

        free(html); // PSRAM freigeben
    }
#endif






      void myFunction() {
        // Deine Funktion hier
        send_knx_data();
        Serial.println("Funktion wurde ausgeführt!");
      }

      #ifndef Firmware_backup
      void handleExecuteFunction() {
        // Hier die gewünschte Funktion ausführen
        myFunction();

        // Antwort senden (kann leer sein, da die Seite neu geladen wird)
        server3.send(200, "text/plain", "");
      }
      #endif


      /*
        void handle_combined_chart() {
            //Serial.println("Start handle_combined_chart");
            String html = FPSTR(combined_chart_html);
            esp_task_wdt_reset();
            
            // Ersetze die Platzhalter durch die tatsächlichen Werte
            //Serial.println("Replacing radon_mittelwert_monat placeholders");
            for (int i = 0; i < 12; i++) {
                html.replace("{radon_mittelwert_monat[" + String(i) + "]}", String(radon_mittelwert_monat[i]));
                //Serial.print("radon_mittelwert_monat["); Serial.print(i); Serial.print("] = "); Serial.println(radon_mittelwert_monat[i]);
            }

            // Zeitachse erstellen
            //Serial.println("Creating time array");
            String timeArray[48];
            timeArray[0] = chartime00;
            timeArray[4] = chartime01a;
            timeArray[8] = chartime02b;
            timeArray[12] = chartime04;
            timeArray[16] = chartime05a;
            timeArray[20] = chartime06b;
            timeArray[24] = chartime08a;
            timeArray[28] = chartime09a;
            timeArray[32] = chartime10b;
            timeArray[36] = chartime12;
            timeArray[40] = chartime13a;
            timeArray[44] = chartime14b;
            timeArray[47] = chartime16; // Korrigiert den Index für das letzte Element


            // Fehlende Zeitstempel rückwärts von jetzt auffüllen
            time_t now;
            struct tm timeinfo;
            char buffer[20];
            time(&now);
            localtime_r(&now, &timeinfo);

            // Set the current live value with the current minutes and date
            strftime(buffer, sizeof(buffer), "%d.%m.%y %H:%M", &timeinfo);
            timeArray[47] = String(buffer);
            //Serial.print("Current time: "); Serial.println(String(buffer));

            // Fill in the rest of the timeArray with the last full hour and go back one hour for each previous element
            timeinfo.tm_min = 0; // Minuten auf 0 setzen
            for (int i = 46; i >= 0; i--) {
                timeinfo.tm_hour -= 1;
                mktime(&timeinfo);
                strftime(buffer, sizeof(buffer), "%d.%m.%y %H:%M", &timeinfo);
                timeArray[i] = String(buffer);
                //Serial.print("timeArray["); Serial.print(i); Serial.print("] = "); Serial.println(timeArray[i]);
            }
            esp_task_wdt_reset();

            // Zeitachse als String erstellen
            //Serial.println("Creating stringtime");
            String stringtime = "['" + timeArray[0] + "'";
            for (int i = 1; i < 48; i++) {
                stringtime += ",'" + timeArray[i] + "'";
            }
            stringtime += "]";
            //Serial.print("stringtime = "); Serial.println(stringtime);

            // Datenreihe erstellen
            //Serial.println("Creating stringdata");
          
            String stringdata = "[";
            for (int i = 0; i < 48; i++) {
                stringdata += String(charInts[i]);
                if (i < 47) {
                    stringdata += ",";
                }
                //Serial.print("charInts["); Serial.print(i); Serial.print("] = "); Serial.println(charInts[i]);
            }
            stringdata += "]";
            // Ersetze die Platzhalter durch die tatsächlichen Werte
            //Serial.println("Replacing placeholders in HTML");
            html.replace("{stringtime}", stringtime);
            html.replace("{stringdata}", stringdata);
            html.replace("{device_id}", String(device_id_c));
            esp_task_wdt_reset();
            server3.send(200, "text/html", html);
            //Serial.println("End handle_combined_chart");
            esp_task_wdt_reset();
        }
       */

        #ifndef Firmware_backup
        void handle_combined_chart() {
            char* html = allocateHtmlInPSRAM(combined_chart_html);
            if (!html) {
                Serial.println(F("Fehler beim Zuordnen von PSRAM"));
                server3.send(500, F("text/plain"), F("Serverfehler"));
                return;
            }

            g_force_ping = true;

            esp_task_wdt_reset();

            // HTML-Template in einen String umwandeln
            String htmlString = String(html);

            // Ersetze die Platzhalter durch die tatsächlichen Werte
            for (int i = 0; i < 12; i++) {
                String placeholder = String(F("{radon_mittelwert_monat[")) + String(i) + String(F("]}"));
                htmlString.replace(placeholder, String(radon_mittelwert_monat[i]));
            }



            /*
            // Zeitachse erstellen
            String timeArray[48];
            timeArray[0] = chartime00;
            timeArray[4] = chartime01a;
            timeArray[8] = chartime02b;
            timeArray[12] = chartime04;
            timeArray[16] = chartime05a;
            timeArray[20] = chartime06b;
            timeArray[24] = chartime08a;
            timeArray[28] = chartime09a;
            timeArray[32] = chartime10b;
            timeArray[36] = chartime12;
            timeArray[40] = chartime13a;
            timeArray[44] = chartime14b;
            timeArray[47] = chartime16; // Korrigiert den Index für das letzte Element

            // Fehlende Zeitstempel rückwärts von jetzt auffüllen
            time_t now;
            struct tm timeinfo;
            char buffer[20];
            time(&now);
            localtime_r(&now, &timeinfo);

            // Set the current live value with the current minutes and date
            strftime(buffer, sizeof(buffer), "%d.%m.%y %H:%M", &timeinfo);
            timeArray[47] = String(buffer);

            // Fill in the rest of the timeArray with the last full hour and go back one hour for each previous element
            timeinfo.tm_min = 0; // Minuten auf 0 setzen
            for (int i = 46; i >= 0; i--) {
                timeinfo.tm_hour -= 1;
                mktime(&timeinfo);
                strftime(buffer, sizeof(buffer), "%d.%m.%y %H:%M", &timeinfo);
                timeArray[i] = String(buffer);
            }

            esp_task_wdt_reset();

              //-------------------------------------
          
                // Zeitachse als String erstellen
                String stringtime = "['" + timeArray[0] + "'";
                for (int i = 1; i < 48; i++) {
                    stringtime += ", '" + timeArray[i] + "'";
                }
                stringtime += "]";

                // Datenreihe erstellen
                String stringdata = "[";
                for (int i = 0; i < 48; i++) {
                    stringdata += String(charInts[i]);
                    if (i < 47) {
                        stringdata += ",";
                    }
                }
                stringdata += "]";
            */

                  // Zeitachse erstellen
                  char timeArray[48][20]; // Angenommen, jedes Datum-Zeit-Format passt in 19 Zeichen + Nullterminator
                  strcpy(timeArray[0], chartime00);
                  strcpy(timeArray[4], chartime01a);
                  strcpy(timeArray[8], chartime02b);
                  strcpy(timeArray[12], chartime04);
                  strcpy(timeArray[16], chartime05a);
                  strcpy(timeArray[20], chartime06b);
                  strcpy(timeArray[24], chartime08a);
                  strcpy(timeArray[28], chartime09a);
                  strcpy(timeArray[32], chartime10b);
                  strcpy(timeArray[36], chartime12);
                  strcpy(timeArray[40], chartime13a);
                  strcpy(timeArray[44], chartime14b);
                  strcpy(timeArray[47], chartime16); // Korrigiert den Index für das letzte Element

                  // Fehlende Zeitstempel rückwärts von jetzt auffüllen
                  time_t now;
                  struct tm timeinfo;
                  char buffer[20];
                  time(&now);
                  localtime_r(&now, &timeinfo);

                  // Set the current live value with the current minutes and date
                  strftime(buffer, sizeof(buffer), "%d.%m.%y %H:%M", &timeinfo);
                  strncpy(timeArray[47], buffer, sizeof(timeArray[47]));

                  // Fill in the rest of the timeArray with the last full hour and go back one hour for each previous element
                  timeinfo.tm_min = 0; // Minuten auf 0 setzen
                  for (int i = 46; i >= 0; i--) {
                      timeinfo.tm_hour -= 1;
                      mktime(&timeinfo);
                      strftime(buffer, sizeof(buffer), "%d.%m.%y %H:%M", &timeinfo);
                      strncpy(timeArray[i], buffer, sizeof(timeArray[i]));
                  }

                  esp_task_wdt_reset();

                  //-------------------------------------

                  // Zeitachse als char Array erstellen
                  char stringtime[1024]; // Angenommen, dies ist groß genug, um die gesamte Zeitachse zu speichern
                  strcpy(stringtime, "['");
                  strcat(stringtime, timeArray[0]);
                  strcat(stringtime, "'");

                  for (int i = 1; i < 48; i++) {
                      strcat(stringtime, ", '");
                      strcat(stringtime, timeArray[i]);
                      strcat(stringtime, "'");
                  }
                  strcat(stringtime, "]");

                  // Datenreihe erstellen
                  char stringdata[1024]; // Angenommen, dies ist groß genug, um die gesamte Datenreihe zu speichern
                  char temp[7]; // Temporärer Puffer für die Zahlen

                  strcpy(stringdata, "[");
                  for (int i = 0; i < 48; i++) {
                      sprintf(temp, "%d", charInts[i]);
                      strcat(stringdata, temp);
                      if (i < 47) {
                          strcat(stringdata, ",");
                      }
                  }
                  strcat(stringdata, "]");



          
              //---------------------------------------
              /*
                    // Zeitachse als String erstellen
                    //Serial.println("Creating stringtime");
                    String stringtime = "['" + timeArray[0] + "'";
                    for (int i = 1; i < 48; i++) {
                        stringtime += ",'" + timeArray[i] + "'";
                    }
                    stringtime += "]";
                    //Serial.print("stringtime = "); Serial.println(stringtime);

                    // Datenreihe erstellen
                    //Serial.println("Creating stringdata");
                  
                    String stringdata = "[";
                    for (int i = 0; i < 48; i++) {
                        stringdata += String(charInts[i]);
                        if (i < 47) {
                            stringdata += ",";
                        }
                        //Serial.print("charInts["); Serial.print(i); Serial.print("] = "); Serial.println(charInts[i]);
                    }
                    stringdata += "]";
                  */




            if (Internt_online) {
                Serial.println(F("Online .js"));
                htmlString.replace(F("{highcharts.js}"), "https://code.highcharts.com/highcharts.js");
            }else{
                Serial.println(F("SPIFFSe .js"));
                htmlString.replace(F("{highcharts.js}"), "/highcharts.js");
            }


            // Ersetze die Platzhalter durch die tatsächlichen Werte
            htmlString.replace(F("{stringtime}"), stringtime);
            htmlString.replace(F("{stringdata}"), stringdata);
            htmlString.replace(F("{device_id}"), String(device_id_c));

            esp_task_wdt_reset();
            server3.send(200, F("text/html"), htmlString);
            free(html); // PSRAM freigeben

            esp_task_wdt_reset();
        }
        #endif



        void handleRestart() {
          if (server3.hasArg("password") && strcmp(server3.arg("password").c_str(), correctPassword) == 0) {
              server3.send(200, "text/plain", "OK");
              g_esp_soft_restart = true;
          } else {
              server3.sendHeader("Location", "/", true);
              server3.send(302, "text/plain", "");
          }
        }

        void handleRestarting() {
            server3.send(200, "text/html", FPSTR(restart_html_template));
        }





    #ifndef aktivate_psram_flash


      void handleRoot() {
          
          //char html[3000]; // Puffergröße anpassen je nach Bedarf
          //strcpy_P(html, (PGM_P)start_html_template);
          // Ersetzen der Platzhalter
          //char buffer[3000]; // Puffergröße anpassen je nach Bedarf  
          // Ersetzen von {device_id} 
          //replacePlaceholder(buffer, html, "{device_id}", device_id_c, sizeof(html));
          // Übermittlung der Webseite
          //server3.send(200, F("text/html"), buffer);
          
          String html = FPSTR(start_html_template);

          html.replace(F("{current_datetime}"), String(current_datetime));
          html.replace(F("{device_id}"), String(device_id_c));
          html.replace(F("{mb_radon_live_32bit}"), String(mb_radon_live_32bit) + F(" Bq/m&sup3;"));
          html.replace(F("{correctPassword}"), correctPassword);
          server3.send(200, F("text/html"), html);
       
          g_force_ping = true;

      }

    
    #else


      void handleRoot() {
          char* html = allocateHtmlInPSRAM(start_html_template);
          if (!html) {
              Serial.println(F("Fehler beim Zuordnen von PSRAM"));
              server3.send(500, F("text/plain"), F("Serverfehler"));
              return;
          }


          // HTML-Template in einen String umwandeln
          String htmlString = String(html);
          htmlString.replace(F("{current_datetime}"), String(current_datetime));
          htmlString.replace(F("{device_id}"), String(device_id_c));
          htmlString.replace(F("{mb_radon_live_32bit}"), String(mb_radon_live_32bit) + F(" Bq/m&sup3;"));

          server3.send(200, F("text/html"), htmlString);

          free(html); // PSRAM freigeben
      }

    #endif




   #ifndef aktivate_psram_flash

    #ifndef Firmware_backup
    void handle_ble_info() {
      
          isBleOnSensorPage = true;
          isUserOnModbusPage = false;
          isUserOnKNXPage = false;
          isUserOnSensorPage = false;
      
         
          String html = FPSTR(ble_html_template);
          html.replace("{device_id}", String(device_id_c));
          html.replace("{ble_device_name}", String(device_id_c));
          html.replace("{ble_status}", BLE_Server_enabled ? "Aktiv" : "Inaktiv");
          html.replace("{ble_status}", BLE_Beacon_enabled ? "Aktiv" : "Inaktiv");
          
          html.replace("{best_rssi}", String(bestRssi)); 
          html.replace("{worst_rssi}", String(worstRssi));
          html.replace("{ble_rssi}", String(ble_rssi));
          int signalStrength = map(ble_rssi, -100, -40, 0, 100); // RSSI in Prozentsatz umwandeln
          html.replace("{signal_strength}", String(signalStrength));
          html.replace("{ble_uuid}", SERVICE_UUID);
          html.replace("{connected_users}", String(connected_users)); // Beispielwert, Anzahl der verbundenen Benutzer
          html.replace("{traffic}", String(traffic) + " KB/s");
          html.replace("{received_traffic}", String(receivedTraffic) + " KB/s");
          html.replace("{sent_traffic}", String(sentTraffic) + " KB/s");
             
          // Ersetze Radon-Geräteliste
          String deviceList;

          // Debug-Ausgabe für Radon-Geräte
          Serial.println("Radon-Geräte:");
          for (int i = 0; i < radonDeviceCount; i++) {
              deviceList += "<li>" + radonDevices[i] + "</li>";
              Serial.printf("Radon-Gerät %d: %s\n", i, radonDevices[i].c_str());
          }
          html.replace("{radon_devices}", deviceList);

          // Debug-Ausgabe für benannte Geräte
          deviceList = "";  // Zurücksetzen der Liste für benannte Geräte
          Serial.println("Benannte Geräte:");
          for (int i = 0; i < namedDeviceCount; i++) {
              deviceList += "<li>" + namedDevices[i] + "</li>";
              Serial.printf("Benanntes Gerät %d: %s\n", i, namedDevices[i].c_str());
          }
          html.replace("{named_devices}", deviceList);
           

         server3.send(200, "text/html", html);
    }
    #endif


    #else


    void handle_ble_info() {
        isBleOnSensorPage = true;
        isUserOnModbusPage = false;
        isUserOnKNXPage = false;
        isUserOnSensorPage = false;

        char* html = allocateHtmlInPSRAM(ble_html_template);
        if (!html) {
            Serial.println(F("Fehler beim Zuordnen von PSRAM"));
            server3.send(500, F("text/plain"), F("Serverfehler"));
            return;
        }

        String htmlString = String(html);
        htmlString.replace(F("{device_id}"), String(device_id_c));
        htmlString.replace(F("{ble_device_name}"), String(device_id_c));
        htmlString.replace(F("{ble_status}"), BLE_Server_enabled ? F("Aktiv") : F("Inaktiv"));
        htmlString.replace(F("{best_rssi}"), String(bestRssi)); 
        htmlString.replace(F("{worst_rssi}"), String(worstRssi));
        htmlString.replace(F("{ble_rssi}"), String(ble_rssi));
        int signalStrength = map(ble_rssi, -100, -40, 0, 100); // RSSI in Prozentsatz umwandeln
        htmlString.replace(F("{signal_strength}"), String(signalStrength));
        htmlString.replace(F("{ble_uuid}"), SERVICE_UUID);
        htmlString.replace(F("{connected_users}"), String(connected_users)); // Beispielwert, Anzahl der verbundenen Benutzer
        htmlString.replace(F("{traffic}"), String(traffic) + F(" KB/s"));
        htmlString.replace(F("{received_traffic}"), String(receivedTraffic) + F(" KB/s"));
        htmlString.replace(F("{sent_traffic}"), String(sentTraffic) + F(" KB/s"));

        // Ersetze Radon-Geräteliste
        String deviceList;

        // Debug-Ausgabe für Radon-Geräte
        Serial.println(F("Radon-Geräte:"));
        for (int i = 0; i < radonDeviceCount; i++) {
            deviceList += F("<li>");
            deviceList += radonDevices[i];
            deviceList += F("</li>");
            Serial.printf("Radon-Gerät %d: %s\n", i, radonDevices[i].c_str());
        }
        htmlString.replace(F("{radon_devices}"), deviceList);

        // Debug-Ausgabe für benannte Geräte
        deviceList = "";  // Zurücksetzen der Liste für benannte Geräte
        Serial.println(F("Benannte Geräte:"));
        for (int i = 0; i < namedDeviceCount; i++) {
            deviceList += F("<li>");
            deviceList += namedDevices[i];
            deviceList += F("</li>");
            Serial.printf("Benanntes Gerät %d: %s\n", i, namedDevices[i].c_str());
        }
        htmlString.replace(F("{named_devices}"), deviceList);

        server3.send(200, F("text/html"), htmlString);
        free(html); // PSRAM freigeben
    }



    #endif









   #ifdef use_psram_flash


 void handle_root2() {
    isUserOnModbusPage = false;
    isUserOnKNXPage = false;
    isUserOnSensorPage = false;

    String html = FPSTR(index_html_template);
    html.replace(F("{device_id}"), String(device_id_c));
    
    html.replace(F("{rtc_status}"), update_rtc_ready == 1 ? F("ok") : F("nok"));
    html.replace(F("{rtc_text}"), update_rtc_ready == 1 ? F("gestellt") : F("nicht gestellt"));

    html.replace(F("{sensor_status}"), g_sensor_online > 2 ? F("nok") : F("ok"));
    html.replace(F("{sensor_text}"), g_sensor_online > 2 ? F("Fehler") : F("OK"));

    html.replace(F("{mb_radon_live_32bit}"), String(mb_radon_live_32bit) + F(" Bq/m&sup3;"));
    html.replace(F("{radon_mittelwert_24h}"), String(radon_mittelwert_24h) + F(" Bq/m&sup3;"));
    html.replace(F("{radon_mittelwert_long}"), String(radon_mittelwert_long) + F(" Bq/m&sup3;"));
    html.replace(F("{mb_radon_save_eintrarge}"), String(mb_radon_save_eintrarge));


    html.replace(F("{current_datetime}"), String(current_datetime));

    
    html.replace(F("{tme_status}"), g_u_mez_ea_ist == 1 ? F("tme-ok") : F("tme-nok"));
    html.replace(F("{tme_text}"), g_u_mez_ea_ist == 1 ? F("DST On") : F("DST Off"));

    html.replace(F("{utc_status}"), g_sensor_online > 2 ? F("utc-nok") : F("utc-ok"));
    html.replace(F("{utc_text}"), timeDifferenceStr);

    html.replace(F("{ntp_status}"), update_ntp_ready == 1 ? F("ntp-ok") : F("ntp-nok"));
    html.replace(F("{ntp_text}"), update_ntp_ready == 1 ? F("aktualisiert") : F("nicht aktualisiert"));

    html.replace(F("{tb_status}"), TB_status ? F("tb-ok") : F("tb-nok"));
    html.replace(F("{tb_text}"), TB_status ? F("verbunden") : F("nicht verbunden"));

    html.replace(F("{wlan_status}"), WiFi.status() == WL_CONNECTED ? F("wlan-ok") : F("wlan-nok"));
    html.replace(F("{wlan_text}"), WiFi.status() == WL_CONNECTED ? F("verbunden") : F("nicht verbunden"));

    html.replace(F("{ble_status}"), BLE_enabled ? F("ble-ok") : F("ble-nok"));
    html.replace(F("{ble_text}"), BLE_enabled ? F("aktiviert") : F("deaktiviert"));

    // Modbus TCPIP Status
    html.replace(F("{modbus_status}"), WiFi.status() == WL_CONNECTED ? F("modbus-ok") : F("modbus-nok"));
    html.replace(F("{modbus_text}"), WiFi.status() == WL_CONNECTED ? F("aktiv") : F("deaktiviert"));

    // Cloud Status
    html.replace(F("{cloud_status}"), g_Cloud_ea_ist == 1 ? F("cloud-ok") : F("cloud-nok"));
    html.replace(F("{cloud_text}"), g_Cloud_ea_ist == 1 ? F("aktiv") : F("deaktiviert"));

    // JSON Status
    html.replace(F("{json_status}"), json_aktiv == 1 ? F("json-ok") : F("json-nok"));
    html.replace(F("{json_text}"), json_aktiv == 1 ? F("aktiv") : F("deaktiviert"));

    // XML Status
    html.replace(F("{xml_status}"), xml_aktiv == 1 ? F("xml-ok") : F("xml-nok"));
    html.replace(F("{xml_text}"), xml_aktiv == 1 ? F("aktiv") : F("deaktiviert"));

    // Bluetooth Status
    html.replace(F("{ble2_status}"), BLE_Server_enabled ? F("ble2-ok") : F("ble2-nok"));
    html.replace(F("{ble2_text}"), BLE_Server_enabled ? F("aktiv") : F("deaktiviert"));

    // Bluetooth Beacon Status
    html.replace(F("{beacon_status}"), BLE_Beacon_enabled ? F("beacon-ok") : F("beacon-nok"));
    html.replace(F("{beacon_text}"), BLE_Beacon_enabled ? F("aktiv") : F("deaktiviert"));

    // KNX Status
    html.replace(F("{knx_status}"), g_KNX_S_ist == 1 ? F("knx-ok") : F("knx-nok"));  //   KNX_enabled
    html.replace(F("{knx_text}"), g_KNX_S_ist == 1 ? F("aktiv") : F("deaktiviert"));

    // MQTT Status
    html.replace(F("{mqtt_status}"), p_mqonoff == 1 ? F("mqtt-ok") : F("mqtt-nok")); 
    html.replace(F("{mqtt_text}"), p_mqonoff == 1 ? F("aktiv") : F("deaktiviert"));

    // Web Status
    html.replace(F("{web_status}"), disable_server >= 1 ? F("web-ok") : F("web-nok")); 
    html.replace(F("{web_text}"), disable_server >= 1 ? F("aktiv") : F("deaktiviert"));


    // Monatsmittelwerte und Jahresmittelwert
    for (int i = 0; i < 12; i++) {
        String placeholder = String(F("{radon_mittelwert_monat[")) + String(i) + String(F("]}"));
        html.replace(placeholder, String(radon_mittelwert_monat[i]) + F(" Bq/m&sup3;"));
    }

    html.replace(F("{mittelwert_jahr}"), String(mittelwert_jahr) + F(" Bq/m&sup3;"));

    // Dynamisch den KNX-Link hinzufügen
    String knx_link = "";
    if (g_KNX_S_ist == 1) {
        knx_link = F("<a href=\"/knx\">KNX</a>");
    }
    html.replace(F("{knx_link}"), knx_link);

    server3.send(200, F("text/html"), html);
}


    #endif




    #ifndef use_psram_flash
 void handle_root2() {
    char* html = allocateHtmlInPSRAM(index_html_template);
    if (!html) {
        Serial.println(F("Fehler beim Zuordnen von PSRAM"));
        server3.send(500, F("text/plain"), F("Serverfehler"));
        return;
    }

    isUserOnModbusPage = false;
    isUserOnKNXPage = false;
    isUserOnSensorPage = false;
    isBleOnSensorPage = false;

    // HTML-Template in einen String umwandeln
    String htmlString = String(html);
    htmlString.replace(F("{device_id}"), String(device_id_c));
    htmlString.replace(F("{rtc_status}"), update_rtc_ready == 1 ? F("ok") : F("nok"));
    htmlString.replace(F("{rtc_text}"), update_rtc_ready == 1 ? F("gestellt") : F("nicht gestellt"));
    htmlString.replace(F("{sensor_status}"), g_sensor_online > 2 ? F("nok") : F("ok"));
    htmlString.replace(F("{sensor_text}"), g_sensor_online > 2 ? F("Fehler") : F("OK"));
    htmlString.replace(F("{mb_radon_live_32bit}"), String(mb_radon_live_32bit) + F(" Bq/m&sup3;"));
    htmlString.replace(F("{radon_mittelwert_24h}"), String(radon_mittelwert_24h) + F(" Bq/m&sup3;"));
    htmlString.replace(F("{radon_mittelwert_long}"), String(radon_mittelwert_long) + F(" Bq/m&sup3;"));
    htmlString.replace(F("{mb_radon_save_eintrarge}"), String(mb_radon_save_eintrarge));

    htmlString.replace(F("{current_datetime}"), String(current_datetime));

    htmlString.replace(F("{tme_status}"), g_u_mez_ea_ist == 1 ? F("tme-ok") : F("tme-nok"));
    htmlString.replace(F("{tme_text}"), g_u_mez_ea_ist == 1 ? F("DST On") : F("DST Off"));
    htmlString.replace(F("{utc_status}"), g_sensor_online > 2 ? F("utc-nok") : F("utc-ok"));
    htmlString.replace(F("{utc_text}"), timeDifferenceStr);
    htmlString.replace(F("{ntp_status}"), update_ntp_ready == 1 ? F("ntp-ok") : F("ntp-nok"));
    htmlString.replace(F("{ntp_text}"), update_ntp_ready == 1 ? F("aktualisiert") : F("nicht aktualisiert"));
    htmlString.replace(F("{tb_status}"), TB_status ? F("tb-ok") : F("tb-nok"));
    htmlString.replace(F("{tb_text}"), TB_status ? F("verbunden") : F("nicht verbunden"));
    htmlString.replace(F("{wlan_status}"), WiFi.status() == WL_CONNECTED ? F("wlan-ok") : F("wlan-nok"));
    htmlString.replace(F("{wlan_text}"), WiFi.status() == WL_CONNECTED ? F("verbunden") : F("nicht verbunden"));
    htmlString.replace(F("{ble_status}"), BLE_enabled ? F("ble-ok") : F("ble-nok"));
    htmlString.replace(F("{ble_text}"), BLE_enabled ? F("aktiviert") : F("deaktiviert"));

    // Modbus TCPIP Status
    htmlString.replace(F("{modbus_status}"), WiFi.status() == WL_CONNECTED ? F("modbus-ok") : F("modbus-nok"));
    htmlString.replace(F("{modbus_text}"), WiFi.status() == WL_CONNECTED ? F("aktiv") : F("deaktiviert"));

    // Cloud Status
    htmlString.replace(F("{cloud_status}"), g_Cloud_ea_ist == 1 ? F("cloud-ok") : F("cloud-nok"));
    htmlString.replace(F("{cloud_text}"), g_Cloud_ea_ist == 1 ? F("aktiv") : F("deaktiviert"));

    // JSON Status
    htmlString.replace(F("{json_status}"), json_aktiv == 1 ? F("json-ok") : F("json-nok"));
    htmlString.replace(F("{json_text}"), json_aktiv == 1 ? F("aktiv") : F("deaktiviert"));

    // XML Status
    htmlString.replace(F("{xml_status}"), xml_aktiv == 1 ? F("xml-ok") : F("xml-nok"));
    htmlString.replace(F("{xml_text}"), xml_aktiv == 1 ? F("aktiv") : F("deaktiviert"));

    // Bluetooth Status
    htmlString.replace(F("{ble2_status}"), BLE_Server_enabled ? F("ble2-ok") : F("ble2-nok"));
    htmlString.replace(F("{ble2_text}"), BLE_Server_enabled ? F("aktiv") : F("deaktiviert"));

    // Bluetooth Beacon Status
    htmlString.replace(F("{beacon_status}"), BLE_Beacon_enabled ? F("beacon-ok") : F("beacon-nok"));
    htmlString.replace(F("{beacon_text}"), BLE_Beacon_enabled ? F("aktiv") : F("deaktiviert"));

    // KNX Status
    htmlString.replace(F("{knx_status}"), g_KNX_S_ist == 1 ? F("knx-ok") : F("knx-nok"));  // KNX_enabled
    htmlString.replace(F("{knx_text}"), g_KNX_S_ist == 1 ? F("aktiv") : F("deaktiviert"));

    // MQTT Status
    htmlString.replace(F("{mqtt_status}"), p_mqonoff == 1 ? F("mqtt-ok") : F("mqtt-nok")); 
    htmlString.replace(F("{mqtt_text}"), p_mqonoff == 1 ? F("aktiv") : F("deaktiviert"));

    // Web Status
    htmlString.replace(F("{web_status}"), disable_server >= 1 ? F("web-ok") : F("web-nok")); 
    htmlString.replace(F("{web_text}"), disable_server >= 1 ? F("aktiv") : F("deaktiviert"));

    // Monatsmittelwerte und Jahresmittelwert
    for (int i = 0; i < 12; i++) {
        String placeholder = String(F("{radon_mittelwert_monat[")) + String(i) + String(F("]}"));
        htmlString.replace(placeholder, String(radon_mittelwert_monat[i]) + F(" Bq/m&sup3;"));
    }
    htmlString.replace(F("{mittelwert_jahr}"), String(mittelwert_jahr) + F(" Bq/m&sup3;"));

    // Dynamisch den KNX-Link hinzufügen
    String knx_link = "";
    if (g_KNX_S_ist == 1) {
        knx_link = F("<a href=\"/knx\">KNX</a>");
    }
    htmlString.replace(F("{knx_link}"), knx_link);

    server3.send(200, F("text/html"), htmlString);

    free(html); // PSRAM freigeben

        g_force_ping = true;

}


#endif



     #ifndef aktivate_psram_flash

    void handle_esp32_info() {
      String html = FPSTR(esp32_info_html);
      html.replace("{flash_size}", String(ESP.getFlashChipSize() / (1024 * 1024)));
      html.replace("{cpu_freq}", String(ESP.getCpuFreqMHz()));
      html.replace("{ram_size}", "384");//String(ESP.getHeapSize() / 1024)); 
      html.replace("{psram_size}", "8"); //String(ESP.getPsramSize() / (1024 * 1024))
        // Chip-Temperatur auslesen
      float temperature;
      temp_sensor_read_celsius(&temperature);
      html.replace("{chip_temperatur}", String(temperature));

      // PSRAM Berechnungen
      float totalPSRAM = (ESP.getPsramSize() + 1000000) / (1024 * 1024); // Gesamt-PSRAM in MB     size_t largestFreeBlock = xPortGetFreeHeapSize();   xPortGetFreeHeapSize()  Total PSRAM
      float freePSRAM = ESP.getFreePsram() / (1024.0 * 1024.0); // Freier PSRAM in MB
      float usedPSRAM = totalPSRAM - freePSRAM; // Verwendeter PSRAM in MB
      //float usedPercentagePSRAM = (float)usedPSRAM / totalPSRAM * 100; // Verwendeter PSRAM in Prozent
      float usedPercentagePSRAM = (usedPSRAM * 100) / totalPSRAM;

      //Serial.print("totalPSRAM ");Serial.println(totalPSRAM);
      //Serial.print("freePSRAM ");Serial.println(freePSRAM);
      //Serial.print("usedPSRAM ");Serial.println(usedPSRAM);
      //Serial.print("xPortGetFreeHeapSize() ");Serial.println(xPortGetFreeHeapSize());
      
      html.replace("{usedPSRAM}", String(usedPSRAM, 2));
      html.replace("{totalPSRAM}", String(totalPSRAM, 2));
      html.replace("{usedPercentagePSRAM}", String(usedPercentagePSRAM, 2));

      float totalHeapSizet = ESP.getHeapSize() / (1024.0 * 1024.0);
      float usedHeapSize = (ESP.getHeapSize() - ESP.getFreeHeap()) / (1024.0 * 1024.0);
      float usedPercentageHeap = (usedHeapSize * 100) / totalHeapSizet;
      
      float totalRAM = ESP.getHeapSize() / (1024.0 * 1024.0);
      float usedRAM = (ESP.getHeapSize() - ESP.getFreeHeap()) / (1024.0 * 1024.0);
      float usedPercentageRAM = (usedRAM * 100) / totalRAM;
      
      float totalFlash = ESP.getFlashChipSize() / (1024.0 * 1024.0);
      float usedFlash = (ESP.getFlashChipSize() - ESP.getFreeSketchSpace()) / (1024.0 * 1024.0);
      float usedPercentageFlash = (usedFlash * 100) / totalFlash;
      
      nvs_stats_t nvs_stats;
      nvs_get_stats(NULL, &nvs_stats);
      float usedPercentageNVS = (nvs_stats.used_entries * 100.0) / nvs_stats.total_entries;
      
      float totalBytes = SPIFFS.totalBytes() / (1024.0 * 1024.0);
      float usedBytes = SPIFFS.usedBytes() / (1024.0 * 1024.0);
      float usedPercentageSPIFFS = (usedBytes * 100) / totalBytes;
      
      html.replace("{used_ram}", String(usedHeapSize, 2));
      html.replace("{usedPercentageHeap}", String(usedPercentageHeap, 2));
      html.replace("{usedPercentageRAM}", String(usedPercentageRAM, 2));
      html.replace("{usedPercentageFlash}", String(usedPercentageFlash, 2));
      html.replace("{usedPercentageNVS}", String(usedPercentageNVS, 2));
      html.replace("{usedPercentageSPIFFS}", String(usedPercentageSPIFFS, 2));
      html.replace("{usedHeap}", String(usedHeapSize, 2));
      html.replace("{totalHeap}", String(totalHeapSizet, 2));
      html.replace("{usedRAM}", String(usedRAM, 3));
      html.replace("{totalRAM}", String(totalRAM, 3));


      html.replace("{usedFlash}", String(usedFlash, 2));
      html.replace("{totalFlash}", String(totalFlash, 2));
      html.replace("{nvs_used_entries}", String(nvs_stats.used_entries));
      html.replace("{nvs_total_entries}", String(nvs_stats.total_entries));
      html.replace("{usedBytes}", String(usedBytes, 2));
      html.replace("{totalBytes}", String(totalBytes, 2));
      
      html.replace("{hardware_name}", String(ESP.getChipModel()));
      html.replace("{chip_revision}","Xtensa dual-core 32-bit LX7");     //String(ESP.getChipRevision())
      html.replace("{mac_address}", WiFi.macAddress());
      html.replace("{ip_address}", WiFi.localIP().toString());
      html.replace("{gateway_address}", WiFi.gatewayIP().toString());
      html.replace("{subnet_address}", WiFi.subnetMask().toString());

      html.replace("{rtc_temperatur}", String(rtc_temperatur)); // Funktion zum Abrufen der RTC-Temperatur
      html.replace("{rtc_oszi}", rtc_oszi ? "Oszillator ok" : "Oszillator nicht ok");
      html.replace("{g_u_clock}", g_u_clock_ist == 1 ? "24h" : "12h");



      html.replace("{device_id}", String(device_id_c));
      html.replace("{fw_version}", TB_currFwVersion);
      html.replace("{fw_datum}", FIRMWARE_DATE_TIME);
      
      html.replace("{modbus_ip}", WiFi.localIP().toString());

      // MQTT Informationen hinzufügen
      html.replace("{mqtt_topic}", String(p_inputmqtopicc));
      html.replace("{mqtt_server}", String(p_inputmqserverc));

    // WLAN-Frequenz abrufen
    String wifi_frequency = (WiFi.channel() <= 14) ? "2.4" : "5";
    html.replace("{wifi_frequency}", wifi_frequency);

    // WLAN-Verschlüsselungsart abrufen
    html.replace("{wifi_encryption}", wIFI_encryptionType_c);

      
      // BLE MAC-Adresse abrufen
      uint8_t ble_mac[6];
      esp_read_mac(ble_mac, ESP_MAC_BT);
      char ble_mac_str[18];
      snprintf(ble_mac_str, sizeof(ble_mac_str), "%02X:%02X:%02X:%02X:%02X:%02X", ble_mac[0], ble_mac[1], ble_mac[2], ble_mac[3], ble_mac[4], ble_mac[5]);
      html.replace("{ble_mac_address}", String(ble_mac_str));
      html.replace("{ble_info}", "Bluetooth LE: Bluetooth 5"); // Hier kannst du spezifische BLE-Informationen einfügen
      
      // KNX Informationen
      uint8_t knx_address[3] = {area, line, device};
      char knx_address_str[12];
      snprintf(knx_address_str, sizeof(knx_address_str), "%d.%d.%d", knx_address[0], knx_address[1], knx_address[2]);
      html.replace("{knx_address}", String(knx_address_str));
      
      uint8_t multicastAddress[4] = {storedData[57], storedData[58], storedData[59], storedData[60]};
      char multicast_address_str[16];
      snprintf(multicast_address_str, sizeof(multicast_address_str), "%d.%d.%d.%d", multicastAddress[0], multicastAddress[1], multicastAddress[2], multicastAddress[3]);
      html.replace("{multicast_address}", String(multicast_address_str));
      

        // Gruppenadressen lesen
        uint8_t numAddressest = storedData[173];
        String group_addresses[4];
        for (uint8_t i = 0; i < numAddressest && i < 4; i++) {
            uint8_t highByte = storedData[174 + i * 2];
            uint8_t lowByte = storedData[175 + i * 2];
            uint8_t mainGroup = highByte >> 3;
            uint8_t middleGroup = ((highByte & 0x07) << 3) | (lowByte >> 5);
            uint8_t subGroup = lowByte & 0x1F;
            group_addresses[i] = String(mainGroup) + "/" + String(middleGroup) + "/" + String(subGroup);
        }

      html.replace("{address1}", group_addresses[0]);
      
      html.replace("{address2}", group_addresses[1]);
      
      html.replace("{address3}", group_addresses[2]);
      
      html.replace("{address4}", group_addresses[3]);
      
      server3.send(200, "text/html", html);
    }



     #else



    //-----------------------------------------------------------
      void handle_esp32_info() {
          char* html = allocateHtmlInPSRAM(esp32_info_html);
          if (!html) {
              Serial.println(F("Fehler beim Zuordnen von PSRAM"));
              server3.send(500, F("text/plain"), F("Serverfehler"));
              return;
          }

          String htmlString = String(html);
          htmlString.replace(F("{flash_size}"), String(ESP.getFlashChipSize() / (1024 * 1024)));
          htmlString.replace(F("{cpu_freq}"), String(ESP.getCpuFreqMHz()));
          htmlString.replace(F("{ram_size}"), F("384"));
          htmlString.replace(F("{psram_size}"), F("8"));

          // Chip-Temperatur auslesen
          float temperature;
          temp_sensor_read_celsius(&temperature);
          htmlString.replace(F("{chip_temperatur}"), String(temperature));

          // PSRAM Berechnungen
          float totalPSRAM = (ESP.getPsramSize() + 1000000) / (1024 * 1024); // Gesamt-PSRAM in MB
          float freePSRAM = ESP.getFreePsram() / (1024.0 * 1024.0); // Freier PSRAM in MB
          float usedPSRAM = totalPSRAM - freePSRAM; // Verwendeter PSRAM in MB
          float usedPercentagePSRAM = (usedPSRAM * 100) / totalPSRAM;

          htmlString.replace(F("{usedPSRAM}"), String(usedPSRAM, 2));
          htmlString.replace(F("{totalPSRAM}"), String(totalPSRAM, 2));
          htmlString.replace(F("{usedPercentagePSRAM}"), String(usedPercentagePSRAM, 2));

          float totalHeapSizet = ESP.getHeapSize() / (1024.0 * 1024.0);
          float usedHeapSize = (ESP.getHeapSize() - ESP.getFreeHeap()) / (1024.0 * 1024.0);
          float usedPercentageHeap = (usedHeapSize * 100) / totalHeapSizet;
          
          float totalRAM = ESP.getHeapSize() / (1024.0 * 1024.0);
          float usedRAM = (ESP.getHeapSize() - ESP.getFreeHeap()) / (1024.0 * 1024.0);
          float usedPercentageRAM = (usedRAM * 100) / totalRAM;
          
          float totalFlash = ESP.getFlashChipSize() / (1024.0 * 1024.0);
          float usedFlash = (ESP.getFlashChipSize() - ESP.getFreeSketchSpace()) / (1024.0 * 1024.0);
          float usedPercentageFlash = (usedFlash * 100) / totalFlash;

          htmlString.replace(F("{used_ram}"), String(usedHeapSize, 2));
          htmlString.replace(F("{usedPercentageHeap}"), String(usedPercentageHeap, 2));
          htmlString.replace(F("{usedPercentageRAM}"), String(usedPercentageRAM, 2));
          htmlString.replace(F("{usedPercentageFlash}"), String(usedPercentageFlash, 2));

          nvs_stats_t nvs_stats;
          nvs_get_stats(NULL, &nvs_stats);
          float usedPercentageNVS = (nvs_stats.used_entries * 100.0) / nvs_stats.total_entries;

          float totalBytes = SPIFFS.totalBytes() / (1024.0 * 1024.0);
          float usedBytes = SPIFFS.usedBytes() / (1024.0 * 1024.0);
          float usedPercentageSPIFFS = (usedBytes * 100) / totalBytes;
        
          htmlString.replace(F("{usedPercentageNVS}"), String(usedPercentageNVS, 2));
          htmlString.replace(F("{usedPercentageSPIFFS}"), String(usedPercentageSPIFFS, 2));
          htmlString.replace(F("{usedHeap}"), String(usedHeapSize, 2));
          htmlString.replace(F("{totalHeap}"), String(totalHeapSizet, 2));
          htmlString.replace(F("{usedRAM}"), String(usedRAM, 3));
          htmlString.replace(F("{totalRAM}"), String(totalRAM, 3));
          htmlString.replace(F("{usedFlash}"), String(usedFlash, 2));
          htmlString.replace(F("{totalFlash}"), String(totalFlash, 2));
          htmlString.replace(F("{nvs_used_entries}"), String(nvs_stats.used_entries));
          htmlString.replace(F("{nvs_total_entries}"), String(nvs_stats.total_entries));
          htmlString.replace(F("{usedBytes}"), String(usedBytes, 2));
          htmlString.replace(F("{totalBytes}"), String(totalBytes, 2));

          htmlString.replace(F("{hardware_name}"), String(ESP.getChipModel()));
          htmlString.replace(F("{chip_revision}"), F("Xtensa dual-core 32-bit LX7"));
          htmlString.replace(F("{mac_address}"), WiFi.macAddress());
          htmlString.replace(F("{ip_address}"), WiFi.localIP().toString());
          htmlString.replace(F("{gateway_address}"), WiFi.gatewayIP().toString());
          htmlString.replace(F("{subnet_address}"), WiFi.subnetMask().toString());

          htmlString.replace(F("{rtc_temperatur}"), String(rtc_temperatur));
          htmlString.replace(F("{rtc_oszi}"), rtc_oszi ? F("Oszillator ok") : F("Oszillator nicht ok"));
          htmlString.replace(F("{g_u_clock}"), g_u_clock_ist == 1 ? F("24h") : F("12h"));

          htmlString.replace(F("{device_id}"), String(device_id_c));
          htmlString.replace(F("{fw_version}"), TB_currFwVersion);
          htmlString.replace(F("{fw_datum}"), FIRMWARE_DATE_TIME);
          htmlString.replace(F("{modbus_ip}"), WiFi.localIP().toString());

          // MQTT Informationen hinzufügen
          htmlString.replace(F("{mqtt_topic}"), String(p_inputmqtopicc));
          htmlString.replace(F("{mqtt_server}"), String(p_inputmqserverc));

          // WLAN-Frequenz abrufen
          String wifi_frequency = (WiFi.channel() <= 14) ? F("2.4") : F("5");
          htmlString.replace(F("{wifi_frequency}"), wifi_frequency);

          // WLAN-Verschlüsselungsart abrufen
          htmlString.replace("{wifi_encryption}", wIFI_encryptionType_c);


          // BLE MAC-Adresse abrufen
          uint8_t ble_mac[6];
          esp_read_mac(ble_mac, ESP_MAC_BT);
          char ble_mac_str[18];
          snprintf(ble_mac_str, sizeof(ble_mac_str), "%02X:%02X:%02X:%02X:%02X:%02X", ble_mac[0], ble_mac[1], ble_mac[2], ble_mac[3], ble_mac[4], ble_mac[5]);
          htmlString.replace(F("{ble_mac_address}"), String(ble_mac_str));
          htmlString.replace(F("{ble_info}"), F("Bluetooth LE: Bluetooth 5"));

          // KNX Informationen
          uint8_t knx_address[3] = {1, 3, 7};
          char knx_address_str[8];
          snprintf(knx_address_str, sizeof(knx_address_str), "%d.%d.%d", knx_address[0], knx_address[1], knx_address[2]);
          htmlString.replace(F("{knx_address}"), String(knx_address_str));

          uint8_t multicastAddress[4] = {224, 0, 23, 12};
          char multicast_address_str[16];
          snprintf(multicast_address_str, sizeof(multicast_address_str), "%d.%d.%d.%d", multicastAddress[0], multicastAddress[1], multicastAddress[2], multicastAddress[3]);
          htmlString.replace(F("{multicast_address}"), String(multicast_address_str));

          uint8_t address1[3] = {8, 0, 0};
          char address1_str[8];
          snprintf(address1_str, sizeof(address1_str), "%d/%d/%d", address1[0], address1[1], address1[2]);
          htmlString.replace(F("{address1}"), String(address1_str));

          uint8_t address2[3] = {8, 0, 1};
          char address2_str[8];
          snprintf(address2_str, sizeof(address2_str), "%d/%d/%d", address2[0], address2[1], address2[2]);
          htmlString.replace(F("{address2}"), String(address2_str));

          uint8_t address3[3] = {8, 0, 2};
          char address3_str[8];
          snprintf(address3_str, sizeof(address3_str), "%d/%d/%d", address3[0], address3[1], address3[2]);
          htmlString.replace(F("{address3}"), String(address3_str));

          uint8_t address4[3] = {8, 0, 3};
          char address4_str[8];
          snprintf(address4_str, sizeof(address4_str), "%d/%d/%d", address4[0], address4[1], address4[2]);
          htmlString.replace(F("{address4}"), String(address4_str));

          server3.send(200, F("text/html"), htmlString);

          free(html); // PSRAM freigeben
    }

   #endif















void handle_upload_page() {
  if (!isAuthenticated()) {
    return;
  }
  server3.sendHeader("Cache-Control", "no-cache, no-store, must-revalidate");
  server3.sendHeader("Pragma", "no-cache");
  server3.sendHeader("Expires", "-1");
  String html = R"rawliteral(
    <!DOCTYPE html>
    <html>
    <head>
      <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
      <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
      <meta http-equiv="Pragma" content="no-cache">
      <meta name='viewport' content='width=device-width, initial-scale=1'/>
      <meta name="author" content="Gebauer Holger, https://www.auto-steuerung.de/">
      <title>Datei hochladen {device_id}</title>
      <style>
        body { font-family: Arial, sans-serif; text-align: center; padding: 10px 50px; background-color: black; color: white; }
        h1 { color: #fff; border: 2px solid white; padding: 10px; }
        h2 { color: #fff; }
        p { color: #ccc; }
        a {
          display: block;
          margin: 10px auto;
          color: #007BFF;
          text-decoration: none;
          font-weight: bold;
          font-size: 1.2em;
          border: 2px solid #007BFF;
          padding: 10px;
          border-radius: 5px;
          width: 300px;
          background-color: #222;
          box-shadow: 0 4px 8px rgba(0, 0, 0, 0.4);
        }
        a:hover {
          text-decoration: underline;
          background-color: #007BFF;
          color: white;
          box-shadow: 0 8px 16px rgba(0, 0, 0, 0.8);
        }

        .status-ok {
          background-color: #28a745;
        }
        .status-nok {
          background-color: #dc3545;
        }
        table {
          margin: 20px auto;
          border-collapse: collapse;
          width: 80%;
          background-color: #222;
          color: white;
        }
        th, td {
          border: 1px solid #777;
          padding: 10px;
          text-align: center;
        }
        th {
          background-color: #0056b3;
        }
        .upload-container {
          border: 2px solid white;
          padding: 20px;
          border-radius: 10px;
          display: inline-block;
        }
      </style>
    </head>
    <body>
      <div class="upload-container">
        <h1>Datei hochladen</h1>
        <form method="POST" action="/upload" enctype="multipart/form-data">
          <input type="file" name="file">
          <input type="submit" value="Hochladen">
        </form>
      </div>
      <br>
      <a href="/index">Zur&uuml;ck</a>
    </body>
    </html>
  )rawliteral";
  server3.send(200, "text/html", html);
}



    //-----------------------------------------------------------
void call_sel_time() {
    if (data_with_time == true) {
        size_t requiredSize = strlen(w_getTime()) + strlen(answer) + 2;
        if (requiredSize < sizeof(workBuffer)) {
            int written = snprintf(workBuffer, sizeof(workBuffer), "%s %s", w_getTime(), answer);
            if (written < 0 || written >= sizeof(workBuffer)) {
                // Fehlerbehandlung für zu lange Eingabestrings
                strncpy(workBuffer, w_getTime(), sizeof(workBuffer) - 1);
                strncat(workBuffer, " ", sizeof(workBuffer) - strlen(workBuffer) - 1);
                strncat(workBuffer, answer, sizeof(workBuffer) - strlen(workBuffer) - 1);
                workBuffer[sizeof(workBuffer) - 1] = '\0'; // Sicherstellen, dass der Puffer nullterminiert ist
            }
        } else {
            // Fehlerbehandlung für zu lange Eingabestrings
            strncpy(workBuffer, w_getTime(), sizeof(workBuffer) - 1);
            strncat(workBuffer, " ", sizeof(workBuffer) - strlen(workBuffer) - 1);
            strncat(workBuffer, answer, sizeof(workBuffer) - strlen(workBuffer) - 1);
            workBuffer[sizeof(workBuffer) - 1] = '\0'; // Sicherstellen, dass der Puffer nullterminiert ist
        }
    } else {
        if (without_time == false) {
            size_t requiredSize = strlen(w_getLine()) + strlen(answer) + 2;
            if (requiredSize < sizeof(workBuffer)) {
                int written = snprintf(workBuffer, sizeof(workBuffer), "%s %s", w_getLine(), answer);
                if (written < 0 || written >= sizeof(workBuffer)) {
                    // Fehlerbehandlung für zu lange Eingabestrings
                    strncpy(workBuffer, w_getLine(), sizeof(workBuffer) - 1);
                    strncat(workBuffer, " ", sizeof(workBuffer) - strlen(workBuffer) - 1);
                    strncat(workBuffer, answer, sizeof(workBuffer) - strlen(workBuffer) - 1);
                    workBuffer[sizeof(workBuffer) - 1] = '\0'; // Sicherstellen, dass der Puffer nullterminiert ist
                }
            } else {
                // Fehlerbehandlung für zu lange Eingabestrings
                strncpy(workBuffer, w_getLine(), sizeof(workBuffer) - 1);
                strncat(workBuffer, " ", sizeof(workBuffer) - strlen(workBuffer) - 1);
                strncat(workBuffer, answer, sizeof(workBuffer) - strlen(workBuffer) - 1);
                workBuffer[sizeof(workBuffer) - 1] = '\0'; // Sicherstellen, dass der Puffer nullterminiert ist
            }
        }
    }
}
    //-----------------------------------------------------------





   #endif
//--------------Webserver-------------------------------






void mainEvaluation1() {
       
          //Serial.print("[WL] "); Serial.print(wifiCheckEnabled); Serial.print(" ");Serial.print(lastWifiCheckEnabled); Serial.print(" ");Serial.print(nightModeActive);
          // Überprüfen, ob die WLAN-Überprüfung aktiviert ist
          // Der Code überprüft, ob die WLAN-Überprüfung aktiviert oder deaktiviert ist, und speichert den Status nur, wenn sich der Wert geändert hat. 
          // Dies verhindert unnötige Schreibvorgänge und stellt sicher, dass der aktuelle Status korrekt gespeichert wird.
          if (!wifiCheckEnabled) {
              if (wifiCheckEnabled != lastWifiCheckEnabled) {
                  WLAN_DEBUG_PRINTLN("[WL][  ] WLAN-Check deaktiviert.");
                  lastWifiCheckEnabled = wifiCheckEnabled;
                  Preferences preferences;
                  preferences.begin("eenvs", false); // Ordner eenvs anlegen/verwenden
                  preferences.putBool("wifiCheckEnabled", wifiCheckEnabled);
                  preferences.end();
                  tb.sendTelemetryData("Night", "WLAN-Check deaktiviert"); 
                  delay(200);
              }
          } else {
              if (wifiCheckEnabled != lastWifiCheckEnabled || temp_set == false) {
                  temp_set = true;
                  lastWifiCheckEnabled = wifiCheckEnabled;
                  Preferences preferences;
                  preferences.begin("eenvs", false); // Ordner eenvs anlegen/verwenden
                  preferences.putBool("wifiCheckEnabled", wifiCheckEnabled);
                  preferences.end();

                  if (!nightModeActive) { 
                      WLAN_DEBUG_PRINTLN("[WL][ v] WLAN-Check aktiviert.");
                      tb.sendTelemetryData("Night", "WLAN-Check aktiviert");
                      delay(200);
                  } else {
                      WLAN_DEBUG_PRINTLN("[WL][ v] WLAN-Check im Nachtmodus aktiviert.");
                      tb.sendTelemetryData("Night", "WLAN-Check im Nachtmodus aktiviert");
                      delay(200);
                  }
              }
          }





            

            // Überprüfen, ob die aktuelle Zeit innerhalb des Nachtschaltungsfensters liegt
            // Der Code überprüft, ob die aktuelle Zeit innerhalb des Nachtschaltungsfensters liegt und passt den Nachtmodus-Status entsprechend an. 
            // Wenn die WLAN-Verbindung aktiv ist, wird der Nachtmodus beendet. Änderungen am Nachtmodus-Status werden nur gespeichert, wenn sich der Wert geändert hat.
           
            // nightModeActive wird immer auf false gesetzt, wenn die Tageszeit erreicht ist (!currentNightMode). 
            // Dies stellt sicher, dass das WLAN weiter gescannt wird, wenn es nicht mehr Nacht ist. 
            // consecutiveNightModeDays wird nur zurückgesetzt, wenn das WLAN innerhalb der Nachtzeit mindestens 1 Stunde verbunden ist.
            
            
            // Überprüfen, ob die aktuelle Zeit innerhalb des Nachtschaltungsfensters liegt
            currentNightMode = (v_currenthour >= nightStartHour || v_currenthour < nightEndHour);

            // Wenn die WLAN-Verbindung aktiv ist, setze nightModeActive auf false
            if (WiFi.status() == WL_CONNECTED) {
                nightConnectedTime += millis() - lastStatusCheckTime;
                if (nightConnectedTime >= pgm_read_dword(&requiredNightConnectedTime)) {
                    consecutiveNightModeDays = 0; // Zurücksetzen des Tageszählers
                }
            } else {
                nightConnectedTime = 0; // Zurücksetzen der verbundenen Zeit, wenn die Verbindung verloren geht
            }


            /*
            if (!nightModeActive) {           
                nightModeActive = false;         //  Nachtschaltung deaktiviert
                 //================================================================================
                //Serial.println("[WL][  ] Tageszeit erreicht. Nachtschaltung deaktiviert. WLAN-Verbindung wird überprüft.");
            } else if (currentNightMode != nightModeActive) {
                if (currentNightMode) {
                    Serial.println("[WL][! ] Nachtschaltung aktiv."); 

                    unsigned long remainingMillis2 = pgm_read_dword(&dayMillis) - (millis() - lastDayMillis);
                    unsigned long remainingMinutes2 = remainingMillis2 / 60000; // Umrechnung in Minuten
                    Serial.printf("[DEBUG] Verbleibende Minuten bis zur Ausführung: %lu\n", remainingMinutes2);
                    //tb.sendTelemetryData("Night", "Nachtschaltung aktiv");
                    if (millis() - lastDayMillis >= pgm_read_dword(&dayMillis)) {
                        lastDayMillis = millis();
                        consecutiveNightModeDays++;
                        if (consecutiveNightModeDays >= requiredConsecutiveDays) {
                            nightModeActive = true;
                            consecutiveNightModeDays = requiredConsecutiveDays;
                            Serial.println("[WL][  ] Nachtschaltung aktiv. WLAN-Verbindung wird nicht überprüft.");
                            tb.sendTelemetryData("Night", "Nachtschaltung aktiv. WLAN-Verbindung wird nicht überprüft.");delay(200);
                        }
                    }
                }
            }
             */

            /*
            Serial.print("[WL][  ] currentNightMode ");Serial.println(currentNightMode);
            Serial.print("[WL][  ] nightModeActive ");Serial.println(nightModeActive);
            Serial.print("[WL][  ] nightCounted ");Serial.println(nightCounted);
            Serial.print("[WL][  ] consecutiveNightModeDays ");Serial.println(consecutiveNightModeDays);
            */
            //-----------------------------------------------------
              if (currentNightMode && !nightModeActive && nightCounted == false) {
                  // WLAN ist offline und im Nachtzeitfenster
                  consecutiveNightModeDays++;
                  if (consecutiveNightModeDays >= requiredConsecutiveDays) {
                      consecutiveNightModeDays = requiredConsecutiveDays;
                  }
                  nightCounted = true; // Setze das Bit, um anzuzeigen, dass der Zähler hochgezählt wurde
                  Preferences preferences;
                  preferences.begin("eenvs", false); 
                  preferences.putBool("nightCounted", nightCounted); // Speichere den Zustand
                  preferences.putInt("conNightModDay", consecutiveNightModeDays);

                  if (consecutiveNightModeDays >= requiredConsecutiveDays && nightModeActive == false) {
                      nightModeActive = true;
                      preferences.putBool("nightModeActive", nightModeActive);
                      WLAN_DEBUG_PRINTLN("[WL][  ] Nachtschaltung aktiv. WLAN-Verbindung wird nicht überprüft.");
                      if (loggingEnabled) {
                          //things_list_t_16 = p_uhrzeit + "  [WL] Nachtschaltung aktiv. WLAN-Verbindung wird nicht überprüft."; 
                          write_to_log(things_list_t_16);
                      }

                      tb.sendTelemetryData("Night", "Nachtschaltung aktiv. WLAN-Verbindung wird nicht überprüft.");
                      delay(200);
                  }
              }

              if (!currentNightMode && nightCounted == true) {
                  // Setze das Bit zurück, wenn das Nachtzeitfenster endet
                  nightCounted = false;
                  Preferences preferences;
                  preferences.begin("eenvs", false); 
                  preferences.putBool("nightCounted", nightCounted); // Speichere den Zustand
              }

              if (consecutiveNightModeDays >= requiredConsecutiveDays && nightModeActive == false && currentNightMode == true) {
                  nightModeActive = true;
                  Preferences preferences;
                  preferences.begin("eenvs", false); 
                  preferences.putBool("nightModeActive", nightModeActive);
                  WLAN_DEBUG_PRINTLN("[WL][  ] Nachtschaltung aktiv. WLAN-Verbindung wird nicht überprüft.");
                  if (loggingEnabled) {
                      //things_list_t_16 = p_uhrzeit + "  [WL] Nachtschaltung aktiv. WLAN-Verbindung wird nicht überprüft."; 
                      write_to_log(things_list_t_16);
                  }
                  tb.sendTelemetryData("Night", "Nachtschaltung aktiv. WLAN-Verbindung wird nicht überprüft.");
                  delay(200);
              }

            //---------------------------------------------------



            // Nur speichern, wenn sich der Wert geändert hat
            if (nightModeActive != storedNightModeActive) {
                Preferences preferences;
                preferences.begin("eenvs", false); // Ordner eenvs anlegen/verwenden
                preferences.putBool("nightModeActive", nightModeActive);
                preferences.putInt("conNightModDay", consecutiveNightModeDays); // Speichern des Tageszählers
                preferences.putULong("lastDayMillis", lastDayMillis); // Speichern des letzten Tageszeitpunkts
                preferences.end();
                storedNightModeActive = nightModeActive; // Aktualisiere den gespeicherten Wert
                snprintf(statusMessagenight, sizeof(statusMessagenight), "Night Mode Active change: %s", nightModeActive ? "true" : "false");
                tb.sendTelemetryData("Night", statusMessagenight);delay(200);
            }

            lastStatusCheckTime = millis(); // Aktualisieren der letzten Statusüberprüfungszeit



            if (lastStatusCheckTime - startMillissend >= pgm_read_dword(&periodsend)) {
                startMillissend = lastStatusCheckTime;  // Timer zurücksetzen
               
                if (nightModeActive) {
                  tb.sendTelemetryData("Night", "Nachtschaltung aktiv");delay(200);
                  snprintf(statusMessagenight, sizeof(statusMessagenight), "Nachtschaltung aktiv");
                } else {
                  tb.sendTelemetryData("Night", "Nachtschaltung deaktiviert");delay(200);
                  snprintf(statusMessagenight, sizeof(statusMessagenight), "Nachtschaltung deaktiviert");
                }
                  
                  //const int attribute_items_37 = 1;
                  Attribute attributes37[1] = {
                  { D_night_staus_KEY,  statusMessagenight },   //   
                  }; 
                    tb.sendAttributes(attributes37, 1);delay(200);



            }









}


//-------------------------------------------------------------------------------------
void mainEvaluation2() {

  //--------------
  // Nur fortfahren, wenn der Nachtmodus nicht aktiv ist
  if (!nightModeActive) {                       //  Nachtschaltung deaktiviert

      //-------------------------------------------------
      // Überprüfen, ob das Intervall abgelaufen ist
      // Der Code überprüft regelmäßig den WLAN-Status und speichert ihn in cachedWiFiStatus. 
      // Wenn der Status nicht WL_CONNECTED ist und dies mehrmals hintereinander passiert, wird der Status entsprechend aktualisiert. 
      // Der aktuelle WLAN-Status wird dann in currentWiFiStatus gespeichert.
      if (previousSeconds >= pgm_read_dword(&checkInterval)) {     
          previousSeconds = 0;
       
         
          if(connectedTime>10){previousConnectedTime = connectedTime;} // Speichern der vorherigen Verbindungszeit
          if(offlineTime>10){previousofflineTime = offlineTime;} // Speichern der vorherigen Verbindungszeit

                    
          // Überprüfen, ob das Intervall abgelaufen ist
          //if (millis() - lastStatusCheckTime >= statusCheckInterval) {
               
               currentStatus = WiFi.status();
               cachedWiFiStatus = currentStatus;

                  //Serial.print("[WL][  ] WiFi Status abfragen: ");
                  if (currentStatus == WL_CONNECTED) {
                      //Serial.println(" WLAN ist verbunden.");
                        char statusMessage[100]; // Puffer für die Statusnachricht
                        WLAN_DEBUG_PRINTLN(" ");
                        //printf("[AP] FREE HEAP: now: %u, contiguous: %u, lowest: %u\n",xPortGetFreeHeapSize(),heap_caps_get_largest_free_block(MALLOC_CAP_DEFAULT),xPortGetMinimumEverFreeHeapSize());
         
                        if (connectedTime < 60) {
                            snprintf(statusMessage, sizeof(statusMessage), "WLAN verbunden seit: %lus", connectedTime);
                            Serial.printf("[WL][  ] WLAN verbunden seit: %lus\n", connectedTime);Serial.println(F(" "));
                        } else if (connectedTime < 3600) {
                            int minutes = connectedTime / 60;
                            int seconds = connectedTime % 60;
                            snprintf(statusMessage, sizeof(statusMessage), "WLAN verbunden seit: %d Min und %d Sek", minutes, seconds);
                            Serial.printf("[WL][  ] WLAN verbunden seit: %d Minuten und %d Sekunden\n", minutes, seconds);Serial.println(F(" "));
                        } else {
                            int hours = connectedTime / 3600;
                            int minutes = (connectedTime % 3600) / 60;
                            snprintf(statusMessage, sizeof(statusMessage), "WLAN verbunden seit: %d Stunden und %d Min", hours, minutes);
                            Serial.printf("[WL][  ] WLAN verbunden seit: %d Stunden und %d Minuten\n", hours, minutes);Serial.println(F(" "));
                        }

                        tb.sendTelemetryData("Night", statusMessage);delay(200);
                        unsigned long currentTime = millis();
                        if (currentTime - lastLogTimeWiFiStatus >= 3600000) { // 3600000 Millisekunden = 1 Stunde
                            if (loggingEnabled) {
                            //things_list_t_16 = p_uhrzeit + "  [WL] " + String(statusMessage);
                            write_to_log(things_list_t_16);
                            }
                            lastLogTimeWiFiStatus = currentTime; // Aktualisieren Sie die letzte Log-Zeit
                        }
                  
                        //---------
                        // Sende die Statusnachricht
                        //const int attribute_items_34 = 1;
                        Attribute attributes34[1] = {
                          { D_WLAN_on_KEY,  statusMessage },   //   WLAN
                        };  
                        tb.sendAttributes(attributes34, 1);delay(200);
          
                        tb.sendTelemetryData("WTD", ee_var_01); delay(200);



                        //---------
                          if (nightModeActive) {
                            //tb.sendTelemetryData("Night", "Nachtschaltung aktiv");
                            snprintf(statusMessagenight, sizeof(statusMessagenight), "Nachtschaltung aktiv");
                          } else {
                            //tb.sendTelemetryData("Night", "Nachtschaltung deaktiviert");
                            snprintf(statusMessagenight, sizeof(statusMessagenight), "Nachtschaltung deaktiviert");
                          }
                          if (currentTime - lastLogTimeNightModeInactive >= 3600000) {
                            if (loggingEnabled) {
                            //things_list_t_16 = p_uhrzeit + "  [WL] Nachtschaltung deaktiviert"; 
                            write_to_log(things_list_t_16);
                            }
                            lastLogTimeNightModeInactive = currentTime;
                          }
                            
                          //const int attribute_items_37 = 1;
                          Attribute attributes37[1] = {
                          { D_night_staus_KEY,  statusMessagenight },   //   
                          }; 
   
                          tb.sendAttributes(attributes37, 1);delay(200);

                          tb.sendTelemetryData("Night", statusMessagenight);delay(200);
                        //---------  


                  } else {
                      
                      if(previousConnectedTime>10){
                          int hours = previousConnectedTime / 3600;
                          int minutes = (previousConnectedTime % 3600) / 60;
                          Serial.printf("[WL][  ] WLAN war verbunden: %d Stunden und %d Minuten\n", hours, minutes);Serial.println(F(" "));
                        
                          //---------
                          char statusMessage[100]; // Puffer für die Statusnachricht
                          snprintf(statusMessage, sizeof(statusMessage), "WLAN war verbunden: %d Stunden und %d Min", hours, minutes);
                          // Sende die Statusnachricht
                          //const int attribute_items_34 = 1;
                          Attribute attributes34[1] = {
                            { D_WLAN_on_KEY,  statusMessage },   //   WLAN
                          };  
                          tb.sendAttributes(attributes34, 1);delay(200);
                          //tb.sendTelemetryData("WLAN__on", statusMessage);
    
                          tb.sendTelemetryData("Night", statusMessage);delay(200);
  

                          //---------
                            if (nightModeActive) {
                              //tb.sendTelemetryData("Night", "Nachtschaltung aktiv");
                              snprintf(statusMessagenight, sizeof(statusMessagenight), "Nachtschaltung aktiv");
                            } else {
                              //tb.sendTelemetryData("Night", "Nachtschaltung deaktiviert");
                              snprintf(statusMessagenight, sizeof(statusMessagenight), "Nachtschaltung deaktiviert");
                            }
                              
                            //const int attribute_items_37 = 1;
                            Attribute attributes37[1] = {
                            { D_night_staus_KEY,  statusMessagenight },   //   
                            }; 

                            tb.sendAttributes(attributes37, 1);delay(200);

                          tb.sendTelemetryData("Night", statusMessagenight);delay(200);
                          //--------- 

                      }
                      Serial.println(F("[WL][  ] WLAN ist nicht verbunden."));
                      WiFi_status = WL_CONNECT_FAILED;    
                  }
              if (currentStatus != WL_CONNECTED) {
                  failedStatusCheckCount++;
                  if (failedStatusCheckCount >= 2) {
                      cachedWiFiStatus = currentStatus;
                      Serial.println(F("[WL][  ] Status is not OK"));
                      WiFi_status = WL_CONNECT_FAILED;
                  }
              } else {
                  failedStatusCheckCount = 0; // Reset the count if the status is OK
                  cachedWiFiStatus = currentStatus;
                  Serial.println(F("[WL][  ] Status is OK "));
              }
              lastStatusCheckTime = millis();
        // }
    
          // WLAN-Status überprüfen
          currentWiFiStatus = (cachedWiFiStatus == WL_CONNECTED);
          //---------------------------------------------


          //---------------------------------------------
          // Wenn sich der WLAN-Status geändert hat
          // Der Code überprüft, ob sich der WLAN-Status geändert hat, und gibt entsprechende Nachrichten aus. 
          // Wenn das WLAN verbunden ist, werden verschiedene Zähler zurückgesetzt. Wenn das WLAN nicht verbunden ist, wird der offlineTime-Zähler zurückgesetzt.
          if (currentWiFiStatus != lastWiFiStatus) {
              Serial.print(F("[WL][!!] Change WIFI Status: "));Serial.println(currentWiFiStatus);
              lastWiFiStatus = currentWiFiStatus;
              lastScanTime = millis();

              if (currentWiFiStatus) {
                  //Serial.println("[WL][  ] WLAN verbunden!");
                  //Serial.print("[WL][  ] IP-Adresse: ");
                  //Serial.println(WiFi.localIP());                     

                        char statusMessage[100]; // Puffer für die Statusnachricht

                        if (connectedTime < 60) {
                            snprintf(statusMessage, sizeof(statusMessage), "WLAN verbunden seit: %lus", connectedTime);
                            Serial.printf("[WL][x ] WLAN verbunden seit: %lus\n", connectedTime);Serial.println(F(" "));
                        } else if (connectedTime < 3600) {
                            int minutes = connectedTime / 60;
                            int seconds = connectedTime % 60;
                            snprintf(statusMessage, sizeof(statusMessage), "WLAN verbunden seit: %d Min und %d Sek", minutes, seconds);
                            Serial.printf("[WL][x ] WLAN verbunden seit: %d Minuten und %d Sekunden\n", minutes, seconds);Serial.println(F(" "));
                        } else {
                            int hours = connectedTime / 3600;
                            int minutes = (connectedTime % 3600) / 60;
                            snprintf(statusMessage, sizeof(statusMessage), "WLAN verbunden seit: %d Stunden und %d Min", hours, minutes);
                            Serial.printf("[WL][x ] WLAN verbunden seit: %d Stunden und %d Minuten\n", hours, minutes);Serial.println(F(" "));
                        }

                        // Sende die Statusnachricht
                        //const int attribute_items_35 = 1;
                        Attribute attributes35[1] = {
                          { D_WLAN_on_KEY,  statusMessage },   //   WLAN
                        };  
                        tb.sendAttributes(attributes35, 1);delay(200);

                        //tb.sendTelemetryData("WLAN__on", statusMessage);
                          tb.sendTelemetryData("Night", statusMessage);delay(200);


                        //---------
                          if (nightModeActive) {
                            //tb.sendTelemetryData("Night", "Nachtschaltung aktiv");
                            snprintf(statusMessagenight, sizeof(statusMessagenight), "Nachtschaltung aktiv");
                          } else {
                            //tb.sendTelemetryData("Night", "Nachtschaltung deaktiviert");
                            snprintf(statusMessagenight, sizeof(statusMessagenight), "Nachtschaltung deaktiviert");
                          }
                            
                          //const int attribute_items_37 = 1;
                          Attribute attributes37[1] = {
                          { D_night_staus_KEY,  statusMessagenight },   //   
                          }; 
         
                          tb.sendAttributes(attributes37, 1);delay(200);
     
                          tb.sendTelemetryData("Night", statusMessagenight);delay(200);
                        //---------  




                  failedCheckCount = 0; // Reset the failed check count on successful connection
                  connectedTime = 0; // Reset the connected time
                  nightModeDetectionCount = 0; // Reset the night mode detection count on successful connection
                  additionalFailedCheckCount = 0; // Reset the additional failed check count on successful connection
              } else {
                  Serial.println(F("[WL][  ] WLAN-Verbindung verloren!!!"));delay(200);

                  tb.sendTelemetryData("Night", "WLAN-Verbindung verloren");delay(200);
                  
                  if(previousConnectedTime>10){
                    int hours = previousConnectedTime / 3600;
                    int minutes = (previousConnectedTime % 3600) / 60;
                    Serial.printf("[WL][  ] WLAN war verbunden: %d Stunden und %d Minuten\n", hours, minutes);Serial.println(F(" ")); // Ausgabe der vorherigen Verbindungszeit

                    snprintf(statusMessagenight, sizeof(statusMessagenight), "WLAN war verbunden für: %lus\n", previousConnectedTime);
  
                    tb.sendTelemetryData("Night", statusMessagenight);delay(200);
                    if (loggingEnabled) {
                    //things_list_t_16 = p_uhrzeit + "  [WL] " + String(statusMessagenight); 
                    write_to_log(things_list_t_16);
                    }
                  }

                  
                  offlineTime = 0; // Reset the offline time
              }
              //Preferences preferences;
              //preferences.begin("eenvs", false);                         //Ordner eenvs anlegen/verwenden
              //preferences.putBool("lastWiFiStatus", lastWiFiStatus);
          }
          //---------------------------------------------

          //---------------------------------------------
          // Wenn das WLAN-Modul ausgefallen ist, ESP32 neu starten
          // Der Code überwacht den WLAN-Status und versucht, das WLAN-Modul neu zu starten, wenn es ausgefallen ist. 
          // Wenn consecutiveFailedChecks 2 oder mehr erreicht und ein WLAN-Scan gestartet
          // Wenn failedCheckCount den Wert von maxFailedChecks erreicht oder überschreitet, wird der ESP32 neu gestartet

          // Wenn Netzwerke gefunden werden, wird failedCheckCount auf 0 zurückgesetzt.
          // Zusätzlicher Zähler für Neustart nach konfigurierbarer Anzahl von Überprüfungen
            WLAN_DEBUG_PRINTLN("[WL][xx] current WiFi Status!  ");
            if (!currentWiFiStatus) {
                WLAN_DEBUG_PRINTLN("[WL][xx] WLAN ist nicht verbunden.");
                WLAN_DEBUG_PRINTLN("[WL][xx] WLAN erneut checken.");
                WiFi_status = WL_CONNECT_FAILED;    

                tb.sendTelemetryData("Night", "WLAN erneut checken"); delay(200);
                currentStatus = WiFi.status();
                cachedWiFiStatus = currentStatus;
                currentWiFiStatus = (cachedWiFiStatus == WL_CONNECTED);
                
                //-------------------
                if (!currentWiFiStatus) {
                    WLAN_DEBUG_PRINTLN("[WL][xx] WLAN ist doch nicht verbunden!");
                    WiFi_status = WL_CONNECT_FAILED;
                } else {
                    WLAN_DEBUG_PRINTLN("[WL][xx] WLAN ist doch verbunden.");
                }
                //--------------------

            } else {
                WLAN_DEBUG_PRINTLN("[WL][xx] WLAN ist verbunden.");
                WLAN_DEBUG_PRINTLN(F(" "));

                char statusMessage[100]; // Puffer für die Statusnachricht

                if (connectedTime < 60) {
                    snprintf(statusMessage, sizeof(statusMessage), "WLAN verbunden seit: %lus", connectedTime);
                    WLAN_DEBUG_PRINTF("[WL][x ] WLAN verbunden seit: %lus\n", connectedTime); WLAN_DEBUG_PRINTLN(F(" "));
                } else if (connectedTime < 3600) {
                    int minutes = connectedTime / 60;
                    int seconds = connectedTime % 60;
                    snprintf(statusMessage, sizeof(statusMessage), "WLAN verbunden seit: %d Min und %d Sek", minutes, seconds);
                    #ifdef WLAN_DEBUG
                    WLAN_DEBUG_PRINTF("[WL][x ] WLAN verbunden seit: %d Minuten und %d Sekunden\n", minutes, seconds); WLAN_DEBUG_PRINTLN(F(" "));
                    #endif
                } else {
                    int hours = connectedTime / 3600;
                    int minutes = (connectedTime % 3600) / 60;
                    snprintf(statusMessage, sizeof(statusMessage), "WLAN verbunden seit: %d Stunden und %d Min", hours, minutes);
                    #ifdef WLAN_DEBUG
                    WLAN_DEBUG_PRINTF("[WL][x ] WLAN verbunden seit: %d Stunden und %d Minuten\n", hours, minutes); WLAN_DEBUG_PRINTLN(F(" "));
                    #endif
                }

                // Sende die Statusnachricht
                //const int attribute_items_35 = 1;
                Attribute attributes35[1] = {
                    { D_WLAN_on_KEY,  statusMessage },   //   WLAN
                };  
                tb.sendAttributes(attributes35, 1); delay(200);

                //tb.sendTelemetryData("WLAN__on", statusMessage);
                tb.sendTelemetryData("Night", statusMessage); delay(200);

                //---------
                if (nightModeActive) {
                    //tb.sendTelemetryData("Night", "Nachtschaltung aktiv");
                    snprintf(statusMessagenight, sizeof(statusMessagenight), "Nachtschaltung aktiv");
                } else {
                    //tb.sendTelemetryData("Night", "Nachtschaltung deaktiviert");
                    snprintf(statusMessagenight, sizeof(statusMessagenight), "Nachtschaltung deaktiviert");
                }

                //const int attribute_items_37 = 1;
                Attribute attributes37[1] = {
                    { D_night_staus_KEY,  statusMessagenight },   //   
                }; 

                tb.sendAttributes(attributes37, 1); delay(200);
                tb.sendTelemetryData("Night", statusMessagenight); delay(200);
                //---------  
            }



          if (!currentWiFiStatus) {
              consecutiveFailedChecks++;
              additionalFailedCheckCount++;

              if (consecutiveFailedChecks >= 2) {

                  consecutiveFailedChecks = 0;
                  WLAN_DEBUG_PRINTLN("[WL][  ] WiFi.scanNetworks!");
                  esp_task_wdt_reset();
                 //---------------------------

                int scanResult = -1;

                if (heap_caps_get_largest_free_block(MALLOC_CAP_DEFAULT) > 5000) {

                    scanResult = WiFi.scanNetworks(true); // Starte den Scan im Hintergrund
                    unsigned long startTime = millis(); // Speichere die Startzeit

                    if (scanResult == WIFI_SCAN_FAILED) {
   
                        WLAN_DEBUG_PRINTLN("[WL][  ] WiFi Scan failed to start");
                        WLAN_DEBUG_PRINTLN("[WL][  ] WiFi erneut initialisieren und Scan starten");

                        // Initialisiere das WiFi-Modul nur bei Fehler
                        WiFi.mode(WIFI_STA);
                        WiFi.disconnect(); // Trenne alle bestehenden Verbindungen
                        // Starte den Scan erneut
                        scanResult = WiFi.scanNetworks(true);
                        startTime = millis(); // Aktualisiere die Startzeit
                    }

                    if (scanResult == WIFI_SCAN_RUNNING) { // WIFI_SCAN_RUNNING: Der Scan läuft noch.
                        // Warte auf das Ende des Scans oder breche nach 20 Sekunden ab
                        while (WiFi.scanComplete() == WIFI_SCAN_RUNNING) { // WIFI_SCAN_RUNNING: Der Scan läuft noch.
                            esp_task_wdt_reset();
                            delay(100);
                            if (millis() - startTime > 20000) { // 20 Sekunden sind vergangen
                                WLAN_DEBUG_PRINTLN("[WL][  ] WiFi Scan aborted after 20 seconds");
                                break;
                            }
                        }
                        scanResult = WiFi.scanComplete();
                        
                        if (scanResult == WIFI_SCAN_FAILED) {
                            WLAN_DEBUG_PRINTLN("[WL][  ] WiFi Scan failed to complete");
                        } else if (scanResult != WIFI_SCAN_RUNNING) {
                            WLAN_DEBUG_PRINTF("[WL][  ] Anzahl der gefundenen WLAN-Netzwerke: %d\n", scanResult);
                            WLAN_DEBUG_PRINTLN(F(" "));
                            for (int i = 0; i < scanResult; ++i) {
                                WLAN_DEBUG_PRINTF("[  ][- ] SSID: %s, RSSI: %d\n", WiFi.SSID(i).c_str(), WiFi.RSSI(i));
                                WLAN_DEBUG_PRINTLN(F(" "));
                            }
                        }
                    } else {
                        // Ausgabe der Anzahl der gefundenen WLAN-Netzwerke

                        WLAN_DEBUG_PRINTF("[WL][ -] Anzahl der gefundenen WLAN-Netzwerke: %d\n", scanResult);
                        WLAN_DEBUG_PRINTLN(F(" "));
                        #ifdef WLAN_DEBUG
                          for (int i = 0; i < scanResult; ++i) {
                              WLAN_DEBUG_PRINTF("[  ][  ] SSID: %s, RSSI: %d\n", WiFi.SSID(i).c_str(), WiFi.RSSI(i));
                              WLAN_DEBUG_PRINTLN(F(" "));
                          }
                        #endif
                    }
                } else {
                    #ifdef WLAN_DEBUG
                    size_t largestFreeBlock = heap_caps_get_largest_free_block(MALLOC_CAP_DEFAULT);
                    #endif
                    WLAN_DEBUG_PRINT("[WI][  ] Kein Scan möglich wegen zu wenig Arbeitsspeicher: ");

                    WLAN_DEBUG_PRINTLN(largestFreeBlock);
                    scanResult = 0;
                }

                  //-----------------------



                  //------------------------------------------------------------------------------------
                  if (scanResult == 0 || WiFi.status() != WL_CONNECTED) {
                      failedCheckCount++;
                      #ifdef WLAN_DEBUG
                      Serial.println(F(" "));
                      Serial.printf("[WL][  ] WLAN-Modul scheint ausgefallen zu sein, oder Router ist nicht in Reichweite. Fehlversuche: %d/%d\n", failedCheckCount, maxFailedChecks);Serial.println(F(" "));
                      Serial.printf("[WL][  ] WLAN-Modul scheint instabil zu sein. Aktuell %d Versuche erfolgt zum wiederherstellen.\n", additionalFailedCheckCount);Serial.println(F(" "));

                      int hours = previousConnectedTime / 3600;
                      int minutes = (previousConnectedTime % 3600) / 60;

                      Serial.printf("[WL][  ] WLAN war verbunden: %d Stunden und %d Minuten\n", hours, minutes);Serial.println(F(" ")); // Ausgabe der vorherigen Verbindungszeit
                      #endif 
                      snprintf(statusMessagenight, sizeof(statusMessagenight), "WLAN-Modul scheint ausgefallen zu sein, oder Router nicht in Reichweite. Fehlversuche: %d/%d\n", failedCheckCount, maxFailedChecks);
                      tb.sendTelemetryData("Night", statusMessagenight);delay(200);
                      if (loggingEnabled) {
                      //things_list_t_16 = p_uhrzeit + "  [WL] " + String(statusMessagenight); 
                      write_to_log(things_list_t_16);
                      }
                      connectionAttemptCount++;

                      if (connectionAttemptCount % 3 == 0) {
                          #ifdef WLAN_DEBUG
                          Serial.printf("WLAN-Verbindung wird überprüft... Offline-Zeit: %lus\n", offlineTime);Serial.println(F(" "));
                          #endif
                      }

                      if (failedCheckCount >= maxFailedChecks || additionalFailedCheckCount >= maxAdditionalFailedChecks) {
                          restartCount++;
                          #ifdef WLAN_DEBUG
                          Serial.printf("[WL][  ] WLAN-Modul immer noch ausgefallen. Neustart des ESP32... (Fehlversuche: %d, Offline-Zeit: %lus, Neustarts: %d)\n", failedCheckCount, offlineTime, restartCount);Serial.println(F(" "));
                          #endif
                          int len = snprintf(NULL, 0, "WLAN-Modul immer noch ausgefallen. Neustart des ESP32... (Fehlversuche: %d, Offline-Zeit: %lus, Neustarts: %d)\n", failedCheckCount, offlineTime, restartCount);
                          if (len < sizeof(statusMessagenight)) {
                              snprintf(statusMessagenight, sizeof(statusMessagenight), "WLAN-Modul immer noch ausgefallen. Neustart des ESP32... (Fehlversuche: %d, Offline-Zeit: %lus, Neustarts: %d)\n", failedCheckCount, offlineTime, restartCount);
                              tb.sendTelemetryData("Night", statusMessagenight);delay(200);
                          } else {
                              // Fehlerbehandlung, falls die Nachricht zu lang ist
                          }

                          Preferences preferences;
                          preferences.begin("eenvs", false); // Ordner eenvs anlegen/verwenden
                          preferences.putInt("restartCount", restartCount);
  
                          g_boot_fail = 1;
                          preferences.putUChar("boot_g_fail", g_boot_fail);    // 
                          preferences.end(); 

                          tb.sendTelemetryData("Night", "WLAN-Modul immer noch ausgefallen. Neustart des ESP32");delay(200);

                          printStatus();
                          g_esp_soft_restart = true;
                      }

                      Preferences preferences;
                      preferences.begin("eenvs", false); // Ordner eenvs anlegen/verwenden
                      preferences.putInt("failedCheckCount", failedCheckCount);
                      preferences.putInt("connecCount", connectionAttemptCount);
                      preferences.end();
                  } else {
                      failedCheckCount = 0; // Reset the failed check count if the scan is successful
                      additionalFailedCheckCount = 0; // Reset the additional failed check count if the scan is successful
                  }

              }


              connectionAttemptCount++;
              //Serial.println("[WL][  ] connectionAttemptCount ");Serial.println(connectionAttemptCount);

              if (connectionAttemptCount % 3 == 0) {
                  if (offlineTime < 60) {
                      if (offlineTime > 1) {
                          #ifdef WLAN_DEBUG
                          Serial.printf("[WL][  ] WLAN getrennt seit: %lus\n", offlineTime);Serial.println(F(" "));
                          #endif
                          snprintf(statusMessagenight, sizeof(statusMessagenight), "WLAN getrennt seit: %lus\n", offlineTime);
                      }
                  } else if (offlineTime < 3600) {
                      int minutes = offlineTime / 60;
                      int seconds = offlineTime % 60;
                      #ifdef WLAN_DEBUG
                      Serial.printf("[WL][  ] WLAN getrennt seit: %d Minuten und %d Sekunden\n", minutes, seconds);Serial.println(F(" "));
                      #endif
                      snprintf(statusMessagenight, sizeof(statusMessagenight), "WLAN getrennt seit: %d Minuten und %d Sekunden\n", minutes, seconds);
                  } else {
                      int hours = offlineTime / 3600;
                      int minutes = (offlineTime % 3600) / 60;
                      #ifdef WLAN_DEBUG
                      Serial.printf("[WL][  ] WLAN getrennt seit: %d Stunden und %d Minuten\n", hours, minutes);Serial.println(F(" "));
                      #endif
                      snprintf(statusMessagenight, sizeof(statusMessagenight), "WLAN getrennt seit: %d Stunden und %d Minuten\n", hours, minutes);
                  
                  }
                
                  tb.sendTelemetryData("Night", statusMessagenight);delay(200);
                  if (loggingEnabled) {
                  //things_list_t_16 = p_uhrzeit + "  [WL] " + String(statusMessagenight); 
                  write_to_log(things_list_t_16);
                  }
                  
                  Preferences preferences;
                  preferences.begin("eenvs", false); // Ordner eenvs anlegen/verwenden
                  preferences.putInt("failedCheckCount", failedCheckCount);
                  preferences.putInt("connecCount", connectionAttemptCount);
                  preferences.end();

              }





          } else {

              // Reset the failed check count if the scan is successful
              failedCheckCount = 0;
              consecutiveFailedChecks = 0;
              additionalFailedCheckCount = 0;
              connectionAttemptCount = 0;


          }

          //---------------------------------------------



            // Zusätzlicher Zähler für Neustart nach konfigurierbarer Anzahl von Überprüfungen
            // Der Code überwacht den WLAN-Status und führt einen Scan durch, wenn das WLAN nicht verbunden ist. 
            // Wenn der Scan erfolgreich ist, wird der Zähler für fehlgeschlagene Überprüfungen zurückgesetzt. 
            // Wenn der Zähler einen bestimmten Wert erreicht, wird der ESP32 neu gestartet.
            /*
            Serial.println("[WL][xx] currentWiFiStatus!");
            if (!currentWiFiStatus) {
                Serial.println("[WL][ x] WiFi.scanNetworks!");
                esp_task_wdt_reset();
                int scanResult = WiFi.scanNetworks(true); // Starte den Scan im Hintergrund
                if (scanResult == WIFI_SCAN_RUNNING) { // WIFI_SCAN_RUNNING: Der Scan läuft noch.
                    // Warte auf das Ende des Scans
                    while (WiFi.scanComplete() == WIFI_SCAN_RUNNING) {// WIFI_SCAN_RUNNING: Der Scan läuft noch.
                        esp_task_wdt_reset();
                        delay(100);
                    }
                    scanResult = WiFi.scanComplete();
                }

                if (scanResult > 0 || WiFi.status() != WL_CONNECTED) {
                    additionalFailedCheckCount++;
                    Serial.printf("[WL][  ] WLAN-Modul scheint instabil zu sein. Aktuell %d Versuche erfolgt zum wiederherstellen.\n", additionalFailedCheckCount);
                    if (additionalFailedCheckCount >= maxAdditionalFailedChecks) {
                        Serial.printf("[WL][  ] WLAN-Modul scheint instabil zu sein. Neustart des ESP32 nach %d fehlgeschlagenen Überprüfungen...\n", maxAdditionalFailedChecks);
                        printStatus();
                        
                        g_esp_soft_restart = true;
                    }
                } else {
                    additionalFailedCheckCount = 0; // Reset the additional failed check count if the scan is successful
                }
            }
              */



      }
        //----------------------------------------------------




        
        //----------------------------------------------------
        // Überprüfen, ob die Wartezeit abgelaufen ist
        if (restartTimer != 0 && previousSeconds >= restartTimer) {
            // Erste Überprüfung
            if (!currentWiFiStatus) {
                // Starte den Scan im Hintergrund
                #ifdef WLAN_DEBUG
                Serial.println(F("[WL][ x] WiFi.scanNetworks, Starte den Scan im Hintergrund"));
                #endif
                esp_task_wdt_reset();
                //-------------------------------

                    //------------------------------
                    int scanResult = -1;

                    if (heap_caps_get_largest_free_block(MALLOC_CAP_DEFAULT) > 5000) {

                      scanResult = WiFi.scanNetworks(true); // Starte den Scan im Hintergrund
                        unsigned long startTime = millis(); // Speichere die Startzeit

                        if (scanResult == WIFI_SCAN_FAILED) {
                            #ifdef WLAN_DEBUG
                            Serial.println(F("[WL][ x] WiFi Scan failed to start"));
                            Serial.println(F("[WL][ x] WiFi erneut initialisieren und Scan starten"));
                            #endif
                            // Initialisiere das WiFi-Modul nur bei Fehler
                            WiFi.mode(WIFI_STA);
                            WiFi.disconnect(); // Trenne alle bestehenden Verbindungen
                            // Starte den Scan erneut
                            scanResult = WiFi.scanNetworks(true);
                            startTime = millis(); // Aktualisiere die Startzeit
                        }

                        if (scanResult == WIFI_SCAN_RUNNING) { // WIFI_SCAN_RUNNING: Der Scan läuft noch.
                            // Warte auf das Ende des Scans oder breche nach 20 Sekunden ab
                            while (WiFi.scanComplete() == WIFI_SCAN_RUNNING) { // WIFI_SCAN_RUNNING: Der Scan läuft noch.
                                esp_task_wdt_reset();
                                delay(100);
                                if (millis() - startTime > 20000) { // 20 Sekunden sind vergangen
                                    #ifdef WLAN_DEBUG
                                    WLAN_DEBUG_PRINTLN(F("[WL][ x] WiFi Scan aborted after 20 seconds"));
                                    #endif
                                    break;
                                }
                            }
                            scanResult = WiFi.scanComplete();
                            
                            if (scanResult == WIFI_SCAN_FAILED) {
                                #ifdef WLAN_DEBUG
                                WLAN_DEBUG_PRINTLN(F("[WL][ x] WiFi Scan failed to complete"));
                                #endif
                            } else if (scanResult != WIFI_SCAN_RUNNING) {
                                WLAN_DEBUG_PRINTF("[WL][ x] Anzahl der gefundenen WLAN-Netzwerke: %d\n", scanResult);
                                WLAN_DEBUG_PRINTLN(F(" "));
                                for (int i = 0; i < scanResult; ++i) {
                                    WLAN_DEBUG_PRINTF("[  ][ x] SSID: %s, RSSI: %d\n", WiFi.SSID(i).c_str(), WiFi.RSSI(i));
                                    WLAN_DEBUG_PRINTLN(F(" "));
                                }
                            }
                        } else {
                            // Ausgabe der Anzahl der gefundenen WLAN-Netzwerke
                            WLAN_DEBUG_PRINTF("[WL][ o] Anzahl der gefundenen WLAN-Netzwerke: %d\n", scanResult);
                            WLAN_DEBUG_PRINTLN(F(" "));
                            for (int i = 0; i < scanResult; ++i) {
                                WLAN_DEBUG_PRINTF("[  ][  ] SSID: %s, RSSI: %d\n", WiFi.SSID(i).c_str(), WiFi.RSSI(i));
                                WLAN_DEBUG_PRINTLN(F(" "));
                            }
                        }
                        } else {
                            #ifdef WLAN_DEBUG
                            size_t largestFreeBlock = heap_caps_get_largest_free_block(MALLOC_CAP_DEFAULT);
                            #endif
                            WLAN_DEBUG_PRINT("[WI][ x] Kein Scan möglich wegen zu wenig Arbeitsspeicher: ");
                            WLAN_DEBUG_PRINTLN(largestFreeBlock);
                            scanResult = 0;
                        }



                  // Ausgabe der Anzahl der gefundenen WLAN-Netzwerke
                 // Serial.printf("[WL][  ] Anzahl der gefundenen WLAN-Netzwerke: %d\n", scanResult);Serial.println(F(" "));

                // Zweite Überprüfung
                if (scanResult == 0) {
                    restartCount++;
                    WLAN_DEBUG_PRINTF("[WL][ x] WLAN-Modul immer noch ausgefallen. Neustart des ESP32... (Fehlversuche: %d, Offline-Zeit: %lus, Neustarts: %d)\n", failedCheckCount, offlineTime, restartCount);
                    WLAN_DEBUG_PRINTLN(F(" "));
                    Preferences preferences;
                    preferences.begin("eenvs", false); // Ordner eenvs anlegen/verwenden
                    preferences.putInt("restartCount", restartCount);

                    g_boot_fail = 1;
                    preferences.putUChar("boot_g_fail", g_boot_fail);    

                    tb.sendTelemetryData("Night", "WLAN-Modul immer noch ausgefallen. Neustart des ESP32...");
                    delay(200);

                    preferences.end(); 
                    printStatus();
                    
                    g_esp_soft_restart = true;
                } else {
                    // Wenn das WLAN wieder funktioniert, den Timer zurücksetzen
                    restartTimer = 0;
                }

            } else {
                // Wenn das WLAN wieder funktioniert, den Timer zurücksetzen
                restartTimer = 0;
            }
        }
        //----------------------------------------------------



          if(g_check_send_ueberwachung == true){

            g_check_send_ueberwachung = false;

                //---------------------------------------------------------------
                // Auswertung nur durchführen, wenn send_ueberw_counter_start > 1 ist
                  char statusMessage[100]; // Puffer für die Statusnachricht
                  TB_DEBUG_MED_PRINTLN(F("--------------------------------------------------------")); 
                  for (int i = 0; i < 40; i++) {
                    if (send_ueberw_counter_start_[i] > 1) {
                        if (send_ueberw_counter_start_[i] == send_ueberw_counter_success_[i]) {
                            #if TB_DEBUG_LEVEL == TB_DEBUG_MED
                            Serial.printf("[WL][%d] Erfolgreiche Attribute [%d] Sendungen: %d\n", i, i, send_ueberw_counter_success_[i] - 1);
                            Serial.println(F(" "));
                            #endif
                            snprintf(statusMessage, sizeof(statusMessage), "Erfolgreiche Attribute [%d] Sendungen: %d", i, send_ueberw_counter_success_[i] - 1);
                            //send_ueberw_counter_alarm = 0;
                            send_ueberw_counter_start_[i] = 0;
                            send_ueberw_counter_success_[i] = 0;
                            send_ueberw_counter_error_[i] = 0;
                            send_ueberw_counter_alarm_[i] = 0;
                        } else {
                            #if TB_DEBUG_LEVEL == TB_DEBUG_MED
                            Serial.printf("[WL][%d] Erfolgreiche Attribute [%d] Sendungen: %d, | Fehlgeschlagene Attribute [%d] Sendungen: %d\n", i, i, send_ueberw_counter_success_[i] - 1, i, send_ueberw_counter_error_[i] - 1);
                            Serial.println(F(" "));
                            #endif
                            snprintf(statusMessage, sizeof(statusMessage), "Erfolgreiche Attribute [%d] Sendungen: %d, | Fehlgeschlagene Attribute [%d] Sendungen: %d\n", i, send_ueberw_counter_success_[i] - 1, i, send_ueberw_counter_error_[i] - 1);
                            uint16_t send_ueberw_counter_temp = send_ueberw_counter_error_[i] - 1;
                            tb.sendTelemetryData("send__error", send_ueberw_counter_temp);delay(200);
                            //send_ueberw_counter_alarm++;
                            send_ueberw_counter_alarm_[i]++;
                            send_ueberw_counter_start_[i] = 0;
                            send_ueberw_counter_success_[i] = 0;
                            send_ueberw_counter_error_[i] = 0;
                        }
                    }
                  }
                  
                  TB_DEBUG_MED_PRINTLN(F("--------------------------------------------------------")); 
                  bool alarmFound = false;

                  for (int i = 0; i < 40; i++) {
                      if (send_ueberw_counter_alarm_[i] > 1) {
                         #if TB_DEBUG_LEVEL >= TB_DEBUG_MAX
                          Serial.printf("[DEBUG][%d] Alarm Count: %d\n", i, send_ueberw_counter_alarm_[i]);Serial.println(F(" "));
                          #endif
                          alarmFound = true;
                      }
                  }

                  if (!alarmFound) {
                      #if TB_DEBUG_LEVEL >= TB_DEBUG_MAX
                      Serial.println(F("[DEBUG] Keine Alarme vorhanden. Alle Attribute erfolgreich gesendet."));
                      #endif
                  }
                  TB_DEBUG_MAX_PRINTLN(F("--------------------------------------------------------"));
                //---------------------------------------------------------------

                    // newinstanz


              //---------------------------------------------------------------
              // Auswertung nur durchführen, wenn send_ueberw_counter_start > 1 ist
              if (send_ueberw_counter_start > 1) {
               
                  char statusMessage[100]; // Puffer für die Statusnachricht
               
                if (send_ueberw_counter_start == send_ueberw_counter_success) {
                  #if TB_DEBUG_LEVEL >= TB_DEBUG_MED
                  Serial.printf("[WL][%s] Alle Attribute Daten wurden erfolgreich gesendet. Erfolgreiche Attribute Sendungen: %d",  p_uhrzeit, send_ueberw_counter_success-1);Serial.println(F(" "));
                  #endif
                  snprintf(statusMessage, sizeof(statusMessage), "Erfolgreiche Attribute Sendungen: %d",  send_ueberw_counter_success-1);
                  send_ueberw_counter_alarm = 0;
                  send_ueberw_counter_start = 0;
                  send_ueberw_counter_success = 0;
                  send_ueberw_counter = 0;
                } else {
                  #if TB_DEBUG_LEVEL >= TB_DEBUG_MED
                  Serial.printf("[WL][%s] Erfolgreiche Attribute Sendungen: %d, | Fehlgeschlagene Attribute Sendungen: %d\n", p_uhrzeit, send_ueberw_counter_success-1, send_ueberw_counter-1);Serial.println(F(" "));
                  #endif
                  snprintf(statusMessage, sizeof(statusMessage), "Erfolgreiche Attribute Sendungen: %d, | Fehlgeschlagene Attribute Sendungen: %d\n", send_ueberw_counter_success-1, send_ueberw_counter-1);
                  uint16_t send_ueberw_counter_temp = send_ueberw_counter-1;
                  tb.sendTelemetryData("send__error", send_ueberw_counter_temp);delay(200);

                  send_ueberw_counter_alarm++;
                  send_ueberw_counter_start = 0;
                  send_ueberw_counter_success = 0;
                  send_ueberw_counter = 0;
                }
            
                 // const int attribute_items_36 = 1;
                  Attribute attributes36[1] = {
                  { D_Send_staus_KEY,  statusMessage },   //   
                  };  
                  tb.sendAttributes(attributes36, 1);delay(200);
 
              }
              //---------------------------------------------------------------

              //---------------------------------------------------------------
              // Auswertung nur durchführen, wenn send_ueberw_counter_t_start > 1 ist
              if (send_ueberw_counter_t_start > 1) {
               
                  char statusMessage[100]; // Puffer für die Statusnachricht
               
                if (send_ueberw_counter_t_start == send_ueberw_counter_t_success) {
                  #if TB_DEBUG_LEVEL >= TB_DEBUG_MED
                  Serial.printf("[WL][%s] Alle Telemetry Daten wurden erfolgreich gesendet. Erfolgreiche Telemetry Sendungen: %d",  p_uhrzeit, send_ueberw_counter_t_success-1);Serial.println(F(" "));
                  snprintf(statusMessage, sizeof(statusMessage), "Erfolgreiche Telemetry Sendungen: %d",  send_ueberw_counter_t_success-1);
                  #endif
                  send_ueberw_counter_t_alarm = 0;
                  send_ueberw_counter_t_start = 0;
                  send_ueberw_counter_t_success = 0;
                  send_ueberw_counter_t_error = 0;
                } else {
                  #if TB_DEBUG_LEVEL >= TB_DEBUG_MED
                  Serial.printf("[WL][%s] Erfolgreiche Telemetry Sendungen: %d, | Fehlgeschlagene Telemetry Sendungen: %d\n", p_uhrzeit, send_ueberw_counter_t_success-1, send_ueberw_counter_t_error-1);Serial.println(F(" "));
                  #endif
                  snprintf(statusMessage, sizeof(statusMessage), "Erfolgreiche Telemetry Sendungen: %d, | Fehlgeschlagene Telemetry Sendungen: %d\n", send_ueberw_counter_t_success-1, send_ueberw_counter_t_error-1);
                  uint16_t send_ueberw_counter_temp = send_ueberw_counter_t_error-1;
                  tb.sendTelemetryData("send__error", send_ueberw_counter_temp);delay(200);
 
                  send_ueberw_counter_t_alarm++;
                  send_ueberw_counter_t_start = 0;
                  send_ueberw_counter_t_success = 0;
                  send_ueberw_counter_t_error = 0;
                }
            
                  //const int attribute_items_38 = 1;
                  Attribute attributes38[1] = {
                  { D_Send_staus_t_KEY,  statusMessage },   //   
                  };  
                  tb.sendAttributes(attributes38, 1);delay(200);
 
              }
              //---------------------------------------------------------------
              TB_DEBUG_MAX_PRINTLN(F("--------------------------------------------------------"));
                  bool alarmFoundt = false;

                  for (int i = 0; i < 40; i++) {
                      if (send_ueberw_counter_t_alarm > 1) {
                          #if TB_DEBUG_LEVEL >= TB_DEBUG_MAX
                          Serial.printf("[DEBUG][%d] Alarm Count: %d\n", i, send_ueberw_counter_t_alarm);Serial.println(F(" "));
                          #endif
                          alarmFoundt = true;
                      }
                  }

                  if (!alarmFoundt) {
                      #if TB_DEBUG_LEVEL >= TB_DEBUG_MAX
                      Serial.println(F("[DEBUG] Keine Alarme vorhanden. Alle Telemetry erfolgreich gesendet."));
                      #endif
                  }
                  TB_DEBUG_MAX_PRINTLN(F("--------------------------------------------------------"));
                //---------------------------------------------------------------




              //---------------------------------------------------------------
              // Überprüfe den Zähler und starte den ESP neu, wenn der Schwellenwert erreicht ist
                bool executeIfBlock = true; // Initialisiere als true
                bool foundRelevantValue = false; // Initialisiere als false

                for (int i = 0; i < 40; i++) {
                    
                    // Alle Attribute müssen mehr wie 4 Fehler haben dann wird sofort Fehlerbit nicht zurückgesetzt
                    if (send_ueberw_counter_alarm_[i] > 1 && send_ueberw_counter_alarm_[i] <= 3) {
                        executeIfBlock = false; // Setze auf false, wenn ein Wert zwischen 2 und 3 gefunden wird
                        break;
                    }
                    // Wenn einer mehr wie 7 Fehler hatte wird auf jeden fall gesetzt
                    if (send_ueberw_counter_alarm_[i] > 6) {
                        foundRelevantValue = true; // Setze auf true, wenn ein Wert > 6 gefunden wird
                    }
                }

                // allgemein counter, kann irgendwann deaktiveirt werden. weil vorher schon die detail auswertung läuft
                if (send_ueberw_counter_alarm >= error_threshold) {
                    executeIfBlock = true;
                }



              if (executeIfBlock && foundRelevantValue) {

                  if (!restartPending) {

                      tb.disconnect();
                      restartPending = true; // Setze den Neustart auf ausstehend
                      restartPending = true; // Setze den Neustart auf ausstehend
                      #if TB_DEBUG_LEVEL >= TB_DEBUG_MAX
                      Serial.printf("[WL][%s] Mehrere Fehler beim Attribute Senden, starte TB Connection neu... Neustart ausstehend: %s\n", p_uhrzeit, restartPending ? "Ja" : "Nein");Serial.println(F(" "));
                      #endif
                      TB_DEBUG_MAX_PRINTLN(F("--------------------------------------------------------"));
                      delay(500);     // Kurze Verzögerung 
                      if (WiFi.status() == WL_CONNECTED) {
                        TB_connect();
                      }

                  } else {
                      #if TB_DEBUG_LEVEL >= TB_DEBUG_MAX
                      Serial.printf("[WL][%s] Mehrere Fehler beim Attribute Senden, starte ESP neu... Fehler bei Sendungen: %d\n", p_uhrzeit, send_ueberw_counter_alarm);Serial.println(F(" "));
                      #endif
                      TB_DEBUG_MAX_PRINTLN(F("--------------------------------------------------------"));

                      Preferences preferences;
                      preferences.begin("eenvs", false); // Ordner eenvs anlegen/verwenden
                      preferences.putInt("restartCount", restartCount);
                      g_boot_fail = 1;
                      preferences.putUChar("boot_g_fail", g_boot_fail);
                      preferences.end();

                      // Deklaration der char Arrays
                      char message[] = "Mehrere Fehler beim Attribute Senden, starte ESP neu..."; // Beispiel char-Array
                      char formattedMessage[150]; // Puffer für die formatierte Nachricht, sollte groß genug sein

                      // Formatierung der Nachricht
                      snprintf(formattedMessage, sizeof(formattedMessage), "[%s] %s", p_uhrzeit, message);

                      // Ausgabe der Nachricht zur Überprüfung
                      Serial.println(formattedMessage);

                      // Beispielaufruf zur Übertragung der Telemetriedaten
                      tb.sendTelemetryData("Night", formattedMessage); 
                      delay(200);


                      printStatus();

                      g_esp_soft_restart = true;

                }          

              }
              //if (send_ueberw_counter_alarm >= 1) {
                  //Serial.printf("[WL][  ] %d Fehlerhafte Attribute Übertragungen\n", send_ueberw_counter_alarm);Serial.println(F(" "));
              //}
              //---------------------------------------------------------------


              //---------------------------------------------------------------
              // Überprüfe den Zähler und starte den ESP neu, wenn der Schwellenwert erreicht ist
              if (send_ueberw_counter_t_alarm >= error_threshold_t) {
                #if TB_DEBUG_LEVEL >= TB_DEBUG_MAX
                Serial.printf("[WL][%s] Mehrere Fehler beim Telemetry Senden, starte ESP neu... Erfolgreiche Sendungen: %d\n", p_uhrzeit, successful_sends);
                #endif
                TB_DEBUG_MAX_PRINTLN(F("--------------------------------------------------------"));

                Preferences preferences;
                preferences.begin("eenvs", false); // Ordner eenvs anlegen/verwenden
                preferences.putInt("restartCount", restartCount);
                g_boot_fail = 1;
                preferences.putUChar("boot_g_fail", g_boot_fail);
                preferences.end();


                char message[] = "Mehrere Fehler beim Telemetry Senden, starte ESP neu...";
                char formattedMessage[150]; // Puffer für die formatierte Nachricht, sollte groß genug sein

                // Formatierung der Nachricht
                snprintf(formattedMessage, sizeof(formattedMessage), "[%s] %s", p_uhrzeit, message);

                // Ausgabe zur Überprüfung
                Serial.println(formattedMessage);

                // Beispielaufruf zur Übertragung der Telemetriedaten
                tb.sendTelemetryData("Night", formattedMessage); 
                delay(200);


                printStatus();

                g_esp_soft_restart = true;

              }
              if (send_ueberw_counter_alarm >= 1) {
                  #if TB_DEBUG_LEVEL >= TB_DEBUG_MAX
                  Serial.printf("[WL][  ] %d Fehlerhafte Telemetry Übertragungen\n", send_ueberw_counter_t_alarm);Serial.println(F(" "));
                  #endif
                  TB_DEBUG_MAX_PRINTLN(F("--------------------------------------------------------"));
              }
              //---------------------------------------------------------------


              //   restartWiFiAndClients();




          } 



  } // if (!nightModeActive) {

}
//---------------------------------------------------------------------------------------------------




//---------------------------------------------------------------------------------------------------
void mainEvaluation3() {

  //------------------------------------------------------------
  // Nur fortfahren, wenn der Nachtmodus nicht aktiv ist
  int scanResult;
  
  if (nightModeActive) {           //  Nachtschaltung aktiviert
      
      
                          
      if (!lastWiFiStatus) {

                                                                                        // scan deaktivieren im Nachtmodus
          if (millis() - lastScanTime >= pgm_read_dword(&requiredNightConnectedTime)  && !nightModeActive) {
              
            currentStatus = WiFi.status();
             
              if (currentStatus != WL_CONNECTED) {

                  //--------------------------------------
                  /*
                  esp_task_wdt_reset();
                  Serial.println("[WL][xx] WiFi.scanNetworks");
                  scanResult = WiFi.scanNetworks(true); // Starte den Scan im Hintergrund
                  if (scanResult == WIFI_SCAN_RUNNING) {// WIFI_SCAN_RUNNING: Der Scan läuft noch.
                      // Warte auf das Ende des Scans
                      while (WiFi.scanComplete() == WIFI_SCAN_RUNNING) {// WIFI_SCAN_RUNNING: Der Scan läuft noch.
                          esp_task_wdt_reset();
                          delay(100);
                      }
                      scanResult = WiFi.scanComplete();
                      esp_task_wdt_reset();
                  }
                  */
                  //----------------------------------------

                  //--------------------------------------------------------------------------------------------------
                    int scanResult = -1;

                    if (heap_caps_get_largest_free_block(MALLOC_CAP_DEFAULT) > 5000) {

                      scanResult = WiFi.scanNetworks(true); // Starte den Scan im Hintergrund
                        unsigned long startTime = millis(); // Speichere die Startzeit

                        if (scanResult == WIFI_SCAN_FAILED) {
                            Serial.println(F("[WL][xx] WiFi Scan failed to start"));

                            Serial.println(F("[WL][xx] WiFi erneut initialisieren und Scan starten"));
                            // Initialisiere das WiFi-Modul nur bei Fehler
                            WiFi.mode(WIFI_STA);
                            WiFi.disconnect(); // Trenne alle bestehenden Verbindungen
                            // Starte den Scan erneut
                            scanResult = WiFi.scanNetworks(true);
                            startTime = millis(); // Aktualisiere die Startzeit
                        }

                        if (scanResult == WIFI_SCAN_RUNNING) { // WIFI_SCAN_RUNNING: Der Scan läuft noch.
                            // Warte auf das Ende des Scans oder breche nach 20 Sekunden ab
                            while (WiFi.scanComplete() == WIFI_SCAN_RUNNING) { // WIFI_SCAN_RUNNING: Der Scan läuft noch.
                                esp_task_wdt_reset();
                                delay(100);
                                if (millis() - startTime > 20000) { // 20 Sekunden sind vergangen
                                    Serial.println(F("[WL][ x] WiFi Scan aborted after 20 seconds"));
                                    break;
                                }
                            }
                            scanResult = WiFi.scanComplete();
                            
                            if (scanResult == WIFI_SCAN_FAILED) {
                                Serial.println("[WL][ x] WiFi Scan failed to complete");
                            } else if (scanResult != WIFI_SCAN_RUNNING) {
                                Serial.printf("[WL][xx] Anzahl der gefundenen WLAN-Netzwerke: %d\n", scanResult);
                                Serial.println(F(" "));
                                for (int i = 0; i < scanResult; ++i) {
                                    Serial.printf("[  ][ x] SSID: %s, RSSI: %d\n", WiFi.SSID(i).c_str(), WiFi.RSSI(i));Serial.println(F(" "));
                                }
                            }
                        } else {
                            // Ausgabe der Anzahl der gefundenen WLAN-Netzwerke
                            Serial.printf("[WL][ o] Anzahl der gefundenen WLAN-Netzwerke: %d\n", scanResult);
                            Serial.println(F(" "));
                            for (int i = 0; i < scanResult; ++i) {
                                Serial.printf("[  ][  ] SSID: %s, RSSI: %d\n", WiFi.SSID(i).c_str(), WiFi.RSSI(i));Serial.println(F(" "));
                            }
                        }
                    } else {
                                        size_t largestFreeBlock = heap_caps_get_largest_free_block(MALLOC_CAP_DEFAULT);
                                        Serial.print(F("[WI][ o] Kein Scan möglich wegen zu wenig Arbeitsspeicher: "));
                                        Serial.println(largestFreeBlock);
                        scanResult = 0;
                    }

                  //----------------------------------------------------------------------------------------------------
         
              }else{
                scanResult = 1;
              }

            lastScanTime = millis();
         
          }else{

            scanResult = 1;

          }


          if (scanResult == 0) {
              nightModeDetectionCount++;
              Serial.printf("[WL][  ] WLAN regelmäßig zur gleichen Zeit offline. Nachtschaltungserkennung: %d/%d\n", nightModeDetectionCount, nightModeDetectionThreshold);Serial.println(F(" "));
              if (nightModeDetectionCount >= nightModeDetectionThreshold) {
                  Serial.println(F("[WL][  ] Nachtschaltung erkannt. Keine WLAN-Verbindung erforderlich."));
                  nightModeActive = true;
                  Preferences preferences;
                  preferences.begin("eenvs", false); // Ordner eenvs anlegen/verwenden
                  preferences.putBool("nightModeActive", nightModeActive);
                  preferences.end();
              }
          }



      } 


      if (currentStatus == WL_CONNECTED) {

          // Überprüfen, ob das WLAN während der Nachtschaltung stabil bleibt
          if (currentWiFiStatus && currentNightMode) {
              connectedTime_off++;
              if (connectedTime_off >= stableWiFiThreshold) {
                  nightModeDetectionCount = 0; // Reset the night mode detection count if the WiFi is stable for a long period during night mode
                  Preferences preferences;
                  preferences.begin("eenvs", false); // Ordner eenvs anlegen/verwenden
                  preferences.putInt("nightModeDet", nightModeDetectionCount);
                  
                  Serial.println(F("[WL][  ] WLAN während der Nachtschaltung stabil == Nachtschaltung deaktiviert."));
                  nightModeActive = false;
                  preferences.putBool("nightModeActive", nightModeActive);

                  consecutiveNightModeDays = 0;
                  preferences.putInt("conNightModDay", consecutiveNightModeDays);

                  preferences.end();
              }
          }

      }



  }

}




    void load_cloud_settings() {
        Preferences preferences;
        preferences.begin("eenvs", true);  // Nur lesen

        g_Cloud_ea_ist = preferences.getUChar("g_cloud_ea", 0);  // 0=Standard, Cloud Ein Aus
        p_cloudonoff = preferences.getString("p_clon", "0");
        p_inputcloudserver = preferences.getString("p_clserv", "radoncloud.com");
        p_inputcloudpage = preferences.getString("p_clpage", "LoRaWAN-Live-Link-K1-W33rt22bd11np00L/lora_radon.php");

        String storedValue = preferences.getString("p_clpre", "submit=Daten");
        storedValue.toCharArray(p_inputcloudprec, sizeof(p_inputcloudprec));

        p_inputcloudporti = preferences.getShort("p_clport", 80);
        p_inputcloudchain = preferences.getString("p_clchain", "&p");

        preferences.end();
    }



    void load_mqtt_settings() {
        Preferences preferences;
        preferences.begin("eenvs", true);  // Nur lesen
     
        p_mqonoff = preferences.getBool("p_mqon", false); 
        p_inputmqclient = preferences.getString("p_mqclie", ""); 
        p_inputmqserver = preferences.getString("p_mqserv", "io.adafruit.com"); 
        p_inputmquser = preferences.getString("p_mquser", "radonvalue"); 
        p_inputmqport = preferences.getString("p_mqport", "1883"); 
        p_inputmqtopic = preferences.getString("p_mqtopic", "radonvalue/feeds/radon.radon"); 
        p_inputmqpass = preferences.getString("p_mqpass", "4056e40b03b14156ab7d701f5104255e");   // 0056e40b03b14156ab7d707f5104256e

        preferences.end();

        p_inputmqserver.toCharArray(p_inputmqserverc, 40);
        p_inputmqporti = p_inputmqport.toInt();

    }



      //----------------------------------------------------------
      // Endpunkt zur Validierung des NTP-Servers
      void handle_validateNTPServer() {
        if (server3.hasArg("plain")) {
          String body = server3.arg("plain");
          //Serial.println("Received NTP Server Validation Request: " + body);

          // Hier kannst du die Logik zur Validierung des NTP-Servers hinzufügen
          // Zum Beispiel:
          DynamicJsonDocument doc(1024);
          deserializeJson(doc, body);
          //const char* ntpServer = doc["ntpServer"];
          bool valid = true;  // Setze hier die tatsächliche Validierungslogik ein

          // Sende eine JSON-Antwort zurück
          DynamicJsonDocument response(1024);
          response["valid"] = valid;
          String responseBody;
          serializeJson(response, responseBody);
          server3.send(200, "application/json", responseBody);
        } else {
          server3.send(400, "application/json", "{\"valid\":false}");
        }
      }



      void setNTPServer() {
        
          if (server3.hasArg("plain") == false) { // Check if body received
              server3.send(400, "application/json", "{\"success\": false, \"message\": \"Kein Body empfangen\"}");
              return;
          }

          // Parse JSON
          String body = server3.arg("plain");
          DynamicJsonDocument doc(1024);
          deserializeJson(doc, body);
          
          String ntpServer = doc["ntpServer"];


          if (ntpServer.equals("default")) {
              
                ntp_change_web = 0;

                strncpy(g_u_ntp3_ist, "pool.ntp.org", sizeof(g_u_ntp3_ist) - 1);
                g_u_ntp3_ist[sizeof(g_u_ntp3_ist) - 1] = '\0';

                strncpy(g_u_ntp3_soll, "pool.ntp.org", sizeof(g_u_ntp3_soll) - 1);
                g_u_ntp3_soll[sizeof(g_u_ntp3_soll) - 1] = '\0';


                Preferences preferences;
                preferences.begin("eenvs", false);
                preferences.putUChar("g_ntp_web", 0);
                preferences.putString("g_u_ntp3", ntpServer); // NTP Server 3 speichern
                preferences.end();
               

                Serial.print(F("Standard NTP Server gesetzt: ")); 
                Serial.println(g_u_ntp3_ist);

                server3.send(200, "application/json", "{\"success\": true, \"message\": \"Standard NTP Server gesetzt\"}");

                updateNTPServer(g_u_ntp3_ist);
                Serial.print(F("NTP-Server geändert zu: "));
                Serial.println(g_u_ntp3_ist);

                if (timeClient.forceUpdate()) {
                  Serial.print(F("Server 1 Update Success: "));
                  Serial.print(F("Server 1 Time: "));
                  Serial.println(timeClient.getFormattedTime());
                  update_ntp_ready = 1;
                } else {
                  Serial.println(F("Failed set to update from Server 1"));
                  update_ntp_ready = 0;
                }

            
          } else {

                  strncpy(g_u_ntp3_ist, ntpServer.c_str(), sizeof(g_u_ntp3_ist) - 1);
                  g_u_ntp3_ist[sizeof(g_u_ntp3_ist) - 1] = '\0';

                  strncpy(g_u_ntp3_soll, ntpServer.c_str(), sizeof(g_u_ntp3_soll) - 1);
                  g_u_ntp3_soll[sizeof(g_u_ntp3_soll) - 1] = '\0';


                  ntp_change_web = 1;
                  Preferences preferences;
                  preferences.begin("eenvs", false);
                  preferences.putUChar("g_ntp_web", 1);
     
                  preferences.putString("g_u_ntp3", ntpServer); // NTP Server 3 speichern
                  preferences.end();
                  
                  Serial.print(F("neuer NTP Server gespeichert: ")); Serial.println(ntpServer);

                  server3.send(200, "application/json", "{\"success\": true, \"message\": \"NTP Server erfolgreich gespeichert\"}");

                  updateNTPServer(g_u_ntp3_ist);
                  Serial.print(F("NTP-Server geändert zu: "));
                  Serial.println(g_u_ntp3_ist);

                if (timeClient.forceUpdate()) {
                  Serial.print(F("Server 1 Update Success: "));
                  Serial.print(F("Server 1 Time: "));
                  Serial.println(timeClient.getFormattedTime());
                  update_ntp_ready = 1;
                } else {
                  Serial.println(F("Failed set to update from Server 1"));
                  update_ntp_ready = 0;
                }

          }

      }


      void getNTPServer() {
          Preferences preferences;
          preferences.begin("eenvs", true); // Ordner eenvs zum Lesen öffnen
          String ntpServer = preferences.getString("g_u_ntp3", "pool.ntp.org"); // Standardwert, falls nicht gesetzt
          preferences.end();

          String jsonResponse = "{\"success\": true, \"ntpServer\": \"" + ntpServer + "\"}";
          server3.send(200, "application/json", jsonResponse);
      }
      //----------------------------------------------------------



//------ WLAN Überwachung ------------------------------------------------------------


  // Funktion zum Aktivieren/Deaktivieren der WLAN-Überprüfung und zum Setzen der maximalen Anzahl fehlerhafter Überprüfungen
  void setWiFiCheckEnabled(bool enabled, int maxChecks) {
    wifiCheckEnabled = enabled;
    maxFailedChecks = maxChecks;
    failedCheckCount = 0; // Reset the failed check count when changing the settings
        Preferences preferences;
        preferences.begin("eenvs", false);                         //Ordner eenvs anlegen/verwenden
    preferences.putBool("wifiCheckEnabled", wifiCheckEnabled);
    preferences.putInt("maxFailedChecks", maxFailedChecks);
    preferences.putInt("failedCheckCount", failedCheckCount);
    preferences.end();
  }
//----------------------------------------------------------------------


/*
void printProgressBar(float percentage, const char* label) {
    int barWidth = 50; // Breite des Ladebalkens

    // Ausgabe der Überschrift
    Serial.println(label);
    Serial.print(" --------------------------------------------------\n[");

    // Ausgabe des Ladebalkens
    int pos = barWidth * percentage / 100;
    for (int i = 0; i < barWidth; ++i) {
        if (i < pos) Serial.print("=");
        else if (i == pos) Serial.print(">");
        else Serial.print(" ");
    }
    Serial.print("] ");
    Serial.print(percentage, 2); // Ausgabe des Prozentsatzes mit 2 Dezimalstellen
    Serial.println(" %");
    Serial.println(" --------------------------------------------------");
    Serial.println(F(" "));
}
*/

void printProgressBar(float percentage, const char* label, size_t usedBytes, size_t totalBytes) {
    int barWidth = 25; // Breite des Ladebalkens

    // Formatierte Ausgabe der Überschrift
    char formattedLabel[20];
    snprintf(formattedLabel, sizeof(formattedLabel), "%-8s", label);
    Serial.print(formattedLabel);

    // Ausgabe des Ladebalkens
    Serial.print("[");
    int pos = barWidth * percentage / 100;
    for (int i = 0; i < barWidth; ++i) {
        if (i < pos) Serial.print("=");
        else if (i == pos) Serial.print(">");
        else Serial.print(" ");
    }
    Serial.print(F("] "));
    Serial.print(percentage, 2); // Ausgabe des Prozentsatzes mit 2 Dezimalstellen
    Serial.print(F(" % (used "));
    Serial.print(usedBytes);
    Serial.print(F(" bytes from "));
    Serial.print(totalBytes);
    Serial.println(F(" bytes)"));
}





void my_translator_function(const void *src, rmt_item32_t *dest, size_t src_size, size_t wanted_num, size_t *translated_size, size_t *item_num) {
    const uint8_t *data = (const uint8_t *)src;
    size_t size = 0;
    size_t num = 0;

    for (size_t i = 0; i < src_size; i++) {
        uint8_t byte = data[i];
        for (int j = 0; j < 8; j++) {
            if (num < wanted_num) {
                dest[num].duration0 = (byte & 0x80) ? 10 : 5; // Dauer für logische 1 oder 0
                dest[num].level0 = 1; // High-Level
                dest[num].duration1 = 10; // Dauer für Low-Level
                dest[num].level1 = 0; // Low-Level
                byte <<= 1;
                num++;
            }
        }
        size++;
    }

    *translated_size = size;
    *item_num = num;
}


static bool rmt_installed = false;

void uninstall_rmt_driver() {
    if (rmt_installed) {
        rmt_driver_uninstall(RMT_CHANNEL_0);
        rmt_installed = false;
        ESP_LOGI("RMT", "RMT-Treiber erfolgreich deinstalliert.");
    } else {
        ESP_LOGW("RMT", "RMT-Treiber ist nicht installiert.");
    }
}

void install_rmt_driver() {
    if (!rmt_installed) {
        rmt_config_t config;
        config.rmt_mode = RMT_MODE_TX;
        config.channel = RMT_CHANNEL_0;
        config.gpio_num = GPIO_NUM_18;
        config.clk_div = 2;
        config.mem_block_num = 2; // Setze die Anzahl der Speicherblöcke auf 2
        config.tx_config.carrier_freq_hz = 38000;
        config.tx_config.carrier_level = RMT_CARRIER_LEVEL_HIGH;
        config.tx_config.idle_level = RMT_IDLE_LEVEL_LOW;
        config.tx_config.carrier_duty_percent = 33;
        config.tx_config.carrier_en = false;
        config.tx_config.loop_en = false;
        config.tx_config.idle_output_en = true;

        rmt_config(&config);
        rmt_driver_install(config.channel, 0, 0);
        rmt_translator_init(config.channel, my_translator_function);

        rmt_installed = true;
        ESP_LOGI("RMT", "RMT-Treiber erfolgreich installiert.");
    } else {
        ESP_LOGW("RMT", "RMT-Treiber ist bereits installiert.");
    }
}


    bool checkFileContent(const char* path) {
      File file = SPIFFS.open(path, "r");
      if (!file) {
        Serial.println("Fehler beim Öffnen der Datei!");
        return false;
      }

      bool hasData = file.size() > 0;
      file.close();
      return hasData;
    }



      // Handler-Funktion für das Favicon
      /*
      void handle_favicon() {
          File file = SPIFFS.open("/favicon-16x16.png", "r");
          if (!file) {
              esp_task_wdt_reset(); // WDT zurücksetzen, bevor eine 404-Antwort gesendet wird
              server3.send(404, "text/plain", "File not found");
              return;
          }

          const size_t bufferSize = 512; // Puffergröße für das Streaming
          uint8_t buffer[bufferSize]; // Puffer zum Speichern der Daten
          unsigned long startMillis = millis(); // Startzeit des Transfers
          const unsigned long timeout = 5000; // Timeout in Millisekunden (z.B. 5 Sekunden)

          while (file.available()) {
              size_t bytesRead = file.read(buffer, bufferSize); // Lese Daten in den Puffer
              esp_task_wdt_reset(); // WDT zurücksetzen
              if (bytesRead > 0) {
                  server3.sendContent((const char*)buffer, bytesRead); // Sende die gelesenen Daten
              }

              // Überprüfe, ob die Übertragungszeit das Timeout überschreitet
              if (millis() - startMillis > timeout) {
                  file.close();
                  esp_task_wdt_reset(); // WDT zurücksetzen, nachdem die Datei geschlossen wurde
                  server3.send(500, "text/plain", "Transfer timeout");
                  return;
              }
          }

          file.close();
          esp_task_wdt_reset(); // WDT zurücksetzen, nachdem die Datei geschlossen wurde
      }
      */

      #ifndef Firmware_backup
      void handle_favicon() {
          esp_task_wdt_reset(); // WDT zurücksetzen, bevor eine Antwort gesendet wird

          // Favicon direkt aus dem Flash-Speicher senden
          server3.sendHeader("Content-Type", "image/png");
          server3.sendHeader("Content-Length", String(favicon16_png_len));
          server3.send_P(200, "image/png", (const char*)favicon16_png, favicon16_png_len);

          esp_task_wdt_reset(); // WDT zurücksetzen, nachdem die Antwort gesendet wurde
      }
      #endif




      #ifndef Firmware_backup
      void handle_css() {
          File file = SPIFFS.open("/style.css", "r");
          if (!file) {
              esp_task_wdt_reset(); // WDT zurücksetzen, bevor eine 404-Antwort gesendet wird
              server3.send(404, "text/plain", "File not found");
              return;
          }

          const size_t bufferSize = 512; // Puffergröße für das Streaming
          uint8_t buffer[bufferSize]; // Puffer zum Speichern der Daten
          unsigned long startMillis = millis(); // Startzeit des Transfers
          const unsigned long timeout = 5000; // Timeout in Millisekunden (z.B. 5 Sekunden)

          while (file.available()) {
              size_t bytesRead = file.read(buffer, bufferSize); // Lese Daten in den Puffer
              esp_task_wdt_reset(); // WDT zurücksetzen
              if (bytesRead > 0) {
                  server3.sendContent((const char*)buffer, bytesRead); // Sende die gelesenen Daten
              }

              // Überprüfe, ob die Übertragungszeit das Timeout überschreitet
              if (millis() - startMillis > timeout) {
                  file.close();
                  esp_task_wdt_reset(); // WDT zurücksetzen, nachdem die Datei geschlossen wurde
                  server3.send(500, "text/plain", "Transfer timeout");
                  return;
              }
          }

          file.close();
          esp_task_wdt_reset(); // WDT zurücksetzen, nachdem die Datei geschlossen wurde
      }


      void handle_js() {
          File file = SPIFFS.open("/trac2.js", "r");
          if (!file) {
              esp_task_wdt_reset(); // WDT zurücksetzen, bevor eine 404-Antwort gesendet wird
              server3.send(404, "text/plain", "File not found");
              return;
          }

          const size_t bufferSize = 512; // Puffergröße für das Streaming
          uint8_t buffer[bufferSize]; // Puffer zum Speichern der Daten
          unsigned long startMillis = millis(); // Startzeit des Transfers
          const unsigned long timeout = 5000; // Timeout in Millisekunden (z.B. 5 Sekunden)

          while (file.available()) {
              size_t bytesRead = file.read(buffer, bufferSize); // Lese Daten in den Puffer
              esp_task_wdt_reset(); // WDT zurücksetzen
              if (bytesRead > 0) {
                  server3.sendContent((const char*)buffer, bytesRead); // Sende die gelesenen Daten
              }

              // Überprüfe, ob die Übertragungszeit das Timeout überschreitet
              if (millis() - startMillis > timeout) {
                  file.close();
                  esp_task_wdt_reset(); // WDT zurücksetzen, nachdem die Datei geschlossen wurde
                  server3.send(500, "text/plain", "Transfer timeout");
                  return;
              }
          }

          file.close();
          esp_task_wdt_reset(); // WDT zurücksetzen, nachdem die Datei geschlossen wurde
      }



      void handle_cssg() {
          File file = SPIFFS.open("/styles.css", "r");
          if (!file) {
              esp_task_wdt_reset(); // WDT zurücksetzen, bevor eine 404-Antwort gesendet wird
              server3.send(404, "text/plain", "File not found");
              return;
          }

          const size_t bufferSize = 512; // Puffergröße für das Streaming
          uint8_t buffer[bufferSize]; // Puffer zum Speichern der Daten
          unsigned long startMillis = millis(); // Startzeit des Transfers
          const unsigned long timeout = 5000; // Timeout in Millisekunden (z.B. 5 Sekunden)

          while (file.available()) {
              size_t bytesRead = file.read(buffer, bufferSize); // Lese Daten in den Puffer
              esp_task_wdt_reset(); // WDT zurücksetzen
              if (bytesRead > 0) {
                  server3.sendContent((const char*)buffer, bytesRead); // Sende die gelesenen Daten
              }

              // Überprüfe, ob die Übertragungszeit das Timeout überschreitet
              if (millis() - startMillis > timeout) {
                  file.close();
                  esp_task_wdt_reset(); // WDT zurücksetzen, nachdem die Datei geschlossen wurde
                  server3.send(500, "text/plain", "Transfer timeout");
                  return;
              }
          }

          file.close();
          esp_task_wdt_reset(); // WDT zurücksetzen, nachdem die Datei geschlossen wurde
      }


        void handle_jsg() {
            File file = SPIFFS.open("/jsthree.js", "r");
            if (!file) {
                esp_task_wdt_reset(); // WDT zurücksetzen, bevor eine 404-Antwort gesendet wird
                server3.send(404, "text/plain", "File not found");
                return;
            }

            const size_t bufferSize = 512; // Puffergröße für das Streaming
            uint8_t buffer[bufferSize]; // Puffer zum Speichern der Daten
            unsigned long startMillis = millis(); // Startzeit des Transfers
            const unsigned long timeout = 5000; // Timeout in Millisekunden (z.B. 5 Sekunden)

            while (file.available()) {
                size_t bytesRead = file.read(buffer, bufferSize); // Lese Daten in den Puffer
                esp_task_wdt_reset(); // WDT zurücksetzen
                if (bytesRead > 0) {
                    server3.sendContent((const char*)buffer, bytesRead); // Sende die gelesenen Daten
                }

                // Überprüfe, ob die Übertragungszeit das Timeout überschreitet
                if (millis() - startMillis > timeout) {
                    file.close();
                    esp_task_wdt_reset(); // WDT zurücksetzen, nachdem die Datei geschlossen wurde
                    server3.send(500, "text/plain", "Transfer timeout");
                    return;
                }
            }

            file.close();
            esp_task_wdt_reset(); // WDT zurücksetzen, nachdem die Datei geschlossen wurde
        }
        #endif


       /*
        void handle_256_js() {
            File file = SPIFFS.open("/sha256.js", "r");
            if (!file) {
                esp_task_wdt_reset(); // WDT zurücksetzen, bevor eine 404-Antwort gesendet wird
                server3.send(404, "text/plain", "File not found");
                return;
            }

            const size_t bufferSize = 512; // Puffergröße für das Streaming
            uint8_t buffer[bufferSize]; // Puffer zum Speichern der Daten
            unsigned long startMillis = millis(); // Startzeit des Transfers
            const unsigned long timeout = 5000; // Timeout in Millisekunden (z.B. 5 Sekunden)

            while (file.available()) {
                size_t bytesRead = file.read(buffer, bufferSize); // Lese Daten in den Puffer
                esp_task_wdt_reset(); // WDT zurücksetzen
                if (bytesRead > 0) {
                    server3.sendContent((const char*)buffer, bytesRead); // Sende die gelesenen Daten
                }

                // Überprüfe, ob die Übertragungszeit das Timeout überschreitet
                if (millis() - startMillis > timeout) {
                    file.close();
                    esp_task_wdt_reset(); // WDT zurücksetzen, nachdem die Datei geschlossen wurde
                    server3.send(500, "text/plain", "Transfer timeout");
                    return;
                }
            }

            file.close();
            esp_task_wdt_reset(); // WDT zurücksetzen, nachdem die Datei geschlossen wurde
        }
        */
        /*
        void handle_256_js() {
            server3.send_P(200, "application/javascript", sha256_js);
            esp_task_wdt_reset(); // WDT zurücksetzen
        }
        */
      #ifndef Firmware_backup  
        void handle_256_js() {
            const size_t chunkSize = 1024; // Definiere die Größe der Datenblöcke
            size_t totalSize = sizeof(sha256_js);
            size_t bytesSent = 0;

            server3.setContentLength(totalSize); // Setze die Gesamtgröße des Inhalts
            server3.sendHeader("Content-Type", "application/javascript");
            server3.send(200);

            while (bytesSent < totalSize) {
                size_t remainingBytes = totalSize - bytesSent;
                size_t currentChunkSize = remainingBytes < chunkSize ? remainingBytes : chunkSize;
                
                // Sende den aktuellen Datenblock
                server3.client().write(sha256_js + bytesSent, currentChunkSize);
                bytesSent += currentChunkSize;

                // Watchdog Timer zurücksetzen
                esp_task_wdt_reset();
            }
        }

        
        void handleSegmentDisplayJS() {
          server3.send_P(200, "application/javascript", segment_display_js);
          esp_task_wdt_reset(); // WDT zurücksetzen
      }
      #endif
     /*
      void handleSegmentDisplayJS() {
          const size_t chunkSize = 1024; // Definiere die Größe der Datenblöcke
          size_t totalSize = sizeof(segment_display_js);
          size_t bytesSent = 0;

          server3.setContentLength(totalSize); // Setze die Gesamtgröße des Inhalts
          server3.sendHeader("Content-Type", "application/javascript");
          server3.send(200);

          while (bytesSent < totalSize) {
              size_t remainingBytes = totalSize - bytesSent;
              size_t currentChunkSize = remainingBytes < chunkSize ? remainingBytes : chunkSize;
              
              // Sende den aktuellen Datenblock
              server3.client().write(segment_display_js + bytesSent, currentChunkSize);
              bytesSent += currentChunkSize;

              // Watchdog Timer zurücksetzen
              esp_task_wdt_reset();
          }
      }
      */


      /*  
      void handlejquery_min_js() {
          server3.send_P(200, "application/javascript", jquery_min_js);
          esp_task_wdt_reset(); // WDT zurücksetzen
      }
      */
     #ifndef Firmware_backup
      void handlejquery_min_js() {
          const size_t chunkSize = 1024; // Definiere die Größe der Datenblöcke
          size_t totalSize = sizeof(jquery_min_js);
          size_t bytesSent = 0;

          server3.setContentLength(totalSize); // Setze die Gesamtgröße des Inhalts
          server3.sendHeader("Content-Type", "application/javascript");
          server3.send(200);

          while (bytesSent < totalSize) {
              size_t remainingBytes = totalSize - bytesSent;
              size_t currentChunkSize = remainingBytes < chunkSize ? remainingBytes : chunkSize;
              
              // Sende den aktuellen Datenblock
              server3.client().write(jquery_min_js + bytesSent, currentChunkSize);
              bytesSent += currentChunkSize;

              // Watchdog Timer zurücksetzen
              esp_task_wdt_reset();
          }
      }

      


        void handle_zonehead() {
            File file = SPIFFS.open("/zonehead.js", "r");
            if (!file) {
                esp_task_wdt_reset(); // WDT zurücksetzen, bevor eine 404-Antwort gesendet wird
                server3.send(404, "text/plain", "File not found");
                return;
            }

            const size_t bufferSize = 512; // Puffergröße für das Streaming
            uint8_t buffer[bufferSize]; // Puffer zum Speichern der Daten
            unsigned long startMillis = millis(); // Startzeit des Transfers
            const unsigned long timeout = 5000; // Timeout in Millisekunden (z.B. 5 Sekunden)

            while (file.available()) {
                size_t bytesRead = file.read(buffer, bufferSize); // Lese Daten in den Puffer
                esp_task_wdt_reset(); // WDT zurücksetzen
                if (bytesRead > 0) {
                    server3.sendContent((const char*)buffer, bytesRead); // Sende die gelesenen Daten
                }

                // Überprüfe, ob die Übertragungszeit das Timeout überschreitet
                if (millis() - startMillis > timeout) {
                    file.close();
                    esp_task_wdt_reset(); // WDT zurücksetzen, nachdem die Datei geschlossen wurde
                    server3.send(500, "text/plain", "Transfer timeout");
                    return;
                }
            }

            file.close();
            esp_task_wdt_reset(); // WDT zurücksetzen, nachdem die Datei geschlossen wurde
        }


        void handle_chartdiv() {
            File file = SPIFFS.open("/chartdiv.js", "r");
            if (!file) {
                esp_task_wdt_reset(); // WDT zurücksetzen, bevor eine 404-Antwort gesendet wird
                server3.send(404, "text/plain", "File not found");
                return;
            }

            const size_t bufferSize = 512; // Puffergröße für das Streaming
            uint8_t buffer[bufferSize]; // Puffer zum Speichern der Daten
            unsigned long startMillis = millis(); // Startzeit des Transfers
            const unsigned long timeout = 5000; // Timeout in Millisekunden (z.B. 5 Sekunden)

            while (file.available()) {
                size_t bytesRead = file.read(buffer, bufferSize); // Lese Daten in den Puffer
                esp_task_wdt_reset(); // WDT zurücksetzen
                if (bytesRead > 0) {
                    server3.sendContent((const char*)buffer, bytesRead); // Sende die gelesenen Daten
                }

                // Überprüfe, ob die Übertragungszeit das Timeout überschreitet
                if (millis() - startMillis > timeout) {
                    file.close();
                    esp_task_wdt_reset(); // WDT zurücksetzen, nachdem die Datei geschlossen wurde
                    server3.send(500, "text/plain", "Transfer timeout");
                    return;
                }
            }

            file.close();
            esp_task_wdt_reset(); // WDT zurücksetzen, nachdem die Datei geschlossen wurde
        }


        void handle_tracg() {
            File file = SPIFFS.open("/tracg.js", "r");
            if (!file) {
                esp_task_wdt_reset(); // WDT zurücksetzen, bevor eine 404-Antwort gesendet wird
                server3.send(404, "text/plain", "File not found");
                return;
            }

            const size_t bufferSize = 512; // Puffergröße für das Streaming
            uint8_t buffer[bufferSize]; // Puffer zum Speichern der Daten
            unsigned long startMillis = millis(); // Startzeit des Transfers
            const unsigned long timeout = 5000; // Timeout in Millisekunden (z.B. 5 Sekunden)

            while (file.available()) {
                size_t bytesRead = file.read(buffer, bufferSize); // Lese Daten in den Puffer
                esp_task_wdt_reset(); // WDT zurücksetzen
                if (bytesRead > 0) {
                    server3.sendContent((const char*)buffer, bytesRead); // Sende die gelesenen Daten
                }

                // Überprüfe, ob die Übertragungszeit das Timeout überschreitet
                if (millis() - startMillis > timeout) {
                    file.close();
                    esp_task_wdt_reset(); // WDT zurücksetzen, nachdem die Datei geschlossen wurde
                    server3.send(500, "text/plain", "Transfer timeout");
                    return;
                }
            }

            file.close();
            esp_task_wdt_reset(); // WDT zurücksetzen, nachdem die Datei geschlossen wurde
        }

        #endif




    /*
    void handleHighchartsJS() {
        File file = SPIFFS.open("/highcharts.js", "r");
        if (!file) {
            Serial.println("File not found: /highcharts.js");
            server3.send(404, "text/plain", "File not found");
            return;
        }

        size_t fileSize = file.size();
        Serial.print("File size: ");     // File size: 278582    File size: 278582
        Serial.println(fileSize);

        if (fileSize == 0) {
            Serial.println("Error: File is empty");
            server3.send(500, "text/plain", "File is empty");
            file.close();
            return;
        }

        // Setze den HTTP-Header
        server3.setContentLength(fileSize);
        server3.sendHeader("Content-Type", "application/javascript");
        server3.send(200, "application/javascript", ""); // Leere Antwort, um Header zu senden

        // Datei in Blöcken lesen und senden
        const size_t bufferSize = 2048; // Größe der Blöcke
        uint8_t buffer[bufferSize];
        size_t bytesRead;
        while ((bytesRead = file.read(buffer, bufferSize)) > 0) {
            server3.client().write(buffer, bytesRead);
        }

        file.close();
        Serial.println("End handleHighchartsJS");
    }
   */

    #ifndef Firmware_backup
    void handleHighchartsJS() {
        server3.setContentLength(strlen_P(highcharts_js_part1) + strlen_P(highcharts_js_part2));
        server3.sendHeader("Content-Type", "application/javascript");
        server3.send(200, "application/javascript", ""); // Leere Antwort, um Header zu senden

        // Senden des ersten Teils
        esp_task_wdt_reset(); // WDT zurücksetzen
        server3.sendContent_P(highcharts_js_part1);
        esp_task_wdt_reset(); // WDT zurücksetzen
        // Senden des zweiten Teils
        server3.sendContent_P(highcharts_js_part2);
        esp_task_wdt_reset(); // WDT zurücksetzen
    }
    #endif
  








      void handleSPrefix(int number, String value) {
          // Verarbeitung für Präfix 'S'
          if (number == 33 && value == "1") {
              ntp_update_start = true;
              Serial.println(F("NTP-Update wird gestartet."));
          } else {
              Serial.print(F("Verarbeitung für Präfix S mit Nummer: "));
              Serial.print(number);
              Serial.print(F(" und Wert: "));
              Serial.println(value);
          }

          if (number == 90 && value == "1") {
              Serial.println(F("BLE Server starten."));
              startBLEserver();
          } else if (number == 90 && value == "0") {
               Serial.println(F("BLE Server stoppen."));
               stopBLEserver();
          } else {
              Serial.print(F("Verarbeitung für Präfix S mit Nummer: "));
              Serial.print(number);
              Serial.print(F(" und Wert: "));
              Serial.println(value);
          }

          if (number == 91 && value == "1") {
              Serial.println(F("BLE Beacon starten."));
              //user_on_webside = false;
              git_startBeacon2 = true;
          } else if (number == 91 && value == "0") {
               Serial.println(F("BLE Beacon stoppen."));
               //user_on_webside = true;
               git_stopBeacon2 = true;
          } else {
              Serial.print(F("Verarbeitung für Präfix S mit Nummer: "));
              Serial.print(number);
              Serial.print(F(" und Wert: "));
              Serial.println(value);
          }



      }

      void handleGPrefix(int number, String value) {
          // Verarbeitung für Präfix 'G'
          Serial.print(F("Verarbeitung für Präfix G mit Nummer: "));
          Serial.print(number);
          Serial.print(F(" und Wert: "));
          Serial.println(value);

          if (number == 34 && value == "1") {
              Serial.println(F("WLAN Suchen..."));
                g_scan_start = true; 
                g_scan_alternative = false;
          } else if (number == 34 && value == "0") {
              Serial.println(F("WLAN Suchen zurücksetzen."));
                g_scan_start = false;
                g_scan_alternative = false;
          } else {
              Serial.print(F("Verarbeitung für Präfix G mit Nummer: "));
              Serial.print(number);
              Serial.print(F(" und Wert: "));
              Serial.println(value);
          }

          if (number == 80 && value == "1") {
                Serial.println(F("Firwmare Update Manuel start..."));
                                
                Serial.print(F("[IF] Installierte  FW "));Serial.println(TB_currFwVersion);
                Serial.print(F("[IF] NEW  FW          "));Serial.println(TB_newFwVersion);
                
                gFW_Update_start = 1;  // neue FW verfügbar
                g_set_new_FW = true;

                Preferences preferences;
                preferences.begin("eenvs", false);                         //Ordner eenvs anlegen/verwenden                      
                verzoegerung_fw_update = 2;
                preferences.putUChar("fw_verz_update", verzoegerung_fw_update);    //  0=Standard  aus   
                //preferences.putString("t_fw_version", TB_currFwVersion);                           
                preferences.end();

               tb.Start_Firmware_Update(callback);

          } else if (number == 80 && value == "0") {
              Serial.println(F("Firwmare Update Manuel zurücksetzen."));
          } else {
              Serial.print(F("Verarbeitung für Präfix G mit Nummer: "));
              Serial.print(number);
              Serial.print(F(" und Wert: "));
              Serial.println(value);
          }

      }

      void handleAPrefix(int number, String value) {
          // Verarbeitung für Präfix 'A'
          Serial.print(F("Verarbeitung für Präfix A mit Nummer: "));
          Serial.print(number);
          Serial.print(F(" und Wert: "));
          Serial.println(value);
      }




      void parseSerialInput(String input) {
          // Entferne mögliche Leerzeichen am Anfang und Ende
          input.trim();

          // Überprüfe das Eingabeformat (einen Buchstaben gefolgt von zwei Zahlen und einem Doppelpunkt)
          if (input.length() >= 4 && isAlpha(input.charAt(0)) && isDigit(input.charAt(1)) && isDigit(input.charAt(2)) && input.charAt(3) == ':') {
              char prefix = input.charAt(0); // Der Buchstabe (S, G oder A)
              int number = input.substring(1, 3).toInt(); // Die zweistellige Zahl
              String value = input.substring(4); // Der Wert nach dem Doppelpunkt

              // Debugging
              //Serial.println("Debugging: Eingabewerte");
              //Serial.print("Prefix: "); Serial.println(prefix);
              //Serial.print("Nummer: "); Serial.println(number);
              //Serial.print("Wert: "); Serial.println(value);

              // Führe die Aktion basierend auf dem Präfix und der Nummer aus
              switch (prefix) {
                  case 'S':
                      handleSPrefix(number, value);
                      break;
                  case 'G':
                      handleGPrefix(number, value);
                      break;
                  case 'A':
                      handleAPrefix(number, value);
                      break;
                  default:
                      Serial.println(F("Ungültiges Präfix!"));
                      break;
              }
          } else {
              Serial.println(F("Ungültiges Eingabeformat!"));
          }
      }


// ntp_update_start = false;





    //-------------------------------------------------------------------------------------------
      void displayFirmwareVersion(String fwString) {
          
          //Serial.println(F("displayFirmwareVersion"));
          char zeile[20];
          snprintf(zeile, sizeof(zeile), "%s", fwString.c_str());

          char *fw_daten[4];
          int i = 0;
          char *token = strtok(zeile, ".");
          while (token != NULL && i < 4) {
              fw_daten[i++] = token;
              token = strtok(NULL, ".");
          }

          // Überprüfe die Anzahl der Teile der Version
          if (i < 1 || i > 4) { // mind. 1 und max. 4 Teile erlauben
              Serial.println(F("Ungültiges Firmware-Version Format."));
              return;
          }

          // Konvertiere die Teile in Ganzzahlen
          int fw_00 = (i > 0) ? atoi(fw_daten[0]) : 0;
          int fw_01 = (i > 1) ? atoi(fw_daten[1]) : 0;
          int fw_02 = (i > 2) ? atoi(fw_daten[2]) : 0;
          int fw_03 = (i > 3) ? atoi(fw_daten[3]) : 0;

          // Debug-Ausgabe der konvertierten Werte
          /*
          Serial.print(F("fw_00: "));
          Serial.println(fw_00);
          Serial.print(F("fw_01: "));
          Serial.println(fw_01);
          Serial.print(F("fw_02: "));
          Serial.println(fw_02);
          Serial.print(F("fw_03: "));
          Serial.println(fw_03);
          */
          // lc.clearDisplay(0); // Sicherstellen, dass das Display vorher geleert wird

          // Anzeige der einzelnen Teile mit Punktstatus
          bool point = true;

          if (fw_00 >= 10) {
              lc.setChar(0,0, char('0' + fw_00 / 10), false); // Zehnerstelle
              lc.setChar(0,1, char('0' + fw_00 % 10), point); // Einerstelle mit Punkt
          } else {
              lc.setChar(0,0, char('0' + fw_00), point); // Einzelne Zahl mit Punkt
          }

          point = i > 2; // Punkt nur setzen, wenn es einen dritten Teil gibt

          if (fw_01 >= 10) {
              lc.setChar(0,1, char('0' + fw_01 / 10), false); // Zehnerstelle ohne Punkt
              lc.setChar(0,2, char('0' + fw_01 % 10), point); // Einerstelle mit Punkt, wenn es einen dritten Teil gibt
          } else if (i > 1) {
              lc.setChar(0,1, char('0' + fw_01), point); // Einzelne Zahl mit Punkt, wenn es einen dritten Teil gibt
          }

          point = i > 3; // Punkt nur setzen, wenn es einen vierten Teil gibt

          if (fw_02 >= 10) {
              lc.setChar(0,2, char('0' + fw_02 / 10), false); // Zehnerstelle ohne Punkt
              lc.setChar(0,3, char('0' + fw_02 % 10), point); // Einerstelle mit Punkt, wenn es einen vierten Teil gibt
          } else if (i > 2) {
              lc.setChar(0,2, char('0' + fw_02), point); // Einzelne Zahl mit Punkt, wenn es einen vierten Teil gibt
          }

          if (i > 3) {
              lc.setChar(0,3, char('0' + fw_03), false); // Einzelne Zahl ohne Punkt
          }
      }
    //-------------------------------------------------------------------------------------------





    //----------------------------------------------------------

        
      void displayProgress(float progress) {
          int progressInt = static_cast<int>(progress);
          byte einer = progressInt % 10;
          byte zehner = (progressInt / 10) % 10;
          byte hunderter = (progressInt / 100) % 10;

          if (progress < 10) {
              lc.setChar(0, 0, 'F', agFW_write);
              lc.setRow(0, 1, 0x00);
              lc.setRow(0, 2, 0x00);
              lc.setChar(0, 3, char(einer), false);
          } else if (progress < 100) {
              lc.setChar(0, 0, 'F', agFW_write);
              lc.setRow(0, 1, 0x00);
              lc.setChar(0, 2, char(zehner), false);
              lc.setChar(0, 3, char(einer), false);
          } else {
              lc.setChar(0, 0, 'F', agFW_write);
              lc.setChar(0, 1, char(hunderter), false);
              lc.setChar(0, 2, char(zehner), false);
              lc.setChar(0, 3, char(einer), false);
          }
      }

      // factoryResetBit
      void performFactoryReset() {
          File backupFile = SPIFFS.open("/backup/firmware.bin", FILE_READ);
          if (!backupFile) {
              Serial.println(F("Failed to open firmware.bin in backup directory"));
              return;
          }

          size_t fileSize = backupFile.size();
          Serial.println(F("Firmware.bin erfolgreich im Backup-Verzeichnis geöffnet!"));
          Serial.print("Firmware-Größe: ");
          Serial.println(fileSize);

          // Starte das Update
          if (!Update.begin(fileSize)) {
              Serial.println(F("Fehler beim Starten des Updates"));
              backupFile.close();
              return;
          }


          // Timer für die Fortschrittsanzeige
          unsigned long lastPrintTime = 0;
          int lastProgress = 0;

          // Lese die Datei und schreibe sie in den Update-Prozess
          size_t written = 0;
          const size_t bufferSize = 512;
          uint8_t buffer[bufferSize];

          while (backupFile.available()) {
              esp_task_wdt_reset(); // Watchdog-Timer zurücksetzen

              size_t bytesRead = backupFile.read(buffer, bufferSize);
              if (bytesRead == 0) {
                  break; // Keine weiteren Daten
              }

              size_t bytesWritten = Update.write(buffer, bytesRead);
              if (bytesWritten != bytesRead) {
                  Serial.println(F("Fehler beim Schreiben in den Update-Stream"));
                  Update.abort();
                  backupFile.close();
                  return;
              }

              written += bytesWritten;

              // Fortschritt in 0,2%-Schritten anzeigen
              float progress = (written * 100.0) / fileSize;
              int progressInt = static_cast<int>(progress);
              if (progressInt > lastProgress) {
                  displayProgress(progress);
                  lastProgress = progressInt;
              }

              // Punkt alle 0,2% toggeln
              if (static_cast<int>(progress * 10) % 2 == 0) {
                  agFW_write = !agFW_write;
                  lc.setChar(0, 0, 'F', agFW_write);
                  ledcWrite(ledChannel2, 0);     //   GPIO02  Bq/m³
                  ledcWrite(ledChannel15, 0);    //   GPIO15  PcI/L  
                  ledcWrite(ledChannel14, 0);    //   GPIO14  WLAN
                  ledcWrite(ledChannel26, 0);    //   GPIO38  NTP
                  ledcWrite(ledChannel,  0);     //   dp

                  strip.setBrightness(130);
                  v_Colortknx = 4;    
                  //  0=aus     1=rot   2=grün  3=blau    4=weiss    5=orange   6=lila  
                  colorWipe2(strip.Color(m_color[v_Colortknx][0], m_color[v_Colortknx][1], m_color[v_Colortknx][2])); 
              }

              unsigned long currentTime = millis();
              // Fortschritt nur alle 5% ausgeben
              if (progressInt % 5 == 0 && currentTime - lastPrintTime >= 3000) {
                  Serial.print("Fortschritt Restore: ");
                  Serial.print(progressInt);
                  Serial.println("%");
                  lastPrintTime = currentTime;
    
              }
          }

          if (written == fileSize) {
              Serial.println(F("Update-Stream erfolgreich geschrieben"));
          } else {
              Serial.print(F("Update-Stream Fehler: nur "));
              Serial.print(written);
              Serial.print(F(" / "));
              Serial.print(fileSize);
              Serial.println(F(" Bytes geschrieben"));
          }

          if (Update.end()) {
              Serial.println(F("Update erfolgreich abgeschlossen"));
              if (Update.isFinished()) {
                  Serial.println(F("Update fertig. Gerät wird neu gestartet..."));
                  ESP.restart();
              } else {
                  Serial.println(F("Update nicht fertig. Etwas ist schief gelaufen."));
              }
          } else {
              Serial.print(F("Update Fehler: "));
              Serial.println(Update.getError());
          }

          backupFile.close();
      }

    //----------------------------------------------------------






    //----------------------------------------------------------
    void get_time_vars2() {   


      if(update_rtc_ready == 1){   

      }else{



      }



    }
    //----------------------------------------------------------





    //----------------------------------------------------------
    void get_time_vars() {       

     
    
     
      if(update_rtc_ready == 1){   

        currentSec = myRTC.getSecond();
        v_currentSec = currentSec;


        //--------------------------------------------------------------------
        if (!firstRun) { 
            // Prüfen, ob die Differenz mehr als 2 Sekunden beträgt
            int diff = currentSec - t_previousSec;
            if (diff < 0) { // Korrigieren der Differenz, wenn Sekunde überläuft (59 zu 0)
                diff += 60;
            }

            if (diff >= 3) {
                if(warningCounter > 0){
                  Serial.print(F("[IF] Warnung: Zeitintervall ist "));
                  Serial.print(diff);
                  Serial.println(F(" Sekunden"));
                }
                warningCounter++;

                if (warningCounter >= 120) {
                    
                    tb.sendTelemetryData("Reset", formattedTime);
                    Serial.println(F("10 Warnungen aufgetreten, Neustart wird durchgeführt..."));  // FREE_RAM
                    // Neustart durchführen (hier muss ein Mikrocontroller-spezifischer Befehl eingesetzt werden)
                    // Beispiel für einen ESP8266 oder ESP32:
                    warningCounter = 0;
                    //delay(2000); // Kurze Verzögerung vor dem Neustart
                    //ESP.restart();
                    //g_esp_restsrt == true
                    Preferences preferences;
                    preferences.begin("eenvs", false);                         //Ordner eenvs anlegen/verwenden       
                    g_boot_fail = 1;
                    preferences.putUChar("boot_g_fail", g_boot_fail);    // 
                    g_esp_soft_restart = true;
                }
            } else {
                // Zähler zurücksetzen, wenn die Differenz korrekt ist
                warningCounter = 0;
            }
        } else {
            firstRun = false; // Setze das Flag auf false nach dem ersten Durchlauf
        }

        t_previousSec = currentSec; // Speichere die aktuelle Sekunde
        //--------------------------------------------------------------------



        // Nur fortfahren, wenn sich die Minute geändert hat
        if (lastMinute != myRTC.getMinute()) {
           
            //currentSec = myRTC.getSecond();
            //v_currentSec = currentSec;
           
            currentmin = myRTC.getMinute();
            lastMinute = currentmin;
            v_currentmin = currentmin;

            currenthour = myRTC.getHour2();
            v_currenthour = currenthour;

            currenthour12 = currenthour;

            currentYearTwoDigits = myRTC.getYear();

            currentmonth = myRTC.getMonth(century);
            v_currentmonth = currentmonth;

            currentdate = myRTC.getDate();  
            v_currentdate = currentdate;    

            weekday = myRTC.getDoW();    

            // Konvertiere currentyear in ein zweistelliges Format
            //byte yearTwoDigits = currentyear % 100;

            snprintf(formattedDate, sizeof(formattedDate), "%02d.%02d.%02d", currentdate, currentmonth, currentYearTwoDigits);
            snprintf(formattedDateYYMMDD, sizeof(formattedDateYYMMDD), "%02d.%02d.%02d", currentYearTwoDigits, currentmonth, currentdate);
            snprintf(formattedTime, sizeof(formattedTime), "%02d:%02d:%02d", v_currenthour, v_currentmin, v_currentSec);
            //Serial.print(F("Aktualisierte Zeit: "));Serial.print(formattedTime);Serial.print(F("  "));Serial.print(formattedDate);Serial.print(F("  "));Serial.println(formattedDateYYMMDD);

            strcpy(p_date_DDMMYY, formattedDate); 
            //printf("p_date_DDMMYY     : %s\n", p_date_DDMMYY);

            strcpy(p_date_YYMMDD, formattedDateYYMMDD); 
            //printf("p_date_YYMMDD     : %s\n", p_date_YYMMDD);

            snprintf(formattedDateHH, sizeof(formattedDateHH), "%02d", v_currenthour);
            //printf("formattedDateHH   : %s\n", formattedDateHH);

            // Formatierung der Zeit
            snprintf(formattedDateHHMM, sizeof(formattedDateHHMM), "%02d:%02d", v_currenthour, v_currentmin);
            // Ausgabe zur Überprüfung
            //printf("formattedDateHHMM : %s\n", formattedDateHHMM);

            //sprintf(current_datetime, "%s, %02d.%02d.%d %02d:%02d", getDayOfWeek(esp_dOW), currentdate, currentmonth, currentYearTwoDigits, v_currenthour, v_currentmin);
            sprintf(current_datetime, "%s, %02d.%02d.%02d %02d:%02d", getDayOfWeek(weekday), currentdate, currentmonth, currentYearTwoDigits, v_currenthour, v_currentmin);
              // Ausgabe mit Serial.print
            #if TM_DEBUG_LEVEL >= TM_DEBUG_MED
              Serial.print("[TM] Formatted Date and Time: ");
              Serial.println(current_datetime);
            #endif



            // Kopiere die ersten 6 Zeichen von formattedTime nach p_uhrzeit (HH:MM)
            strncpy(p_uhrzeit, formattedTime, 6);
            // Füge die neuen Sekunden hinzu
            sprintf(p_uhrzeit + 6, "%02d", currentSec);
            // Füge den Nullterminator hinzu
            p_uhrzeit[8] = '\0';
            // Ausgabe zur Überprüfung
           #if TM_DEBUG_LEVEL >= TM_DEBUG_MED
            Serial.print(F("p_uhrzeit: "));Serial.print(p_uhrzeit);Serial.print(F("   "));Serial.print(v_currenthour);Serial.print(F(":"));Serial.println(v_currentmin);
           #endif

        }
       

                  if(g_u_clock_ist == 1){ 
                    currenthourAM_PM = false;
                  }
                  if(g_u_clock_ist == 2){ 
                    currenthour12 = v_currenthour;  
                    currenthourAM_PM = false;
                    if( currenthour12 == 0 ){currenthour12 = 12;currenthourAM_PM = true;}
                    if( currenthour12 > 12 ){currenthour12 = currenthour12 - 12;currenthourAM_PM = true;}
                  } 
        
    
      }else{


                  struct tm timeinfo;
                  time_t now;

              if (WiFi.status() == WL_CONNECTED) {
                if (!getLocalTime(&timeinfo)) {
                  #if TM_DEBUG_LEVEL >= TM_DEBUG_MAX
                    Serial.println("[TM] Failed to obtain time");
                  #endif
                }else{
                  #if TM_DEBUG_LEVEL >= TM_DEBUG_MAX
                  Serial.print(F("[TM] 3: "));
                  Serial.println(&timeinfo, "%A, %B %d %Y %H:%M:%S");
                  #endif
                }
              } else {
                #if TM_DEBUG_LEVEL >= TM_DEBUG_MAX
                  Serial.println("[TM] WiFi nicht verbunden. Zeit wird vom ESP abgerufen.");
                #endif
                time(&now);
                localtime_r(&now, &timeinfo);
              }

                  currentSec = timeinfo.tm_sec;
                  v_currentSec = currentSec;
                  currentmin = timeinfo.tm_min;
                  v_currentmin = currentmin;
                  currenthour = timeinfo.tm_hour;
                  v_currenthour = currenthour;
                  weekday = timeinfo.tm_wday;

                  currentdate = timeinfo.tm_mday;
                  currentmonth = timeinfo.tm_mon + 1;
                  currentyear = timeinfo.tm_year + 1900;

                  currentYearTwoDigits = currentyear % 100; // Zweistellige Darstellung z.B. 24

                  //Serial.print("Zweistelliges Jahr: ");
                  //Serial.println(currentYearTwoDigits);


                  /*
                  currentSec = timeClient.getSeconds();
                  currentmin = timeClient.getMinutes();
                  //currenthour = timeClient.getHours();  // Stunden ohne Sommer Winter
                  */

                  currenthour12 = currenthour;

                  //Serial.print(F("[TM] get Stunde     from ESP: "));Serial.println(currenthour);
                  //Serial.print(F("[TM] get minute     from ESP: "));Serial.println(currentmin);
                  //Serial.print(F("[TM] get Sekunde    from ESP: "));Serial.println(currentSec);
                  //Serial.print(F("[TM] get Year       from ESP: "));Serial.println(currentYearTwoDigits);
                  //Serial.print(F("[TM] get Month      from ESP: "));Serial.println(currentmonth);
                  //Serial.print(F("[TM] get Date       from ESP: "));Serial.println(currentdate);



                  if(g_u_clock_ist == 1){ 
                    currenthourAM_PM = false;
                  }
                  if(g_u_clock_ist == 2){ 
                    currenthour12 = v_currenthour;  
                    currenthourAM_PM = false;
                    if( currenthour12 == 0 ){currenthour12 = 12;currenthourAM_PM = true;}
                    if( currenthour12 > 12 ){currenthour12 = currenthour12 - 12;currenthourAM_PM = true;}
                  } 


                  snprintf(formattedDate, sizeof(formattedDate), "%02d.%02d.%02d", currentdate, currentmonth, currentYearTwoDigits);
                  snprintf(formattedDateYYMMDD, sizeof(formattedDateYYMMDD), "%02d.%02d.%02d", currentYearTwoDigits, currentmonth, currentdate);
                  snprintf(formattedTime, sizeof(formattedTime), "%02d:%02d:%02d", v_currenthour, v_currentmin, v_currentSec);
                  #if TM_DEBUG_LEVEL >= TM_DEBUG_MIN
                  Serial.print(F("Aktualisierte Zeit: "));Serial.print(formattedTime);Serial.print(F("  "));Serial.println(formattedDate);Serial.print(F("  "));Serial.println(formattedDateYYMMDD);
                  #endif   
                  strcpy(p_date_DDMMYY, formattedDate); 
                  //printf("p_date_DDMMYY: %s\n", p_date_DDMMYY);

                  strcpy(p_date_YYMMDD, formattedDateYYMMDD); 
                  //printf("p_date_YYMMDD: %s\n", p_date_YYMMDD);


                  // Formatierung der Stunde
                  snprintf(formattedDateHH, sizeof(formattedDateHH), "%02d", v_currenthour);
                  // Ausgabe zur Überprüfung
                  //printf("formattedDateHH: %s\n", formattedDateHH);


                  // Formatierung der Zeit
                  snprintf(formattedDateHHMM, sizeof(formattedDateHHMM), "%02d:%02d", v_currenthour, v_currentmin);
                  // Ausgabe zur Überprüfung
                  //printf("formattedDateHHMM: %s\n", formattedDateHHMM);

                // Kopiere die ersten 6 Zeichen von formattedTime nach p_uhrzeit (HH:MM)
                strncpy(p_uhrzeit, formattedTime, 6);
                // Füge die neuen Sekunden hinzu
                sprintf(p_uhrzeit + 6, "%02d", currentSec);
                // Füge den Nullterminator hinzu
                p_uhrzeit[8] = '\0';
                // Ausgabe zur Überprüfung
                //Serial.print(F("p_uhrzeit: "));Serial.print(p_uhrzeit);Serial.print(F("   "));Serial.print(v_currenthour);Serial.print(F(":"));Serial.println(v_currentmin);


              //sprintf(current_datetime, "%s, %02d.%02d.%d %02d:%02d", getDayOfWeek(esp_dOW), currentdate, currentmonth, currentYearTwoDigits, v_currenthour, v_currentmin);
                sprintf(current_datetime, "%s, %02d.%02d.%02d %02d:%02d", getDayOfWeek(weekday), currentdate, currentmonth, currentYearTwoDigits, v_currenthour, v_currentmin);
           

   

      }



      if(currentyear < 2024 || currentyear > 2060){
          currentyear = 2024;
          currentYearTwoDigits = 24;
      }


        // HH:MM:SS
        // Formatierung der Zeit
        //snprintf(p_uhrzeit, sizeof(p_uhrzeit), "%02d:%02d:%02d", currenthour, currentmin, currentSec);
        //snprintf(p_uhrzeit, sizeof(p_uhrzeit), "%02d:%02d:%02d", currenthour, currentmin, currentSec);
       

          // Kopiere die ersten 6 Zeichen von formattedTime nach p_uhrzeit (HH:MM)
          strncpy(p_uhrzeit, formattedTime, 6);
          // Füge die neuen Sekunden hinzu
          sprintf(p_uhrzeit + 6, "%02d", currentSec);
          // Füge den Nullterminator hinzu
          p_uhrzeit[8] = '\0';
          // Ausgabe zur Überprüfung
          //Serial.print(F("p_uhrzeit: "));Serial.print(p_uhrzeit);Serial.print(F("   "));Serial.print(v_currenthour);Serial.print(F(":"));Serial.println(v_currentmin);

       



         printLocalEpoch();



         //Serial.println("g_set_new_FW " + String(g_set_new_FW));
         if(g_set_new_FW == true) {
           //Serial.print("g_set_new_FW1");Serial.println(g_set_new_FW_time);
           g_set_new_FW_time ++;
          if(g_set_new_FW_time >= 20) {
            g_set_new_FW_time = 0;

                            Preferences preferences;
                            preferences.begin("eenvs", false);                         //Ordner eenvs anlegen/verwenden       
                            g_boot_fail = 1;
                            preferences.putUChar("boot_g_fail", g_boot_fail);    // 
                            
                          if(verzoegerung_fw_update >= 1){
                            verzoegerung_fw_update = 2;
                            preferences.putUChar("fw_verz_update", verzoegerung_fw_update);    //  0=Standard  aus 
                          }
                            preferences.end();         
           
           
            Serial.println(F("Done, Reboot now for FW"));
            delay(2000);
            esp_restart();
          }
         }



    }
   //----------------------------------------------------------





//------------------------------------------------------------------------------------------------------------------------------------------
void setup() {


  /*
  // ESP-IDF anstelle der Arduino-Framework
  // USB-Peripherie deaktivieren
  //USB_DEVICE.jtag_ctrl &= ~USB_JTAG_ENABLE;
  //periph_module_disable(PERIPH_USB_MODULE);
  //usb_ll_stop();
  //usb_jtag_disable();

  // Pins als normale GPIOs konfigurieren
  gpio_pad_select_gpio(GPIO_NUM_19);
  gpio_set_direction(GPIO_NUM_19, GPIO_MODE_OUTPUT);  // funktioniert

  //gpio_pad_select_gpio(GPIO_NUM_20);
  //gpio_set_direction(GPIO_NUM_20, GPIO_MODE_INPUT);
  //gpio_set_direction(GPIO_NUM_20, GPIO_MODE_OUTPUT);
  */
 


    // Deaktivieren der USB-Funktionalität auf GPIO 19 und 20
    //gpio_reset_pin(GPIO_NUM_19);
    //gpio_reset_pin(GPIO_NUM_20);

    // Konfigurieren der Pins als normale GPIO-Pins
    //gpio_set_direction(GPIO_NUM_19, GPIO_MODE_OUTPUT);
    //gpio_set_direction(GPIO_NUM_20, GPIO_MODE_OUTPUT);
    
    //gpio_set_level(GPIO_NUM_19, 1);
    //gpio_set_level(GPIO_NUM_20, 1);

    //gpio_set_level(GPIO_NUM_19, 0);
    //gpio_set_level(GPIO_NUM_20, 0);



      /*
      ESP_LOG_ERROR: Nur Fehler werden geloggt.
      ESP_LOG_WARN: Warnungen und Fehler werden geloggt.
      ESP_LOG_INFO: Informationsmeldungen, Warnungen und Fehler werden geloggt.
      ESP_LOG_DEBUG: Debugging-Informationen, Informationsmeldungen, Warnungen und Fehler werden geloggt.
      ESP_LOG_VERBOSE: Alle oben genannten sowie sehr detaillierte Debugging-Informationen werden geloggt.
      */

      esp_log_level_set("BT_HCI", ESP_LOG_NONE);  //ESP_LOG_VERBOSE
      //esp_log_level_set("BT_HCI", ESP_LOG_VERBOSE);  
      
      //esp_log_level_set("BT_BTM", ESP_LOG_ERROR);
      //esp_log_level_set("BT_L2CAP", ESP_LOG_ERROR);


  //******************************************************************************
  //                         Starte Watchdog                                     *
  //******************************************************************************
  //Serial.println("Configuring WDT");

  esp_task_wdt_init(WDT_TIMEOUT, true); // WDT initialisieren mit Timeout und Panikmodus
  esp_task_wdt_add(NULL);  // Aktuellen Task zum WDT hinzufügen

   esp_task_wdt_reset(); 
 


  // WDT deaktivieren
  //esp_task_wdt_delete(NULL);


  /*
  // RWDT initialisieren
  rtc_wdt_protect_off();  // Schreibschutz des RWDT deaktivieren
  rtc_wdt_set_stage(RTC_WDT_STAGE0, RTC_WDT_STAGE_ACTION_RESET_SYSTEM);  // Stufe 0 auf System-Reset setzen
  rtc_wdt_set_time(RTC_WDT_STAGE0, WDT_TIMEOUT * 1000);  // Timeout auf 30 Sekunden setzen
  rtc_wdt_enable();  // RWDT aktivieren
  rtc_wdt_protect_on();  // Schreibschutz des RWDT reaktivieren
  */
  //******************************************************************************

          pinMode(buzzerPin, INPUT_PULLUP);
          pinMode(buzzerPin, OUTPUT);
          //digitalWrite(buzzerPin, LOW);
          // Verwende einen externen Pull-Down-Widerstand, um den Pin während des Bootens auf LOW zu halten. Ein 10kΩ-Widerstand zwischen dem Pin und GND sollte ausreichen.
          // Ein kleiner Kondensator (z.B. 0.1µF) zwischen dem Pin und GND kann helfen, kurze Spannungsspitzen zu glätten. 
          delay(10); // Kurze Verzögerung
          //digitalWrite(buzzerPin, HIGH);
          digitalWrite(buzzerPin, LOW);




          pinMode(WTD_toggle, OUTPUT);
          digitalWrite(WTD_toggle, LOW);     //   Watchdog Toggle Pin   

          pinMode(WTD_Set, OUTPUT);
          digitalWrite(WTD_Set, LOW);      //   Watchdog Set Pin       0 = Disable   1 = Enable


          randomSeed(analogRead(0)); // Initialisiere den Zufallsgenerator

        
          //--------------------------------------
       
          // Warteschlange erstellen
          notificationQueue = xQueueCreate(10, sizeof(String));

          // Task für das Senden der Benachrichtigungen erstellen
          xTaskCreate(
            notificationTask,  // Task-Funktion
            "NotificationTask",  // Name der Task
            4096,  // Stapelgröße
            NULL,  // Task-Parameter
            1,  // Priorität der Task
            &notificationTaskHandle  // Task-Handle
          );
         
          //--------------------------------------------
          //--------------------------------------
            // Warteschlange im PSRAM erstellen


            //--------------------------------------------
          //--------------------------------------------




        Serial.begin(115200);
          while (!Serial) {}
          Serial.println(F("                            "));

          while (!Serial) {}
          Serial.println(F("========================================================"));
          Serial.println(F("vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv"));

          //Serial.println("[IF] Serial Debug OK");


          // Überprüfen, ob PSRAM verfügbar ist
          if (psramFound()) {
              Serial.println(F("[IF] PSRAM gefunden und aktiviert."));

              size_t psram_size = esp_spiram_get_size();
              Serial.print(F("PSRAM Größe: "));
              Serial.print(psram_size);
              Serial.println(F(" Bytes"));

             
              // Beispiel für die Verwendung von PSRAM
              /*
              uint8_t *buffer = (uint8_t *)ps_malloc(7 * 1024 * 1024); // 8MB Buffer
              if (buffer != NULL) {
                Serial.println("[IF] 8MB Buffer im PSRAM erfolgreich zugewiesen.");
                // Verwende den Buffer...
                free(buffer);
              } else {
                Serial.println("[IF] Fehler beim Zuweisen des Buffers im PSRAM.");
              }
              */
          } else {
            Serial.println(F("[IF] PSRAM nicht gefunden."));

          }
           // Gesamte Heap-Größe
           totalHeapSize = xPortGetFreeHeapSize();
                  

          esp_task_wdt_reset(); 
          // ESP32 Heap-Speicher
          //Serial.printf("[IF] Total heap: %d\n", ESP.getHeapSize());Serial.println(F(" "));
          //Serial.printf("[IF] Free heap: %d\n", ESP.getFreeHeap());Serial.println(F(" "));
          Serial.printf("[IF] Total PSRAM: %d\n", ESP.getPsramSize());
          Serial.printf("[IF] Free PSRAM: %d\n", ESP.getFreePsram());
          Serial.println(F(" "));
          Serial.println(F("vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv"));
          esp_task_wdt_reset();

          Serial.println(F("------------------[ Preferences ]--------------------"));
          //printf("[AP] FREE RAM: now: %.2f MB\n", getUsedRAMMB());





        Preferences preferences;
        preferences.begin("eenvs", false);

        epochTime_save = preferences.getLong("epoch_save", 1704067200);

          //--- !! das noch chevken ob auch aktiviert wir und navh 2 mal rest dekatiert wird
          //knx_program_mode = false;
          //preferences.putBool("p_KNX_ets", knx_program_mode); // KNX Program Mode deaktiviert
          //------------
          // Lese den aktuellen Boot-Zähler aus den Preferences
          int bootCount = preferences.getInt("boot_count", 0);

          // Lese den KNX-Programmiermodus aus den Preferences
          knx_program_mode = preferences.getBool("p_KNX_ets", false);
          Serial.print(F("knx_program_mode "));Serial.println(knx_program_mode);
          if (knx_program_mode) {
              bootCount++;
              Serial.println(F("KNX-Programmiermodus aktiv"));

              // Überprüfe, ob die maximale Anzahl der Boot-Vorgänge erreicht wurde
              if (bootCount >= 3) {
                  knx_program_mode = false;
                  preferences.putBool("p_KNX_ets", false);
                  bootCount = 0;
                  preferences.putInt("boot_count", bootCount);
                  Serial.println(F("KNX-Programmiermodus zurückgesetzt"));   // [Web] KNX toggle Prog Mode
              } else {
                  preferences.putInt("boot_count", bootCount);
              }
          } else {
              // Setze den Boot-Zähler zurück, wenn der KNX-Programmiermodus nicht aktiviert ist
              bootCount = 0;
              preferences.putInt("boot_count", bootCount);
          }
        //----------------------



        //knx_program_mode = preferences.getBool("p_KNX_ets", 0);
        //Serial.print(".....................");Serial.print(knx_program_mode);Serial.println(".....................");

        currentPinStateknx = digitalRead(20); // Lese den Zustand von Pin 20

        Serial.print(F("currentPinState "));Serial.println(currentPinStateknx);
        // if (currentPinStateknx == 0 && knx_program_mode == true) {
        if (knx_program_mode == true) {
          knx.toggleProgMode(); // Beispielaufruf; ersetze dies durch deine tatsächliche Funktion
          Serial.println(F("KNX-Programmiermodus toggleProgMode"));
        }

        disable_bootloop = preferences.getUChar("g_bllop", 0);    // für Werkseinstellung
        not_aus_ble = preferences.getUChar("g_bleoff", 0);        // ble off bei bootlok und webserver an für Werkseinstellung


        g_boot_fail = preferences.getUChar("boot_g_fail", 0);     // 0=Standard
        g_unit_ist = preferences.getUShort("p_unit_ist", 1);      // 1=Standard   1 = bqm3  0=pCi
        g_LEDT_T_ist = preferences.getUShort("p_LEDT_T", 1);      // 1=Standard   Top led EIN
        g_KNX_S_ist = preferences.getUShort("p_KNX_S", 0);        // 0=Standard   KNX Aus
        //Serial.print("[IF] KNX ");Serial.println(g_KNX_S_ist);
        g_LEDT_F_ist = preferences.getUShort("p_LEDT_F", 1);      // 1=Standard   7 Segment  EIN
        g_LEDT_FB_ist = preferences.getUShort("p_LEDT_FB", 5);    // 5=Standard   Helligkeit forne
        g_LEDT_TB_ist = preferences.getUShort("p_LEDT_TB", 100);  // 50=Standard  Top LED Helligkeit
        g_LEDT_TF_ist = preferences.getUShort("p_LEDT_TF", 1);    // 1=Standard   LED oben Flamme

        g_Range_T_ist = preferences.getUShort("g_Range_T", 300);  // 300=Standard   oben Range ROT
        g_Range_M_ist = preferences.getUShort("g_Range_M", 100);  // 150=Standard   mitte Range Orange
        g_Range_U_ist = preferences.getUShort("g_Range_U", 0);    //  0=Standard    unten Range Grün

        g_u_clock_ist = preferences.getUShort("g_u_clock", 0);          //1= 24h   2= 12h  3= Datum
        g_u_view_switch_ist = preferences.getUShort("g_u_view_s", 2);   //  0=Radon  1= Uhr  2= Wechsel

        g_LEDT_T_color = preferences.getUChar("p_LEDT_color", 2);      // 2=green   Top led green


        save_rad_val = preferences.getUInt("s_rad_val", 0);

        g_getrow0 = preferences.getUChar("getrow0", 0);     // 0=Standard
        g_getrow1 = preferences.getUChar("getrow1", 0);     // 0=Standard
        g_getrow2 = preferences.getUChar("getrow2", 0);     // 0=Standard
        g_getrow3 = preferences.getUChar("getrow3", 0);     // 0=Standard


        filePos = preferences.getUInt("filePos", 0);


      currentLogFile = preferences.getString("cLogFile", logFileName1);
      currentEntryIndex = preferences.getUInt("cEntryIndex", 0);
      isLogFull = preferences.getBool("isLogFull", false); // Lade die Variable aus den Preferences
    

      //correctPassword = preferences.getString("password", "deinPasswort");
        // Lade das Passwort als String
      String storedPassword = preferences.getString("password", "deinPasswort");
        // Kopiere den String in das char Array
      storedPassword.toCharArray(correctPassword, sizeof(correctPassword));


        String ntpServer = preferences.getString("g_u_ntp3", "pool.ntp.org");
        ntpServer.toCharArray(g_u_ntp3_ist, sizeof(g_u_ntp3_ist));

  
        web_timestamp = preferences.getLong("timestamp", 0);
        web_timezone = preferences.getInt("timezone", 0);
        web_dst = preferences.getBool("dst", false);
        web_customZone = preferences.getString("customZone", "GMT0");
        web_bit = preferences.getBool("bit", false);
        web_region = preferences.getString("region", "");
        web_city = preferences.getString("city", "");
        



        for (int i = 0; i < 49; i++) {
          char key[7];
          sprintf(key, "int%02d", i);
          charInts[i] = preferences.getUShort(key, 0); // 0 ist der Standardwert, falls der Schlüssel nicht existiert
        }




        //sendValueStr2b = new (heap_caps_malloc(sizeof(String), MALLOC_CAP_SPIRAM)) String();










      //******************************************************************************
      //                            TEMPERATUR                                      *
      //****************************************************************************** 

      temp_sensor_config_t temp_sensor = TSENS_CONFIG_DEFAULT();
      temp_sensor_get_config(&temp_sensor);
      temp_sensor.dac_offset = TSENS_DAC_DEFAULT;
      temp_sensor_set_config(temp_sensor);
      temp_sensor_start();




      //******************************************************************************
      //                            Start  PWM                                       *
      //****************************************************************************** 
      #define switchled           //auskommentiert, ist neue Platine

        // Lese die Pin-Nummern aus den Preferences
        
        //Preferences preferences;
        //preferences.begin("eenvs", false);
        ledPin26c = preferences.getUChar("ledPin26", 27); // Standardwert ist 27
        ledPin27c = preferences.getUChar("ledPin27", 26); // Standardwert ist 26



      // configure LED PWM functionalitites
      ledcSetup(ledChannel,   freq, resolution);  //   DP
      ledcSetup(ledChannel2,  freq, resolution);  //   GPIO02  Bq/m³
      ledcSetup(ledChannel15, freq, resolution);  //   GPIO15  PcI/L
      ledcSetup(ledChannel27, freq, resolution);  //   GPIO27  AM   Pin12
      ledcSetup(ledChannel25, freq, resolution);  //   GPIO37  PM
      ledcSetup(ledChannel26, freq, resolution);  //   GPIO38  NTP
      ledcSetup(ledChannel14, freq, resolution);  //   GPIO14  WLAN  Pin13
      
      // attach the channel to the GPIO to be controlled
      ledcAttachPin(ledPin,     ledChannel);
      ledcAttachPin(ledPin2,   ledChannel2);
      ledcAttachPin(ledPin15, ledChannel15);
      ledcAttachPin(ledPin27, ledChannel27);
      ledcAttachPin(ledPin25, ledChannel25);
      ledcAttachPin(ledPin26, ledChannel26);
      ledcAttachPin(ledPin14, ledChannel14);

      dutyCycle = 0;
      dutyCycle_dp = 0;
      ledcWrite(ledChannel,   dutyCycle);//   DP
      ledcWrite(ledChannel2,  dutyCycle);//   GPIO02  Bq/m³
      ledcWrite(ledChannel15, dutyCycle);//   GPIO15  PcI/L
      ledcWrite(ledChannel27, dutyCycle);//   GPIO27  AM
      ledcWrite(ledChannel25, dutyCycle); //   GPIO37  PM
      ledcWrite(ledChannel26, dutyCycle); //   GPIO38  NTP
      ledcWrite(ledChannel14, dutyCycle);//   GPIO14  WLAN


      //--------------- AKTIV bei Fast Boot ---------------

/*
          // vorladen   //  0=Radon  1= Uhr  2= Wechsel
          if(g_u_view_switch_ist == 0){ 
*/
        if(g_boot_fail >= 1){
          if(g_LEDT_F_ist == 1){   
             
              if(g_unit_ist == 1){  
                  ledcWrite(ledChannel2, dutyCycle_t215);    //   GPIO02  Bq/m³
                  ledcWrite(ledChannel15, 0);                //   GPIO15  PcI/L             
              }else{
                  ledcWrite(ledChannel15, dutyCycle_t215);   //   GPIO15  PcI/L
                  ledcWrite(ledChannel2, 0);                 //   GPIO02  Bq/m³
              } 

   
              ledcWrite(ledChannel14, dutyCycle_t215);   //   GPIO14  WLAN
              ledcWrite(ledChannel26, dutyCycle_t215);   //   GPIO38  NTP  
              ledcWrite(ledChannel,  0);                 //   dp         

          }else{

            ledcWrite(ledChannel2, 0);     //   GPIO02  Bq/m³
            ledcWrite(ledChannel15, 0);    //   GPIO15  PcI/L  
            ledcWrite(ledChannel14, 0);    //   GPIO14  WLAN
            ledcWrite(ledChannel26, 0);    //   GPIO38  NTP
            ledcWrite(ledChannel,  0);     //   dp

          }


          if(g_Seg__boot_ani == true){  
            
              ledcWrite(ledChannel27, 0);              //   GPIO27  AM
              ledcWrite(ledChannel25, 0);              //   GPIO37  PM
              ledcWrite(ledChannel26, 0);              //   GPIO38  NTP
              ledcWrite(ledChannel14, 0);              //   GPIO14  WLAN 
              ledcWrite(ledChannel2, 0);               //   GPIO02  Bqm3
              ledcWrite(ledChannel,  0);               //           dp

          }
     


       }
        //******************************************************************************
        //                            Start  7 Segment                                 *
        //****************************************************************************** 
          while (!Serial) {}
          Serial.println(F("------------------[ Segment ]--------------------"));

          //Serial.println("[IF] 7 Segment OK");
          //printf("[AP] FREE RAM: now: %.2f MB\n", getUsedRAMMB());

          #ifdef siebenSegment
          
              //Konfiguration für den Controller
              controller_configuration<1,1> conf;

              //Das setzt die nńutzung von harware SPI
              conf.useHardwareSpi = false;

              //deaktivieren von virtual_muti_row
              conf.SPI_CS = 42;

              conf.SPI_MOSI = 40;
              conf.SPI_CLK = 39;

              conf.virtual_multi_row = false;

                /*
                #define MOSI 41        //GPIO 41
                #define DIN 40         //GPIO 40
                #define CLK 39         //GPIO 39
                #define CS 42          //GPIO 42
                //Die CS Pins für die einzelnen Zeilen
                #define CS_BOTTOM 42  //GPIO 42
                */

              //hier werden die Chip Select Pins der einzelnen Reihen gesetzt.
              //Die untere Zeile (Zeile 0) ist an Pin 16 geschlossen und die obere Reihe (Reihe 1) an Pin 22
              conf.row_SPI_CS[0] = CS_BOTTOM;
              //conf.row_SPI_CS[1] = CS_TOP;


              //Das schaltet die Debug Ausgabe an.
              conf.debug_output = true;

              //Das setzt die Übertragungsgeschwindigkeit der SPI Schnittstelle.
              //Falls hohe Werte gesetzt werden, sollte eine gute Verbingung sichergestellt werden.
              conf.spiTransferSpeed = 600000;

                //Initialisiere den LedController mit der erstellten Konfiguration.
                lc.init(conf);


              // MOSI




              if(g_boot_fail >= 1){

                if(g_LEDT_F_ist == 1){     
                  
                  //setzt die Helligkeit auf die niedrigste Helligkeit
                  lc.setIntensity(g_LEDT_FB_ist);

                    lc.setRow(0,0,g_getrow0);
                    lc.setRow(0,1,g_getrow1);
                    lc.setRow(0,2,g_getrow2);
                    lc.setRow(0,3,g_getrow3);

                }else{

                  lc.setIntensity(0);
                  //schaltet alle Ziffern aus
                  for(unsigned int i = 0; i < 4;i++){
                    lc.setRow(0,i,0x00);
                  }

                }

              }else{

                lc.setIntensity(0);
                //schaltet alle Ziffern aus
                for(unsigned int i = 0; i < 4;i++){
                  lc.setRow(0,i,0x00);
                } 

              }


          #endif
        //****************************************************************************** 



        //******************************************************************************
        //                            Start  NeoPixel                                  *
        //****************************************************************************** 
          while (!Serial) {}
          Serial.println(F("------------------[ NeoPixel ]--------------------"));

          //Serial.println("[IF] NeoPixel OK");
          //printf("[AP] FREE RAM: now: %.2f MB\n", getUsedRAMMB());
          #ifdef NeoPixel

            strip.begin();

            //clearStrip(); // Initialize all pixels to 'off'

              

              if(g_boot_fail >= 1){
                
                if(g_LEDT_F_ist == 1){  

                  strip.setBrightness(g_LEDT_TB_ist);
                  uint8_t v_Colort = g_LEDT_T_color;     //green
                  colorWipe(strip.Color(m_color[v_Colort][0], m_color[v_Colort][1], m_color[v_Colort][2]), 1); 


                }else{

                  strip.setBrightness(0);
                  clearStrip(); // Initialize all pixels to 'off'

                }   

              }else{

                strip.setBrightness(0);
                clearStrip(); // Initialize all pixels to 'off'

              }


          #endif
        //****************************************************************************** 







        /*

        // RMT-Initialisierung und -Konfiguration
        config.rmt_mode = RMT_MODE_TX;
        config.channel = RMT_CHANNEL_0;
        config.gpio_num = GPIO_NUM_18;
        config.mem_block_num = 1;     // Erhöhe die Anzahl der Speicherblöcke auf 4
        config.tx_config.loop_en = false;
        config.tx_config.idle_output_en = true;
        config.tx_config.idle_level = RMT_IDLE_LEVEL_LOW;
        config.tx_config.carrier_en = false;
        config.clk_div = 80;
        


        esp_err_t err = rmt_config(&config);
        if (err != ESP_OK) {
          Serial.printf("Error configuring RMT: %s\n", esp_err_to_name(err));
          return;
        }

        err = rmt_driver_install(config.channel, 0, 0);
        if (err != ESP_OK) {
          Serial.printf("Error installing RMT driver: %s\n", esp_err_to_name(err));
          return;
        }

        // Konfigurationsstruktur auslesen und ausgeben
        Serial.println("=========================");
        Serial.println("RMT Configuration:");
        Serial.printf("Mode: %d\n", config.rmt_mode);Serial.println(F(" "));
        Serial.printf("Channel: %d\n", config.channel);Serial.println(F(" "));
        Serial.printf("GPIO Number: %d\n", config.gpio_num);Serial.println(F(" "));
        Serial.printf("Memory Block Number: %d\n", config.mem_block_num);Serial.println(F(" "));
        Serial.printf("Loop Enabled: %d\n", config.tx_config.loop_en);Serial.println(F(" "));
        Serial.printf("Idle Output Enabled: %d\n", config.tx_config.idle_output_en);Serial.println(F(" "));
        Serial.printf("Idle Level: %d\n", config.tx_config.idle_level);Serial.println(F(" "));
        Serial.printf("Carrier Enabled: %d\n", config.tx_config.carrier_en);Serial.println(F(" "));
        Serial.printf("Clock Divider: %d\n", config.clk_div);Serial.println(F(" "));

        // RMT-Status auslesen und ausgeben
        rmt_channel_status_result_t status;
        err = rmt_get_channel_status(&status);
        if (err != ESP_OK) {
          Serial.printf("Error getting RMT status: %s\n", esp_err_to_name(err));Serial.println(F(" "));
          return;
        }
         Serial.println("=========================");


        */

          // Deinstalliere den RMT-Treiber, falls er installiert ist
          //uninstall_rmt_driver();

          // Installiere den RMT-Treiber erneut mit mem_block_num = 2
          //install_rmt_driver();

        
          /*
          Serial.println("RMT Status:");
          Serial.printf("Idle Level: %d\n", status.idle_level);
          Serial.printf("Memory Block Number: %d\n", status.mem_block_num);
          Serial.printf("Clock Divider: %d\n", status.clk_div);
        */
        /*
        rmt_config(&config);
        rmt_driver_install(config.channel, 0, 0);
        esp_err_t erri = rmt_driver_install(config.channel, 0, 0);
        if (erri != ESP_OK) {
            Serial.printf("Error installing RMT driver: %s\n", esp_err_to_name(erri));
            return;
        }
        */







  //******************************************************************************
  //                       Starte SPIFFS Dateisystem                             *
  //****************************************************************************** 
     while (!Serial) {}
     Serial.println(F("------------------[ SPIFFS ]--------------------"));

     //Serial.println("[IF] SPIFFS Load");
     //printf("[AP] FREE RAM: now: %.2f MB\n", getUsedRAMMB());

   #define FORMAT_SPIFFS_IF_FAILED true

    if(!SPIFFS.begin(FORMAT_SPIFFS_IF_FAILED)){
        //#ifdef NVS_DEBUG
        Serial.println(F("[IF] SPIFFS Mount Failed"));
        //#endif
        //return;
    }else{
        //#ifdef NVS_DEBUG
        Serial.println(F("[IF] SPIFFS OK, mounted correctly."));   
        //#endif 
    }




  //******************************************************************************
  //                     Starte Backup SPIFFS Dateisystem                        *
  //****************************************************************************** 
    // Zugriff auf die hochgeladene Datei im /backup-Verzeichnis
    /*
    File backupFile = SPIFFS.open("/backup/firmware.bin", FILE_READ);
    if (!backupFile) {
        Serial.println(F("Failed to open firmware.bin in backup directory"));
        return;
    }

    Serial.println(F("Firmware.bin erfolgreich im Backup-Verzeichnis geöffnet!"));
    // Dateiinhalt verarbeiten...
    backupFile.close();
    */



 
  //******************************************************************************
  //                         Start  Preferences Restore                          *
  //****************************************************************************** 
     while (!Serial) {}
          NVS_DEBUG_PRINTLN(F("----------------[ Preferences Restore ]------------------"));
          //NVS_DEBUG_PRINTLN(F("[IF] Preferences  OK"));
         // printf("[AP] FREE RAM: now: %.2f MB\n", getUsedRAMMB());
          bool g_backup_rwestore_start = false;

          NVS_DEBUG_PRINTLN(F(" "));
          NVS_DEBUG_PRINTLN(F("<<<<<<<<<<<<= Checke NVS-System =>>>>>>>>>>>>"));
          int error = checkFileSystemAndPreferences();

          switch (error) {
              case 1:
                  NVS_DEBUG_PRINTLN(F("[KY] Error 1: NVS nicht verfügbar oder ein Versionsfehler"));
                  break;
              case 2:
                  NVS_DEBUG_PRINTLN(F("[KY] Error 2: Standard NVS KEY's nicht verfügbar"));
                  break;
              case 3:
                  NVS_DEBUG_PRINTLN(F("[KY] Error 3: NVS Count KEY nicht verfügbar"));
                  break;
              case 4:
                  NVS_DEBUG_PRINTLN(F("[KY] Error 4: NVS Error KEY nicht verfügbar"));
                  break;
              case 6:
                  NVS_DEBUG_PRINTLN(F("[KY] Kein Fehler: NVS-System erfolgreich geladen, Standard KEY's verfügbar."));
                  break;
              case 7:
                  NVS_DEBUG_PRINTLN(F("[KY] Kein Fehler: NVS-System erfolgreich geladen, Start Counter KEY's verfügbar."));
                  break;
              case 8:
                  NVS_DEBUG_PRINTLN(F("[KY] Kein Fehler: NVS-System erfolgreich geladen, Start Error KEY's verfügbar."));
                  break;  
              case 9:
                  NVS_DEBUG_PRINTLN(F("[KY] Kein Fehler: NVS-System erfolgreich geladen."));
                  //savePreferencesToSPIFFS();
                  //NVS_DEBUG_PRINTLN(F("NVS-System Daten gesichert"));
                  break;
              default:
                  NVS_DEBUG_PRINTLN(F("[KY] Unbekannter Fehler"));
                  break;
          }


                            
                  
                  
          if (error >= 1 && error <= 4) {

               NVS_DEBUG_PRINTLN(F("[KY] Error 1.2.3.4 handle"));
              Preferences preferences;
              preferences.begin("eenvs", false); // NVS initialisieren

              //----------------------------------
              if (error == 1) {

                  NVS_DEBUG_PRINTLN(F("-----------------------------------------"));  
                  // NVS-Dateisystem löschen
                  preferences.begin("eenvs", false); // NVS initialisieren
                  preferences.clear();
                  NVS_DEBUG_PRINTLN(F("[KY] NVS-Dateisystem gelöscht."));

                  NVS_DEBUG_PRINTLN(F("+++++++++++++++++++++++++++++++++++"));  
                  // Initialisiere die benutzerdefinierte NVS-Partition
                  esp_err_t err = nvs_flash_init_partition("nvs");

                  // Überprüfe, ob die Initialisierung erfolgreich war
                  if (err == ESP_OK) {
                      NVS_DEBUG_PRINTLN(F("Benutzerdefinierte NVS-Partition erfolgreich initialisiert."));
                  } else if (err == ESP_ERR_NVS_NO_FREE_PAGES || err == ESP_ERR_NVS_NEW_VERSION_FOUND) {
                      // NVS-Partition neu formatieren, wenn keine freien Seiten vorhanden sind oder eine neue Version gefunden wurde
                      NVS_DEBUG_PRINTLN(F("NVS-Partition neu formatieren..."));
                      ESP_ERROR_CHECK(nvs_flash_erase_partition("nvs"));
                      err = nvs_flash_init_partition("nvs");
                      if (err == ESP_OK) {
                          NVS_DEBUG_PRINTLN(F("Benutzerdefinierte NVS-Partition erfolgreich neu formatiert und initialisiert."));
                      } else {
                          NVS_DEBUG_PRINTF("Fehler1 bei der Initialisierung der NVS-Partition: %s\n", esp_err_to_name(err));
                      }
                  } else {
                      NVS_DEBUG_PRINTF("Fehler2 bei der Initialisierung der NVS-Partition: %s\n", esp_err_to_name(err));
                  }

                  // Lösche die NVS-Partition
                  esp_err_t err2 = nvs_flash_erase_partition("nvs");
                  if (err2 != ESP_OK) {
                      NVS_DEBUG_PRINTF("Fehler beim Löschen der NVS-Partition: %s\n", esp_err_to_name(err2));
                  } else {
                      NVS_DEBUG_PRINTLN(F("[KY] NVS-Dateisystem erfolgreich gelöscht und formatiert."));
                  }

                  // Initialisiere die NVS-Partition neu
                  err2 = nvs_flash_init_partition("nvs");
                  if (err2 == ESP_OK) {
                      NVS_DEBUG_PRINTLN(F("NVS-Partition erfolgreich NEU initialisiert."));
                  } else {
                      NVS_DEBUG_PRINTF("Fehler bei der Initialisierung der NVS-Partition: %s\n", esp_err_to_name(err2));
                  }

                  NVS_DEBUG_PRINTLN(F("+++++++++++++++++++++++++++++++++++")); 
                  NVS_DEBUG_PRINTLN(F("-----------------------------------------"));   

                  preferences.begin("eenvs", false); // NVS initialisieren
              }
              //----------------------------------

              NVS_DEBUG_PRINTLN(F("[KY] NVS-System initialisieren."));




              //----------------------------------
                if (error == 2) {

                    #ifdef NVS_DEBUG
                    size_t freieEintraege = preferences.freeEntries();
                    #endif
                    NVS_DEBUG_PRINT(F("Freie Einträge: "));
                    NVS_DEBUG_PRINTLN(freieEintraege);

                    // Set a bit to indicate that there is an error
                    NVS_DEBUG_PRINTLN(F("[KY] NVS Ident Keys angelegt."));
                    preferences.putBool("errorNVS", true);
                    preferences.putUChar("countNVS", 1);

                    if (!preferences.isKey("countNVS")) {
                        NVS_DEBUG_PRINTLN(F("[KY] ========= NVS error: Start KEY's not found"));
                    } else {
                        NVS_DEBUG_PRINTLN(F("[KY] NVS Neu angelegte Ident Keys konnten gelesen werden. Jetzt schauen ob Backup vorhanden ist"));
                        g_backup_rwestore_start = true;
                    }
                }

              //----------------------------------
              //----------------------------------
              if (error == 3 || error == 4) {

                  #ifdef NVS_DEBUG
                  size_t freieEintraege = preferences.freeEntries();
                  #endif
                  NVS_DEBUG_PRINT(F("Freie Einträge: "));
                  NVS_DEBUG_PRINTLN(freieEintraege);

                  // Set a bit to indicate that there is an error
                  NVS_DEBUG_PRINTLN(F("[KY] NVS Ident Keys angelegt."));
                  preferences.putBool("errorNVS", true);
                  preferences.putUChar("countNVS", 1);

                  if (!preferences.isKey("countNVS")) {
                      NVS_DEBUG_PRINTLN(F("[KY] ========= NVS error: Start KEY's not found"));
                  } else {
                      NVS_DEBUG_PRINTLN(F("[KY] NVS Neu angelegte Ident Keys gelesen."));
                  }
              }
              //----------------------------------

              preferences.end();

              NVS_DEBUG_PRINTLN(F("<<<<<<<<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>>>>>>>"));          
              NVS_DEBUG_PRINTLN(F("[KY] NVS-System RESTORE!"));

              bool hasData = checkFileContent(dateiGrSP);    // Überprüfen, ob Daten in der Datei vorhanden sind
              if (hasData) {
                  NVS_DEBUG_PRINTLN(F("[KY] Die Backup Datei enthält Daten."));   // ich darf erst bei verlorenen Daten restore machen, nicht beim ersten mal beim initiialisieren.        
                  //restorePreferencesFromSPIFFS(false); // Daten nur ausgeben
                  restorePreferencesFromSPIFFS(true);  // Daten wiederherstellen
              } else {
                  NVS_DEBUG_PRINTLN(F("[KY] Die Backup Datei ist leer."));
              }

              if (g_backup_rwestore_start == false) {
                  // Restart  !!!!!!!!!!!!!!!!!!!!!
                  NVS_DEBUG_PRINTLN(F("[IF] ESP Reeboot wegen NVS!!")); 
                  preferences.end();
                  delay(2000);
                  ESP.restart(); 
              } else {
                  NVS_DEBUG_PRINTLN(F("[IF] ESP Reeboot überspringen und normal booten!")); 
              }

              } else {  // (error >= 1 && error <= 4) 

                  NVS_DEBUG_PRINTLN(F("[KY] Refernz KEY's sind vorhanden."));
                  NVS_DEBUG_PRINTLN(F("[KY] NVS-System erfolgreich geladen."));
                  savePreferencesToSPIFFS();
                  NVS_DEBUG_PRINTLN(F("[KY] NVS-System Daten gesichert"));
                  NVS_DEBUG_PRINTLN(F("[KY] Die Backup Datei enthält Daten.")); 
                  restorePreferencesFromSPIFFS(false); // false = Daten nur ausgeben
              }
              //----------------------------------------------------
              NVS_DEBUG_PRINTLN(F("<<<<<<<<<<<= Checked NVS-System =>>>>>>>>>>>"));
              NVS_DEBUG_PRINTLN(F(" "));




           /*
          Serial.print("[CO] MOSI: ");
          Serial.println(MOSI);
          Serial.print("[CO] MISO: ");
          Serial.println(MISO);
          Serial.print("[CO] SCK: ");
          Serial.println(SCK);
          Serial.print("[CO] SS: ");
          Serial.println(SS);  
          Serial.print("[CO] SCL: ");
          Serial.println(SCL); 
          Serial.print("[CO] SDA: ");
          Serial.println(SDA); 
          */




          size_t freieEintraege = preferences.freeEntries();
          Serial.print(F("[IF] Freie Preferences Einträge: "));
          Serial.println(freieEintraege);

          rtc_time_valid = preferences.getUInt("rtc_time_valid", 0);
          update_rtc_ready = rtc_time_valid;

          g_Set_mesz = preferences.getUInt("g_Set_mesz", 0);
          alreadyAdjusted = preferences.getBool("alreadyAdjusted", false);

          verzoegerung_fw_update = preferences.getUChar("fw_verz_update", 0); 
          if(verzoegerung_fw_update > 0){
              Serial.print(F("[IF] >>>>>++++++ verzoegerung für FW Update: "));
              Serial.println(verzoegerung_fw_update);
          }
          if(verzoegerung_fw_update != 0){
              g_bit_fw_load = true;
          }


          preferences.getBytes("wSSID_s", wIFI_SSID_c, sizeof(wIFI_SSID_c));
          preferences.getBytes("wPWD_s", wIFI_PASSWORD_c, sizeof(wIFI_PASSWORD_c));
          preferences.getBytes("encryption", wIFI_encryptionType_c, sizeof(wIFI_encryptionType_c));
          Serial.print(F("[IF] wIFI_encryptionType: "));
          Serial.println(wIFI_encryptionType_c);





        //wIFI_SSID_s = "FRITZ!Box 6490 Holger"; 
        //wIFI_PASSWORD_s = "15400240614617116002"; 
        //preferences.putString("wISSID_s", wIFI_SSID_s); 
        //preferences.putString("wPWD_s", wIFI_PASSWORD_s); 



        //#define DeviceID_LENt 9
        //char device_id_ct[DeviceID_LENt + 1] = "HF0309F0"; // Initialisiere device_id_c einmalig mit "HF0309F0"
        //preferences.putBytes("p_device_id", device_id_ct, DeviceID_LENt);


        // Gerätedaten aus den Preferences lesen und in device_id_c kopieren
        preferences.getBytes("p_device_id", device_id_c, DeviceID_LEN);
        device_id_c[DeviceID_LEN] = '\0'; // Sicherstellen, dass die Zeichenkette nullterminiert ist
        // Kürze die Zeichenkette auf 8 Zeichen, falls sie länger ist
        if (strlen(device_id_c) > 8) {
            device_id_c[8] = '\0'; // Zeichenkette auf 8 Zeichen kürzen
            preferences.putBytes("p_device_id", device_id_c, 8);
        }

        // Ausgabe zur Überprüfung
        //Serial.print(F("device_id_c: "));
        //Serial.println(device_id_c);

       


        uint32_t ee_provision_t = preferences.getUInt("eprovision", 0); 
        ee_provision = static_cast<uint8_t>(ee_provision_t);  // muss ich so machen, weil sonst pov Gerät nicht mehr Prov sind, -  muss 32bit bleiben

        g_Seg__boot_ani = preferences.getBool("boot_ani", true);
        if(g_Seg__boot_ani == false){
          preferences.putBool("boot_ani", true);  // // boot ani LCD  nächstes mal wieder automatisch aktivieren
          ani_segment_finish = true; // damit farbig led aktiviert wird
          g_showani = false;
          g_view_fw = false;
        }

        boot_ani_off = preferences.getBool("boot_ani_1", false);
        if(boot_ani_off == true){
          preferences.putBool("boot_ani_1", false);  // nächstes mal wieder automatisch aktivieren
          ani_segment_finish = true;// damit farbig led aktiviert wird
          g_showani = false;
          g_view_fw = false;
        }
        boot_ani_off2 = preferences.getBool("boot_ani_2", false);
        if(boot_ani_off2 == true){
          preferences.putBool("boot_ani_2", false);  // nächstes mal wieder automatisch aktivieren     false = led pulsen
          ani_segment_finish = true; // damit farbig led aktiviert wird  
          g_showani = false;
          g_view_fw = false;
        }

        p_tb_client_id = preferences.getString("p_client_id", ""); 
        p_tb_username = preferences.getString("p_username", ""); 
        p_tb_password = preferences.getString("p_password", ""); 

        p_fw_success = preferences.getUChar("fw_success", 0);


        // https://github.com/nayarsystems/posix_tz_db/blob/master/zones.csv
        g_u_timezone_ist = preferences.getString("g_u_timezone", "CET-1CEST,M3.5.0,M10.5.0/3"); 
        g_u_mez_ea_ist = preferences.getUShort("g_mez_ea", 1);    //  1=EIN  


        // Lade die NTP-Server als Strings und kopiere sie in die char Arrays
        String ntp1 = preferences.getString("g_u_ntp1", "ptbtime1.ptb.de");
        String ntp2 = preferences.getString("g_u_ntp2", "europe.pool.ntp.org");
        String ntp3 = preferences.getString("g_u_ntp3", "pool.ntp.org");

        ntp1.toCharArray(g_u_ntp1_ist, sizeof(g_u_ntp1_ist));
        ntp2.toCharArray(g_u_ntp2_ist, sizeof(g_u_ntp2_ist));
        ntp3.toCharArray(g_u_ntp3_ist, sizeof(g_u_ntp3_ist));

  
        epochTime_start = preferences.getULong64("epochstart", 0);
        p_timeon = preferences.getInt("p_timeon", 0);


            //-----------------------------
            if(rtc_time_valid == 1){
                Serial.println(F("[TM] RTC Uhr ist gestellt"));

                if(g_Set_mesz == 0){
                    Serial.println(F("[TM] Es ist Sommer  | MESZ"));
                }else{
                    Serial.println(F("[TM] Es ist Winter   MEZ"));
                }

            }else{
                Serial.println(F("[TM] RTC Uhr wurde noch nicht gestellt"));
                Serial.println(F("[TM] Sommer-Winterzeit noch undeffiniert"));
            }
            //-----------------------------


            

        sperre_10Time2 = preferences.getBool("sperre_10Time2", false);
        sperre_10Time3 = preferences.getBool("sperre_10Time3", true);

            
            
          lora_change_bt = preferences.getUChar("g_cloud_bttb", 0);
          if (lora_change_bt == 1) {    // Wenn über BT geändert wurde, wird Thingsboard ignoriert
              Serial.println(F("[BT] Cloud Einstellungen wird von BT Daten verwaltet"));
          } else {
              Serial.println(F("[BT] Cloud Einstellungen wird von TB Daten verwaltet"));
          } 

          ntp_change_web = preferences.getUChar("g_ntp_web", 0);
          if (ntp_change_web == 1) {    // Wenn über BT geändert wurde, wird Thingsboard ignoriert
              Serial.println(F("[BT] NTP Einstellungen wird von Web Daten verwaltet"));
          } else {
              Serial.println(F("[BT] NTP Einstellungen wird von TB Daten verwaltet"));
          }




    //******************************************************************************
    //                                MQTT                                    *
    //****************************************************************************** 

      Serial.println(F("--------------------[ MQTT ]----------------------"));

      //printf("[AP] FREE RAM: now: %.2f MB\n", getUsedRAMMB());
      load_mqtt_settings();

 
      if(p_mqonoff == true){
        mqttClient.setServer(p_inputmqserverc, 1883);
        mqttClient.setCallback(mqtt_callback);
      }




    //******************************************************************************
    //                                RTC  UHR                                     *
    //****************************************************************************** 
   //printf("[AP] FREE HEAP: now: %u, contiguous: %u, lowest: %u\n",xPortGetFreeHeapSize(),heap_caps_get_largest_free_block(MALLOC_CAP_DEFAULT),xPortGetMinimumEverFreeHeapSize());
        Serial.println(F("--------------------[ RTC ]----------------------"));

        //printf("[AP] FREE RAM: now: %.2f MB\n", getUsedRAMMB());
        epochTime_save = preferences.getLong("epoch_save", 1704067200);


 

        //Wire.begin();
        //TwoWire I2CRTC = TwoWire(0);
        Wire.begin(I2C_SDA, I2C_SCL);    //  DS3231 myRTC;   getHour

        //I2CRTC.begin(I2C_SDA, I2C_SCL, 100000);


        //SoftwareWire myWire(I2C_SDA, I2C_SCL); // Definiere die SDA und SCL Pins für Software I2C

        //DS3231 myRTC(myWire);

         /*
        if (myRTC.begin(&myWire)) {
            Serial.println("RTC initialisiert.");
        } else {
            Serial.println("RTC Initialisierung fehlgeschlagen.");
        }
          */
        //TwoWire I2CRTC = TwoWire(0);
        //I2CRTC.begin(I2C_SDA, I2C_SCL, 100000);

        //bool status = myRTC.DS3231(&I2CRTC);  
        //if (!status) {
          //Serial.println("no sensor found");
          //while (1);
        //}

        //-------------  SCAN  -----------

        //Serial.println("\nI2C Scanner"); 
        //scanI2C(); // Call the I2C scan function once
        
        //scanI2C68();


        read_clock_RTC();

        if(rtc_time_valid == 1){
          if(g_Set_mesz == 0){
              
              if(g_u_mez_ea_ist == 1){
                Serial.println("[TM] Aktuell ist Sommer | MESZ | Sommer/Winterzeit umstellung aktiv | --> abzug Sommer/Winter und Zeitzone");
                epochTime_rtc = epochTime_rtc - 3600;   // Sommer/Winterzeit umstellung 
                epochTime_rtc = epochTime_rtc - 3600;   // Zeitzone 
              }else{
                Serial.println("[TM] Aktuell ist Sommer | MESZ | Deaktiviert Sommer/Winterzeit umstellung | --> abzug nur Zeitzone");
                epochTime_rtc = epochTime_rtc - 0;      // Sommer/Winterzeit umstellung 
                epochTime_rtc = epochTime_rtc - 3600;   // Zeitzone 
              }
              
          }else{

              if(g_u_mez_ea_ist == 1){
                Serial.println("[TM] Aktuell ist Winter | MEZ | Sommer/Winterzeit umstellung aktiv | --> abzug Sommer/Winter und Zeitzone");
                epochTime_rtc = epochTime_rtc - 0;     // Sommer/Winterzeit umstellung 
                epochTime_rtc = epochTime_rtc - 3600;   // Zeitzone 
              }else{
                Serial.println("[TM] Aktuell ist Winter | MEZ | Deaktiviert Sommer/Winterzeit umstellung | --> abzug nur Zeitzone");
                epochTime_rtc = epochTime_rtc - 0;      // Sommer/Winterzeit umstellung 
                epochTime_rtc = epochTime_rtc - 3600;   // Zeitzone 
              }
          }
        }


        echo_clock_info();  





    //******************************************************************************
    //                                ESP  UHR                                     *
    //****************************************************************************** 
          Serial.println(F("-------------------[ ESP RTC ]---------------------"));
          //printf("[AP] FREE RAM: now: %.2f MB\n", getUsedRAMMB());
          struct timespec tp;      
          
          if(update_rtc_ready == 0){ 
            Serial.println(F("[IF] ESP32 Uhr von RTC Uhr stellen"));
            tp.tv_sec = epochTime_rtc;  //hier die Uhrzeit stellen
          }else{
            Serial.println(F("[IF] ESP32 Uhr nicht von RTC Uhr gestelt!!"));
            tp.tv_sec = epochTime_save; 
            epochTime_rtc = epochTime_save;
            epochTime_esp = epochTime_save;
          }


          clock_settime(CLOCK_REALTIME, &tp);
          Serial.print(F("[IF] ESP32 Uhr Stellen von RTC Uhr | "));Serial.println(epochTime_rtc);
      
                  time_t now;
                  char strftime_buf[64];
                  struct tm timeinfo;
                  time(&now);
                  Serial.print(F("[TM] Load Timezone: "));Serial.println(g_u_timezone_ist);
                  setenv("TZ",g_u_timezone_ist.c_str(),1); 
                  tzset();
                  localtime_r(&now, &timeinfo);
                  strftime(strftime_buf, sizeof(strftime_buf), "%c", &timeinfo);
                  //ESP_LOGI(TAG, "The current date/time in Germany is: %s", strftime_buf);
                  printf("[IF] The current date/time is: %s\n", strftime_buf);
                  esp_task_wdt_reset(); 

     

          
        //Serial.println("-----------------");
        //Serial.print("[IF] Get timeClient "); Serial.println(timeClient.getEpochTime());

        timeClient.setEpochTime(epochTime_rtc + daylightOffset_sec); // hier Sommer Winter dazuaddieren das Epoch passt
        
        //Serial.println("[IF] Set timeClient with RTC Time");

        //Serial.print("[IF] Get timeClient "); Serial.print(timeClient.getEpochTime());Serial.print(" | ");Serial.print(timeClient.getHours());Serial.print(":");Serial.println(timeClient.getMinutes());
        //Serial.println("-----------------");


      read_clock_esp32();   

      get_time_vars();

    //****************************************************************************** 





        TB_newFwVersion = preferences.getString("t_fw_version", CURRENT_FIRMWARE_VERSION); 
        TB_currFwVersion = String(CURRENT_FIRMWARE_VERSION);
        //TB_currFwVersion_view = TB_currFwVersion;

        g13FileRead = preferences.getUShort("p_13file", 0);       // in datei gespeicherte zeilen   //lese ab dieser zeile 

        gFW_Update_start = preferences.getUChar("fw_s_upd", 0);  // 1= neue FW verfügbar
        gFW_counter = preferences.getUChar("fw_counter", 0);
        

        g_kalibriert = preferences.getUChar("s_kalibriert", 0); //kalibrierter Sensor
        g_checked = preferences.getUChar("s_checked", 0);       //gecheckter Sensor



        g14Filewrite = preferences.getUShort("g14Filewr", 0); 
        g15Filewrite = preferences.getUShort("g15Filewr", 0); 
        g1415_full = preferences.getUShort("g1415_full", 0); 
        g1415Side = preferences.getUShort("g1415Side", 0); 

        g17Filewrite = preferences.getUShort("g17Filewr", 0); 
        g18Filewrite = preferences.getUShort("g18Filewr", 0); 
        g1718_full = preferences.getUShort("g1718_full", 0); 
        g1718Side = preferences.getUShort("g1718Side", 0); 


        gFilewrite = preferences.getUShort("gFilewrite", 0); 
        gFileread = preferences.getUShort("gFileread", 1); 
        g_full = preferences.getUShort("g_full", 0); 





        g_u_buzzer_ea = preferences.getUShort("g_buz_ea", 0);      // 0  =Standard 
        g_Buzzer_ist  = preferences.getUShort("g_buz_ist", 300);   // 300=Standard  


        g_file_start = preferences.getUShort("g_file_start", 0);   //
        g_file_end = preferences.getUShort("g_file_end", 0);       //
        g_file_read = preferences.getUShort("g_file_read", 0);     //  
            
        g_u_beacon_ist = preferences.getUShort("g_beacon", 3);    //  0=Aus    



        dutyCycle_t215 = preferences.getUChar("dutyCycle", 150);    //  150   


        mb_radon_save_eintrarge = preferences.getUShort("r_eintrarge", 0); 

        g_G00_ist = preferences.getUShort("g_G00", 0); 
        g_G01_ist = preferences.getUShort("g_G01", 0); 
        g_G02_ist = preferences.getUShort("g_G02", 0); 
        g_G18_ist = preferences.getUShort("g_G18", 0); 
        g_G19_ist = preferences.getUShort("g_G19", 0); 
        g_G21_ist = preferences.getUShort("g_G21", 0); 

        //g_checked_soll = preferences.getUInt("g_Gcheck", 0); 
        //g_kalibriert_soll = preferences.getUInt("g_Gkali", 0); 

        v_Brightness = g_LEDT_TB_ist;



        disable_server = preferences.getUChar("g_server", 1);    //  1=Standard   AN 

       
        if(verzoegerung_fw_update == 2) {
            Serial.println(F("[IF] -------------->>>>  NEW  FW load")); 
            disable_server = 0;
        }

        if(disable_server == 0){
            Serial.println(F("[IF] -------------->>>>  Disable Webserver")); 
        }


        if(g_LEDT_F_ist == 0){  // ani überspringen
          g_Seg__boot_ani = false;
          g_t_led_off = true;
        }

   //disable_server = 0;

        p_i_fw_title = preferences.getString("t_fw_title", ""); 
        p_i_fw_version = preferences.getString("t_fw_version", ""); 
        p_i_fw_tag = preferences.getString("t_fw_tag", ""); 
        p_i_fw_size = preferences.getString("t_fw_size", ""); 
        p_i_fw_checksum_algorithm = preferences.getString("t_fw_algorithm", ""); 
        p_i_fw_checksum = preferences.getString("t_fw_checksum", ""); 

        p_i_G00 = preferences.getString("t_S00_KEY", " "); 
        p_i_G01 = preferences.getString("t_S01_KEY", " "); 
        p_i_G02 = preferences.getString("t_S02_KEY", " "); 
        p_i_G18 = preferences.getString("t_S18_KEY", " "); 
        p_i_G19 = preferences.getString("t_S19_KEY", " "); 
        p_i_G21 = preferences.getString("t_S21_KEY", " "); 


   
      
      //if(lora_change_bt == 0){  // Wenn über BT geändert wurde, wird Thingsboard ignoriert


          load_cloud_settings();
        //}  

        //p_inputcloudkey = preferences.getString("p_clkey", "3as44643euW"); 
        //p_inputcloudinter = preferences.getString("p_clinter", "15"); 
        gReboot_TOKENFlag = preferences.getUChar("p_crebbot", 0);   // nur neu Speichern wenn Zeit abgelaufen ist
        //p_inputcloudinteri = p_inputcloudinter.toInt(); 
        //p_inputcloudporti = p_inputcloudport.toInt(); 

        g12FileRead = preferences.getUShort("p_12file", 0);   // in datei gespeicherte zeilen   //lese ab dieser zeile 


        p_inputcloudserver.toCharArray(p_inputcloudserverc, CLOUD_SERVER_LEN);

        restartBit = preferences.getBool("restart_bit", false);
        /*
        if(restartBit == true){
          restartBit = false;
          preferences.putBool("restart_bit", restartBit); // Das Neustart-Bit löschen
        }
        */

        startMillis = millis(); // Speichere den Startzeitpunkt



        //wIFI_SSID_s = "FRITZ!Box 6490 Holger";
        //wIFI_PASSWORD_s = "15400240614617116002";

        /*
        int lengtht = wIFI_SSID_s.length();
        wIFI_SSID_s.toCharArray(wIFI_SSID_c, lengtht+1); 
        lengtht = wIFI_PASSWORD_s.length();
        wIFI_PASSWORD_s.toCharArray(wIFI_PASSWORD_c, lengtht+1); 
        */



    // nvs_flash_init


  //****************************************************************************** 




     

      ee_var_01 = preferences.getUInt("ee_var_01", 0);      
      ee_var_01++;                                               //Variable counter um 1 erhöhen
      Serial.printf("[IF] Boot Anzahl: %u\n", ee_var_01);Serial.println("");          //Variable counter Seriell ausgeben
      preferences.putUInt("ee_var_01", ee_var_01);                  //Variable counter unter "Datei" ee_var_01 speichern

      




      
        //  datei_lesen_line16(); // erst lesen wegen daten
          //charcount16_w = charcount16_r;
          //gFileread = charcount16_r;
    

 
    #ifdef NVS_space_DEBUG
    // Get all information of SPIFFS
    unsigned int totalBytes = SPIFFS.totalBytes();
    unsigned int usedBytes = SPIFFS.usedBytes();
    //Serial.println("-----------------------------------");
    Serial.println("===== NVS File system info =====");
    Serial.print("Total space:      ");
    Serial.print(totalBytes);
    Serial.println(" byte");
    Serial.print("Total space used:  ");
    Serial.print(usedBytes);
    Serial.println(" byte");
    Serial.println("-----------------------------------"); 
    //Serial.println(); 
    #endif 
    //listDir(SPIFFS, "/", 0);
    //writeFile(SPIFFS, "/hello.txt", "Hello ");
    //appendFile(SPIFFS, "/hello.txt", "World!\r\n");

    
    #ifdef NVS_space_DEBUG
    String logFile2Content = read_file_content(dateiGrSP);
    Serial.println("File Content:");
    Serial.println(logFile2Content);
    #endif


    //readFile(SPIFFS, "/lightman.js");
    //readFile(SPIFFS, "/mobil04.html");
   // renameFile(SPIFFS, "/hello.txt", "/foo.txt");
    //readFile(SPIFFS, "/foo.txt");
    //deleteFile(SPIFFS, "/foo.txt");
    //testFileIO(SPIFFS, "/test.txt");
   // deleteFile(SPIFFS, "/test.txt");
    //Serial.println( "Test complete" );
    
  // Dateisystem formatieren
  //SPIFFS.format();



  //datei_schreiben();
  //datei_lesen();
  //datei_lesen_line();

  //----------------------------------------------------------------

  //******************************************************************************
  //                                RTC  UHR                                     *
  //****************************************************************************** 


       








  //****************************************************************************** 


    /*
        pinMode (BUZZZER_PIN, OUTPUT);
    */

    /*
        pinMode(buzzer, OUTPUT);
        ledcSetup(channel, frequenz, resolutionBits);
        ledcAttachPin(buzzer, channel);
    */




  //--******************************************************************************
  // Increase internal buffer size after inital creation.
  tb.setBufferSize(MAX_MESSAGE_SIZE); //MAX_MESSAGE_SIZE
  //--******************************************************************************






 
    //--******************************************************************************




    //--******************************************************************************






    //--******************************************************************************
        IF_DEBUG_PRINTLN(F("-------------------------------------------------------------"));

        // Variablen für die Prozentsätze
       
        #ifdef IF_DEBUG
        float freePercentageHeap;
        float freePercentageNVS;
        float freePercentageRAM;
        float freePercentageSPIFFS;
        float freePercentageFlash;

        #endif
        float usedPercentageHeap;
        float usedPercentageRAM;
        float usedPercentageNVS;
        float usedPercentageSPIFFS;
        float usedPercentageFlash;
        


        
        // ESP32 Heap-Speicher
        size_t totalHeap = ESP.getHeapSize();
        size_t freeHeap = ESP.getFreeHeap();
        size_t usedHeap = totalHeap - freeHeap;
       
        usedPercentageHeap = (float)usedHeap / totalHeap * 100;
        #ifdef IF_DEBUG
        freePercentageHeap = (float)freeHeap / totalHeap * 100;
        #endif

        IF_DEBUG_PRINT(F("Gesamt ESP32 Heap-Speicher: "));
        IF_DEBUG_PRINT(totalHeap);
        IF_DEBUG_PRINTLN(F(" Bytes"));

        IF_DEBUG_PRINT(F("Verwendeter Heap-Speicher: "));
        IF_DEBUG_PRINT(usedHeap);
        IF_DEBUG_PRINT(F(" Bytes ("));
        IF_DEBUG_PRINT(usedPercentageHeap);
        IF_DEBUG_PRINTLN(F(" %)"));

        IF_DEBUG_PRINT(F("Freier Heap-Speicher: "));
        IF_DEBUG_PRINT(freeHeap);
        IF_DEBUG_PRINT(F(" Bytes ("));
        IF_DEBUG_PRINT(freePercentageHeap);
        IF_DEBUG_PRINTLN(F(" %)"));

        IF_DEBUG_PRINTLN(F("-------------------------------------------------------------"));

        // ESP32 RAM-Speicher
        
        size_t totalRAM = ESP.getHeapSize(); // Gesamtgröße des RAM
        size_t freeRAM = ESP.getFreeHeap(); // Freier RAM
        size_t usedRAM = totalRAM - freeRAM; // Verwendeter RAM
        
        usedPercentageRAM = (float)usedRAM / totalRAM * 100;
        #ifdef IF_DEBUG
        freePercentageRAM = (float)freeRAM / totalRAM * 100;
        #endif

        IF_DEBUG_PRINT(F("Gesamt ESP32 RAM-Speicher: "));
        IF_DEBUG_PRINT(totalRAM);
        IF_DEBUG_PRINTLN(F(" Bytes"));

        IF_DEBUG_PRINT(F("Verwendeter RAM-Speicher: "));
        IF_DEBUG_PRINT(usedRAM);
        IF_DEBUG_PRINT(F(" Bytes ("));
        IF_DEBUG_PRINT(usedPercentageRAM);
        IF_DEBUG_PRINTLN(F(" %)"));

        IF_DEBUG_PRINT(F("Freier RAM-Speicher: "));
        IF_DEBUG_PRINT(freeRAM);
        IF_DEBUG_PRINT(F(" Bytes ("));
        IF_DEBUG_PRINT(freePercentageRAM);
        IF_DEBUG_PRINTLN(F(" %)"));
        IF_DEBUG_PRINTLN(F("-------------------------------------------------------------"));

        // Flash-Speicher
        //#ifdef IF_Debug
        size_t totalFlash = ESP.getFlashChipSize();
        //#endif
        size_t usedFlash = ESP.getSketchSize();
        #ifdef IF_DEBUG
        size_t freeFlash = totalFlash - usedFlash;
        #endif


        usedPercentageFlash = (float)usedFlash / totalFlash * 100;
        #ifdef IF_DEBUG     
        freePercentageFlash = (float)freeFlash / totalFlash * 100;
        #endif

        IF_DEBUG_PRINT(F("Gesamt ESP32 Flash-Speicher: "));
        IF_DEBUG_PRINT(totalFlash);
        IF_DEBUG_PRINTLN(F(" Bytes"));

        IF_DEBUG_PRINT(F("Verwendeter Flash-Speicher: "));
        IF_DEBUG_PRINT(usedFlash);
        IF_DEBUG_PRINT(F(" Bytes ("));
        IF_DEBUG_PRINT(usedPercentageFlash);
        IF_DEBUG_PRINTLN(F(" %)"));

        IF_DEBUG_PRINT(F("Freier Flash-Speicher: "));
        IF_DEBUG_PRINT(freeFlash);
        IF_DEBUG_PRINT(F(" Bytes ("));
        IF_DEBUG_PRINT(freePercentageFlash);
        IF_DEBUG_PRINTLN(F(" %)"));
        IF_DEBUG_PRINTLN(F("-------------------------------------------------------------"));


   

   
   
    esp_err_t errf = nvs_flash_init();
    if (errf == ESP_ERR_NVS_NO_FREE_PAGES || errf == ESP_ERR_NVS_NEW_VERSION_FOUND) {
        // NVS-Partition ist beschädigt oder eine neue Version wurde gefunden
        //ESP_ERROR_CHECK(nvs_flash_erase());
        //ret = nvs_flash_init();
        //nvs_flash_init();
        Serial.println(F("NVS-Partition ist beschädigt oder eine neue Version wurde gefunden. Daten könnten verloren gehen."));

    } else {
        //ESP_ERROR_CHECK(ret);
        //Serial.println(F("NVS-Partition OK."));
        NVS_DEBUG_PRINTLN(F("NVS-Partition OK."));
    }

    
    nvs_stats_t nvs_stats;
    nvs_get_stats(NULL, &nvs_stats);
    usedPercentageNVS = (float)nvs_stats.used_entries / nvs_stats.total_entries * 100;

    #ifdef IF_DEBUG
    freePercentageNVS = (float)nvs_stats.free_entries / nvs_stats.total_entries * 100;
    
    #endif


      IF_DEBUG_PRINT(F("Gesamter NVS-Speicher: "));
      IF_DEBUG_PRINT(nvs_stats.total_entries);
      IF_DEBUG_PRINTLN(F(" entries"));

      IF_DEBUG_PRINT(F("Freier NVS-Speicher: "));
      IF_DEBUG_PRINT(nvs_stats.free_entries);
      IF_DEBUG_PRINT(F(" entries ("));
      IF_DEBUG_PRINT(freePercentageNVS);
      IF_DEBUG_PRINTLN(F(" %)"));

      IF_DEBUG_PRINT(F("Verwendeter NVS-Speicher: "));
      IF_DEBUG_PRINT(nvs_stats.used_entries);
      IF_DEBUG_PRINT(F(" entries ("));
      IF_DEBUG_PRINT(usedPercentageNVS);
      IF_DEBUG_PRINTLN(F(" %)"));
      IF_DEBUG_PRINTLN(F("-------------------------------------------------------------"));

      // SPIFFS Speicher

      size_t totalBytes = SPIFFS.totalBytes();
      size_t usedBytes = SPIFFS.usedBytes();
      #ifdef IF_DEBUG
      size_t freeBytes = totalBytes - usedBytes;
      #endif

      usedPercentageSPIFFS = (float)usedBytes / totalBytes * 100;
      #ifdef IF_DEBUG
      freePercentageSPIFFS = (float)freeBytes / totalBytes * 100;
      #endif



      IF_DEBUG_PRINT(F("Gesamter SPIFFS-Speicher: "));
      IF_DEBUG_PRINT(totalBytes);
      IF_DEBUG_PRINTLN(F(" Bytes"));

      IF_DEBUG_PRINT(F("Verwendeter SPIFFS-Speicher: "));
      IF_DEBUG_PRINT(usedBytes);
      IF_DEBUG_PRINT(F(" Bytes ("));
      IF_DEBUG_PRINT(usedPercentageSPIFFS);
      IF_DEBUG_PRINTLN(F(" %)"));

      IF_DEBUG_PRINT(F("Freier SPIFFS-Speicher: "));
      IF_DEBUG_PRINT(freeBytes);
      IF_DEBUG_PRINT(F(" Bytes ("));
      IF_DEBUG_PRINT(freePercentageSPIFFS);
      IF_DEBUG_PRINTLN(F(" %)"));
      IF_DEBUG_PRINTLN(F("-------------------------------------------------------------"));
      IF_DEBUG_PRINTLN(F(" "));


    // Gruppierte Anzeige der Speicherinformationen
    printProgressBar(usedPercentageHeap, "Heap", usedHeap, totalHeap);
    printProgressBar(usedPercentageRAM, "RAM", usedRAM, totalRAM);
    printProgressBar(usedPercentageFlash, "Flash", usedFlash, totalFlash);
    printProgressBar(usedPercentageNVS, "NVS", nvs_stats.used_entries, nvs_stats.total_entries);
    printProgressBar(usedPercentageSPIFFS, "SPIFFS", usedBytes, totalBytes);

    Serial.println("  ");
    IF_DEBUG_PRINTLN(F("-------------------------------------------------------------"));




   //printf("[AP] aFREE HEAP: now: %u, contiguous: %u, lowest: %u\n",xPortGetFreeHeapSize(),heap_caps_get_largest_free_block(MALLOC_CAP_DEFAULT),xPortGetMinimumEverFreeHeapSize());
   

  //******************************************************************************
  //                            Start  WIFI                                     *
  //****************************************************************************** 
     while (!Serial) {}
     Serial.println(F("--------------------[ WIFI ]----------------------"));

     //printf("[AP] FREE RAMa: now: %.3f MB\n", getUsedRAMMB());  //11


        // WiFi-Konfiguration anpassen
        /*
        wifi_init_config_t cfg = WIFI_INIT_CONFIG_DEFAULT();
        cfg.static_rx_buf_num = 2; // Statische RX-Puffer
        cfg.dynamic_rx_buf_num = 10; // Dynamische RX-Puffer
        cfg.static_tx_buf_num = 2; // Statische TX-Puffer
        cfg.dynamic_tx_buf_num = 10; // Dynamische TX-Puffer
        esp_wifi_init(&cfg);
        */

      WiFi.mode(WIFI_STA);  
      WiFi.setHostname(device_id_c); 
      WiFi.disconnect();
      InitWiFi();  
      //printf("[AP] FREE RAMe: now: %.3f MB\n", getUsedRAMMB());   //15 
      
      //  esp_wifi_set_ps(WIFI_PS_NONE); // WLAN-Stromsparmodus deaktivieren

        //if(!MDNS.begin(hostname.c_str())) {
        //Serial.println("Error starting mDNS");
        //}

      


        //read_all_logs();

  //printf("[AP] bFREE HEAP: now: %u, contiguous: %u, lowest: %u\n",xPortGetFreeHeapSize(),heap_caps_get_largest_free_block(MALLOC_CAP_DEFAULT),xPortGetMinimumEverFreeHeapSize());
   
        if (loggingEnabled) {
        things_list_t_16 = "------------------------------------------------------"; 
        write_to_log(things_list_t_16);
        }


  //******************************************************************************
  //                            Start  VARS                                      *
  //****************************************************************************** 
     while (!Serial) {}
     Serial.println(F("--------------------[ VARS ]----------------------"));

     //printf("[AP] FREE RAM: now: %.2f MB\n", getUsedRAMMB());
     //Serial.println("[IF] VARS OK");


    //---------------------------------------
    if(ee_provision == 0){
       
        provisionResponseProcessed = false; 
        provisionRequestSent = false;

        if(strcmp(device_id_c, "00000000") == 0){
            while (!Serial) {}
            Serial.println(F("[SA] Generate ID: "));

            generate_device_id();


        }

    }else{
      provisionResponseProcessed = true; 
      provisionRequestSent = true;
    }




        // Gerätedaten aus dem char-Array in das char-Array DEVICE_NAME kopieren
        strcpy(DEVICE_NAME, device_id_c);

        p_APname_p = "Radon Home Tracer";
        if (strcmp(device_id_c, "00000000") != 0) {
            p_APname_p += " ";
            p_APname_p += String(device_id_c);
        }


     
          // Kopiere die Daten aus dem PROGMEM in den RAM
          #if defined(g_PROGMEM_aktiv)
              strcpy_P(ram_p_APname_c, p_APname_c);
              strcpy_P(ram_device_id, device_id);
              p_APname_p.toCharArray(ram_p_APname_c, APname_LEN);
          #else
              p_APname_p.toCharArray(p_APname_c, APname_LEN);
          #endif

        #ifdef ea_webserver
        #ifdef j_2_webserver
        if(disable_server >= 1 && TB_currFwVersion == TB_newFwVersion) {
        if (loggingEnabled) {
        things_list_t_16 = "          [IF] Device ID: " + p_APname_p;
        write_to_log(things_list_t_16);
        }
        }
        #endif
        #endif

    //TB#*****
    previous_processing_time = millis();
    //TB#*****



     //while (!Serial) {}
     //Serial.println("[IF] B O O T...");

  



  //****************************************************************************** 



      if((TB_currFwVersion == TB_newFwVersion && verzoegerung_fw_update == 0) || disable_server == 0){ 
       
        g_low_data = true;
        //Serial.println("[IF] g_low_datae");

  
      }else{  
                   
         g_low_data = false;
        //Serial.println("[IF] g_low_datae");

      }  

      esp_task_wdt_reset(); 



      Serial.print(F("[SA] AP Name: "));
      Serial.println(p_APname_p);
      Serial.println(F("  --------------------------------- "));
      Serial.println(F(" --------                    -------"));
      Serial.print(F("-------        "));
      Serial.print(device_id_c);
      Serial.println(F("        -----"));
      Serial.println(F(" --------                    -------"));
      Serial.println(F("  --------------------------------- "));


          
    
     
    
    //Serial.print("[IF] CURRENT FIRMWARE VERSION: ");Serial.println(CURRENT_FIRMWARE_VERSION);  



          read_SSID_String = String(WiFi.SSID()); //String 
          
        Serial.print(F("[IF] Connected to: "));
        Serial.println(read_SSID_String);

        Serial.print(F("[IF] IP: "));
        Serial.println(WiFi.localIP());

        Serial.print(F("[IF] Installierte FW: "));
        Serial.println(TB_currFwVersion); // CURRENT_FIRMWARE_VERSION aktuall Get_Firmware_Version()

        //Serial.print("[IF] Neue FW in Cloud: "); Serial.println(TB_newFwVersion); // new
                    
        //Serial.print("[IF] Neue FW in Cloud: ");Serial.println(TB_newFwVersion); // new 
        esp_task_wdt_reset(); 

         if(WiFi_status != WL_CONNECTED){
                TB_newFwVersion = TB_currFwVersion;
                g_set_new_FW = false;
                g_set_new_FW_time = 0;
                gFW_Update_start = 0;  // 1= neue FW verfügbar
                disable_server = 1;
                //Preferences preferences;
                //preferences.begin("eenvs", false);                         //Ordner eenvs anlegen/verwenden
                //preferences.putUInt("fw_s_upd", gFW_Update_start);    //  0=Standard  aus // 1= neue FW verfügbar
               
               verzoegerung_fw_update = 0;
               Preferences preferences;
               preferences.begin("eenvs", false); // Ordner eenvs anlegen/verwenden
               preferences.putUChar("fw_verz_update", verzoegerung_fw_update);    //  0=Standard  aus 
                


        }


        if(TB_currFwVersion != TB_newFwVersion || verzoegerung_fw_update == 2){
                Serial.println(F("[IF] A new Firmware is available.."));

                g_set_new_FW = true;
                g_set_new_FW_time = 0;
                gFW_Update_start = 1;  // 1= neue FW verfügbar
                fw_state_i = "INITIATED";
                Preferences preferences;
                preferences.begin("eenvs", false);                         //Ordner eenvs anlegen/verwenden
                preferences.putUChar("fw_s_upd", gFW_Update_start);    //  0=Standard  aus // 1= neue FW verfügbar
         
            if(disable_server >= 1){
                Serial.println(F("[IF] Disable Webserver")); 
                #ifdef ea_webserver
                if(disable_server >= 1) { 
                    if(webserver_aktiviert == 1){
                      server3.stop();
                    }
                }
                #endif
                disable_server = 0; 
                preferences.begin("eenvs", false);                         //Ordner eenvs anlegen/verwenden
                preferences.putUChar("g_server", disable_server);    //  1=Standard   AN 

            }
        
        }else{

            fw_state_i = "UPDATED";
            if(disable_server == 0){
                Serial.println(F("[IF] Enable Webserver")); 
                disable_server = 1; 
                preferences.begin("eenvs", false);                         //Ordner eenvs anlegen/verwenden
                preferences.putUChar("g_server", disable_server);    //  1=Standard   AN 
            }

        }


      

      if(TB_currFwVersion == TB_newFwVersion && verzoegerung_fw_update == 0){ 
        // Init and get the time
        // Define NTP Client to get time

  
        //timeClient.setUpdateInterval(60000);


  
        #ifndef myNTP
          configTzTime(g_u_timezone_ist.c_str(), g_u_ntp3_ist, g_u_ntp2_ist, g_u_ntp1_ist);
        #else
          configTzTime(g_u_timezone_ist.c_str(), ntpServerIP);
        #endif
          
          //Serial.printf("[TM] ForceUpdate, timeZone: %s, server1: %s, server2: %s, server3: %s\n", g_u_timezone_ist.c_str(), g_u_ntp1_ist.c_str(), g_u_ntp2_ist.c_str(), g_u_ntp3_ist.c_str());
         

        timeClient.begin();
        //startNTPServer(g_u_ntp3_ist);
        #ifdef ntp_2_3
        timeClient2.begin();
        timeClient3.begin();
        #endif


        Serial.println(F("--------------------[ Time ]----------------------"));
        //printf("[AP] FREE RAM: now: %.2f MB\n", getUsedRAMMB());
        //if(update_rtc_ready == 0){ 
          //Serial.println("call_time_set_g 3");
          call_time_set_g(); 

          //setTime(2021,10,31,0,59,50,0);    // Set it to 1 minute before daylight savings comes in.


          //printLocalTime();
          printLocalEpoch();

        Serial.println(F("------------------------"));


      }else{   //disable_server
          
         Serial.println(F("[IF] ------------> disable Time"));
         timeClient.begin();  // doch aktivieren

      }  
      esp_task_wdt_reset(); 



          //Serial.println(F("Start..."));
          fw_myString = TB_currFwVersion;
          char zeile[10];
          snprintf( zeile, sizeof(zeile), "%s", fw_myString.c_str() );
          snprintf( fw_daten[0], sizeof(fw_daten[0]), "%s", strtok(zeile, ".") );
          snprintf( fw_daten[1], sizeof(fw_daten[1]), "%s", strtok(NULL, ".") );
          snprintf( fw_daten[2], sizeof(fw_daten[2]), "%s", strtok(NULL, ".") );

             fw_00 = atoi(fw_daten[0]); 
             fw_01 = atoi(fw_daten[1]); 
             fw_02 = atoi(fw_daten[2]); 


            g_view_fw = true;
            time_view_fw = 2;








                  //Serial.println("Read graph start");
             #ifdef ea_webserver     
             #ifdef j_2_webserver
            
              if(disable_server >= 1 && TB_currFwVersion == TB_newFwVersion && verzoegerung_fw_update == 0) {
               
                if(webserver_aktiviert == 1){ 

            
                        
                  strcpy(dgrxx_s, "dgr00");
                  datei_r_graph(dgrxx_s);
                  //chartime00 = chartemp;
                  strcpy(chartime00, chartemp);

                  strcpy(dgrxx_s, "dgr01a");
                  datei_r_graph(dgrxx_s);
                  //chartime01a = chartemp;
                  strcpy(chartime01a, chartemp);

                  strcpy(dgrxx_s, "dgr02b");
                  datei_r_graph(dgrxx_s);
                  //chartime02b = chartemp;
                  strcpy(chartime02b, chartemp);

                  strcpy(dgrxx_s, "dgr04");
                  datei_r_graph(dgrxx_s);
                  //chartime04 = chartemp;
                  strcpy(chartime04, chartemp);

                  strcpy(dgrxx_s, "dgr05a");
                  datei_r_graph(dgrxx_s);
                  //chartime05a = chartemp;
                  strcpy(chartime05a, chartemp);

                  strcpy(dgrxx_s, "dgr06b");
                  datei_r_graph(dgrxx_s);
                  //chartime06b = chartemp;
                  strcpy(chartime06b, chartemp);

                  strcpy(dgrxx_s, "dgr08a");
                  datei_r_graph(dgrxx_s);
                  //chartime08a = chartemp;
                  strcpy(chartime08a, chartemp);

                  strcpy(dgrxx_s, "dgr09a");
                  datei_r_graph(dgrxx_s);
                  //chartime09a = chartemp;
                  strcpy(chartime09a, chartemp);

                  strcpy(dgrxx_s, "dgr10b");
                  datei_r_graph(dgrxx_s);
                  //chartime10b = chartemp;
                  strcpy(chartime10b, chartemp);

                  strcpy(dgrxx_s, "dgr12");
                  datei_r_graph(dgrxx_s);
                  //chartime12 = chartemp;
                  strcpy(chartime12, chartemp);

                  strcpy(dgrxx_s, "dgr13b");
                  datei_r_graph(dgrxx_s);
                  //chartime13a = chartemp;
                  strcpy(chartime13a, chartemp);

                  strcpy(dgrxx_s, "dgr14b");
                  datei_r_graph(dgrxx_s);
                  //chartime14b = chartemp;
                  strcpy(chartime14b, chartemp);

                  strcpy(dgrxx_s, "dgr16");
                  datei_r_graph(dgrxx_s);
                  //chartime16 = chartemp;
                  strcpy(chartime16, chartemp);

                              
    

                }
           
              }else{   //disable_server
          
                  Serial.println(F("[IF] ------------> disable Data"));

              }  
                  //Serial.println("Read graph end");
              #endif
              #endif







  //--******************************************************************************
  //                               ArduinoOTA                                    *
  //--****************************************************************************** 


      /*
      // Initialisiere OTA
      ArduinoOTA.onStart( {
        String type;
        if (ArduinoOTA.getCommand() == U_FLASH) {
          type = "sketch";
        } else { // U_SPIFFS
          type = "filesystem";
        }
        Serial.println("Start updating " + type);
      });

      ArduinoOTA.onEnd( {
        Serial.println("\nEnd");
      });

      ArduinoOTA.onProgress( {
        Serial.printf("Progress: %u%%\r", (progress / (total / 100)));
      });

      ArduinoOTA.onError( {
        Serial.printf("Error[%u]: ", error);
        if (error == OTA_AUTH_ERROR) {
          Serial.println("Auth Failed");
        } else if (error == OTA_BEGIN_ERROR) {
          Serial.println("Begin Failed");
        } else if (error == OTA_CONNECT_ERROR) {
          Serial.println("Connect Failed");
        } else if (error == OTA_RECEIVE_ERROR) {
          Serial.println("Receive Failed");
        } else if (error == OTA_END_ERROR) {
          Serial.println("End Failed");
        }
      });

      ArduinoOTA.begin();
  */
 
  //--****************************************************************************** 










  //******************************************************************************
  //                           Start  WebServer                                  *
  //****************************************************************************** 
   Serial.println(F("------------------[ WebServer ]--------------------"));
   //Serial.println("[IF] Enable WebServer");
  // printf("[AP] FREE RAM: now: %.2f MB\n", getUsedRAMMB());
    #ifdef ea_webserver
    #ifdef j_2_webserver

    if(webserver_aktiviert == 1 && knx_program_mode == 0){ 

      if(disable_server >= 1 && TB_currFwVersion == TB_newFwVersion && verzoegerung_fw_update == 0) {

          
          #ifndef Firmware_backup   
          server3.on("/json", HTTP_GET, []() {

                //Json
                // Kopiere p_date_YYMMDD in things_list_web
                strcpy(things_list_web, p_date_YYMMDD);
                // Füge ein Leerzeichen hinzu
                strcat(things_list_web, " ");
                // Füge formattedDateHH hinzu
                strcat(things_list_web, formattedDateHH);
                // Füge ":00" hinzu
                strcat(things_list_web, ":00");
            
            
            String json = "{";
            json += "\"date\":"; json += things_list_web; 
            json += ", \"radon\":";  json +=  String(radon_1h_ist); 
            json += ", \"24h\":";  json +=  String(radon_mittelwert_24h); 
            json += ", \"long\":";  json +=  String(radon_mittelwert_long); 
            json += ", \"time\":";  json +=  String(mb_radon_save_eintrarge); 
            json += "}";
            //Serial.println(json);

              int str_len = json.length() + 1; 
              char buf[1024];
              json.toCharArray(buf, str_len);
              //Serial.println(str_len);   
              server3.send_P(200, "text/json", buf,str_len);
              json = String();

          });


 
          server3.on("/xml", HTTP_GET, []() {

                //Json
                // Kopiere p_date_YYMMDD in things_list_web
                strcpy(things_list_web, p_date_YYMMDD);
                // Füge ein Leerzeichen hinzu
                strcat(things_list_web, " ");
                // Füge formattedDateHH hinzu
                strcat(things_list_web, formattedDateHH);
                // Füge ":00" hinzu
                strcat(things_list_web, ":00");
           
            // XML-Zeichenkette aufbauen
            String xml = "<?xml version=\"1.0\" encoding=\"UTF-8\"?>";
            xml += "<data>";
            xml += "<date>" + String(things_list_web) + "</date>";
            xml += "<radon>" + String(radon_1h_ist) + "</radon>";
            xml += "<radon_24h>" + String(radon_mittelwert_24h) + "</radon_24h>";
            xml += "<radon_long>" + String(radon_mittelwert_long) + "</radon_long>";
            xml += "<time>" + String(mb_radon_save_eintrarge) + "</time>";
            xml += "</data>";

            //Serial.println(xml);

            int str_len = xml.length() + 1;
            char buf[1024];
            xml.toCharArray(buf, str_len);
            //Serial.println(str_len);
            server3.send(200, "text/xml", buf);
            xml = String();

          });
          #endif


          server3.on("/serverStatus", HTTP_GET, []() {
              bool serverRunning = true; // Hier logik um den Serverstatus zu prüfen
              String jsonResponse = "{\"serverRunning\": " + String(serverRunning ? "true" : "false") + "}";
              server3.send(200, "application/json", jsonResponse);
          });





            // Definiere Routen für die Willkommensseite
            server3.on("/", handleRoot);
            server3.on("/restart", HTTP_POST, handleRestart);
            server3.on("/restarting", handleRestarting);
            
            // Falls die URL "/restart" direkt ohne POST-Aufruf aufgerufen wird
            server3.onNotFound([]() {
                if (server3.uri() == "/restart") {
                    server3.sendHeader("Location", "/", true);
                    server3.send(302, "text/plain", "");
                } else {
                    server3.send(404, "text/plain", "Not found");
                }
            });
            
            server3.on("/index", handle_root2);
            server3.on("/index.htm", handle_root2);
            server3.on("/index.html", handle_root2);

          
          
            #ifndef Firmware_backup
            server3.on("/chart", handle_combined_chart);

            server3.on("/knx", handle_knx);
            server3.on("/executeFunction", handleExecuteFunction);

            server3.on("/cloud", handle_cloud);
            server3.on("/mqtt", handle_mqtt);
            server3.on("/modbus", handle_modbus);
            server3.on("/ble", HTTP_GET, handle_ble_info);

            #endif
            



            server3.on("/esp32", handle_esp32_info);


           server3.on("/user", handle_user);


            #ifndef Firmware_backup
           
            server3.on("/time", handle_time);
            

            server3.on("/favicon-16x16.png", handle_favicon);

            server3.on("/style.css", handle_css);
            server3.on("/trac2.js", handle_js);

            server3.on("/sha256.js", handle_256_js); 

            server3.on("/styles.css", handle_cssg);
            server3.on("/jsthree.js", handle_jsg);
            server3.on("/zonehead.js", handle_zonehead);
            server3.on("/chartdiv.js", handle_chartdiv);
            server3.on("/tracg.js", handle_tracg);
            server3.on("/highcharts.js", HTTP_GET, handleHighchartsJS);
            #endif


            // Definiere den Endpunkt /getLEDStatus
            #ifndef Firmware_backup  
            server3.on("/getLEDStatus", HTTP_GET, []() {
              int currentPinStatew = digitalRead(20);
              String jsonResponse = "{\"ledStatus\":" + String(currentPinStatew) + "}";
              server3.send(200, "application/json", jsonResponse);
            });
            #endif




          #ifndef Firmware_backup   
          server3.on("/sensor", handle_sensor);
          #endif

          /*
          server3.on("/segment-display.js", HTTP_GET, []() {
              File file = SPIFFS.open("/segment-display.js", "r");
              if (!file) {
                  server3.send(404, "text/plain", "File not found");
                  return;
              }
              server3.streamFile(file, "application/javascript");
              file.close();
          });
          */
         #ifndef Firmware_backup
         server3.on("/segment-display.js", HTTP_GET, handleSegmentDisplayJS);

         server3.on("/jquery.min.js", HTTP_GET, handlejquery_min_js);
         #endif
         

          /*
          server3.on("/Sensor_gruen.jpg", HTTP_GET, []() {
              File file = SPIFFS.open("/Sensor_gruen.jpg", "r");
              if (!file) {
                  esp_task_wdt_reset(); // WDT zurücksetzen, bevor eine 404-Antwort gesendet wird
                  server3.send(404, "text/plain", "File not found");
                  return;
              }

              const size_t bufferSize = 512; // Puffergröße für das Streaming
              uint8_t buffer[bufferSize]; // Puffer zum Speichern der Daten
              unsigned long startMillis = millis(); // Startzeit des Transfers
              const unsigned long timeout = 5000; // Timeout in Millisekunden (z.B. 5 Sekunden)

              while (file.available()) {
                  size_t bytesRead = file.read(buffer, bufferSize); // Lese Daten in den Puffer
                  esp_task_wdt_reset(); // WDT zurücksetzen
                  if (bytesRead > 0) {
                      server3.sendContent((const char*)buffer, bytesRead); // Sende die gelesenen Daten
                  }

                  // Überprüfe, ob die Übertragungszeit das Timeout überschreitet
                  if (millis() - startMillis > timeout) {
                      file.close();
                      esp_task_wdt_reset(); // WDT zurücksetzen, nachdem die Datei geschlossen wurde
                      server3.send(500, "text/plain", "Transfer timeout");
                      return;
                  }
              }

              file.close();
              esp_task_wdt_reset(); // WDT zurücksetzen, nachdem die Datei geschlossen wurde
          });
           */
          // Definiert den HTTP-Handler für das Bild
          /*
          server3.on("/Sensor_gruen.jpg", HTTP_GET, []() {
              esp_task_wdt_reset(); // WDT zurücksetzen, bevor eine Antwort gesendet wird

              // Bild direkt aus dem Flash-Speicher senden
              server3.sendHeader("Content-Type", "image/jpeg");
              server3.sendHeader("Content-Length", String(Sensor_gruen_jpg_len));
              server3.send_P(200, "image/jpeg", (const char*)Sensor_gruen_jpg, Sensor_gruen_jpg_len);

              esp_task_wdt_reset(); // WDT zurücksetzen, nachdem die Antwort gesendet wurde
          });
          */
         #ifndef Firmware_backup
          server3.on("/Sensor_gruen.jpg", HTTP_GET, []() {
              esp_task_wdt_reset(); // WDT zurücksetzen, bevor eine Antwort gesendet wird

              const size_t chunkSize = 1024; // Definiere die Größe der Datenblöcke
              size_t totalSize = Sensor_gruen_jpg_len;
              size_t bytesSent = 0;

              server3.setContentLength(totalSize); // Setze die Gesamtgröße des Inhalts
              server3.sendHeader("Content-Type", "image/jpeg");
              server3.send(200);

              while (bytesSent < totalSize) {
                  size_t remainingBytes = totalSize - bytesSent;
                  size_t currentChunkSize = remainingBytes < chunkSize ? remainingBytes : chunkSize;

                  // Sende den aktuellen Datenblock
                  server3.client().write((const char*)Sensor_gruen_jpg + bytesSent, currentChunkSize);
                  bytesSent += currentChunkSize;

                  // Watchdog Timer zurücksetzen
                  esp_task_wdt_reset();
              }

              esp_task_wdt_reset(); // WDT zurücksetzen, nachdem die Antwort gesendet wurde
          });
          #endif



          /*
          server3.on("/Sensor_rot.jpg", HTTP_GET, []() {
              File file = SPIFFS.open("/Sensor_rot.jpg", "r");
              if (!file) {
                  esp_task_wdt_reset(); // WDT zurücksetzen, bevor eine 404-Antwort gesendet wird
                  server3.send(404, "text/plain", "File not found");
                  return;
              }

              const size_t bufferSize = 512; // Puffergröße für das Streaming
              uint8_t buffer[bufferSize]; // Puffer zum Speichern der Daten
              unsigned long startMillis = millis(); // Startzeit des Transfers
              const unsigned long timeout = 5000; // Timeout in Millisekunden (z.B. 5 Sekunden)

              while (file.available()) {
                  size_t bytesRead = file.read(buffer, bufferSize); // Lese Daten in den Puffer
                  esp_task_wdt_reset(); // WDT zurücksetzen
                  if (bytesRead > 0) {
                      server3.sendContent((const char*)buffer, bytesRead); // Sende die gelesenen Daten
                  }

                  // Überprüfe, ob die Übertragungszeit das Timeout überschreitet
                  if (millis() - startMillis > timeout) {
                      file.close();
                      esp_task_wdt_reset(); // WDT zurücksetzen, nachdem die Datei geschlossen wurde
                      server3.send(500, "text/plain", "Transfer timeout");
                      return;
                  }
              }

              file.close();
              esp_task_wdt_reset(); // WDT zurücksetzen, nachdem die Datei geschlossen wurde
          });
           */
          #ifndef Firmware_backup
          server3.on("/Sensor_rot.jpg", HTTP_GET, []() {
              esp_task_wdt_reset(); // WDT zurücksetzen, bevor eine Antwort gesendet wird

              // Bild direkt aus dem Flash-Speicher senden
              server3.sendHeader("Content-Type", "image/jpeg");
              server3.sendHeader("Content-Length", String(Sensor_rot_jpg_len));
              server3.send_P(200, "image/jpeg", (const char*)Sensor_rot_jpg, Sensor_rot_jpg_len);

              esp_task_wdt_reset(); // WDT zurücksetzen, nachdem die Antwort gesendet wurde
          });
          #endif

          
          /*
          server3.on("/Sensor_orange.jpg", HTTP_GET, []() {
              File file = SPIFFS.open("/Sensor_orange.jpg", "r");
              if (!file) {
                  esp_task_wdt_reset(); // WDT zurücksetzen, bevor eine 404-Antwort gesendet wird
                  server3.send(404, "text/plain", "File not found");
                  return;
              }

              const size_t bufferSize = 512; // Puffergröße für das Streaming
              uint8_t buffer[bufferSize]; // Puffer zum Speichern der Daten
              unsigned long startMillis = millis(); // Startzeit des Transfers
              const unsigned long timeout = 5000; // Timeout in Millisekunden (z.B. 5 Sekunden)

              while (file.available()) {
                  size_t bytesRead = file.read(buffer, bufferSize); // Lese Daten in den Puffer
                  esp_task_wdt_reset(); // WDT zurücksetzen
                  if (bytesRead > 0) {
                      server3.sendContent((const char*)buffer, bytesRead); // Sende die gelesenen Daten
                  }

                  // Überprüfe, ob die Übertragungszeit das Timeout überschreitet
                  if (millis() - startMillis > timeout) {
                      file.close();
                      esp_task_wdt_reset(); // WDT zurücksetzen, nachdem die Datei geschlossen wurde
                      server3.send(500, "text/plain", "Transfer timeout");
                      return;
                  }
              }

              file.close();
              esp_task_wdt_reset(); // WDT zurücksetzen, nachdem die Datei geschlossen wurde
          });
          */
         #ifndef Firmware_backup
          server3.on("/Sensor_orange.jpg", HTTP_GET, []() {
              esp_task_wdt_reset(); // WDT zurücksetzen, bevor eine Antwort gesendet wird

              // Bild direkt aus dem Flash-Speicher senden
              server3.sendHeader("Content-Type", "image/jpeg");
              server3.sendHeader("Content-Length", String(Sensor_orange_jpg_len));
              server3.send_P(200, "image/jpeg", (const char*)Sensor_orange_jpg, Sensor_orange_jpg_len);

              esp_task_wdt_reset(); // WDT zurücksetzen, nachdem die Antwort gesendet wurde
          });
          #endif




          /*
          server3.on("/Sensor_weiss.jpg", HTTP_GET, []() {
              File file = SPIFFS.open("/Sensor_weiss.jpg", "r");
              if (!file) {
                  esp_task_wdt_reset(); // WDT zurücksetzen, bevor eine 404-Antwort gesendet wird
                  server3.send(404, "text/plain", "File not found");
                  return;
              }

              const size_t bufferSize = 512; // Puffergröße für das Streaming
              uint8_t buffer[bufferSize]; // Puffer zum Speichern der Daten
              unsigned long startMillis = millis(); // Startzeit des Transfers
              const unsigned long timeout = 5000; // Timeout in Millisekunden (z.B. 5 Sekunden)

              while (file.available()) {
                  size_t bytesRead = file.read(buffer, bufferSize); // Lese Daten in den Puffer
                  esp_task_wdt_reset(); // WDT zurücksetzen
                  if (bytesRead > 0) {
                      server3.sendContent((const char*)buffer, bytesRead); // Sende die gelesenen Daten
                  }

                  // Überprüfe, ob die Übertragungszeit das Timeout überschreitet
                  if (millis() - startMillis > timeout) {
                      file.close();
                      esp_task_wdt_reset(); // WDT zurücksetzen, nachdem die Datei geschlossen wurde
                      server3.send(500, "text/plain", "Transfer timeout");
                      return;
                  }
              }

              file.close();
              esp_task_wdt_reset(); // WDT zurücksetzen, nachdem die Datei geschlossen wurde
          });
          */
         #ifndef Firmware_backup
          server3.on("/Sensor_weiss.jpg", HTTP_GET, []() {
              esp_task_wdt_reset(); // WDT zurücksetzen, bevor eine Antwort gesendet wird

              // Bild direkt aus dem Flash-Speicher senden
              server3.sendHeader("Content-Type", "image/jpeg");
              server3.sendHeader("Content-Length", String(Sensor_weiss_jpg_len));
              server3.send_P(200, "image/jpeg", (const char*)Sensor_weiss_jpg, Sensor_weiss_jpg_len);

              esp_task_wdt_reset(); // WDT zurücksetzen, nachdem die Antwort gesendet wurde
          });
          #endif


          /*
          server3.on("/Sensor_grau.jpg", HTTP_GET, []() {
              File file = SPIFFS.open("/Sensor_grau.jpg", "r");
              if (!file) {
                  esp_task_wdt_reset(); // WDT zurücksetzen, bevor eine 404-Antwort gesendet wird
                  server3.send(404, "text/plain", "File not found");
                  return;
              }

              const size_t bufferSize = 512; // Puffergröße für das Streaming
              uint8_t buffer[bufferSize]; // Puffer zum Speichern der Daten
              unsigned long startMillis = millis(); // Startzeit des Transfers
              const unsigned long timeout = 5000; // Timeout in Millisekunden (z.B. 5 Sekunden)

              while (file.available()) {
                  size_t bytesRead = file.read(buffer, bufferSize); // Lese Daten in den Puffer
                  esp_task_wdt_reset(); // WDT zurücksetzen
                  if (bytesRead > 0) {
                      server3.sendContent((const char*)buffer, bytesRead); // Sende die gelesenen Daten
                  }

                  // Überprüfe, ob die Übertragungszeit das Timeout überschreitet
                  if (millis() - startMillis > timeout) {
                      file.close();
                      esp_task_wdt_reset(); // WDT zurücksetzen, nachdem die Datei geschlossen wurde
                      server3.send(500, "text/plain", "Transfer timeout");
                      return;
                  }
              }

              file.close();
              esp_task_wdt_reset(); // WDT zurücksetzen, nachdem die Datei geschlossen wurde
          });
          */
         #ifndef Firmware_backup
          server3.on("/Sensor_grau.jpg", HTTP_GET, []() {
              esp_task_wdt_reset(); // WDT zurücksetzen, bevor eine Antwort gesendet wird

              // Bild direkt aus dem Flash-Speicher senden
              server3.sendHeader("Content-Type", "image/jpeg");
              server3.sendHeader("Content-Length", String(Sensor_grau_jpg_len));
              server3.send_P(200, "image/jpeg", (const char*)Sensor_grau_jpg, Sensor_grau_jpg_len);

              esp_task_wdt_reset(); // WDT zurücksetzen, nachdem die Antwort gesendet wurde
          });
          #endif



       /*
       server3.on("/Sensor_blau.jpg", HTTP_GET, []() {
              File file = SPIFFS.open("/Sensor_blau.jpg", "r");
              if (!file) {
                  esp_task_wdt_reset(); // WDT zurücksetzen, bevor eine 404-Antwort gesendet wird
                  server3.send(404, "text/plain", "File not found");
                  return;
              }

              const size_t bufferSize = 512; // Puffergröße für das Streaming
              uint8_t buffer[bufferSize]; // Puffer zum Speichern der Daten
              unsigned long startMillis = millis(); // Startzeit des Transfers
              const unsigned long timeout = 5000; // Timeout in Millisekunden (z.B. 5 Sekunden)

              while (file.available()) {
                  size_t bytesRead = file.read(buffer, bufferSize); // Lese Daten in den Puffer
                  esp_task_wdt_reset(); // WDT zurücksetzen
                  if (bytesRead > 0) {
                      server3.sendContent((const char*)buffer, bytesRead); // Sende die gelesenen Daten
                  }

                  // Überprüfe, ob die Übertragungszeit das Timeout überschreitet
                  if (millis() - startMillis > timeout) {
                      file.close();
                      esp_task_wdt_reset(); // WDT zurücksetzen, nachdem die Datei geschlossen wurde
                      server3.send(500, "text/plain", "Transfer timeout");
                      return;
                  }
              }

              file.close();
              esp_task_wdt_reset(); // WDT zurücksetzen, nachdem die Datei geschlossen wurde
          });
          */
         #ifndef Firmware_backup
          server3.on("/Sensor_blau.jpg", HTTP_GET, []() {
              esp_task_wdt_reset(); // WDT zurücksetzen, bevor eine Antwort gesendet wird

              // Bild direkt aus dem Flash-Speicher senden
              server3.sendHeader("Content-Type", "image/jpeg");
              server3.sendHeader("Content-Length", String(Sensor_blau_jpg_len));
              server3.send_P(200, "image/jpeg", (const char*)Sensor_blau_jpg, Sensor_blau_jpg_len);

              esp_task_wdt_reset(); // WDT zurücksetzen, nachdem die Antwort gesendet wurde
          });
          #endif


            
            #ifndef Firmware_backup  
            server3.on("/excanvas.js", HTTP_GET, []() {
                File file = SPIFFS.open("/excanvas.js", "r");
                if (!file) {
                    esp_task_wdt_reset(); // WDT zurücksetzen, bevor eine 404-Antwort gesendet wird
                    server3.send(404, "text/plain", "File not found");
                    return;
                }

                const size_t bufferSize = 512; // Puffergröße für das Streaming
                uint8_t buffer[bufferSize]; // Puffer zum Speichern der Daten
                unsigned long startMillis = millis(); // Startzeit des Transfers
                const unsigned long timeout = 5000; // Timeout in Millisekunden (z.B. 5 Sekunden)

                while (file.available()) {
                    size_t bytesRead = file.read(buffer, bufferSize); // Lese Daten in den Puffer
                    esp_task_wdt_reset(); // WDT zurücksetzen
                    if (bytesRead > 0) {
                        server3.sendContent((const char*)buffer, bytesRead); // Sende die gelesenen Daten
                    }

                    // Überprüfe, ob die Übertragungszeit das Timeout überschreitet
                    if (millis() - startMillis > timeout) {
                        file.close();
                        esp_task_wdt_reset(); // WDT zurücksetzen, nachdem die Datei geschlossen wurde
                        server3.send(500, "text/plain", "Transfer timeout");
                        return;
                    }
                }

                file.close();
                esp_task_wdt_reset(); // WDT zurücksetzen, nachdem die Datei geschlossen wurde
            });
            #endif



          // API zum Abrufen des Bildstatus
          #ifndef Firmware_backup  
          server3.on("/imageStatus", HTTP_GET, []() {
              esp_task_wdt_reset();
              String image;
              switch (imageStatus) {
                  case 0:
                      image = "/Sensor_rot.jpg";
                      break;
                  case 1:
                      image = "/Sensor_gruen.jpg";
                      break;
                  case 2:
                      image = "/Sensor_orange.jpg";
                      break;
                  case 3:
                      image = "/Sensor_weiss.jpg";
                      break;
                  case 4:
                      image = "/Sensor_grau.jpg";
                      break;
                  case 5:
                      image = "/Sensor_blau.jpg";
                      break;
                  default:
                      image = "/Sensor_grau.jpg";
                      break;
              }
              server3.send(200, "text/plain", image);
          });

          server3.on("/getTime", HTTP_GET, []() {
              String timeData = String(v_currenthour) + ":" + String(v_currentmin) + ":" + String(v_currentSec);
              server3.send(200, "text/plain", timeData);
          });

          // Füge den neuen Handler für getImageStatus hinzu
          server3.on("/getImageStatus", HTTP_GET, []() {
              server3.send(200, "text/plain", String(imageStatus));
          });
          #endif
                              



        //  deinPasswort2

        server3.on("/checkPasswordSPIFFS", HTTP_POST, []() {
            if (!server3.hasArg("plain")) {
                server3.send(400, "text/plain", "Body not found");
                return;
            }

            // Initialisieren der Preferences
            Preferences preferences;
            preferences.begin("eenvs", false);

            unsigned long currentTime = millis();
            spiffsLockoutTime = preferences.getULong("spiffsLockoutTime", 0);
            spiffsAttempts = preferences.getInt("spiffsAttempts", 0);

            Serial.printf("currentTime: %lu, spiffsLockoutTime: %lu, spiffsAttempts: %d\n", currentTime, spiffsLockoutTime, spiffsAttempts);

            if (spiffsLockoutTime > 0 && currentTime < spiffsLockoutTime) {
                unsigned long remainingTime = (spiffsLockoutTime - currentTime) / 60000; // Restzeit in Minuten
                Serial.printf("Remaining lockout time: %lu minutes\n", remainingTime);
                server3.send(401, "application/json", "{\"success\": false, \"message\": \"Zu viele Fehlversuche. Bitte versuchen Sie es in " + String(remainingTime) + " Minuten erneut.\"}");
                preferences.end();
                return;
            }

            String body = server3.arg("plain");
            DynamicJsonDocument doc(1024);
            deserializeJson(doc, body);

            String password = doc["password"];
            String correctPassword = preferences.getString("password", "deinPasswort");

            if (password != correctPassword) {
                spiffsAttempts++;
                preferences.putInt("spiffsAttempts", spiffsAttempts);
                Serial.printf("Incorrect password attempt %d\n", spiffsAttempts);
                if (spiffsAttempts == 2) {
                    server3.send(401, "application/json", "{\"success\": false, \"message\": \"Noch ein Versuch übrig vor der 15-Minuten-Sperre.\"}");
                } else if (spiffsAttempts >= 3) {
                    spiffsLockoutTime = currentTime + (15 * 60 * 1000); // 15 Minuten in Millisekunden
                    preferences.putULong("spiffsLockoutTime", spiffsLockoutTime);
                    Serial.printf("Lockout activated until: %lu\n", spiffsLockoutTime);
                    server3.send(401, "application/json", "{\"success\": false, \"message\": \"Zu viele Fehlversuche. Sie können es in 15 Minuten erneut versuchen.\"}");
                } else {
                    server3.send(401, "application/json", "{\"success\": false, \"message\": \"Passwort ist falsch.\"}");
                }
            } else {
                // Setze Versuche nur bei erfolgreicher Eingabe zurück
                spiffsAttempts = 0;
                spiffsLockoutTime = 0;
                preferences.putInt("spiffsAttempts", spiffsAttempts);
                preferences.putULong("spiffsLockoutTime", spiffsLockoutTime);
                Serial.println(F("Password correct, attempts reset"));

                server3.send(200, "application/json", "{\"success\": true}");
            }

            // Beenden der Preferences
            preferences.end();
        });





      server3.on("/checkPassword", HTTP_POST, []() {
          if (!server3.hasArg("plain")) {
              server3.send(400, "text/plain", "Body not found");
              return;
          }

          // Initialisieren der Preferences
          Preferences preferences;
          preferences.begin("eenvs", false);

          String body = server3.arg("plain");
          DynamicJsonDocument doc(1024);
          deserializeJson(doc, body);

          String password = doc["password"];
          String correctPassword = preferences.getString("password", "deinPasswort");

          bool success = (password == correctPassword);

          if (success) {
              server3.send(200, "application/json", "{\"success\": true}");
          } else {
              server3.send(401, "application/json", "{\"success\": false, \"message\": \"Passwort ist falsch.\"}");
          }

          // Beenden der Preferences
          preferences.end();
      });





      //  deinPasswort2

      server3.on("/changePassword", HTTP_POST, []() {
          if (!server3.hasArg("plain")) {
              server3.send(400, "text/plain", "Body not found");
              return;
          }

          // Initialisieren der Preferences
          Preferences preferences;
          preferences.begin("eenvs", false);

          unsigned long currentTime = millis();
          spiffsLockoutTime = preferences.getULong("spiffsLockoutTime", 0);
          spiffsAttempts = preferences.getInt("spiffsAttempts", 0);

          Serial.printf("currentTime: %lu, spiffsLockoutTime: %lu, spiffsAttempts: %d\n", currentTime, spiffsLockoutTime, spiffsAttempts);

          if (spiffsLockoutTime > 0 && currentTime < spiffsLockoutTime) {
              unsigned long remainingTime = (spiffsLockoutTime - currentTime) / 60000; // Restzeit in Minuten
              Serial.printf("Remaining lockout time: %lu minutes\n", remainingTime);
              server3.send(401, "application/json", "{\"success\": false, \"message\": \"Zu viele Fehlversuche. Bitte versuchen Sie es in " + String(remainingTime) + " Minuten erneut.\"}");
              preferences.end();
              return;
          }

          String body = server3.arg("plain");
          DynamicJsonDocument doc(1024);
          deserializeJson(doc, body);

          String currentPassword = doc["currentPassword"];
          String newPassword = doc["newPassword"];
          String correctPassword = preferences.getString("password", "deinPasswort");

          if (currentPassword != correctPassword) {
              spiffsAttempts++;
              preferences.putInt("spiffsAttempts", spiffsAttempts);
              Serial.printf("Incorrect password attempt %d\n", spiffsAttempts);
              if (spiffsAttempts == 2) {
                  server3.send(401, "application/json", "{\"success\": false, \"message\": \"Noch ein Versuch übrig vor der 15-Minuten-Sperre.\"}");
              } else if (spiffsAttempts >= 3) {
                  spiffsLockoutTime = currentTime + (15 * 60 * 1000); // 15 Minuten in Millisekunden
                  preferences.putULong("spiffsLockoutTime", spiffsLockoutTime);
                  Serial.printf("Lockout activated until: %lu\n", spiffsLockoutTime);
                  server3.send(401, "application/json", "{\"success\": false, \"message\": \"Zu viele Fehlversuche. Sie können es in 15 Minuten erneut versuchen.\"}");
              } else {
                  server3.send(401, "application/json", "{\"success\": false, \"message\": \"Aktuelles Passwort ist falsch.\"}");
              }
          } else {
              // Setze Versuche nur bei erfolgreicher Eingabe zurück
              spiffsAttempts = 0;
              spiffsLockoutTime = 0;
              preferences.putInt("spiffsAttempts", spiffsAttempts);
              preferences.putULong("spiffsLockoutTime", spiffsLockoutTime);
              Serial.println(F("Password correct, attempts reset"));

              if (isPasswordValid(newPassword)) {
                  // Speichern des neuen Passworts
                  preferences.putString("password", newPassword);
                  server3.send(200, "application/json", "{\"success\": true}");
              } else {
                  server3.send(400, "application/json", "{\"success\": false, \"message\": \"Das neue Passwort muss mindestens 5 Zeichen lang sein und sowohl Zahlen als auch Buchstaben enthalten.\"}");
              }
          }

          // Beenden der Preferences
          preferences.end();
      });






        #ifndef Firmware_backup  
        server3.on("/setNTPServer", HTTP_POST, setNTPServer);
        server3.on("/validateNTPServer", HTTP_POST, handle_validateNTPServer);
        server3.on("/getNTPServer", HTTP_GET, getNTPServer);
        #endif

        server3.on("/setTimestamp", HTTP_POST, setTimestamp);  

        server3.on("/setTimeFormat", HTTP_POST, handleSetTimeFormat);


            // Definiere den Endpunkt /toggleProgramMode
            #ifndef Firmware_backup  
            server3.on("/toggleProgramMode", HTTP_GET, []() {
              // Wechsle den Programmiermodus
              Serial.println(F("[Web] KNX toggle Prog Mode"));
              
              currentPinState_knx_web = digitalRead(20); // Liest den aktuellen Pin-Zustand

              knx.toggleProgMode(); // Beispielaufruf; ersetze dies durch deine tatsächliche Funktion
              startTime_knx = millis();
   
              //int currentPinState = digitalRead(20); // Lese den Zustand von Pin 20
              g_toggle_knx_prog = true;

            });
            #endif



            // Definiere den Endpunkt /sendDataToKNX
            #ifndef Firmware_backup  
            server3.on("/sendDataToKNX", HTTP_GET, []() {
              // Hier fügst du deine Funktion zum Senden der Daten an KNX ein
              Serial.println(F("[Web] Sende Daten an KNX"));
              // Sende die Daten an KNX

              server3.send(200, "text/plain", "Daten an KNX gesendet");
              send_knx_data();
              
            });
            #endif


            #ifndef Firmware_backup  
            server3.on("/radonValues", HTTP_GET, []() {
                String jsonResponse = "{\"radonLive\": \"" + String(mb_radon_live_32bit) + "\", \"radon24h\": \"" + String(radon_mittelwert_24h) + "\", \"radonLong\": \"" + String(radon_mittelwert_long) + "\", \"runTime\": \"" + String(mb_radon_save_eintrarge) + "\"}";
                server3.send(200, "application/json", jsonResponse);
            });
            #endif


          #ifndef Firmware_backup  
          server3.on("/radonValues2", HTTP_GET, []() {
          
              String jsonResponse = "{";
              jsonResponse += "\"currentDateTime\": \"" + String(current_datetime) + "\", ";
              jsonResponse += "\"radonLive\": \"" + String(mb_radon_live_32bit) + " Bq/m³\", ";
              jsonResponse += "\"radon24h\": \"" + String(radon_mittelwert_24h) + " Bq/m³\", ";
              jsonResponse += "\"radonLong\": \"" + String(radon_mittelwert_long) + " Bq/m³\", ";
              jsonResponse += "\"mittelwertJahr\": \"" + String(mittelwert_jahr) + " Bq/m³\", ";
              jsonResponse += "\"runTime\": \"" + String(mb_radon_save_eintrarge) + " h\"";
              jsonResponse += "}";

              server3.send(200, "application/json", jsonResponse);
          });
         #endif



           #ifndef Firmware_backup  
            server3.on("/save_knx_settings", HTTP_POST, []() {

              bool knx_status = server3.arg("knx_status") == "on";
              String knx_addresst = server3.arg("knx_address");
              String group_address_1 = server3.arg("group_address_1");
              String group_address_2 = server3.arg("group_address_2");
              String group_address_3 = server3.arg("group_address_3");
              String group_address_4 = server3.arg("group_address_4");
              String sensor_boot_time = server3.arg("sensor_boot_time");
              String auto_transfer = server3.arg("auto_transfer");
              String ip_address = server3.arg("ip_address");
              String subnet_mask = server3.arg("subnet_mask");
              String gateway = server3.arg("gateway");
              String multicast_address = server3.arg("multicast_address");

              // Debug-Ausgaben
              Serial.println(F("KNX-Einstellungen werden gespeichert:"));
              Serial.print(F("KNX Address: "));
              Serial.println(knx_addresst);
              Serial.print(F("Group Address 1: "));
              Serial.println(group_address_1);
              Serial.print(F("Group Address 2: "));
              Serial.println(group_address_2);
              Serial.print(F("Group Address 3: "));
              Serial.println(group_address_3);
              Serial.print(F("Group Address 4: "));
              Serial.println(group_address_4);
              Serial.print(F("Sensor Boot Time: "));
              Serial.println(sensor_boot_time);
              Serial.print(F("Auto Transfer: "));
              Serial.println(auto_transfer);
              Serial.print(F("IP Address: "));
              Serial.println(ip_address);
              Serial.print(F("Subnet Mask: "));
              Serial.println(subnet_mask);
              Serial.print(F("Gateway: "));
              Serial.println(gateway);
              Serial.print(F("Multicast Address: "));
              Serial.println(multicast_address);
              Serial.print(F("KNX Status: "));
              Serial.println(knx_status ? F("on") : F("off"));


              if(knx_status == true){
                g_KNX_S_ist = 1;
              }else{
                g_KNX_S_ist = 0;
              }
              Preferences preferences;
              preferences.begin("eenvs", false);  // Ordner eenvs anlegen/verwenden
              preferences.putUShort("p_KNX_S", g_KNX_S_ist);
              //if(g_KNX_S_ist == 0){knx_program_mode = false;}
              //preferences.putBool("p_KNX_ets", knx_program_mode);  // KNX Program Mode aktivieren
              preferences.end();

                // KNX-Adresse aufteilen
                uint8_t areat = (uint8_t)knx_addresst.substring(0, knx_addresst.indexOf('.')).toInt();
                knx_addresst = knx_addresst.substring(knx_addresst.indexOf('.') + 1);
                uint8_t linet = (uint8_t)knx_addresst.substring(0, knx_addresst.indexOf('.')).toInt();
                uint8_t devicet = (uint8_t)knx_addresst.substring(knx_addresst.indexOf('.') + 1).toInt();

                // Korrekte Debug-Ausgabe sicherstellen
                Serial.print(F("KNX area: "));
                Serial.println(areat, DEC);  // Verwendung von DEC für dezimale Ausgabe
                Serial.print(F("KNX line: "));
                Serial.println(linet, DEC);
                Serial.print(F("KNX device: "));
                Serial.println(devicet, DEC);


                saveKNXAddress(areat, linet, devicet);

              // Gruppenadressen sicher konvertieren
              uint8_t addresses[4][3] = {
                  {(uint8_t)group_address_1.substring(0, group_address_1.indexOf('/')).toInt(), (uint8_t)group_address_1.substring(group_address_1.indexOf('/') + 1, group_address_1.lastIndexOf('/')).toInt(), (uint8_t)group_address_1.substring(group_address_1.lastIndexOf('/') + 1).toInt()},
                  {(uint8_t)group_address_2.substring(0, group_address_2.indexOf('/')).toInt(), (uint8_t)group_address_2.substring(group_address_2.indexOf('/') + 1, group_address_2.lastIndexOf('/')).toInt(), (uint8_t)group_address_2.substring(group_address_2.lastIndexOf('/') + 1).toInt()},
                  {(uint8_t)group_address_3.substring(0, group_address_3.indexOf('/')).toInt(), (uint8_t)group_address_3.substring(group_address_3.indexOf('/') + 1, group_address_3.lastIndexOf('/')).toInt(), (uint8_t)group_address_3.substring(group_address_3.lastIndexOf('/') + 1).toInt()},
                  {(uint8_t)group_address_4.substring(0, group_address_4.indexOf('/')).toInt(), (uint8_t)group_address_4.substring(group_address_4.indexOf('/') + 1, group_address_4.lastIndexOf('/')).toInt(), (uint8_t)group_address_4.substring(group_address_4.lastIndexOf('/') + 1).toInt()}
              };
              saveGroupAddresses(addresses, 4);

              // IP-Adressen sicher konvertieren
              uint8_t ip[4];
              sscanf(ip_address.c_str(), "%hhu.%hhu.%hhu.%hhu", &ip[0], &ip[1], &ip[2], &ip[3]);
              saveIPAddress(ip);

              uint8_t subnet[4];
              sscanf(subnet_mask.c_str(), "%hhu.%hhu.%hhu.%hhu", &subnet[0], &subnet[1], &subnet[2], &subnet[3]);
              saveSubnetMask(subnet);

              uint8_t gateway_ip[4];
              sscanf(gateway.c_str(), "%hhu.%hhu.%hhu.%hhu", &gateway_ip[0], &gateway_ip[1], &gateway_ip[2], &gateway_ip[3]);
              saveGateway(gateway_ip);

              uint8_t multicast[4];
              sscanf(multicast_address.c_str(), "%hhu.%hhu.%hhu.%hhu", &multicast[0], &multicast[1], &multicast[2], &multicast[3]);
              saveMulticastAddress(multicast);

              // Nach dem Speichern zur Hauptseite zurückkehren
              server3.sendHeader("Location", "/", true);
              server3.send(302, "text/plain", "");

              g_esp_soft_restart = true;
          });
         #endif




           // void handle_mqtt()       mqtt_html_template[] PROGMEM          server3.on("/save_mqtt_settings
          #ifndef Firmware_backup  
          server3.on("/save_mqtt_settings", HTTP_POST, []() {     // mqtt_html_template    deinPasswort    0056e40b03b14156ab7d707f5104256e
                         
              String mqtt_topic = server3.arg("mqtt_topic");
              String mqtt_server = server3.arg("mqtt_server");
              String mqtt_client = server3.arg("mqtt_client");
              String mqtt_user = server3.arg("mqtt_user");
              String mqtt_pass = server3.arg("mqtt_pass");
              String mqtt_port = server3.arg("mqtt_port");
              bool mqtt_status = server3.arg("mqtt_status") == "on";

              // Debug-Ausgaben
              Serial.println(F("Einstellungen werden gespeichert:"));
              Serial.print(F("MQTT Topic: "));
              Serial.println(mqtt_topic);
              Serial.print(F("MQTT Server: "));
              Serial.println(mqtt_server);
              Serial.print(F("MQTT Client: "));
              Serial.println(mqtt_client);
              Serial.print(F("MQTT Benutzer: "));
              Serial.println(mqtt_user);
              Serial.print(F("MQTT Passwort: "));
              Serial.println(mqtt_pass);
              Serial.print(F("MQTT Port: "));
              Serial.println(mqtt_port);
              Serial.print(F("MQTT Status: "));
              Serial.println(mqtt_status ? F("on") : F("off"));



            
              Preferences preferences;
              preferences.begin("eenvs", false);
              preferences.putString("p_mqtopic", mqtt_topic);
              preferences.putString("p_mqserv", mqtt_server);
              preferences.putString("p_mqclie", mqtt_client);
              preferences.putString("p_mquser", mqtt_user);
              preferences.putString("p_mqpass", mqtt_pass);
              preferences.putString("p_mqport", mqtt_port);
              preferences.putBool("p_mqon", mqtt_status);
              preferences.end();
          
              load_mqtt_settings();

              // Nach dem Speichern zur Hauptseite zurückkehren
              server3.sendHeader("Location", "/", true);
              server3.send(302, "text/plain", "");

              //g_esp_soft_restart = true;

          });
          #endif


          #ifndef Firmware_backup  
          server3.on("/save_cloud_settings", HTTP_POST, []() {
              String cloud_server = server3.arg("cloud_server");
              String cloud_page = server3.arg("cloud_page");
              String cloud_pre = server3.arg("cloud_pre");
              String cloud_chain = server3.arg("cloud_chain");
              bool cloud_status = server3.arg("cloud_status") == "on";

              // Debug-Ausgaben
              Serial.println(F("Cloud-Einstellungen werden gespeichert:"));
              Serial.print(F("Cloud Server: "));
              Serial.println(cloud_server);
              Serial.print(F("Cloud Seite: "));
              Serial.println(cloud_page);
              Serial.print(F("Cloud Präfix: "));
              Serial.println(cloud_pre);
              Serial.print(F("Cloud Kette: "));
              Serial.println(cloud_chain);
              Serial.print(F("Cloud Status: "));
              Serial.println(cloud_status ? F("on") : F("off"));


              Preferences preferences;
              preferences.begin("eenvs", false);
              preferences.putString("p_clserv", cloud_server);
              preferences.putString("p_clpage", cloud_page);
              preferences.putString("p_clpre", cloud_pre);
              preferences.putString("p_clchain", cloud_chain);
              preferences.putUChar("g_cloud_ea", cloud_status);
              preferences.end();

              load_cloud_settings();

              // Nach dem Speichern zur Hauptseite zurückkehren
              server3.sendHeader("Location", "/", true);
              server3.send(302, "text/plain", "");

              g_esp_soft_restart = true;
          });
          #endif


          #ifndef Firmware_backup   
          server3.on("/get-second-dropdown-options", HTTP_GET, []() {
              if (server3.hasArg("region")) {
                  String region = server3.arg("region");
                  String options = generateSecondDropdownOptions(region);
                  server3.send(200, "text/plain", options);
              } else {
                  server3.send(404, "text/plain", "Region not specified");
              }
          });
          #endif







            //------------------------------------------
            // Route für das Hochladen von Dateien
            server3.on("/upload", HTTP_POST,[](){
              if (!isAuthenticated()) {
                return;
              }
              server3.send(200, "text/plain", "Datei erfolgreich hochgeladen.\n\n<a href='/'>Zur&uuml;ck</a>");  
            }, handleFileUpload);
            // Route für das Anzeigen der Upload-Seite
            server3.on("/upload.html", HTTP_GET, handle_upload_page);
            //------------------------------------------


            //------------------------------------------
              // Route für das Auflisten der Dateien
              //server3.on("/filelist", HTTP_GET, handleFileList);
              server3.on("/filelist", HTTP_GET,[](){
                if (!isAuthenticated()) {
                  return;
                }
                handleFileList();
              });
            //------------------------------------------

        


      }  //disable_server

      
      if(disable_server >= 1 && TB_currFwVersion == TB_newFwVersion && verzoegerung_fw_update == 0) {
            if(TB_currFwVersion == TB_newFwVersion){

                Serial.println("[IF] Server start");
                server3.begin();
               
                webSocket.begin();
                webSocket.onEvent(webSocketEvent);

            }
      }


      //-----------------------------------------------------------------    
      //  deinPasswort2            spiffs_html_template

      server3.on("/updateFileSystem", handle_spiffs);

      //-----------------------------------------------------------------    





        // OTA Update Setup
        server3.on("/updateSPIFFS", HTTP_POST, []() {
          server3.sendHeader("Connection", "close");
          server3.send(200, "text/plain", (Update.hasError()) ? "FAIL" : "OK");
          ESP.restart();
        }, []() {
          HTTPUpload& upload = server3.upload();
          static size_t totalSize = 0;
          static size_t currentSize = 0;
          static int lastProgress = -1;

          if (upload.status == UPLOAD_FILE_START) {
            totalSize = upload.totalSize;
            currentSize = 0;
            lastProgress = -1; // Setze den letzten Fortschritt auf -1 zurück
            Serial.printf("Update: %s\n", upload.filename.c_str());
            Serial.printf("Total Size at START: %u\n", totalSize);
            if (!Update.begin(UPDATE_SIZE_UNKNOWN, U_SPIFFS)) {
              Update.printError(Serial);
            }
          } else if (upload.status == UPLOAD_FILE_WRITE) {
            if (totalSize == 0) {
              totalSize = upload.totalSize; // Gesamtgröße beim ersten Schreibvorgang initialisieren
              Serial.printf("Total Size initialized: %u\n", totalSize);
              if (totalSize == 0) {
                // Fallback-Mechanismus, falls totalSize immer noch null ist
                Serial.println(F("Total Size is zero, trying fallback mechanism."));
                totalSize = 1700000; // Setze totalSize manuell auf 1,70 MB
              }
            }
            //Serial.printf("Writing: %u bytes\n", upload.currentSize);
            if (Update.write(upload.buf, upload.currentSize) != upload.currentSize) {
              Update.printError(Serial);
            } else {
              currentSize += upload.currentSize;
              //Serial.printf("Current Size: %u\n", currentSize);
              //Serial.printf("Total Size: %u\n", totalSize); // Debug-Ausgabe der totalSize bei WRITE
              // Fortschritt berechnen
              if (totalSize > 0) {
                float progress = ((float)currentSize / (float)totalSize) * 100.0f;
                int roundedProgress = (int)progress;
                // Fortschritt nur in 10% Schritten anzeigen
                if (roundedProgress / 10 > lastProgress / 10) {
                  Serial.printf("Progress: %d%%\n", (roundedProgress / 10) * 10);
                  lastProgress = roundedProgress;
                }
              } else {
                Serial.println(F("Total Size is zero, cannot calculate progress."));
              }
              // WDT zurücksetzen
              esp_task_wdt_reset();
            }
          } else if (upload.status == UPLOAD_FILE_END) {
            Serial.printf("Upload Status: END\n");
            if (Update.end(true)) {
              Serial.printf("Update Success: %uB\n", upload.totalSize);
            } else {
              Update.printError(Serial);
            }
          } else if (upload.status == UPLOAD_FILE_ABORTED) {
            Update.end();
            Serial.println(F("Update aborted"));
          }
          delay(0);
        });





    }

      #endif
      #endif













   //printf("[AP] cFREE HEAP: now: %u, contiguous: %u, lowest: %u\n",xPortGetFreeHeapSize(),heap_caps_get_largest_free_block(MALLOC_CAP_DEFAULT),xPortGetMinimumEverFreeHeapSize());
   


  //******************************************************************************
  //                            Start  Thread                                    *
  //****************************************************************************** 
    //----------------------------------
     // Serial.println(F("------------------[ Threads ]--------------------"));
      //Serial.println("[IF] Enable Threads");
      //printf("[AP] FREE RAM: now: %.2f MB\n", getUsedRAMMB());


     
      //Thread_bt->onRun(btCallback);  // 100 ms
      //Thread_bt->setInterval(100);
     
      //Thread_tb_task->onRun(Callback_tb_task);  //callback 1 Sec.
      //Thread_tb_task->setInterval(1000);

      //Thread_2s->onRun(Callback_2s);  // 2 sec
      //Thread_2s->setInterval(2000);


      //Thread_30s->onRun(Callback_30s);  // 30 sec
      //Thread_30s->setInterval(30000);

      //Thread_1m->onRun(Callback_1m);  // 1 min
      //Thread_1m->setInterval(60000);


      //Thread_tb_send->onRun(Callback_tb_send);
      //Thread_tb_send->setInterval(100000);  //100sec.



      //Thread_mb4->onRun(mb4Callback);//90min
      //Thread_mb4->setInterval(5400000); //90min

      //Thread_45min->onRun(Callback_tb_shared);
      //Thread_45min->setInterval(2700000);   // 45min

      //Thread_tb_FW->onRun(Callback_tb_FW);
      //Thread_tb_FW->setInterval(3600000);  //1h


      //Thread_fail_FW->onRun(Callback_fail_FW);
      //Thread_fail_FW->setInterval(8000000);  //2h

  
 
      if(TB_currFwVersion == TB_newFwVersion && verzoegerung_fw_update == 0 && knx_program_mode == 0){
        
        //controll.add(Thread_1m);
        //controll.add(Thread_bt);
        
        //controll.add(Thread_45min);
        //controll.add(Thread_30s);
        //controll.add(Thread_tb_send);
        

      }else{   //disable_server
          
            Serial.println(F("[IF] ------------> controll Thread"));

      }  

  
      //if(knx_program_mode == 0){
        //controll.add(Thread_2s);
        //controll.add(Thread_mb4);
        //controll.add(Thread_tb_FW);
        //controll.add(Thread_fail_FW);
      //}

      //controll.add(Thread_tb_task);  // 1sec.



    //----------------------------------
  //****************************************************************************** 


   //printf("[AP] dFREE HEAP: now: %u, contiguous: %u, lowest: %u\n",xPortGetFreeHeapSize(),heap_caps_get_largest_free_block(MALLOC_CAP_DEFAULT),xPortGetMinimumEverFreeHeapSize());
   


  //******************************************************************************
  //                            Start  Modbus                                    *
  //****************************************************************************** 
      Serial.println(F("-------------------[ Modbus ]---------------------"));
      //Serial.println("[MB] Enable Modbus");
      //printf("[AP] FREE RAM: now: %.3f MB\n", getUsedRAMMB());

      Serial1.begin(mbus_baud, SERIAL_8N1, Serial1_RXPIN, Serial1_TXPIN); 

       //Serial.println("-------------------[ Modbus aa ]---------------------");
       //printf("[AP] FREE RAM: now: %.3f MB\n", getUsedRAMMB());

        // Set RTU Modbus message timeout to 2000ms
        MB.setTimeout(resp_tim_out);
        
        // Start ModbusRTU background task
        MB.begin(1);
      // Serial.println("-------------------[ Modbus bb ]---------------------");
       //printf("[AP] FREE RAM: now: %.3f MB\n", getUsedRAMMB());

        ModbusMessage n, m;     
      
        MBbridge.attachServer(1, 1, READ_HOLD_REGISTER, &MB);
        MBbridge.addFunctionCode(1, READ_INPUT_REGISTER);
        
        MBbridge.attachServer(1, 1, WRITE_HOLD_REGISTER, &MB);
        MBbridge.addFunctionCode(1, WRITE_HOLD_REGISTER);

       //Serial.println("-------------------[ Modbus cc ]---------------------");
       //printf("[AP] FREE RAM: now: %.3f MB\n", getUsedRAMMB());

        m.setMessage(1, ANY_FUNCTION_CODE, 0, 10);
        
        n = MBbridge.localRequest(m);
      
        //char dataStringb[50] = {0};
        //sprintf(dataStringb, "%02X %02X %02X %02X %02X",Expec_b[0],Expec_b[1],Expec_b[2],Expec_b[3],Expec_b[4]);  
        //testOutput(makeVector(dataStringb), n);   
   
       //Serial.println("-------------------[ Modbus dd ]---------------------");
       //printf("[AP] FREE RAM: now: %.3f MB\n", getUsedRAMMB());

        MBbridge.listServer();
         // Start the bridge. Port 502, 4 simultaneous clients allowed, 600ms inactivity to disconnect client

        MBbridge.start(502, 4, 60000);
        //MBbridge.onDataHandler(&handleData); 
        
       //Serial.println("-------------------[ Modbus ee ]---------------------");
       //printf("[AP] FREE RAM: now: %.3f MB\n", getUsedRAMMB());
        // Set up ModbusRTU client.
        //  provide onData handler function
        MB.onDataHandler(&handleData);
     
       // - provide onError handler function
        MB.onErrorHandler(&handleError);

   //****************************************************************************** 
      // Serial.println("-------------------[ Modbusend ]---------------------");
      //printf("[AP] FREE RAM: now: %.3f MB\n", getUsedRAMMB());


   //printf("[AP] eFREE HEAP: now: %u, contiguous: %u, lowest: %u\n",xPortGetFreeHeapSize(),heap_caps_get_largest_free_block(MALLOC_CAP_DEFAULT),xPortGetMinimumEverFreeHeapSize());
    //[AP] eFREE HEAP: now: 109308, contiguous: 109168, lowest: 109180
    //[BT] Enable BLE

    //[AP] fFREE HEAP: now: 11780, contiguous: 11564, lowest: 8692


  //******************************************************************************
  //                            Start  BLE                                       *
  //****************************************************************************** 
  ble_startMillis = millis();  // Startzeitpunkt setzen
    // esp_bt_controller_disable ( ) ;
    // esp_bt_controller_deinit ( ) ;

       //esp_bt_mem_release(ESP_BT_MODE_BLE);
       //esp_bt_mem_release(ESP_BT_MODE_CLASSIC_BT);
       //esp_bt_mem_release(ESP_BT_MODE_BTDM);
       
        //  ESP_BT_MODE_IDLE       = 0x00,   /*!< Bluetooth is not running */
        //  ESP_BT_MODE_BLE        = 0x01,   /*!< Run BLE mode */
        //  ESP_BT_MODE_CLASSIC_BT = 0x02,   /*!< Run Classic BT mode */
        //  ESP_BT_MODE_BTDM       = 0x03,   /*!< Run dual mode */
 





  //****************************************************************************** 


     
    //if(disable_server >= 1 && TB_currFwVersion == TB_newFwVersion && verzoegerung_fw_update == 0 && knx_program_mode == 0) {
    if(disable_server >= 1 && TB_currFwVersion == TB_newFwVersion && verzoegerung_fw_update == 0) {  
      //Serial.println(F("---------Beacon Start-----------"));

      g_end_pAdvertising = true;
      end_pAdvertising = millis() + 100;

      //-------------------------------------

          #ifdef BLEbeacon_space
          // Starte das Beacon
          startBeacon();
          #endif

      //-------------------------------------

    }else{
       
       Serial.println(F("[BT] Disable Beacon"));

    }


   
  //****************************************************************************** 




  // printf("[AP] gFREE HEAP: now: %u, contiguous: %u, lowest: %u\n",xPortGetFreeHeapSize(),heap_caps_get_largest_free_block(MALLOC_CAP_DEFAULT),xPortGetMinimumEverFreeHeapSize());
   
      //Serial.println(F("-------------------[ bb ]---------------------"));
      //printf("[AP] FREE RAM: now: %.2f MB\n", getUsedRAMMB());

       ms2 = millis();
   
      mb4Callback(); //90min // Seriennummer abfragen

      //Serial.println("[MB] mb_read_radon  --  Sensor 5"); 
  
      if(disable_server >= 1 && TB_currFwVersion == TB_newFwVersion && verzoegerung_fw_update == 0) {
        mb_read_radon();
      }


      //Serial.println(F("-------------------[ cc ]---------------------"));
      //printf("[AP] FREE RAM: now: %.2f MB\n", getUsedRAMMB());
         
            if(g_boot_fail >= 1){
               g_Seg__boot_ani = false;
               g_t_led_off = true; 
               g_view_fw = false; 
               time_view_fw = 0; 
               boot_ani_off = true;  
               boot_ani_off2 = true;    // false = led pulsen
               ani_segment_finish = true;// damit farbig led aktiviert wird

            }




   

     
      mb_stufen_start = true;



  //------ WLAN Überwachung ------------------------------------------------------------
    Serial.println(F("------------------[ WLAN Check ]-------------------"));
    printf("[AP] FREE RAM: now: %.2f MB\n", getUsedRAMMB());
          // Gespeicherte Werte laden
            wifiCheckEnabled = preferences.getBool("wifiCheckEnabled", false);
            lastWifiCheckEnabled = !wifiCheckEnabled;
            failedCheckCount = preferences.getInt("failedCheckCount", 0);
            connectionAttemptCount = preferences.getInt("connecCount", 0);
            restartCount = preferences.getInt("restartCount", 0);
            connectedTime = preferences.getULong("connectedTime", 0);
            offlineTime = preferences.getULong("offlineTime", 0);
            nightModeDetectionCount = preferences.getInt("nightModeDet", 0);
            consecutiveNightModeDays = preferences.getInt("conNightModDay", 0);
            nightModeActive = preferences.getBool("nightModeActive", false);
            lastDayMillis = preferences.getULong("lastDayMillis", 0);
            nightCounted = preferences.getBool("nightCounted", false); // Lade den gespeicherten Zustand
            // Lese die gespeicherten Werte aus, falls vorhanden
            nightStartHour = preferences.getInt("nightStartHour", 21); // Standardwert ist 21
            nightEndHour = preferences.getInt("nightEndHour", 6); // Standardwert ist 6

            Serial.print(F("[WL] Night Start Hour: "));Serial.println(nightStartHour);
            Serial.print(F("[WL] Night End Hour: "));Serial.println(nightEndHour);
            //if(WiFi_status == WL_CONNECTED){
              //nightModeActive = false;
              //preferences.putBool("nightModeActive", nightModeActive);
            //}



            // Überprüfen, ob die aktuelle Zeit innerhalb des Nachtschaltungsfensters liegt
            currentNightMode = (v_currenthour >= nightStartHour || v_currenthour < nightEndHour); // Wenn die aktuelle Stunde innerhalb dieses Fensters liegt, wird currentNightMode auf true gesetzt, andernfalls auf false


            // WLAN-Überprüfung aktivieren und maximale Anzahl fehlerhafter Überprüfungen auf 5 setzen
                if (disable_server >= 1 && TB_currFwVersion == TB_newFwVersion) {
                    setWiFiCheckEnabled(true, 4);
                    Serial.println(F("[WL][  ] WIFI Check Enabled"));

                    // Überprüfung, ob eine Stunde für WiFi vergangen ist
                    unsigned long currentTime = millis();
                    if (currentTime - lastLogTimeWiFi >= 3600000) { // 3600000 Millisekunden = 1 Stunde
                        
                        
                        if (loggingEnabled) {
                          //things_list_t_16 = p_uhrzeit + "  [WL] WIFI Check Enabled";
                          write_to_log(things_list_t_16);
                        }
                        lastLogTimeWiFi = currentTime; // Aktualisieren Sie die letzte Log-Zeit
                    }

                    if (currentNightMode) {
                        Serial.println(F("[WL][  ] Nachtschaltung im Zeitfenster"));
                        // Überprüfung, ob eine Stunde für Nachtschaltung im Zeitfenster vergangen ist
                        if (currentTime - lastLogTimeNightModeWindow >= 3600000) {
                            
                            if (loggingEnabled) {
                              //things_list_t_16 = p_uhrzeit + "  [WL] Nachtschaltung im Zeitfenster";
                              write_to_log(things_list_t_16);
                            }
                            lastLogTimeNightModeWindow = currentTime;
                        }
                    } else {
                        Serial.println(F("[WL][  ] Nachtschaltung außerhalb Zeitfenster"));
                        // Überprüfung, ob eine Stunde für Nachtschaltung außerhalb Zeitfenster vergangen ist
                        if (currentTime - lastLogTimeOutsideNightModeWindow >= 3600000) {
                            
                            if (loggingEnabled) {
                              //things_list_t_16 = p_uhrzeit + "  [WL] Nachtschaltung außerhalb Zeitfenster";
                              write_to_log(things_list_t_16);
                            }
                            lastLogTimeOutsideNightModeWindow = currentTime;
                        }
                    }

                    if (nightModeActive) {
                        Serial.println(F("[WL][  ] Nachtschaltung aktiv"));
                        // Überprüfung, ob eine Stunde für Nachtschaltung aktiv vergangen ist
                        if (currentTime - lastLogTimeNightModeActive >= 3600000) {
                           
                            if (loggingEnabled) {
                              //things_list_t_16 = p_uhrzeit + "  [WL] Nachtschaltung aktiv";
                              write_to_log(things_list_t_16);
                            }
                            lastLogTimeNightModeActive = currentTime;
                        }
                    } else {
                        Serial.println(F("[WL][  ] Nachtschaltung deaktiviert"));
                        // Überprüfung, ob eine Stunde für Nachtschaltung deaktiviert vergangen ist
                        if (currentTime - lastLogTimeNightModeInactive >= 3600000) {
                            
                            if (loggingEnabled) {
                              //things_list_t_16 = p_uhrzeit + "  [WL] Nachtschaltung deaktiviert";
                              write_to_log(things_list_t_16);
                            }
                            lastLogTimeNightModeInactive = currentTime;
                        }
                    }

                    Serial.print(F("[WL][  ] Nachtmoduscounter: "));
                    Serial.println(consecutiveNightModeDays);


                } else {
                    setWiFiCheckEnabled(false, 4);
                }
      //------------------------------------------------------------------



           previous_wlan_count = preferences.getInt("wlan_count", 0);   // -1= kein WLAN gefunden   0= Speicher neu    -2= Restart,suche starten    >0= WLAN im Speicher
          // Debug status
            if (previous_wlan_count == -1) {
                Serial.println(F("[IF] Debug: -1 = kein WLAN gefunden"));
            } else if (previous_wlan_count == 0) {
                Serial.println(F("[IF] Debug: 0 = Speicher neu (Werkszustand)"));
            } else if (previous_wlan_count == -2) {
                Serial.println(F("[IF] Debug: -2 = Restart, suche neu starten"));
            } else if (previous_wlan_count > 0) {
                Serial.print(F("[IF] WLAN im Speicher. Found: "));
                Serial.println(previous_wlan_count);
                
                if (loggingEnabled) {
                   things_list_t_16 = "          [WL] WLAN im Speicher. Found:" + String(previous_wlan_count);  
                   write_to_log(things_list_t_16);
                }
            }



          // Schließen Sie die Preferences
          preferences.end();
          // Überprüfen Sie den freien Speicher
          //Serial.print("Freier Preferences Speicher: ");
          //Serial.println(esp_get_free_heap_size());


         calc_diff_timestamp = true;



  //--******************************************************************************
  //                                   KNX                                         *
  //--****************************************************************************** 
      Serial.println(F("--------------------[ KNX ]----------------------"));
      //Serial.println(F("[MB] Enable KNX"));
      //printf("[AP] FREE RAM: now: %.2f MB\n", getUsedRAMMB());

      if (g_KNX_S_ist == 1) {
          if (WiFi.status() == WL_CONNECTED) {
              IPAddress localIP = WiFi.localIP();
              IPAddress subnetMask = WiFi.subnetMask();
              IPAddress gatewayIP = WiFi.gatewayIP();

              for (int i = 0; i < 4; i++) {
                  ipAddressKNX[i] = localIP[i];
                  subnetMaskKNX[i] = subnetMask[i];
                  gatewayKNX[i] = gatewayIP[i];
              }
          }

        #if KNX_DEBUG_LEVEL >= KNX_DEBUG_MED   
          Serial.print(F("[KX] IP Address: "));
          for (int i = 0; i < 4; i++) {
              Serial.print(ipAddressKNX[i]);
              if (i < 3) Serial.print(F("."));
          }
          Serial.println();

          Serial.print(F("[KX] Subnet Mask: "));
          for (int i = 0; i < 4; i++) {
              Serial.print(subnetMaskKNX[i]);
              if (i < 3) Serial.print(F("."));
          }
          Serial.println();

          Serial.print(F("[KX] Gateway: "));
          for (int i = 0; i < 4; i++) {
              Serial.print(gatewayKNX[i]);
              if (i < 3) Serial.print(F("."));
          }
          Serial.println();
        #endif


          knx.readMemory();


          KNX_DEBUG_MED_PRINTLN(F("----------"));
          readGroupAddressesFromStoredData();
          readIPAddressFromStoredData();
          readSubnetMaskFromStoredData();
          readGatewayFromStoredData();
          readMulticastAddressFromStoredData();
          KNX_DEBUG_MED_PRINTLN(F("----------"));







        // print values of parameters if device is already configured
        if (knx.configured()) {
          goRadonlive.dataPointType(Dpt(12, 001));
          goRadon24h.dataPointType(Dpt(12, 001));
          goRadonlong.dataPointType(Dpt(12, 001));
          goRadoneintr.dataPointType(Dpt(7, 001));

          
          Serial.print(F("Startup: "));
          Serial.println(knx.paramByte(0));

          // Serial.print(F("Aenderung senden: "));
          // Serial.println(knx.paramByte(1));

          uint8_t timeUnit = knx.paramByte(1);   // 0 disable  1=1min  2=10min  3=60 min  
          Serial.print(F("Zykl. senden: "));
          switch (timeUnit) {
              case 0:
                  Serial.println(F("Deaktiviert"));
                  break;
              case 1:
                  Serial.println(F("1 Minute"));
                  break;
              case 2:
                  Serial.println(F("10 Minuten"));
                  break;
              case 3:
                  Serial.println(F("60 Minuten"));
                  break;
              default:
                  Serial.println(F("Ungültige Zeiteinheit"));
                  break;
          }

          Serial.println(F("--------------------------------"));

      } else {
          saveDataDirectly();
          saveKNXAddress(area, line, device);
          saveIPAddress(ipAddressKNX);
          saveSubnetMask(subnetMaskKNX);
          saveGateway(gatewayKNX);
          saveMulticastAddress(multicastAddress);
          saveGroupAddresses(groupAddresses, numAddresses);

          // paramByte(0) und paramByte(1) speichern
          uint8_t paramByte0Value = 3;
          uint8_t paramByte1Value = 2;
          saveParamByte0(paramByte0Value);
          saveParamByte1(paramByte1Value);

          Serial.println(F("Done, Reboot now"));

          // Warten Sie 1 Sekunde, bevor Sie neu starten
          unsigned long startTime = millis();
          while (millis() - startTime < 1000) {
              // Sie können hier auch andere Aufgaben ausführen, wenn nötig
              delay(10); // Kurze Verzögerung, um die Schleife nicht zu blockieren
          }

          delay(2000);
          esp_restart();
      }




          // pin or GPIO the programming led is connected to. Default is LED_BUILTIN
          knx.ledPin(20);
          // is the led active on HIGH or low? Default is LOW
          knx.ledPinActiveOn(HIGH);
          // pin or GPIO programming button is connected to. Default is 0
          //knx.buttonPin(14);


          // start the framework.
          knx.start();
          
          //knx.toggleProgMode();
          if (!knx.configured()){knx.toggleProgMode();}
          

    }


  //--****************************************************************************** 












   // Anzahl der Log-Einträge zählen und ausgeben
    //logCount = count_log_entries();
    //logCount_sum = logCount;

    //Serial.println("");Serial.print("Anzahl der Log-Einträge: ");Serial.println(logCount_sum);



    // Alle Logs beim Start lesen und ausgeben
      //print_all_logs();
      //read_all_logs();

      //print_log_info();
      //debug_log_files();


       //printf("[AP] FREE HEAP: now: %u, contiguous: %u, lowest: %u\n",xPortGetFreeHeapSize(),heap_caps_get_largest_free_block(MALLOC_CAP_DEFAULT),xPortGetMinimumEverFreeHeapSize());
        Serial.println(F(" "));
        Serial.println(F(" "));
        Serial.println(F("[IF] Setup END"));
        printf("[AP] FREE RAM: now: %.2f MB\n", getUsedRAMMB());
        Serial.println(F("========================================================"));
        Serial.println(F(" "));



                       
     startMillisknx = millis(); // Speichere den Startzeitpunkt

     //  disable_server = 1; 
     //  preferences.putUChar("g_server", disable_server);    //  1=Standard   AN 
           


    //String csvData = readCSV();
    //Serial.println(csvData);  // Ausgabe der CSV-Daten zur Überprüfung

    

   
    /*
    Serial.println("========================================================");Serial.println(F(" "));
    File file = SPIFFS.open("/favicon-16x16.png", "r");
    if (!file) {
        Serial.println("Failed to open file for reading");
        return;
    }

    Serial.println("Reading file contents:");
    while (file.available()) {
        uint8_t buffer[16]; // Lesen wir in 16-Byte-Chunks
        size_t bytesRead = file.read(buffer, sizeof(buffer));
        
        for (size_t i = 0; i < bytesRead; i++) {
            Serial.print("0x");
            if (buffer[i] < 0x10) Serial.print("0"); // Führende Null hinzufügen
            Serial.print(buffer[i], HEX);
            if (i < bytesRead - 1) {
                Serial.print(", ");
            }
            esp_task_wdt_reset(); // Watchdog-Timer zurücksetzen
        }
        if (file.available()) {
            Serial.print(", "); // Komma am Ende der Zeile einfügen, falls es weitere Bytes gibt
        }
        Serial.println();
    }

    unsigned int fileSize = file.size();
    Serial.print("The size of the file is: ");
    Serial.print(fileSize);
    Serial.println(" bytes");

    file.close();
    Serial.println("========================================================");Serial.println(F(" "));
   */
    





     // Serial.println(p_APname_p);Serial.println(p_APname_c);





}  // SETUP






//  && knx_program_mode == 0

//----------------------------------------------------------------------------------------
void loop() {


      esp_task_wdt_reset();



    unsigned long task_currentMillis = millis();


    //--------------
    // Überprüfung für 1 Sekunde Intervall
    if (task_currentMillis - task_previousMillis1s >= task_interval1s) {
        task_previousMillis1s = task_currentMillis;
        //Serial.println(F("1 Sekunde Intervall"));
             
        
        Callback_tb_task();
        if(currentYearTwoDigits < 24 || currentYearTwoDigits > 60){
          Serial.print(F("!!!currentyear "));Serial.println(currentyear);
          Serial.print(F("!!!currentYearTwoDigits "));Serial.println(currentYearTwoDigits);
        }
    }
    //--------------


    //--------------
    // Überprüfung für 2 Sekunden Intervall
    if(knx_program_mode == 0){
      // Überprüfung für 2 Sekunden Intervall
      if (task_currentMillis - task_previousMillis2s >= task_interval2s) {
          task_previousMillis2s = task_currentMillis;
          Callback_2s();
      }
      if (task_currentMillis - task_previousMillis60m >= task_interval60m) {
          task_previousMillis60m = task_currentMillis;
          Callback_tb_FW();  //1h
      }
      if (task_currentMillis - task_previousMillis120m >= task_interval120m) {
          task_previousMillis120m = task_currentMillis;
          Callback_fail_FW();  //2h
      }
      if (task_currentMillis - task_previousMillis90m >= task_interval90m) {
          task_previousMillis90m = task_currentMillis;
          mb4Callback();  //90h
      } 
    }
    //--------------


    //--------------
    if(TB_currFwVersion == TB_newFwVersion && verzoegerung_fw_update == 0 && knx_program_mode == 0){
      //--------------
      // Überprüfung für 100 ms Intervall
      if (task_currentMillis - task_previousMillis100ms >= task_interval100ms) {
          task_previousMillis100ms = task_currentMillis;
          btCallback();
      }

      // Überprüfung für 30 Sekunden Intervall
      if (task_currentMillis - task_previousMillis30s >= task_interval30s) {
          task_previousMillis30s = task_currentMillis;
          Callback_30s();
      }
     // Überprüfung für 60 Sekunden Intervall
      if (task_currentMillis - task_previousMillis1m >= task_interval1m) {
          task_previousMillis1m = task_currentMillis;
          Callback_1m();
          #if TM_DEBUG_LEVEL >= TM_DEBUG_MAX
          Serial.print(F("t_uhrzeit: "));Serial.print(p_uhrzeit);Serial.print(F("   "));Serial.print(v_currenthour);Serial.print(F(":"));Serial.println(v_currentmin);
          #endif
      }
      //--------------
    }
    //--------------


    //--------------
    // Überprüfung für 100 Sekunden Intervall
    if (task_currentMillis - task_previousMillis100s >= task_interval100s) {
        task_previousMillis100s = task_currentMillis;
        Callback_tb_send();
    }
    //--------------




    //---------------------------------------------------------------------------------------
     if(time_update == true){
       
       time_update = false;
       
       get_time_vars();


        /*
        timeClient.update(); 
        currentSec = timeClient.getSeconds(); 
        currentmin = timeClient.getMinutes(); 
        currenthour = timeClient.getHours();
        currenthour12 = currenthour;

        unsigned long epochTimets = timeClient.getEpochTime();

        currentdate = day(epochTimets);
        currentmonth = month(epochTimets);
        currentyear = year(epochTimets);
        currentYearTwoDigits = currentyear % 100;
        */

     }
    //---------------------------------------------------------------------------------------



    
    currentPinStateknx = digitalRead(20); // Lese den Zustand von Pin 20



    //---------------------------------------------------------------------------------------
    if (factoryResetBit) {
        performFactoryReset();
    }
    //---------------------------------------------------------------------------------------




    //---------------------------------------------------------------------------------------
   // Überprüfe, ob eine Benachrichtigung gesendet werden soll
    if (sendNotification) {
            pTxCharacteristic->setValue(notificationMessage);
            pTxCharacteristic->notify();
            sendNotification = false;
            size_t message_length = strlen(notificationMessage);
            sentTraffic += message_length;
    }


    if (sendNotification_task) {
        xQueueSend(notificationQueue, (void*)&notificationMessage, portMAX_DELAY);
        // sendNotification wird jetzt in notificationTask zurückgesetzt
    }
    //---------------------------------------------------------------------------------------




    //---------------------------------------------------------------------------------------
     // Zeitumstellung prüfen und anpassen
     if(g_u_mez_ea_ist == 1 && Internt_online == true){        // aktiv und Internet verfügar
       checkAndAdjustNTPTime();
     }
    //---------------------------------------------------------------------------------------




    //---------------------------------------------------------------------------------------
      //*****************************************************************
      //************************ S E R I A L ****************************
      //*****************************************************************
      if (Serial.available()) {
          String input = Serial.readStringUntil('\n');
          parseSerialInput(input);
      }
      // handleSPrefix(

      // S90:1 Start BLE Server
      // S90:0 Stop  BLE Server

      // S91:1 Start BLE Beacon
      // S91:0 Stop  BLE Beacon

      // S33:1 Start NTP Update

      // G34:1 WLAN SACN

      //*****************************************************************
      //*****************************************************************
    //---------------------------------------------------------------------------------------




 
 
 





      if(g__boot_restart == true){
      
                  strip.setBrightness(g_LEDT_TB_ist);
                  uint8_t v_Colort = g_LEDT_T_color;     //green
                  colorWipe(strip.Color(m_color[v_Colort][0], m_color[v_Colort][1], m_color[v_Colort][2]), 1); 
       
        Preferences preferences;
        preferences.begin("eenvs", false);                         //Ordner eenvs anlegen/verwenden       
        g_boot_fail = 1;
        preferences.putUChar("boot_g_fail", g_boot_fail);    // 
        preferences.end();

        Serial.println(F("Done, Fast Reboot now"));
        delay(1000);
        esp_restart();

      }  



        // Nur speichern, wenn sich der Wert geändert hat
        if (currentColor != g_LEDT_T_color) {
            currentColor = g_LEDT_T_color; 
            Preferences preferences;
            preferences.begin("eenvs", false);                         //Ordner eenvs anlegen/verwenden   
            preferences.putUChar("p_LEDT_color", g_LEDT_T_color); // Top LED
            preferences.end();
        }




          if(disable_server >= 1 && TB_currFwVersion == TB_newFwVersion) {


              webSocket.loop();

          }





      if(set_g40 == true){
        
        set_g40 = false;
         
        //read_log_entry_by_index(set_g40_var);
        read_log_entry_by_index2(set_g40_var);
        
      
        //Serial.print("[BT] G40: ");Serial.println(set_g40_var);  
        set_g40_var ++;
        String tempstr = "\r\n" ;  
        tempstr += String(set_g40_var);
        tempstr += "\r\n" ;
        pTxCharacteristic->setValue(tempstr.c_str());
        pTxCharacteristic->notify();
        size_t message_length = strlen(tempstr.c_str());
        sentTraffic += message_length;  

      }





      if(set_g42 == true){
        
        Serial.println(F("set_g42"));
        set_g42 = false;
         
        
        if (loggingEnabled) {
          //things_list_t_16 = p_uhrzeit + "  [IF] Testeintrag " + String(testcounter); 
          write_to_log(things_list_t_16);
        }
        testcounter ++;          
        Serial.print(F("[BT] G42: "));Serial.println(testcounter);  

      }




      //-----------------------------------------------
      if(set_g43 == true){
        
        set_g43 = false;
         
        debug_log_files();
      
        Serial.println(F("[BT] G43"));
        String tempstr = "\r\n" ;  
        tempstr += String(set_g40_var);
        tempstr += "\r\n" ;
        pTxCharacteristic->setValue(tempstr.c_str());
        pTxCharacteristic->notify();
        size_t message_length = strlen(tempstr.c_str());
        sentTraffic += message_length;  

      }
      //-----------------------------------------------




      
      //-----------------------------------------------
      if(set_bit_wait_front_view == true){

          unsigned long f_currentMillis = millis();
          if (f_currentMillis - f_previousMillis >= f_interval) {
           
            f_previousMillis = f_currentMillis;
             // String TB_currFwVersion_test = "1.27.5";
            displayFirmwareVersion(TB_currFwVersion);

                  if (millis() - transferCompleteTime >= 10000) {
                    set_bit_wait_front_view = false;
                  }
          }
      }
      //-----------------------------------------------


  







      //--------------------------------------------------------------------------
      //-----------------------------------
      if(g_KNX_S_ist == 1){
        if (knx_program_mode == 1 ||millis() - startMillisknx >= 60000) {  
       
              // don't delay here to much. Otherwise you might lose packages or mess up the timing with ETS
              knx.loop();

              // only run the application code if the device was configured with ETS
              if (knx.configured()){
                uint8_t timeUnit = knx.paramByte(1); // Lese das paramByte von KNX
                handleTimeUnit(currentmin, timeUnit);  
              

                 
                  if (loggingEnabled) {
                    //things_list_t_16 = p_uhrzeit + "  [KX] KNX-Daten gesendet";
                    write_to_log(things_list_t_16);
                    
                    }
            
              }


            //---------------------------------------------------
              currentPinStateknx = digitalRead(20); // Lese den Zustand von Pin 20 = digitalRead(20); // Lese den Zustand von Pin 20
              if (currentPinStateknx != previousPinState) { // Überprüfe, ob sich der Zustand geändert hat
                  if (currentPinStateknx == HIGH) {
                      g_LEDT_T_KNX = 1;
                      //g_progLedOn();
                      strip.setBrightness(130);
                      v_Colortknx = 1;    
                      //  0=aus     1=rot   2=grün  3=blau    4=weiss    5=orange   6=lila  
                      colorWipe2(strip.Color(m_color[v_Colortknx][0], m_color[v_Colortknx][1], m_color[v_Colortknx][2])); 

                      lastChangeTime = millis(); // Speichere die aktuelle Zeit
                      //Serial.println("-progLedOn");
                  } else {
                      //g_progLedOff();
                      strip.setBrightness(0);
                      v_Colortknx = 0;    
                      //  0=aus     1=rot   2=grün  3=blau    4=weiss    5=orange   6=lila  
                      colorWipe2(strip.Color(m_color[v_Colortknx][0], m_color[v_Colortknx][1], m_color[v_Colortknx][2])); 

                      lastChangeTime = millis(); // Speichere die aktuelle Zeit
                      //Serial.println("-progLedOff");
                  }
              }
              previousPinState = currentPinStateknx; // Aktualisiere den vorherigen Zustand
              
              if (g_LEDT_T_KNX == 1) { 
                if (currentPinStateknx == false) { 
                  if (!knx.progMode()) { // Überprüfe, ob der Programmiermodus deaktiviert ist
                    if (millis() - lastChangeTime >= 6000) { // Überprüfe, ob 6 Sekunden vergangen sind
                        g_LEDT_T_KNX = 0;
                        Serial.println("g_LEDT_T_KNX=0");
                        g_t_led_change = true;
                    }
                  }
                }
              }

              //---------------------------------------------------
              if (g_LEDT_T_KNX == 1) { 
                // Initialisierung des Displays
                lc.setIntensity(15); // Helligkeit
                // KNX-Adresse anzeigen
                //Serial.print("displayKNXAddress ");Serial.println(device);
                
                uint8_t areaLine = storedData[12];
                uint8_t device = storedData[13];
                uint8_t areat = areaLine >> 4;
                uint8_t linet = areaLine & 0x0F;
                //String knx_address = String(areat) + "." + String(linet) + "." + String(device);
                
                displayKNXAddress(areat, linet, device);
              }

              //---------------------------------------------------
        }
      }
     //--------------------------------------------------------------------------


if(knx_program_mode == 0){

     //--------------------------------------------------------------------------
      if ((WiFi.status() == WL_CONNECTED && previous_wlan_count == 0 && g_wlan_read == false) || previous_wlan_count == -2) {
        g_wlan_read = true;

                lc.setIntensity(15); //5=Standard   Helligkeit forne
                lc.setChar(0,0,'S',false);
                lc.setChar(0,1,'c',false);
                lc.setChar(0,2,'a',false);
                lc.setChar(0,3,'n',false);
                delay(100);


                int ns = WiFi.scanNetworks();
                int nf = ns;
                int valid_wlan_count = 0; // Variable to count valid WLANs
                Serial.print(F("[BT] Scan done. WLAN Found: "));
                Serial.println(ns);

                char tempstr[110];

                snprintf(tempstr, sizeof(tempstr), "Found:%d\r\n", wlan_found);

                int length2 = strlen(tempstr);
                strncpy(find_wlan, tempstr, length2 + 1);

                if (ns > 0) {
                    if (nf > 0) {
                        if (!SPIFFS.begin(true)) {
                            Serial.println(F("An Error has occurred while mounting SPIFFS"));
                            return;
                        }

                        File file = SPIFFS.open("/wlan_data.txt", FILE_WRITE);
                        if (!file) {
                            Serial.println(F("Failed to open file for writing, creating file..."));
                            file = SPIFFS.open("/wlan_data.txt", FILE_WRITE);
                            if (!file) {
                                Serial.println(F("Failed to create file"));
                                return;
                            }
                        }

                        for (int i = 0; i < ns; i++) {
                            char ssid[50];
                            strncpy(ssid, WiFi.SSID(i).c_str(), sizeof(ssid) - 1);
                            ssid[sizeof(ssid) - 1] = '\0';

                            if (strlen(ssid) > 0) { // Check if SSID is not empty
                                valid_wlan_count++; // Increment valid WLAN count
                                snprintf(tempstr, sizeof(tempstr), "%d,|%s,|%s,|%d dBm, %d%%,|",
                                        i, ssid, WiFi.BSSIDstr(i).c_str(), WiFi.RSSI(i),
                                        constrain(2 * (WiFi.RSSI(i) + 100), 0, 100));

                                encryption = WiFi.encryptionType(i);
                                if (encryption == 0) {
                                    strncat(tempstr, "OPEN", sizeof(tempstr) - strlen(tempstr) - 1);
                                } else if (encryption == 1) {
                                    strncat(tempstr, "WEP", sizeof(tempstr) - strlen(tempstr) - 1);
                                } else if (encryption == 2) {
                                    strncat(tempstr, "WPA", sizeof(tempstr) - strlen(tempstr) - 1);
                                } else if (encryption == 3) {
                                    strncat(tempstr, "WPA2", sizeof(tempstr) - strlen(tempstr) - 1);
                                } else if (encryption == 4) {
                                    strncat(tempstr, "WPA+WPA2", sizeof(tempstr) - strlen(tempstr) - 1);
                                } else if (encryption == 5) {
                                    strncat(tempstr, "WEP", sizeof(tempstr) - strlen(tempstr) - 1);
                                } else if (encryption == 7) {
                                    strncat(tempstr, "NONE", sizeof(tempstr) - strlen(tempstr) - 1);
                                } else if (encryption == 8) {
                                    strncat(tempstr, "AUTO", sizeof(tempstr) - strlen(tempstr) - 1);
                                } else {
                                    strncat(tempstr, "unknown", sizeof(tempstr) - strlen(tempstr) - 1);
                                }

                                Serial.print(F("[BF] "));
                                Serial.println(tempstr);

                                strncat(tempstr, "\r\n", sizeof(tempstr) - strlen(tempstr) - 1);
                                file.print(tempstr);
                            }
                        }

                        file.close();
                        WiFi.scanDelete();
                        g_scan_start = false;
                        g_connect_WLAN = false;
                        nf = 0;
                        ns = 0;
                    }
                }

                wlan_found = valid_wlan_count; // Update wlan_found with the count of valid WLANs
                scanResult_n = valid_wlan_count; // Update scanResult_n with the count of valid WLANs
                Serial.print(F("[BT] Save done. Aktuelle WLAN Anzahl: "));
                Serial.println(valid_wlan_count);


        
       
        if(valid_wlan_count == 0){valid_wlan_count = -1;}    // -1= kein WLAN gefunden 

        Preferences preferences;
        preferences.begin("eenvs", false);                         //Ordner eenvs anlegen/verwenden
        preferences.putInt("wlan_count", valid_wlan_count);  // -1= kein WLAN gefunden   0= Speicher neu    -2= Restart,suche starten    >0= WLAN im Speicher
        previous_wlan_count = valid_wlan_count;
        preferences.end(); 

        g_wlan_read = false;
        // g_scan_start2 = true;     // gespeicherte WLAN Ausgeben mit BT und Seriell 
        // g_scan_alternative = true; // lesen aus datei ofer false= live
        // readAndSendData(x);       // Funktion der Ausgabe
        // previous_wlan_count = 0;  // Erneut WLAN suchen, aber vorher mit HEAP überprüfen - oder mit g_scan_start = true inkl. überprüfung

    } 
    //--------------------------------------------------------------------------





    //--------------------------------------------------------------------------
    if(p_mqonoff == true){
     
      if(write_to_mqtt == true){
       
          write_to_mqtt = false;
          unsigned long mqtt_currentMillis = millis();
          if (mqtt_currentMillis - mqtt_previousMillis >= mqtt_interval) {
            mqtt_previousMillis = mqtt_currentMillis;
            if (!mqttClient.connected()) {
              reconnectmqtt();
            }
            
              if (mqttClient.connected()) {
                  uint32_t positionlen = p_inputmqtopic.length();
                  if (positionlen >= 1) { 
                      //#ifdef MQTT_DEBUG
                      Serial.print(F("[MQ] MQTT Topic: "));
                      Serial.println(p_inputmqtopic);
                      Serial.print(F("[MQ] MQTT Value: "));
                      Serial.println(String(mb_radon_ist_word));
                      //#endif
                      mqttClient.publish(p_inputmqtopicc, String(mb_radon_ist_word).c_str());
                      if (disable_server >= 1) { 
                          if (loggingEnabled) {
                              //things_list_t_16 = p_uhrzeit + F("  [MQ] MQTT-Daten gesendet");
                              write_to_log(things_list_t_16);
                          }
                      }
                  }
              }

 
          }

      }

      mqttClient.loop();
    }
    
    //--------------------------------------------------------------------------






   if(g_save_attribut == true){
    g_save_attribut = false;

    saveAttribute();
   }






    if(gFW_Update_start == 0 && akt_fw_load == false && g_LEDT_T_KNX == 0 && g_identify == false && set_bit_wait_front_view == false){ 
      //-----------------------------------------------------------
      if(g_LEDT_F_ist == 0){
      
        //lc.setRow(0,0,0);
        //lc.setRow(0,1,0);
        //lc.setRow(0,2,0);
        //lc.setRow(0,3,0);
        lc.setRow(0,0,0x00);
        lc.setRow(0,1,0x00);
        lc.setRow(0,2,0x00);
        lc.setRow(0,3,0x00);
                  
        ledcWrite(ledChannel27, 0);              //   GPIO27  AM
        ledcWrite(ledChannel25, 0);              //   GPIO37  PM
        ledcWrite(ledChannel26, 0);              //   GPIO38  NTP
        ledcWrite(ledChannel14, 0);              //   GPIO14  WLAN 
        ledcWrite(ledChannel2, 0);               //   GPIO02  Bqm3
            
      }else{
      
        //------------------------------

        //------------------------------

        //------------------------------
        if (WiFi_status == WL_CONNECTED) {              
          ledcWrite(ledChannel14, dutyCycle_t215);          //   GPIO14  WLAN
        }
        //------------------------------
       
       
        //------------------------------
        if (startplayer == false) {
          if(g_switch_anzeige == 0){    // g_switch_anzeige == 0 = Radon
             
              if(g_unit_ist == 1){  
                  ledcWrite(ledChannel2, dutyCycle_t215);    //   GPIO02  Bq/m³
                  ledcWrite(ledChannel15, 0);                //   GPIO15  PcI/L             
              }else{
                  ledcWrite(ledChannel15, dutyCycle_t215);  //   GPIO15  PcI/L
                  ledcWrite(ledChannel2, 0);                //   GPIO02  Bq/m³
              } 

              if(update_ntp_ready == 1){
                ledcWrite(ledChannel26, 0);  //   GPIO38  NTP
              }

          }else{

            ledcWrite(ledChannel2, 0);                //   GPIO02  Bq/m³
            ledcWrite(ledChannel15, 0);                //   GPIO15  PcI/L  

            if(update_ntp_ready == 1){
              ledcWrite(ledChannel26, dutyCycle_t215);  //   GPIO38  NTP
            }

          }
        }
        //------------------------------

        //------------------------------
        if(g_switch_anzeige == 0){    // g_switch_anzeige == 0 = Radon

            ledcWrite(ledChannel27, 0);              //   GPIO27  AM
            ledcWrite(ledChannel25, 0);              //   GPIO37  PM
            ledcWrite(ledChannel,  0);               //           dp
            ledcWrite(ledChannel26, 0);             //   GPIO38  NTP


        }else{


          if(g_u_clock_ist == 1 || g_u_clock_ist == 3){ 
                     
                    if(g_u_clock_ist == 1){ 
                      //lc.setChar(0,3,char(m_einer),false);     //   24h version
                    }
                    if(g_u_clock_ist == 3){ 
                      //lc.setChar(0,3,char(m_einer),false);     //   Datum
                    }
                    ledcWrite(ledChannel27, 0);                //   GPIO27  AM
                    ledcWrite(ledChannel25, 0);                //   GPIO37  PM

               
                    if(g_u_clock_ist == 3){                    //  Monat und Tag
                      tick2 = true;
                      ledcWrite(ledChannel,  0);               //           dp
                      lc.setChar(0,1,char(h_einer),true); 
                    }else{
                      lc.setChar(0,1,char(h_einer),false); //tick2
                    }
                    //lc.setChar(0,2,char(m_zehner),false);
                    //lc.setChar(0,0,char(h_zehner),false);


          }else{ 
                       
                byte valuet = v_currenthour;               
                //Serial.print("valueta ");Serial.println(valuet);

                if(g_u_clock_ist == 1){ 
                  valuet = v_currenthour;
                }
                if(g_u_clock_ist == 2){ 
                  //valuet = atoi(timeHour12h); 
                  currenthourAM_PM = false;
                  currenthour12 = v_currenthour;  
                  currenthourAM_PM = false;
                  if( currenthour12 == 0 ){currenthour12 = 12;currenthourAM_PM = true;}
                  if( currenthour12 > 12 ){currenthour12 = currenthour12 - 12;currenthourAM_PM = true;}
                  valuet = currenthour12;  // hour12h  
                }    
                //Serial.print("valuetb ");Serial.println(valuet);                            
               
                //---------------- 
                if(g_u_clock_ist <= 2){ 
                  h_einer = valuet % 10;
                  h_zehner = (valuet / 10) % 10;

                  m_einer = v_currentmin % 10;
                  m_zehner = (v_currentmin / 10) % 10;
                }

                if(g_u_clock_ist == 3){ 
                  h_einer = day % 10;
                  h_zehner = (day / 10) % 10;

                  m_einer = month % 10;
                  m_zehner = (month / 10) % 10;
                }
                //---------------- 

                  //---------------- 
                  
                  if(g_u_clock_ist != 3){ 
                    if(h_zehner==0){
                      lc.setChar(0,0,' ',false); 
                    }else{
                      lc.setChar(0,0,char(h_zehner),false); 
                    }

                  }
                  lc.setChar(0,1,char(h_einer),false); 
                  lc.setChar(0,2,char(m_zehner),false);
                  //---------------- 

                    if(g_u_clock_ist == 2){ 
                      if(currenthourAM_PM == true){
                        lc.setChar(0,3,char(m_einer),false);   //   12h version   nachmittags
                        ledcWrite(ledChannel27, 0);            //   GPIO27  AM
                        if(g_LEDT_F_ist == 1){ 
                        ledcWrite(ledChannel25, dutyCycle_t215);  //   GPIO37  PM
                        }
                      }else{
                        lc.setChar(0,3,char(m_einer),false);   //   12h version   vormittags
                        if(g_LEDT_F_ist == 1){ 
                        ledcWrite(ledChannel27, dutyCycle_t215);  //   GPIO27  AM
                        }
                        ledcWrite(ledChannel25, 0);            //   GPIO37  PM
                      }
                      if(update_ntp_ready == 1){ledcWrite(ledChannel26, dutyCycle_t215);} //   GPIO38  NTP
                  } else{
                     ledcWrite(ledChannel27, 0);            //   GPIO27  AM
                     ledcWrite(ledChannel25, 0);            //   GPIO37  PM
                     lc.setChar(0,3,char(m_einer),false); 
                     if(update_ntp_ready == 1){ledcWrite(ledChannel26, 0);} //   GPIO38  NTP
                  }

              //Serial.print("h_zehnera ");Serial.println(h_zehner);  
              //Serial.print("m_zehnera ");Serial.println(m_zehner); 
              //Serial.print("h_einera ");Serial.println(h_einer); 
              //Serial.print("m_zehnera ");Serial.println(m_zehner); 


          }


        }
        //------------------------------

      
      } //g_LEDT_F_ist == 1
      //-----------------------------------------------------------
    }else{
       
        ledcWrite(ledChannel27, 0);              //   GPIO27  AM
        ledcWrite(ledChannel25, 0);              //   GPIO37  PM
        ledcWrite(ledChannel26, 0);              //   GPIO38  NTP
        ledcWrite(ledChannel14, 0);              //   GPIO14  WLAN 
        ledcWrite(ledChannel2, 0);               //   GPIO02  Bqm3
        ledcWrite(ledChannel,  0);               //           dp

    }
    //--------------------------------------------------------------



    if(set_bit_wait_front_view == true || g_Seg__boot_ani == true ){  
      
        ledcWrite(ledChannel27, 0);              //   GPIO27  AM
        ledcWrite(ledChannel25, 0);              //   GPIO37  PM
        ledcWrite(ledChannel26, 0);              //   GPIO38  NTP
        ledcWrite(ledChannel14, 0);              //   GPIO14  WLAN 
        ledcWrite(ledChannel2, 0);               //   GPIO02  Bqm3
        ledcWrite(ledChannel,  0);               //           dp

    }



        if(set_BT_time == true){
          set_BT_time = false;
        // Serial.println("call_time_set_g 4");
          call_time_set_g();
          //---------------------------------------------------------------
                    /* 
                        Serial.print("[TM] ESP Epoch Time: ");Serial.println(epochTime_esp);  
                        //Serial.println("[TM] Sensor Start: " + String(epochTime_start));  
                        //Serial.println("[TM] Sensor diff: " + String(epochTime_diff)); 
                        //}
                        long epoch=epochTime_esp  ; //ADD 2 Hours (For GMT+2) Sommer   MQTT publish new Data
                        // print the hour, minute and second:
                        int hr=(epoch  % 86400L) / 3600;
                        int min=(epoch % 3600) / 60;
                        //int sec=(epoch % 60);
                        Serial.print("[TM] Epoch ESP  Time ");Serial.print(hr);Serial.print(":");Serial.println(min);
                      
                        long epoch3=epochTime_rtc  ; //ADD 2 Hours (For GMT+2) Sommer   MQTT publish new Data
                        // print the hour, minute and second:
                        int hr3=(epoch3  % 86400L) / 3600;
                        int min3=(epoch3 % 3600) / 60;
                        //int sec2=(epoch % 60);
                        Serial.print("[TM] Epoch RTC Time ");Serial.print(hr3);Serial.print(":");Serial.println(min3);

                        long epoch2=epochTime_mqtt  ; //ADD 2 Hours (For GMT+2) Sommer   MQTT publish new Data
                        // print the hour, minute and second:
                        int hr2=(epoch2  % 86400L) / 3600;
                        int min2=(epoch2 % 3600) / 60;
                        //int sec2=(epoch % 60);
                        Serial.print("[TM] Epoch MQT Time ");Serial.print(hr2);Serial.print(":");Serial.println(min2);


                        time_t now;
                        long epoch4 = time(&now);     // Zeit mit Zeitzone und Sommer Winter Offset
                        epoch4=epoch4  ; //ADD 2 Hours (For GMT+2) Sommer   MQTT publish new Data
                        // print the hour, minute and second:
                        int hr4=(epoch4  % 86400L) / 3600;
                        int min4=(epoch4 % 3600) / 60;
                        //int sec2=(epoch % 60);
                        Serial.print("[TM] Epoch now Time ");Serial.print(hr4);Serial.print(":");Serial.println(min4);


                        Serial.println("[TM] Timezone = " + printLocalTimezone());

                        // setEpochTime
                        Serial.print("[TM] Epoch: ");Serial.print(timeClient.getEpochTime());Serial.print(" | ");Serial.print(timeClient.getHours());Serial.print(":");Serial.println(timeClient.getMinutes());

                        if(currenthourAM_PM == false){
                          Serial.println("[TM] AM = " + String(currenthour12));
                        }else{
                          Serial.println("[TM] PM = " + String(currenthour12));
                        }
                        */
                      //---------------------------------------------------------------
        }
                  

          #ifdef ea_webserver
          #ifdef j_2_webserver
          if(getfreesize > getfreesize_v && g_end_boot_time == 0){
            if(disable_server >= 1 && TB_currFwVersion == TB_newFwVersion) {
              if(webserver_aktiviert == 1){ 
                server3.handleClient();
              }
            }
          }
          #endif
          #endif



       if(mb_stufen_read == true){

        mb_stufen_read = false;
        mb_read_stufen();


       }




   //--------------------------------------------------------------
   //--- alle 1h RTC Time zu ESP Time kopieren
     
     // if Time Diff ms: 0    
     
       // if(epochTime_r_e_diff >= 40) { 
      unsigned long rtc_currentMillis3 = millis();
      if (rtc_currentMillis3 - rtc_previousMillis3 >= rtc_interval) {
        rtc_previousMillis3 = rtc_currentMillis3;
        if(g_set_esp_clock == true) {

          bool h_esp_rtc = false;
          if(rtc_hour != v_currenthour && rtc_minute >= 10 && rtc_minute <= 50 && g_h_esp_rtc == false) {
              TM_DEBUG_MAX_PRINT(F("rtc_hour: "));
              TM_DEBUG_MAX_PRINTLN(rtc_hour);
              TM_DEBUG_MAX_PRINT(F("v_currenthour: "));
              TM_DEBUG_MAX_PRINTLN(v_currenthour);
              TM_DEBUG_MAX_PRINT(F("rtc_minute: "));
              TM_DEBUG_MAX_PRINTLN(rtc_minute);
              TM_DEBUG_MAX_PRINT(F("g_h_esp_rtc: "));
              TM_DEBUG_MAX_PRINTLN(g_h_esp_rtc);

              h_esp_rtc = true;
              TM_DEBUG_MAX_PRINTLN(F("[TM] Uhrzeit RTC und ESP32 unterschiedlich"));
              g_h_esp_rtc = true;
          }

          if(rtc_hour == v_currenthour){
            g_h_esp_rtc = false;
          }


          //if(currentmin == 2 || rtc_year >= 65 || h_esp_rtc == true) {  //22
            if(rtc_year >= 65 || h_esp_rtc == true) {  
                g_set_esp_clock = false;

                //TM_DEBUG_MAX_PRINTLN("call_time_set_g 5");
                call_time_set_g();

                echo_clock_info();

                if(update_rtc_ready == 1) { // nur wenn RTC gestellt wurde
                    TM_DEBUG_MAX_PRINTLN(F("[TM] Uhrzeit wird von RTC übernommen und gestellt"));
                    
                    read_clock_RTC();
                    call_time_set_sommer_winter();

                    struct timespec tp;
                    if(rtc_hour != v_currenthour) {
                        TM_DEBUG_MAX_PRINTLN(F("[TM] Timezone und Sommer-Windter stellen, da falsch bei nicht NTP"));
                        call_time_set_timezone(); // ändere Zeitzone inkl. Sommer winter
                        tp.tv_sec = epochTime_esp + noNTPOffset_sec;      // + daylightOffset_sec;
                    }
                    clock_settime(CLOCK_REALTIME, &tp);

                    //setTime(2021,10,31,0,59,50,0);    // Set it to 1 minute before daylight savings comes in.

                    //Winter | MEZ

                    TM_DEBUG_MAX_PRINT(F("[TM] read_clock_esp32: "));
                    read_clock_esp32(); 
                    TM_DEBUG_MAX_PRINT(F("[TM] ESP time "));
                    TM_DEBUG_MAX_PRINTLN(epochTime_esp);

                    g_set_esp_clock = false;
                }
            }

        }
       // }
      }

      if(currentmin >= 4 || currentmin <= 1) { //34   18
        g_set_esp_clock = true;
      }
 
   //--------------------------------------------------------------






  //------------------------------------------
   if(send_bl_status == true){
       send_bl_status = false;

  


   }
  //------------------------------------------





  //------------------------------------------
  if (WiFi_status == WL_CONNECTED) {
     
     count_InitWiFi = 0;


  }

  if(g_TB_connect_Status == true){ 
     
     count_InitTB = 0;

  }
  //------------------------------------------







  //------------------------------------------
     if(g_time_s ==  true){
     
        g_time_s = false;

          temp_esp_int = ESP32temp * 10;
          float temperature;
          temp_sensor_read_celsius(&temperature);
          ESP_LOGI("TEMP_SENSOR", "Chip temperature: %.2f °C", temperature);
          //int measurement = 0;
          //measurement = hallRead();
          //hall_measurement = measurement;
          //Serial.print("Hall sensor measurement: ");
          //Serial.println(hall_measurement); 


     }
  //------------------------------------------




  //------------------------------------------
    if (counter_Attribute > 0) {
        currentTime_Attribute = millis();
      // Überprüfen, ob 2 Sekunden vergangen sind, ohne dass der Zähler erhöht wurde
      if (currentTime_Attribute - lastPrintTime_Attribute >= 10000) {
          #if TB_DEBUG_LEVEL >= TB_DEBUG_MAX
          Serial.printf("[TB] Lesen Shared Attribute beim Booten und bei Anforderung - Anzahl der Anfragen: %d\n", counter_Attribute);
          Serial.println(F(" "));
          #endif
          lastPrintTime_Attribute = currentTime_Attribute; // Reset the timer
          counter_Attribute = 0; // Reset the counter
          g_wlan_check_start = true;
      }
    }
  //------------------------------------------



    //----------- KALIBRIEREN -----------
    if(b_calibrieren == true){    // Sensor öffnen

      // Sensor wird geöffnet  mit 1              starten Sensor öffnen


        // alle 1min*5  =  5min
        if(millis() - ms2 > (60000*10)){

              ms2 = millis(); 

              //kal_vars_read = false;
              //mb_read_cal_vals();    

        }
        
        if(kal_vars_read == true){

              kal_vars_read = false;
             
                  #ifdef MB_KAL_DEBUG
                      Serial.println(F("[CL] Calc Kalibrier Attribute"));
                      Serial.print(F("[KL] G31_KEY: ")); 
                      Serial.println(mb_radon_F3_eintrarge_last); 
                      Serial.println(F("--"));
                      Serial.print(F("[KL] G09_KEY: ")); 
                      Serial.println(mb_cal12); 
                      Serial.print(F("[KL] G33_KEY: ")); 
                      Serial.println(mb_cal12_send); 
                      Serial.println(F("--"));
                      Serial.print(F("[KL] G12_KEY: ")); 
                      Serial.println(mb_cal13); 
                      Serial.print(F("[KL] G33_KEY: ")); 
                      Serial.println(mb_cal13_send); 
                      Serial.println(F(" "));
                  #endif

                  mb_radon_F3_eintrarge_last++;
                  mb_cal12_send = mb_cal12_send + mb_cal12;
                  mb_cal13_send = mb_cal13_send + mb_cal13;

                  #ifdef MB_KAL_DEBUG
                      Serial.println(F("[CL] Sum Kalibrier Attribute"));
                      Serial.print(F("[KL] G31_KEY: ")); 
                      Serial.println(mb_radon_F3_eintrarge_last); 
                      Serial.println(F("--"));
                      Serial.print(F("[KL] G33_KEY: ")); 
                      Serial.println(mb_cal12_send); 
                      Serial.print(F("[KL] G33_KEY: ")); 
                      Serial.println(mb_cal13_send); 
                      Serial.println(F(" "));
                  #endif

     


              #ifdef MB_KAL_DEBUG
              Serial.println("[CL] Send Kalibrier Attribute...");
              #endif

                  //----------------------------
                  //Serial.println("-------attribute_items_t 10------");
                    //const int attribute_items_20 = 10;
                    Attribute attributes20[10] = {
                      { C_KALIBRIERT_KEY,  1 },
                      { G08_KEY,  Radon_live_value },
                      { G30_KEY,  Radon_12h_ist },
                      { G09_KEY,  mb_cal12 },
                      { G12_KEY,  mb_cal13 },
                      { G31_KEY,  mb_radon_F3_eintrarge_last },
                      { G32_KEY,  mb_cal12_send },
                      { G33_KEY,  mb_cal13_send },
                      { G34_KEY,  radon_2h_ist },
                      { G52_KEY,  mb_radon_F3_Version },
                    };
                    tb.sendAttributes(attributes20, 10);delay(200);

                      #ifdef MB_KAL_DEBUG
                          Serial.print(F("[KL] G31_KEY: ")); 
                          Serial.println(mb_radon_F3_eintrarge_last); 
                          Serial.print(F("[KL] G32_KEY: ")); 
                          Serial.println(mb_cal12_send); 
                          Serial.print(F("[KL] G33_KEY: ")); 
                          Serial.println(mb_cal13_send); 
                          Serial.print(F("[KL] G34_KEY: ")); 
                          Serial.println(radon_2h_ist); 
                          Serial.println(F(" "));
                      #endif

                  //----------------------------


        }


        // 00:00    u_kalibrieren  =  1    //kalibrieren starten     !! erkennen ob sensor geöffnet wurde sonst abbrechen das Kalibrieren
        // 



      
    }
    //-----------------------------------



    //----------------- Rereed ------------------
      if(disable_server >= 1 && TB_currFwVersion == TB_newFwVersion) {
        if(g_set_mb_reload == false){  
          if(cb_g_mb_sensor == false){
            if(cb_sensor_mb_ok == 1 && cb_sensor_mb_time == 0 && cb_sensor_mb_count < 5){
          

              cb_sensor_mb_time = 5;
              g_set_mb_reload = true;
              //Serial.println("-------new ask------");
              
                mb3Callback();
    
              

            }
          }
        }
      }


      if(g_set_mb_reload == true && cb_sensor_mb_time == 0){  
        g_set_mb_reload = false;
      }

    //-----------------------------------






   #ifdef siebenSegment      // Callback_Segment_task



    //-----------------------------------
    if(g_identify == true && g_identify_byte_temp != g_identify_byte){

         g_identify_byte_temp = g_identify_byte;
         //Serial.println(g_identify_byte_temp); 
          
          showcolor(6,220);  
          led_farbe = 4;
        
          lc.setIntensity(15); //5=Standard   Helligkeit forne
          switch(g_identify_byte) {
            case 0: 
              lc.setChar(0,0,'8',false);
              lc.setChar(0,1,' ',false);
              lc.setChar(0,2,' ',false);
              lc.setChar(0,3,' ',false);
              break;
            case 1: 
              lc.setChar(0,0,' ',false);
              lc.setChar(0,1,'8',false);
              lc.setChar(0,2,' ',false);
              lc.setChar(0,3,' ',false);
              break;
            case 2:
              lc.setChar(0,0,' ',false);
              lc.setChar(0,1,' ',false);
              lc.setChar(0,2,'8',false);
              lc.setChar(0,3,' ',false);
              break;
            case 3: 
              lc.setChar(0,0,' ',false);
              lc.setChar(0,1,' ',false);
              lc.setChar(0,2,' ',false);
              lc.setChar(0,3,'8',false);
              break;
            default: 
              lc.setChar(0,0,' ',false);
              lc.setChar(0,1,' ',false);
              lc.setChar(0,2,' ',false);
              lc.setChar(0,3,' ',false);
              break;
          } 

    }
    //-----------------------------------



  if(g_kalibrieren_ist == 0 && g_checken_ist == 0 && g_kal_write_ist == 0 && g_identify == false){
   
    if(gFW_Update_start == 1){




      



      if(WiFi.status() == WL_CONNECTED){
          
         WiFi_status = WL_CONNECTED;

    
            if(TB_currFwVersion != TB_newFwVersion && schreib_sperre == false){
              lc.setIntensity(g_LEDT_FB_ist); //5=Standard   Helligkeit forne
              lc.setChar(0,0,'L',false);
              lc.setChar(0,1,'o',false);
              lc.setChar(0,2,'a',false);
              lc.setChar(0,3,'d',false);

              
              
              if(g_set_new_FW == false){
                g_set_new_FW_time = 0;
              }
              g_set_new_FW = true;
            }

         
          if(TB_currFwVersion == TB_newFwVersion){
            gFW_Update_start = 0; // 1= neue FW verfügbar
            Preferences preferences;
            preferences.begin("eenvs", false);                         //Ordner eenvs anlegen/verwenden
            preferences.putUChar("fw_s_upd", gFW_Update_start);    //  0=Standard  aus 
            gFW_counter = 0;
            preferences.putUChar("fw_counter", gFW_counter); 

            //Serial.println("[MB] mb_read_radon  --  Sensor 4"); 
            mb_read_radon();

          }

      }
    }


    // debugVariables
    // Front Segmentanzeige ist aktiviert  
    //                      und kein FW update           anzeige ein
    if(g_view_fw == false  && gFW_Update_start == 0 && g_LEDT_F_ist > 0 && g_LEDT_T_KNX == 0){ 

       if(set_bit_wait_front_view == false){ 
    
          //    kein FW update           anzeige ein
          //if(g_view_fw == false  && gFW_Update_start == 0){   //12077-12590
          if(verzoegerung_fw_update == 0){ 
            if(g_switch_anzeige == 0){   

                  ledcWrite(ledChannel, 0);


              
              
                  if(g_sensor_online > 2 && Segment_no_sensor == true){
                        Segment_no_sensor = false;
                        lc.setChar(0,0,'n',false);
                        lc.setChar(0,1,'o',false);
                        lc.setChar(0,2,' ',false);
                        //lc.setRow(0,2,0);
                        lc.setChar(0,3,'S',false);
                    
                        strip.setBrightness(150);
                        colorWipe(strip.Color(m_color[4][0], m_color[4][1], m_color[4][2]), 5);  
                  }

                  //Serial.println("-------getRow0------");
                                             
                  //                                                         werte empfangen        segment ein       
                  if(g_Seg__boot_ani == false && gFW_Update_start == 0 && g_sensor_online <= 2 && g_LEDT_F_ist == 1 && akt_fw_load == false && g_LEDT_T_KNX == 0){
                    if(Segment_task == true || g_radon_new_seg == true){ 
                      
                      //dutyCycle_t = 0;
                      
                      Segment_task = false;
                      g_radon_new_seg = false;
                      ledcWrite(ledChannel, 0); //dp
                      
                                                      uint32_t radon_temp;
                        float radon_temp_f; 

                        //g_unit_ist = 1;  
                        //Serial.println("-------------");

                        radon_temp = mb_radon_ist_long;
                        //radon_temp = random(950,1050);
                        //radon_temp = 420;
                        //Serial.print("a Radon bqm ");Serial.println(radon_temp);

                        radon_temp_f = radon_temp / 37.00;    //1 pCi/L entspricht 37 Bq/m3
                        //radon_temp_f = radon_temp_f * 100;
                        //Serial.print("b Radon pci ");Serial.println(radon_temp_f);

                    
                      if(g_unit_ist == 0){   

                        //if(radon_temp_f < 0.01){
                          //radon_temp = radon_temp_f * 1000;
                          // Serial.print("<0,01  | ");Serial.print(radon_temp_f);Serial.println(" 3");
                        dot_pos = 4; // 4 = aus
                        if(radon_temp_f < 0.1) {
                          radon_temp = radon_temp_f * 100;
                          dot_pos = 3; // 4 = aus
                          //Serial.print("<0,1  | ");Serial.print(radon_temp_f);Serial.println(" 3");
                        }else if(radon_temp_f < 1) {
                          radon_temp = radon_temp_f * 100;
                          dot_pos = 3; // 4 = aus
                          //Serial.print("<1  | ");Serial.print(radon_temp_f);Serial.println(" 2");
                        }else if(radon_temp_f < 10) {
                          radon_temp = radon_temp_f * 100;
                          dot_pos = 3; // 4 = aus
                          //Serial.print("<10  | ");Serial.print(radon_temp_f);Serial.println(" 2");
                        }else if(radon_temp_f < 100) {
                          radon_temp = radon_temp_f * 100;
                          dot_pos = 3; // 4 = aus
                          //Serial.print("<100  | ");Serial.print(radon_temp_f);Serial.println(" 2");
                        }else if(radon_temp_f < 1000) {
                          radon_temp = radon_temp_f * 10;
                          dot_pos = 2; // 4 = aus
                          //Serial.print("<1000  | ");Serial.print(radon_temp_f);Serial.println(" 1");
                        }else if(radon_temp_f < 10000) {
                          radon_temp = radon_temp_f * 10;
                          dot_pos = 2; // 4 = aus
                          //Serial.print("<10000  | ");Serial.print(radon_temp_f);Serial.println(" 0");
                        }else{
                          radon_temp = radon_temp_f * 1;
                          dot_pos = 1; // 4 = aus
                          //Serial.print(">10000  | ");Serial.print(radon_temp_f);Serial.println(" aus");
                        }

                        //Serial.print("c Radon ");Serial.println(radon_temp_f);
                        //radon_temp=(uint32_t)(radon_temp_f+.5);
                        //Serial.print("d Radon lcd ");Serial.println(radon_temp);
                      }

                        // debugVariables


                        //              *1000   echt
                        //    5 bq      135,1   0,135
                        //   50        1351,3   1,351
                        //  150        4054,0   4,054
                        // 1500       40540,5   40,54
                        // 9999      270243,2   270,2

                        // radon_temp = 135   wäre 0,135
                        // radon_temp = 1351  wäre 1,351


                        byte einer = radon_temp % 10;
                        byte zehner = (radon_temp / 10) % 10;
                        byte hunderter = (radon_temp / 100) % 10;
                        byte tausender = (radon_temp / 1000) % 10;
                        byte ztausender = (radon_temp / 10000) % 10;
                        byte htausender = (radon_temp / 100000) % 10;

                        lc.setIntensity(g_LEDT_FB_ist); //5=Standard   Helligkeit forne


                        //Serial.print("e  Radon ");Serial.println(einer);
                        //Serial.print("z  Radon ");Serial.println(zehner);
                        //Serial.print("h  Radon ");Serial.println(hunderter);
                        //Serial.print("t  Radon ");Serial.println(tausender);
                        //Serial.print("zt Radon ");Serial.println(ztausender);
                        //Serial.print("dot_pos ");Serial.println(dot_pos);


                        //----------------------------------------------------
                      if(g_LEDT_F_ist == 1 && g_LEDT_T_KNX == 0){ 
                        if(g_unit_ist == 0 && g_sensor_boot == true){   //1=Standard   1 = bqm3  0=pCi

                            if(dot_pos == 3){ 
                              if(radon_temp_f >= 1.00){
                                //lc.clearMatrix();
                                if(radon_temp_f >= 10.00){
                                  lc.setChar(0,3,char(einer),false);
                                  lc.setChar(0,2,char(zehner),false);
                                  lc.setChar(0,1,char(hunderter),true);
                                  lc.setChar(0,0,char(tausender),false);
                                }else{
                                  lc.setChar(0,3,char(einer),false);
                                  lc.setChar(0,2,char(zehner),false);
                                  lc.setChar(0,1,char(hunderter),true);
                                  lc.setRow(0,0,0);
                                }
                            
                              }else{
                                //lc.clearMatrix();
                                // Serial.print("<1 ");Serial.println(radon_temp_f);
                                lc.setChar(0,3,char(einer),false);
                                lc.setChar(0,2,char(zehner),false);
                                lc.setChar(0,1,char(hunderter),true);
                                lc.setRow(0,0,0);
                                //lc.setChar(0,3,char(tausender),false);
                              }
                            }

                            if(dot_pos == 2){ 
                              if(radon_temp_f < 1000.00){   
                                //lc.clearMatrix();
                                lc.setChar(0,3,char(einer),false);
                                lc.setChar(0,2,char(zehner),true);
                                lc.setChar(0,1,char(hunderter),false);
                                lc.setChar(0,0,char(tausender),false);
                              }else{
                                //lc.clearMatrix();
                                lc.setChar(0,3,char(zehner),false);
                                lc.setChar(0,2,char(hunderter),false);
                                lc.setChar(0,1,char(tausender),false);
                                lc.setChar(0,0,char(ztausender),false);
                              }

                            }


                            if(dot_pos == 1){ 
                              //lc.clearMatrix();
                              lc.setChar(0,3,'h',false);
                              //lc.setChar(0,2,char(zehner),true);
                              lc.setRow(0,2,0);
                              lc.setChar(0,1,char(tausender),false);
                              lc.setChar(0,0,char(ztausender),false);
                            }
                            
                            if(dot_pos == 0){ 
                              //lc.clearMatrix();
                              lc.setChar(0,3,char(zehner),false);
                              lc.setChar(0,2,char(hunderter),false);
                              lc.setChar(0,1,char(tausender),false);
                              lc.setChar(0,0,char(ztausender),false);
                            }


                        }
                      }
                        //----------------------------------------------------








                        //----------------------------------------------------
                      if(g_LEDT_F_ist == 1 && g_LEDT_T_KNX == 0){   
                        if(g_unit_ist == 1 && g_sensor_boot == true){   //1=Standard   1 = bqm3  0=pCi
                          // 9
                          if(radon_temp < 10){

                            if(g_unitpos_ist == 0){
                              lc.setChar(0,3,char(einer),false);
                              lc.setRow(0,2,0);
                              lc.setRow(0,1,0);
                              lc.setRow(0,0,0);
                            }else{
                              lc.setRow(0,3,0);
                              lc.setChar(0,2,char(einer),false);
                              lc.setRow(0,1,0);
                              lc.setRow(0,0,0);
                            }

                          } 
                        
                          // 99
                          if(radon_temp < 100 && radon_temp >= 10){
                            if(g_unitpos_ist == 0){
                              lc.setChar(0,3,char(einer),false);
                              lc.setChar(0,2,char(zehner),false);
                              lc.setRow(0,1,0);
                              lc.setRow(0,0,0);
                            }else{
                              lc.setRow(0,3,0);
                              lc.setChar(0,2,char(einer),false);
                              lc.setChar(0,1,char(zehner),false);
                              lc.setRow(0,0,0);
                            }
                          }

                          // 999
                          if(radon_temp < 1000 && radon_temp >=100){
                            //lc.clearMatrix();
                            lc.setChar(0,3,char(einer),false);
                            lc.setChar(0,2,char(zehner),false);
                            lc.setChar(0,1,char(hunderter),false);
                            //lc.setChar(0,0,char(tausender),false);
                            lc.setRow(0,0,0);
                          }

                          // 9999
                          if(radon_temp < 9999 && radon_temp >=1000){
                            //lc.clearMatrix();
                            lc.setChar(0,3,char(einer),false);
                            lc.setChar(0,2,char(zehner),false);
                            lc.setChar(0,1,char(hunderter),false);
                            lc.setChar(0,0,char(tausender),false);
                          }



                          // >=10000
                          if(radon_temp < 99999 && radon_temp > 9999){

                          //!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
                            //lc.clearMatrix();
                            lc.setChar(0,0,char(ztausender),false);
                            lc.setChar(0,1,char(tausender),true);
                            lc.setChar(0,2,char(hunderter),false);
                            lc.setChar(0,3,'K',false);
                          }


                          if(radon_temp > 99999){
                          /*
                            Serial.print("e  Radon ");Serial.println(einer);
                            Serial.print("z  Radon ");Serial.println(zehner);
                            Serial.print("h  Radon ");Serial.println(hunderter);
                            Serial.print("t  Radon ");Serial.println(tausender);
                            Serial.print("zt Radon ");Serial.println(ztausender);
                            Serial.print("ht Radon ");Serial.println(htausender);
                          */
                            lc.setChar(0,0,char(htausender),false);
                            lc.setChar(0,1,char(ztausender),false);
                            lc.setChar(0,2,char(tausender),true);
                            lc.setChar(0,3,'K',false);
                          }

                          if(radon_temp > 999999){
                            //Serial.println("--> test3");
                            lc.setChar(0,0,'-',false);
                            lc.setChar(0,1,'-',false);
                            lc.setChar(0,2,'-',false);
                            lc.setChar(0,3,'-',false);
                          }

                        } // bqm3    g_unit_ist == 1 && g_sensor_boot == true
                        
                      }  // g_LEDT_F_ist == 1 && g_LEDT_T_KNX == 0
                        //----------------------------------------------------




                            if(wlan_led_hell_calc == true){
                              wlan_led_hell_calc = false;
            
                            }





                        //----------------------------------------------------
                        //Serial.print("g_sensor_boot ");Serial.println(g_sensor_boot);
                        //Serial.print("g_Seg__boot_ani ");Serial.println(g_Seg__boot_ani);
                        //Serial.print("g_sensor_online ");Serial.println(g_sensor_online);              
                          if(g_sensor_boot == false && g_Seg__boot_ani == false && g_sensor_online <= 2){                
                        
                            currentMillisb = millis();
                            unsigned long elapsedMillis = currentMillisb - startMillisb;
                            unsigned long remainingMillis = pgm_read_dword(&countdownTimeb) - elapsedMillis;  
                            strip.setBrightness(50);                                
                            
                              if (countdownBeendet == false) {
                                    unsigned long remainingMinutes = remainingMillis / 60000;
                                    if (remainingMinutes >= 7) {
                                        // 10 - 7 Minuten: Alle 4 Anzeigen aktiv
                                            lc.setChar(0,0, ' ', false);
                                            lc.setChar(0,1, ' ', false);
                                            lc.setChar(0,2, ' ', false);
                                            lc.setChar(0,3, ' ', tick_radon);
                                            delay(200);
                                            lc.setChar(0,0, '-', false);
                                            lc.setChar(0,1, ' ', false);
                                            lc.setChar(0,2, ' ', false);
                                            lc.setChar(0,3, ' ', tick_radon);
                                            delay(100);
                                            lc.setChar(0,0, '-', false);
                                            lc.setChar(0,1, '-', false);
                                            lc.setChar(0,2, ' ', false);
                                            lc.setChar(0,3, ' ', tick_radon);
                                            delay(100);
                                            lc.setChar(0,0, '-', false);
                                            lc.setChar(0,1, '-', false);
                                            lc.setChar(0,2, '-', false);
                                            lc.setChar(0,3, ' ', tick_radon);
                                            delay(100);
                                        lc.setChar(0,0, '-', false);
                                        lc.setChar(0,1, '-', false);
                                        lc.setChar(0,2, '-', false);
                                        lc.setChar(0,3, '-', tick_radon);
                                        delay(500);
                                    } else if (remainingMinutes >= 5) {
                                            lc.setChar(0,0, ' ', false);
                                            lc.setChar(0,1, ' ', false);
                                            lc.setChar(0,2, ' ', false);
                                            lc.setChar(0,3, ' ', tick_radon);
                                            delay(200);
                                            lc.setChar(0,0, ' ', false);
                                            lc.setChar(0,1, '-', false);
                                            lc.setChar(0,2, ' ', false);
                                            lc.setChar(0,3, ' ', tick_radon);
                                            delay(100);
                                            lc.setChar(0,0, ' ', false);
                                            lc.setChar(0,1, '-', false);
                                            lc.setChar(0,2, '-', false);
                                            lc.setChar(0,3, ' ', tick_radon);
                                            delay(100);                    
                                        
                                        lc.setChar(0,0, ' ', false);
                                        lc.setChar(0,1, '-', false);
                                        lc.setChar(0,2, '-', false);
                                        lc.setChar(0,3, '-', tick_radon);
                                        delay(500);
                                       
                                    } else if (remainingMinutes >= 2) {
                                        // 4 - 1 Minuten: Erste und zweite Anzeige aus, andere 2 aktiv
                                            lc.setChar(0,0, ' ', false);
                                            lc.setChar(0,1, ' ', false);
                                            lc.setChar(0,2, ' ', false);
                                            lc.setChar(0,3, ' ', tick_radon);
                                            delay(200);
                                            lc.setChar(0,0, ' ', false);
                                            lc.setChar(0,1, ' ', false);
                                            lc.setChar(0,2, '-', false);
                                            lc.setChar(0,3, ' ', tick_radon);
                                            delay(100);  
                                        
                                        lc.setChar(0,0, ' ', false);
                                        lc.setChar(0,1, ' ', false);
                                        lc.setChar(0,2, '-', false);
                                        lc.setChar(0,3, '-', tick_radon);
                                        delay(500);

                                    } else {
                                        // 1 - 0 Minuten: Nur letzte Anzeige aus
                                            countdownBeendet = true; // Countdown als beendet markieren
                                            lc.setChar(0,0, ' ', false);
                                            lc.setChar(0,1, ' ', false);
                                            lc.setChar(0,2, ' ', false);
                                            lc.setChar(0,3, ' ', tick_radon);
                                            delay(200);
                                            lc.setChar(0,0, ' ', false);
                                            lc.setChar(0,1, ' ', false);
                                            lc.setChar(0,2, ' ', false);
                                            lc.setChar(0,3, '-', tick_radon);
                                            delay(100);

                                        lc.setChar(0,0, ' ', false);
                                        lc.setChar(0,1, ' ', false);
                                        lc.setChar(0,2, ' ', false);
                                        lc.setChar(0,3, '-', tick_radon);
                                        delay(500);
       

                                    }

                              }else{   // countdownBeendet == false
                                    // 1 - 0 Minuten: Nur letzte Anzeige aus
                                        countdownBeendet = true; // Countdown als beendet markieren
                                        lc.setChar(0,0, ' ', false);
                                        lc.setChar(0,1, ' ', false);
                                        lc.setChar(0,2, ' ', false);
                                        lc.setChar(0,3, ' ', tick_radon);
                                        delay(200);
                                        lc.setChar(0,0, ' ', false);
                                        lc.setChar(0,1, ' ', false);
                                        lc.setChar(0,2, ' ', false);
                                        lc.setChar(0,3, '-', tick_radon);
                                        delay(100);

                                    lc.setChar(0,0, ' ', false);
                                    lc.setChar(0,1, ' ', false);
                                    lc.setChar(0,2, ' ', false);
                                    lc.setChar(0,3, '-', tick_radon);
                                    delay(500);


                              }  // countdownBeendet == false


                            
                          } else{
                            countdownBeendet = false; // Countdown als start markieren
                          } 
                        //----------------------------------------------------


                        lc.setIntensity(g_LEDT_FB_ist); //5=Standard   Helligkeit forne

                            //---------------------------------------
                            if(g_boot_fail >= 1){
                              
                                Preferences preferences;
                                preferences.begin("eenvs", false);                    
                                g_boot_fail = 0;
                                preferences.putUChar("boot_g_fail", g_boot_fail);     
                                preferences.end(); 

                            }
                            //------------------------------------------

                            g_wlan_check_start = true;

                    }   // if(Segment_task == true || g_radon_new_seg == true
                  }   // g_Seg__boot_ani == false && gFW_Update_start == 0 &&.....
                  g_dp_fast = false;
            
            }else{   //if(g_switch_anzeige == 0){ 
            
                  // // g_u_view_switch_ist  0=Radon  1= Uhr  2= Wechsel
                    
                    

                
                  // segment ein 
                  if(g_LEDT_F_ist == 1 && akt_fw_load == false && g_LEDT_T_KNX == 0 && g_identify == false){


                    
                    // Uhr anzeigen   1= 24h   2= 12h   3=Datum
                    clock_start = true;
                    
                          byte valuet = v_currenthour;
                    
                      
                      //Serial.print("v_currenthour ");Serial.println(valuet);
                      //Serial.print("v_currenthour ");Serial.println(v_currenthour);
                      //Serial.print("v_currentmin ");Serial.println(v_currentmin);

                      if(g_dp_fast == false){ 
                        g_dp_fast = true;
                        tick2 = true;
                        ledcWrite(ledChannel, dutyCycle_dp); //dp
                      }


                      if(g_u_clock_ist == 1){ 
                        valuet = v_currenthour;
                      }
                      if(g_u_clock_ist == 2){ 
                        //valuet = atoi(timeHour12h); 
                        currenthour12 = v_currenthour;  
                        currenthourAM_PM = false;
                        if( currenthour12 == 0 ){currenthour12 = 12;currenthourAM_PM = true;}
                        if( currenthour12 > 12 ){currenthour12 = currenthour12 - 12;currenthourAM_PM = true;}
                        valuet = currenthour12;  // hour12h  
                      }    
                      //Serial.print("valuetb ");Serial.println(valuet);                            
                    
                      //---------------- 
                      if(g_u_clock_ist <= 2){ 
                      h_einer = valuet % 10;
                      h_zehner = (valuet / 10) % 10;

                      m_einer = currentmin % 10;
                      m_zehner = (currentmin / 10) % 10;
                      }

                      if(g_u_clock_ist == 3){ 
                      h_einer = day % 10;
                      h_zehner = (day / 10) % 10;

                      m_einer = month % 10;
                      m_zehner = (month / 10) % 10;
                      }
                      //---------------- 

                        //---------------- 
                        
                        if(g_u_clock_ist != 3){ 
                          if(h_zehner==0){
                            lc.setChar(0,0,' ',false); 
                          }else{
                            lc.setChar(0,0,char(h_zehner),false); 
                          }

                        }
                        lc.setChar(0,1,char(h_einer),false); 
                        lc.setChar(0,2,char(m_zehner),false);
                        //---------------- 

                          if(g_u_clock_ist == 2){ 

                            if(currenthourAM_PM == true){
                              lc.setChar(0,3,char(m_einer),false);   //   12h version   nachmittags
                              ledcWrite(ledChannel27, 0);            //   GPIO27  AM
                              if(g_LEDT_F_ist == 1){ 
                              ledcWrite(ledChannel25, dutyCycle_t215);  //   GPIO37  PM
                              }
                            }else{
                              lc.setChar(0,3,char(m_einer),false);   //   12h version   vormittags
                              if(g_LEDT_F_ist == 1){ 
                              ledcWrite(ledChannel27, dutyCycle_t215);  //   GPIO27  AM
                              }
                              ledcWrite(ledChannel25, 0);            //   GPIO37  PM
                            } 
                            if(update_ntp_ready == 1){ledcWrite(ledChannel26, dutyCycle_t215);} //   GPIO38  NTP           
                        } else{
                          ledcWrite(ledChannel27, 0);            //   GPIO27  AM
                          ledcWrite(ledChannel25, 0);            //   GPIO37  PM
                          if(update_ntp_ready == 1){ledcWrite(ledChannel26, 0);} //   GPIO38  NTP
                          lc.setChar(0,3,char(m_einer),false);     
                        }



                          //Serial.print("h_zehnera ");Serial.println(h_zehner);  
                          //Serial.print("m_zehnera ");Serial.println(m_zehner); 
                          //Serial.print("h_einera ");Serial.println(h_einer); 
                          //Serial.print("m_zehnera ");Serial.println(m_zehner); 
                      
                      
                        lc.setIntensity(g_LEDT_FB_ist); //5=Standard   Helligkeit forne

                    





                          // -------   PWM   -------
                          if(tick2 == false){
                            dutyCycle_t = 0;
                          }else{
                            

                            if (g_LEDT_FB_ist > 14) {
                              dutyCycle_dp = 70;
                              dutyCycle = 80;
                            }
                            else if (g_LEDT_FB_ist > 13) {
                              dutyCycle_dp = 70;
                              dutyCycle = 70;
                            }
                            else if (g_LEDT_FB_ist > 12) {
                              dutyCycle_dp = 68;
                              dutyCycle = 50;
                            }
                            else if (g_LEDT_FB_ist > 11) {
                              dutyCycle_dp = 56;
                              dutyCycle = 40;
                            }
                            else if (g_LEDT_FB_ist > 10) {
                              dutyCycle_dp = 50;
                              dutyCycle = 35;
                            }
                            else if (g_LEDT_FB_ist > 9) {
                              dutyCycle_dp = 40;
                              dutyCycle = 30;
                            }
                            else if (g_LEDT_FB_ist > 8) {
                              dutyCycle_dp = 30;
                              dutyCycle = 25;
                            }
                            else if (g_LEDT_FB_ist > 7) {
                              dutyCycle_dp = 22;
                              dutyCycle = 20;
                            }
                            else if (g_LEDT_FB_ist > 6) {
                              dutyCycle_dp = 12;
                              dutyCycle = 15;
                            }
                            else if (g_LEDT_FB_ist > 5) {
                              dutyCycle_dp = 10;
                              dutyCycle = 9;
                            }
                            else if (g_LEDT_FB_ist > 4) {
                              dutyCycle_dp = 7;
                              dutyCycle = 7;
                            }
                            else if (g_LEDT_FB_ist > 3) {
                              dutyCycle_dp = 6;
                              dutyCycle = 4;
                            }
                            else if (g_LEDT_FB_ist > 2) {
                              dutyCycle_dp = 4;
                              dutyCycle = 4;
                            }
                            else if (g_LEDT_FB_ist > 1) {
                              dutyCycle_dp = 2;
                              dutyCycle = 3;
                            }
                            else if (g_LEDT_FB_ist == 1) {
                              dutyCycle_dp = 2;
                              dutyCycle = 2;
                            }
                            else {
                              dutyCycle_dp = 2;
                              dutyCycle = 1;
                            }
                            dutyCycle_t = dutyCycle_dp;

                          }
                            
                            if(g_LEDT_F_ist == 1 && g_LEDT_T_KNX == 0){
                              if(g_switch_anzeige == 1 && g_u_clock_ist != 3){ 
                                //Serial.println("--------ledcWrite(ledChannel, dutyCycle_t);----------------");
                                //ledcWrite(ledChannel, dutyCycle_t); //dp
                              }
                            }

                            if(dutyCycle_t215 != dutyCycle){
                                dutyCycle_t215 = dutyCycle;
                                Preferences preferences;
                                preferences.begin("eenvs", false);                         //Ordner eenvs anlegen/verwenden
                                preferences.putUChar("dutyCycle", dutyCycle_t215); 
                            }                                            
                            
                            dutyCycle_t215 = dutyCycle;


                          // -------   PWM   -------


                          lc.setIntensity(g_LEDT_FB_ist); //5=Standard   Helligkeit forne

                          //Serial.println("----------------g_boot_fail2----------------------");
                          if(g_boot_fail >= 1){
                              Preferences preferences;
                              preferences.begin("eenvs", false);                         //Ordner eenvs anlegen/verwenden       
                              g_boot_fail = 0;
                              preferences.putUChar("boot_g_fail", g_boot_fail);    // 
                              preferences.end(); 
                          }

                  }


              
            } // g_switch_anzeige == 1       kein FW update, also normalanzeige

       }   // verzoegerung_fw_update

     } // set_bit_wait_front_view

    }else{  // g_view_fw =

        if(g_LEDT_F_ist > 0 && g_LEDT_T_KNX == 0){ 
          if(g_Seg__boot_ani == false && gFW_Update_start == 0 && akt_fw_load == false && boot_ani_off2 == false){ 
      
              /*
              fw_myString = TB_currFwVersion;
              char zeile[10];
              snprintf( zeile, sizeof(zeile), "%s", fw_myString.c_str() );
              snprintf( fw_daten[0], sizeof(fw_daten[0]), "%s", strtok(zeile, ".") );
              snprintf( fw_daten[1], sizeof(fw_daten[1]), "%s", strtok(NULL, ".") );
              snprintf( fw_daten[2], sizeof(fw_daten[2]), "%s", strtok(NULL, ".") );

              fw_00 = atoi(fw_daten[0]); 
              fw_01 = atoi(fw_daten[1]); 
              fw_02 = atoi(fw_daten[2]); 

              lc.setIntensity(15); //5=Standard   Helligkeit forne
              lc.setRow(0,0,0);
              lc.setChar(0,1,char(fw_00),true);
              lc.setChar(0,2,char(fw_01),true);
              lc.setChar(0,3,char(fw_02),false);
              */

              //if(only_one == false){
                //only_one = true;
                //displayFirmwareVersion(TB_currFwVersion);
                //set_bit_wait_front_view = true;
              //}
              //Serial.print("-----------fw_daten ");Serial.println(F(" "));
              

          }
        }

    }  // g_view_fw =

  } // kalibrieren   (g_kalibrieren_ist == 0 && g_checken_ist == 0 && g_kal_write_ist == 0 && g_identify == ......
    #endif



    

    #ifdef NeoPixel


           if(g_showani == true){ 
            
              if(g_bl_connect == true){
                s_Color = 3;
                s_Brightness = 190; 
                //showani(s_Color,s_Brightness); 
              }else{

                if(boot_ani_off == false){ // nicht bei geziehltem reboot
                  s_Color = 4; // nach booten
                  s_Brightness = 50; 
                  //Serial.println("g_showani ");

                  lc.setRow(0,0,0);
                  lc.setRow(0,1,0);
                  lc.setRow(0,2,0);
                  lc.setRow(0,3,0);  

                  transferCompleteTime = millis();
                  esp_task_wdt_reset(); // Watchdog-Timer zurücksetzen
                  showani(s_Color,s_Brightness); 
                  
                }
                boot_ani_off = false; 

              }
      
              g_showani = false;
              

          }           
            


    #endif







    //-----------------------------------------------
    if(g_InitWiFi == true){

      g_InitWiFi = false;
      Serial.println("--> g_InitWiFi");
      InitWiFi();

    }  
    //-----------------------------------------------      







     //-----------------------------------------------------------------------------------------------
    //  SEARCH
    if(g_search_start == true){
        
      
        if(g_search_start_count == 0 && millis() - ms3 > 1000){
            g_search_start_count = 1; 
            //--------------------------------------------------------------
                answer_s = "";

                tempstr = "Search "; 
                tempstr += String(scan_max-1); 
                tempstr += " Adressen. \r\n"; 
                pTxCharacteristic->setValue(tempstr.c_str());
                pTxCharacteristic->notify();

                lc.setIntensity(15); //5=Standard   Helligkeit forne
                lc.setChar(0,0,'S',false);
                lc.setChar(0,1,'E',false);
                lc.setChar(0,2,'C',false);
                lc.setChar(0,3,'H',false);


          //************ BAUD **************
          //-------------------------------------
            Serial1.flush(); // wait for last transmitted data to be sent 
            mbus_baud_t = 4800;
            Serial.println(F("-----------------------------------------"));
            Serial.println(F(" "));
            char message[100]; // Puffer für die formatierte Nachricht
            // Formatierung der Nachricht
            snprintf(message, sizeof(message), "[SE] %s | 1 Stopbit | Baud %u", p_uhrzeit, mbus_baud_t);
            // Ausgabe der Nachricht
            Serial.println(message);

                          
                          tempstr = "None Parity | 1 Stopbit | Baud: "; 
                          tempstr += String(mbus_baud_t); 
                          tempstr += "\r\n"; 
                          pTxCharacteristic->setValue(tempstr.c_str());
                          pTxCharacteristic->notify();

            Serial1.begin(mbus_baud_t, SERIAL_8N1, Serial1_RXPIN, Serial1_TXPIN);
            while(Serial1.available()) Serial1.read();
          //-------------------------------------


         //-------------------------------------
          for (uint8_t scan_ids = 1; scan_ids < 5; scan_ids++) { 

                        esp_task_wdt_reset(); 
                       
                        MB.setTimeout(200);
                        ModbusMessage n = MB.syncRequest(1, scan_ids, READ_HOLD_REGISTER, 0, 1);  //void handleData(  
                        Modbus::Error err = n.getError();

                        if (err != SUCCESS ) {
                          ModbusError me(err);
                        } else {
                          ModbusError me(err);
                        }  
                      
          } 
         //-------------------------------------

         //-------------------------------------
            lc.setChar(0,0,'S',false);
            lc.setChar(0,1,'E',false);
            lc.setChar(0,2,'C',false);
            lc.setChar(0,3,'H',false);
        
          for (uint8_t scan_ids = 1; scan_ids < scan_max; scan_ids++) { 

                        esp_task_wdt_reset(); 
                        tick4 = !tick4;
                        lc.setChar(0,0,'S',tick4);
                        if(scan_ids >= scan_max){return;}
                        MB.setTimeout(200);
                        ModbusMessage n = MB.syncRequest(1, scan_ids, READ_HOLD_REGISTER, 0, 1);  //void handleData(  
                        Modbus::Error err = n.getError();

                        if (err != SUCCESS ) {
                              ModbusError me(err);
                              Serial.print("[SE] | None Parity | 1 Stopbit | Baud: " + String(mbus_baud_t) + " | Adresse: ");
                              Serial.printf("%d : %s\n", scan_ids, (const char *)me);

                        } else {
                          ModbusError me(err);
                          Serial.print("[SE] | None Parity | 1 Stopbit | Baud: " + String(mbus_baud_t) + " | Adresse: ");
                          Serial.printf("%d : %s\n", scan_ids, (const char *)me);

                          //String tempstr; 
                          tempstr = "None Parity | 1 Stopbit | Baud: "; 
                          tempstr += String(mbus_baud_t); 
                          tempstr += " | Adresse: "; 
                          tempstr += String(scan_ids);  
                          tempstr += " | ";  
                          tempstr += String((const char *)me);  
                           
                              #ifdef ea_webserver
                              #ifdef j_2_webserver
                              if(disable_server >= 1 && String((const char *)me) == "Success") { 
                                things_list_t_16 = tempstr;
                                answer_s = things_list_t_16;
                                entr_log = true;
                              }
                              #endif
                              #endif
                           tempstr += "\r\n";
                          pTxCharacteristic->setValue(tempstr.c_str());
                          pTxCharacteristic->notify();

                        }  
                      
          } 
         //-------------------------------------


            //--------------------------------------------------------------
            g_search_start_count = 2;
            ms3 = millis(); 
        }





        if(g_search_start_count == 2 && millis() - ms3 > 1000){
            g_search_start_count = 3; 
            //--------------------------------------------------------------



           //-------------------------------------
            Serial1.flush(); // wait for last transmitted data to be sent 
            mbus_baud_t = 9600;
            Serial.println(F(" "));
            Serial.println(F("-----------------------------------------"));
            char message[100]; // Puffer für die formatierte Nachricht
            // Formatierung der Nachricht
            snprintf(message, sizeof(message), "[SE] %s | 1 Stopbit | Baud %u", p_uhrzeit, mbus_baud_t);
            // Ausgabe der Nachricht
            Serial.println(message);


                          //String tempstr; 
                          tempstr = "None Parity | 1 Stopbit | Baud: "; 
                          tempstr += String(mbus_baud_t); 
                          tempstr += "\r\n"; 
                          pTxCharacteristic->setValue(tempstr.c_str());
                          pTxCharacteristic->notify();

            Serial1.begin(mbus_baud_t, SERIAL_8N1, Serial1_RXPIN, Serial1_TXPIN);
            while(Serial1.available()) Serial1.read();
           //-------------------------------------

         //-------------------------------------
          for (uint8_t scan_ids = 1; scan_ids < 5; scan_ids++) { 

                        esp_task_wdt_reset(); 
                        MB.setTimeout(200);
                        ModbusMessage n = MB.syncRequest(1, scan_ids, READ_HOLD_REGISTER, 0, 1);  //void handleData(  
                        Modbus::Error err = n.getError();

                        if (err != SUCCESS ) {
                              ModbusError me(err);
                        } else {
                              ModbusError me(err);
                        }  
                      
          } 
         //-------------------------------------

         //-------------------------------------
            lc.setChar(0,0,'S',false);
            lc.setChar(0,1,'E',false);
            lc.setChar(0,2,'C',false);
            lc.setChar(0,3,'H',false);
        
          for (uint8_t scan_ids = 1; scan_ids < scan_max; scan_ids++) { 

                        esp_task_wdt_reset(); 
                        tick4 = !tick4;
                        lc.setChar(0,1,'E',tick4);
                        if(scan_ids >= scan_max){return;}
                        MB.setTimeout(200);
                        ModbusMessage n = MB.syncRequest(1, scan_ids, READ_HOLD_REGISTER, 0, 1);  //void handleData(  
                        Modbus::Error err = n.getError();

                        if (err != SUCCESS ) {
                    
                              ModbusError me(err);

                              Serial.print("[SE] | None Parity | 1 Stopbit | Baud: " + String(mbus_baud_t) + " | Adresse: ");
                              Serial.printf("%d : %s\n", scan_ids, (const char *)me);

                        } else {
                    
                          ModbusError me(err);

                          Serial.print("[SE] | None Paritäaet | 1 Stopbit | Baud: " + String(mbus_baud_t) + " | Adresse: ");
                          Serial.printf("%d : %s\n", scan_ids, (const char *)me);

                          //String tempstr; 
                          tempstr = "None Parity | 1 Stopbit | Baud: "; 
                          tempstr += String(mbus_baud_t); 
                          tempstr += " | Adresse: "; 
                          tempstr += String(scan_ids);  
                          tempstr += " | ";  
                          tempstr += String((const char *)me);  
                          
                              #ifdef ea_webserver
                              #ifdef j_2_webserver
                              if(disable_server >= 1 && String((const char *)me) == "Success") { 
                                things_list_t_16 = tempstr;
                                answer_s = things_list_t_16;
                                entr_log = true;
                              }
                              #endif
                              #endif
                          tempstr += "\r\n"; 
                          pTxCharacteristic->setValue(tempstr.c_str());
                          pTxCharacteristic->notify();


                        }  
                      
          } 
         //-------------------------------------

            //--------------------------------------------------------------
            g_search_start_count = 4;
            ms3 = millis(); 
        }






        if(g_search_start_count == 4 && millis() - ms3 > 1000){
            g_search_start_count = 5; 
            //--------------------------------------------------------------



           //-------------------------------------
            Serial1.flush(); // wait for last transmitted data to be sent 
            mbus_baud_t = 19200;
            Serial.println(F("-----------------------------------------"));
            Serial.println(F(" "));
            char message[100]; // Puffer für die formatierte Nachricht
            // Formatierung der Nachricht
            snprintf(message, sizeof(message), "[SE] %s None Parity | 1 Stopbit | Baud %u", p_uhrzeit, mbus_baud_t);
            // Ausgabe der Nachricht
            Serial.println(message);

                          //String tempstr; 
                          tempstr = "None Parity | 1 Stopbit | Baud: "; 
                          tempstr += String(mbus_baud_t); 
                          tempstr += "\r\n"; 
                          pTxCharacteristic->setValue(tempstr.c_str());
                          pTxCharacteristic->notify();

            Serial1.begin(mbus_baud_t, SERIAL_8N1, Serial1_RXPIN, Serial1_TXPIN);
            while(Serial1.available()) Serial1.read();
                          tempstr += " "; 
                          pTxCharacteristic->setValue(tempstr.c_str());
                          pTxCharacteristic->notify();
           //-------------------------------------

         //-------------------------------------
          for (uint8_t scan_ids = 1; scan_ids < 5; scan_ids++) { 

                        esp_task_wdt_reset(); 
                        MB.setTimeout(200);
                        ModbusMessage n = MB.syncRequest(1, scan_ids, READ_HOLD_REGISTER, 0, 1);  //void handleData(  
                        Modbus::Error err = n.getError();

                        if (err != SUCCESS ) {
                          ModbusError me(err);
                        } else {
                          ModbusError me(err);
                        }  
                      
          } 
         //-------------------------------------

         //-------------------------------------
            lc.setChar(0,0,'S',false);
            lc.setChar(0,1,'E',false);
            lc.setChar(0,2,'C',false);
            lc.setChar(0,3,'H',false);
        
          for (uint8_t scan_ids = 1; scan_ids < scan_max; scan_ids++) { 

                        esp_task_wdt_reset(); 
                        tick4 = !tick4;
                        lc.setChar(0,2,'C',tick4);
                        if(scan_ids >= scan_max){return;}
                        MB.setTimeout(200);
                        ModbusMessage n = MB.syncRequest(1, scan_ids, READ_HOLD_REGISTER, 0, 1);  //void handleData(  
                        Modbus::Error err = n.getError();

                        if (err != SUCCESS ) {
                              ModbusError me(err);
                              Serial.print("[SE] | None Parity | 1 Stopbit | Baud: " + String(mbus_baud_t) + " | Adresse: ");
                              Serial.printf("%d : %s\n", scan_ids, (const char *)me);

                        } else {
                          ModbusError me(err);
                          Serial.print("[SE] | None Parity | 1 Stopbit | Baud: " + String(mbus_baud_t) + " | Adresse: ");
                          Serial.printf("%d : %s\n", scan_ids, (const char *)me);

                          //String tempstr; 
                          tempstr = "None Parity | 1 Stopbit | Baud: "; 
                          tempstr += String(mbus_baud_t); 
                          tempstr += " | Adresse: "; 
                          tempstr += String(scan_ids);  
                          tempstr += " | ";  
                          tempstr += String((const char *)me);  
                          
                              #ifdef ea_webserver
                              #ifdef j_2_webserver
                              if(disable_server >= 1 && String((const char *)me) == "Success") { 
                                things_list_t_16 = tempstr;
                                answer_s = things_list_t_16;
                                entr_log = true;
                              }
                              #endif
                              #endif
                          tempstr += "\r\n"; 
                          pTxCharacteristic->setValue(tempstr.c_str());
                          pTxCharacteristic->notify();
                          size_t message_length = strlen(tempstr.c_str());
                          sentTraffic += message_length;  

                        }  
                      
          } 
         //-------------------------------------

        //************ BAUD **************


                          tempstr += "-------------------- \r\n"; 
                          pTxCharacteristic->setValue(tempstr.c_str());
                          pTxCharacteristic->notify();
                          size_t message_length = strlen(tempstr.c_str());
                         sentTraffic += message_length;  

            //--------------------------------------------------------------
            g_search_start_count = 6;
            ms3 = millis(); 
        }





        if(g_search_start_count == 6 && millis() - ms3 > 1000){
            g_search_start_count = 7; 
            //--------------------------------------------------------------



       //************ Even Parity SERIAL_5E1 **************
        
           //-------------------------------------
            Serial1.flush(); // wait for last transmitted data to be sent 
            mbus_baud_t = 4800;
            Serial.println(F("-----------------------------------------"));
            Serial.println(F(" "));
            //Serial.println("[SE] " + p_uhrzeit + " | Even Parity | 1 Stopbit | Baud " + String(mbus_baud_t));
                          //String tempstr; 
                          tempstr = "Even Parity | 1 Stopbit | Baud: "; 
                          tempstr += String(mbus_baud_t); 
                          tempstr += "\r\n"; 
                          pTxCharacteristic->setValue(tempstr.c_str());
                          pTxCharacteristic->notify();

            Serial1.begin(mbus_baud_t, SERIAL_5E1, Serial1_RXPIN, Serial1_TXPIN);
            while(Serial1.available()) Serial1.read();
           //-------------------------------------


         //-------------------------------------
          for (uint8_t scan_ids = 1; scan_ids < 5; scan_ids++) { 

                        esp_task_wdt_reset(); 
                        MB.setTimeout(200);
                        ModbusMessage n = MB.syncRequest(1, scan_ids, READ_HOLD_REGISTER, 0, 1);  //void handleData(  
                        Modbus::Error err = n.getError();

                        if (err != SUCCESS ) {
                          ModbusError me(err);
                        } else {
                          ModbusError me(err);
                        }  
                      
          } 
         //-------------------------------------

         //-------------------------------------
            lc.setChar(0,0,'S',false);
            lc.setChar(0,1,'E',false);
            lc.setChar(0,2,'C',false);
            lc.setChar(0,3,'H',false);
        
          for (uint8_t scan_ids = 1; scan_ids < scan_max; scan_ids++) { 

                        esp_task_wdt_reset(); 
                        tick4 = !tick4;
                        lc.setChar(0,3,'H',tick4);
                        MB.setTimeout(200);
                        ModbusMessage n = MB.syncRequest(1, scan_ids, READ_HOLD_REGISTER, 0, 1);  //void handleData(  
                        Modbus::Error err = n.getError();

                        if (err != SUCCESS ) {
                              ModbusError me(err);
                              Serial.print("[SE] | Even Parity | 1 Stopbit | Baud: " + String(mbus_baud_t) + " | Adresse: ");
                              Serial.printf("%d : %s\n", scan_ids, (const char *)me);

                        } else {
                          ModbusError me(err);
                          Serial.print("[SE] | Even Parity | 1 Stopbit | Baud: " + String(mbus_baud_t) + " | Adresse: ");

                          //String tempstr; 
                          tempstr = "Even Parity | 1 Stopbit | Baud: "; 
                          tempstr += String(mbus_baud_t); 
                          tempstr += " | Adresse: "; 
                          tempstr += String(scan_ids);  
                          tempstr += " | ";  
                          tempstr += String((const char *)me);  
                         
                              #ifdef ea_webserver
                              #ifdef j_2_webserver
                              if(disable_server >= 1 && String((const char *)me) == "Success") { 
                                things_list_t_16 = tempstr;
                                answer_s = things_list_t_16;
                                entr_log = true;
                              }
                              #endif
                              #endif
                          tempstr += "\r\n"; 
                          pTxCharacteristic->setValue(tempstr.c_str());
                          pTxCharacteristic->notify();

                        }  
                      
          } 
         //-------------------------------------

            //--------------------------------------------------------------
            g_search_start_count = 8;
            ms3 = millis(); 
        }




        if(g_search_start_count == 8 && millis() - ms3 > 1000){
            g_search_start_count = 9; 
            //--------------------------------------------------------------



           //-------------------------------------
            Serial1.flush(); // wait for last transmitted data to be sent 
            mbus_baud_t = 9600;
            Serial.println(F(" "));
            Serial.println(F("-----------------------------------------"));
            //Serial.println("[SE] " + p_uhrzeit + " | Even Parity | 1 Stopbit | Baud " + String(mbus_baud_t));

                          //String tempstr; 
                          tempstr = "Even Parity | 1 Stopbit | Baud: "; 
                          tempstr += String(mbus_baud_t); 
                          tempstr += "\r\n"; 
                          pTxCharacteristic->setValue(tempstr.c_str());
                          pTxCharacteristic->notify();

            Serial1.begin(mbus_baud_t, SERIAL_5E1, Serial1_RXPIN, Serial1_TXPIN);
            while(Serial1.available()) Serial1.read();
           //-------------------------------------

         //-------------------------------------
          for (uint8_t scan_ids = 1; scan_ids < 5; scan_ids++) { 

                        esp_task_wdt_reset(); 
                        MB.setTimeout(200);
                        ModbusMessage n = MB.syncRequest(1, scan_ids, READ_HOLD_REGISTER, 0, 1);  //void handleData(  
                        Modbus::Error err = n.getError();

                        if (err != SUCCESS ) {
                              ModbusError me(err);
                        } else {
                              ModbusError me(err);
                        }  
                      
          } 
         //-------------------------------------

         //-------------------------------------
            lc.setChar(0,0,'S',false);
            lc.setChar(0,1,'E',false);
            lc.setChar(0,2,'C',false);
            lc.setChar(0,3,'H',false);
        
          for (uint8_t scan_ids = 1; scan_ids < scan_max; scan_ids++) { 

                        esp_task_wdt_reset(); 
                        tick4 = !tick4;
                        lc.setChar(0,0,'S',tick4);
                        MB.setTimeout(200);
                        ModbusMessage n = MB.syncRequest(1, scan_ids, READ_HOLD_REGISTER, 0, 1);  //void handleData(  
                        Modbus::Error err = n.getError();

                        if (err != SUCCESS ) {
                    
                              ModbusError me(err);

                              Serial.print("[SE] | Even Parity | 1 Stopbit | Baud: " + String(mbus_baud_t) + " | Adresse: ");
                              Serial.printf("%d : %s\n", scan_ids, (const char *)me);

                        } else {
                    
                          ModbusError me(err);

                          Serial.print("[SE] | Even Parity | 1 Stopbit | Baud: " + String(mbus_baud_t) + " | Adresse: ");
                          Serial.printf("%d : %s\n", scan_ids, (const char *)me);


                          //String tempstr; 
                          tempstr = "Even Parity | 1 Stopbit | Baud: "; 
                          tempstr += String(mbus_baud_t); 
                          tempstr += " | Adresse: "; 
                          tempstr += String(scan_ids);  
                          tempstr += " | ";  
                          tempstr += String((const char *)me);  
                          
                              #ifdef ea_webserver
                              #ifdef j_2_webserver
                              if(disable_server >= 1 && String((const char *)me) == "Success") { 
                                things_list_t_16 = tempstr;
                                answer_s = things_list_t_16;
                                entr_log = true;
                              }
                              #endif
                              #endif
                          tempstr += "\r\n"; 
                          pTxCharacteristic->setValue(tempstr.c_str());
                          pTxCharacteristic->notify();



                        }  
                      
          } 
         //-------------------------------------

            //--------------------------------------------------------------
            g_search_start_count = 10;
            ms3 = millis(); 
        }




        if(g_search_start_count == 10 && millis() - ms3 > 1000){
            g_search_start_count = 11; 
            //--------------------------------------------------------------


           //-------------------------------------
            Serial1.flush(); // wait for last transmitted data to be sent 
            mbus_baud_t = 19200;
            Serial.println(F("-----------------------------------------"));
            Serial.println(F(" "));
            //Serial.println("[SE] " + p_uhrzeit + " | Even Parity | 1 Stopbit | Change Baud " + String(mbus_baud_t));
                          //String tempstr; 
                          tempstr = "Even Parity | 1 Stopbit | Baud: "; 
                          tempstr += String(mbus_baud_t); 
                          tempstr += "\r\n"; 
                          pTxCharacteristic->setValue(tempstr.c_str());
                          pTxCharacteristic->notify();

            Serial1.begin(mbus_baud_t, SERIAL_5E1, Serial1_RXPIN, Serial1_TXPIN);
            while(Serial1.available()) Serial1.read();
           //-------------------------------------

         //-------------------------------------
          for (uint8_t scan_ids = 1; scan_ids < 5; scan_ids++) { 

                        esp_task_wdt_reset(); 
                        MB.setTimeout(200);
                        ModbusMessage n = MB.syncRequest(1, scan_ids, READ_HOLD_REGISTER, 0, 1);  //void handleData(  
                        Modbus::Error err = n.getError();

                        if (err != SUCCESS ) {
                          ModbusError me(err);
                        } else {
                          ModbusError me(err);
                        }  
                      
          } 
         //-------------------------------------

         //-------------------------------------
            lc.setChar(0,0,'S',false);
            lc.setChar(0,1,'E',false);
            lc.setChar(0,2,'C',false);
            lc.setChar(0,3,'H',false);
        
          for (uint8_t scan_ids = 1; scan_ids < scan_max; scan_ids++) { 

                        esp_task_wdt_reset(); 
                        tick4 = !tick4;
                        lc.setChar(0,1,'E',tick4);
                        MB.setTimeout(200);
                        ModbusMessage n = MB.syncRequest(1, scan_ids, READ_HOLD_REGISTER, 0, 1);  //void handleData(  
                        Modbus::Error err = n.getError();

                        if (err != SUCCESS ) {
                              ModbusError me(err);
                              Serial.print("[SE] | Even Parity | 1 Stopbit | Baud: " + String(mbus_baud_t) + " | Adresse: ");
                              Serial.printf("%d : %s\n", scan_ids, (const char *)me);

                        } else {
                          ModbusError me(err);
                          Serial.print("[SE] | Even Parity | 1 Stopbit | Baud: " + String(mbus_baud_t) + " | Adresse: ");
                          Serial.printf("%d : %s\n", scan_ids, (const char *)me);

                          //String tempstr; 
                          tempstr = "Even Parity | 1 Stopbit | Baud: "; 
                          tempstr += String(mbus_baud_t); 
                          tempstr += " | Adresse: "; 
                          tempstr += String(scan_ids);  
                          tempstr += " | ";  
                          tempstr += String((const char *)me);  
                          
                              #ifdef ea_webserver
                              #ifdef j_2_webserver
                              if(disable_server >= 1 && String((const char *)me) == "Success") { 
                                things_list_t_16 = tempstr;
                                answer_s = things_list_t_16;
                                entr_log = true;
                              }
                              #endif
                              #endif
                          tempstr += "\r\n"; 
                          pTxCharacteristic->setValue(tempstr.c_str());
                          pTxCharacteristic->notify();

                        }  
                      
          } 
         //-------------------------------------

            //--------------------------------------------------------------
            g_search_start_count = 12;
            ms3 = millis(); 
        }




        if(g_search_start_count == 12 && millis() - ms3 > 1000){
            g_search_start_count = 13; 
            //--------------------------------------------------------------



        //************ Even Parity SERIAL_5E1 **************


                          tempstr += "-------------------- \r\n"; 
                          pTxCharacteristic->setValue(tempstr.c_str());
                          pTxCharacteristic->notify();



       //************ Even Parity SERIAL_5O1 **************
        
           //-------------------------------------
            Serial1.flush(); // wait for last transmitted data to be sent 
            mbus_baud_t = 4800;
            Serial.println(F("-----------------------------------------"));
            Serial.println(F(" "));
            //Serial.println("[SE] " + p_uhrzeit + " | Odd Parity | 1 Stopbit | Baud " + String(mbus_baud_t));
                          //String tempstr; 
                          tempstr = "Odd Parity | 1 Stopbit | Baud: "; 
                          tempstr += String(mbus_baud_t); 
                          tempstr += "\r\n"; 
                          pTxCharacteristic->setValue(tempstr.c_str());
                          pTxCharacteristic->notify();

            Serial1.begin(mbus_baud_t, SERIAL_5O1, Serial1_RXPIN, Serial1_TXPIN);
            while(Serial1.available()) Serial1.read();
           //-------------------------------------


         //-------------------------------------
          for (uint8_t scan_ids = 1; scan_ids < 5; scan_ids++) { 

                        esp_task_wdt_reset(); 
                        MB.setTimeout(200);
                        ModbusMessage n = MB.syncRequest(1, scan_ids, READ_HOLD_REGISTER, 0, 1);  //void handleData(  
                        Modbus::Error err = n.getError();

                        if (err != SUCCESS ) {
                          ModbusError me(err);
                        } else {
                          ModbusError me(err);
                        }  
                      
          } 
         //-------------------------------------

         //-------------------------------------
            lc.setChar(0,0,'S',false);
            lc.setChar(0,1,'E',false);
            lc.setChar(0,2,'C',false);
            lc.setChar(0,3,'H',false);
        
          for (uint8_t scan_ids = 1; scan_ids < scan_max; scan_ids++) { 

                        esp_task_wdt_reset(); 
                        tick4 = !tick4;
                        lc.setChar(0,2,'C',tick4);
                        MB.setTimeout(200);
                        ModbusMessage n = MB.syncRequest(1, scan_ids, READ_HOLD_REGISTER, 0, 1);  //void handleData(  
                        Modbus::Error err = n.getError();

                        if (err != SUCCESS ) {
                              ModbusError me(err);
                              Serial.print("[SE] | Odd Parity | 1 Stopbit | Baud: " + String(mbus_baud_t) + " | Adresse: ");
                              Serial.printf("%d : %s\n", scan_ids, (const char *)me);

                        } else {
                          ModbusError me(err);
                          Serial.print("[SE] | Odd Parity | 1 Stopbit | Baud: " + String(mbus_baud_t) + " | Adresse: ");
                          Serial.printf("%d : %s\n", scan_ids, (const char *)me);

                          //String tempstr; 
                          tempstr = "Odd Parity | 1 Stopbit | Baud: "; 
                          tempstr += String(mbus_baud_t); 
                          tempstr += " | Adresse: "; 
                          tempstr += String(scan_ids);  
                          tempstr += " | ";  
                          tempstr += String((const char *)me);  
                           
                              #ifdef ea_webserver
                              #ifdef j_2_webserver
                              if(disable_server >= 1 && String((const char *)me) == "Success") { 
                                things_list_t_16 = tempstr;
                                answer_s = things_list_t_16;
                                entr_log = true;
                              }
                              #endif
                              #endif
                          tempstr += "\r\n"; 
                          pTxCharacteristic->setValue(tempstr.c_str());
                          pTxCharacteristic->notify();

                        }  
                      
          } 
         //-------------------------------------

            
            //--------------------------------------------------------------
            g_search_start_count = 14;
            ms3 = millis(); 
        }




             
        if(g_search_start_count == 14 && millis() - ms3 > 1000){
            g_search_start_count = 15; 
            //--------------------------------------------------------------


           //-------------------------------------
            Serial1.flush(); // wait for last transmitted data to be sent 
            mbus_baud_t = 9600;
            Serial.println(F(" "));
            Serial.println(F("-----------------------------------------"));
            //Serial.println("[SE] " + p_uhrzeit + " | Odd Parity | 1 Stopbit | Baud " + String(mbus_baud_t));

                          //String tempstr; 
                          tempstr = "Odd Parity | 1 Stopbit | Baud: "; 
                          tempstr += String(mbus_baud_t); 
                          tempstr += "\r\n"; 
                          pTxCharacteristic->setValue(tempstr.c_str());
                          pTxCharacteristic->notify();

            Serial1.begin(mbus_baud_t, SERIAL_5O1, Serial1_RXPIN, Serial1_TXPIN);
            while(Serial1.available()) Serial1.read();
           //-------------------------------------

         //-------------------------------------
          for (uint8_t scan_ids = 1; scan_ids < 5; scan_ids++) { 

                        esp_task_wdt_reset(); 
                        MB.setTimeout(200);
                        ModbusMessage n = MB.syncRequest(1, scan_ids, READ_HOLD_REGISTER, 0, 1);  //void handleData(  
                        Modbus::Error err = n.getError();

                        if (err != SUCCESS ) {
                              ModbusError me(err);
                        } else {
                              ModbusError me(err);
                        }  
                      
          } 
         //-------------------------------------

         //-------------------------------------
            lc.setChar(0,0,'S',false);
            lc.setChar(0,1,'E',false);
            lc.setChar(0,2,'C',false);
            lc.setChar(0,3,'H',false);
        
          for (uint8_t scan_ids = 1; scan_ids < scan_max; scan_ids++) { 

                        esp_task_wdt_reset(); 
                        tick4 = !tick4;
                        lc.setChar(0,3,'H',tick4);
                        MB.setTimeout(200);
                        ModbusMessage n = MB.syncRequest(1, scan_ids, READ_HOLD_REGISTER, 0, 1);  //void handleData(  
                        Modbus::Error err = n.getError();

                        if (err != SUCCESS ) {
                    
                              ModbusError me(err);

                              Serial.print("[SE] | Odd Parity | 1 Stopbit | Baud: " + String(mbus_baud_t) + " | Adresse: ");
                              Serial.printf("%d : %s\n", scan_ids, (const char *)me);

                        } else {
                    
                          ModbusError me(err);

                          Serial.print("[SE] | Odd Parity | 1 Stopbit | Baud: " + String(mbus_baud_t) + " | Adresse: ");
                          Serial.printf("%d : %s\n", scan_ids, (const char *)me);


                          //String tempstr; 
                          tempstr = "Odd Parity | 1 Stopbit | Baud: "; 
                          tempstr += String(mbus_baud_t); 
                          tempstr += " | Adresse: "; 
                          tempstr += String(scan_ids);  
                          tempstr += " | ";  
                          tempstr += String((const char *)me);  
                          
                              #ifdef ea_webserver
                              if(disable_server >= 1 && String((const char *)me) == "Success") { 
                                things_list_t_16 = tempstr;
                                answer_s = things_list_t_16;
                                entr_log = true;
                              }
                              #endif
                          tempstr += "\r\n"; 
                          pTxCharacteristic->setValue(tempstr.c_str());
                          pTxCharacteristic->notify();



                        }  
                      
          } 
         //-------------------------------------
            
            //--------------------------------------------------------------
            g_search_start_count = 16;
            ms3 = millis(); 
        }



        if(g_search_start_count == 4 && millis() - ms3 > 1000){
            g_search_start_count = 5; 
            //--------------------------------------------------------------


           //-------------------------------------
            Serial1.flush(); // wait for last transmitted data to be sent 
            mbus_baud_t = 19200;
            Serial.println(F("-----------------------------------------"));
            Serial.println(F(" "));
            //Serial.println("[SE] " + p_uhrzeit + " | Odd Parity | 1 Stopbit | Change Baud " + String(mbus_baud_t));
                          //String tempstr; 
                          tempstr = "Odd Parity | 1 Stopbit | Baud: "; 
                          tempstr += String(mbus_baud_t); 
                          tempstr += "\r\n"; 
                          pTxCharacteristic->setValue(tempstr.c_str());
                          pTxCharacteristic->notify();

            Serial1.begin(mbus_baud_t, SERIAL_5O1, Serial1_RXPIN, Serial1_TXPIN);
            while(Serial1.available()) Serial1.read();
           //-------------------------------------

         //-------------------------------------
          for (uint8_t scan_ids = 1; scan_ids < 5; scan_ids++) { 

                        esp_task_wdt_reset(); 
                        MB.setTimeout(200);
                        ModbusMessage n = MB.syncRequest(1, scan_ids, READ_HOLD_REGISTER, 0, 1);  //void handleData(  
                        Modbus::Error err = n.getError();

                        if (err != SUCCESS ) {
                          ModbusError me(err);
                        } else {
                          ModbusError me(err);
                        }  
                      
          } 
         //-------------------------------------

         //-------------------------------------
            lc.setChar(0,0,'S',false);
            lc.setChar(0,1,'E',false);
            lc.setChar(0,2,'C',false);
            lc.setChar(0,3,'H',false);
        
          for (uint8_t scan_ids = 1; scan_ids < scan_max; scan_ids++) { 

                        esp_task_wdt_reset(); 
                        tick4 = !tick4;
                        lc.setChar(0,0,'S',tick4);
                        MB.setTimeout(200);
                        ModbusMessage n = MB.syncRequest(1, scan_ids, READ_HOLD_REGISTER, 0, 1);  //void handleData(  
                        Modbus::Error err = n.getError();

                        if (err != SUCCESS ) {
                              ModbusError me(err);
                              Serial.print("[SE] | Odd Parity | 1 Stopbit | Baud: " + String(mbus_baud_t) + " | Adresse: ");
                              Serial.printf("%d : %s\n", scan_ids, (const char *)me);

                        } else {
                          ModbusError me(err);
                          Serial.print("[SE] | Odd Parity | 1 Stopbit | Baud: " + String(mbus_baud_t) + " | Adresse: ");
                          Serial.printf("%d : %s\n", scan_ids, (const char *)me);

                          //String tempstr; 
                          tempstr = "Odd Parity | 1 Stopbit | Baud: "; 
                          tempstr += String(mbus_baud_t); 
                          tempstr += " | Adresse: "; 
                          tempstr += String(scan_ids);  
                          tempstr += " | ";  
                          tempstr += String((const char *)me);  
                          
                              #ifdef ea_webserver
                              if(disable_server >= 1 && String((const char *)me) == "Success") { 
                                things_list_t_16 = tempstr;
                                answer_s = things_list_t_16;
                                entr_log = true;
                              }
                              #endif
                          tempstr += "\r\n"; 
                          pTxCharacteristic->setValue(tempstr.c_str());
                          pTxCharacteristic->notify();

                        }  
                      
          } 
         //-------------------------------------
            

            //--------------------------------------------------------------
            g_search_start_count = 6;
            ms3 = millis(); 
        }



        if(g_search_start_count == 16 && millis() - ms3 > 1000){
            g_search_start_count = 17; 
            //--------------------------------------------------------------



        //************ Odd Parity SERIAL_5O1 **************

                          tempstr += "-------------------- \r\n"; 
                          pTxCharacteristic->setValue(tempstr.c_str());
                          pTxCharacteristic->notify();




       //-------------------------------------
            Serial1.flush(); // wait for last transmitted data to be sent 
            mbus_baud_t = 4800;
            Serial.println(F("-----------------------------------------"));
            Serial.println(F(" "));
            //Serial.println("[SE] " + p_uhrzeit + " | 2 Stopbits | Baud " + String(mbus_baud_t));
                          
                          tempstr = "None Parity | 2 Stopbits | Baud: "; 
                          tempstr += String(mbus_baud_t); 
                          tempstr += "\r\n"; 
                          pTxCharacteristic->setValue(tempstr.c_str());
                          pTxCharacteristic->notify();

            Serial1.begin(mbus_baud_t, SERIAL_8N1, Serial1_RXPIN, Serial1_TXPIN);
            while(Serial1.available()) Serial1.read();
           //-------------------------------------


         //-------------------------------------
          for (uint8_t scan_ids = 1; scan_ids < 5; scan_ids++) { 

                        esp_task_wdt_reset(); 
                        MB.setTimeout(200);
                        ModbusMessage n = MB.syncRequest(1, scan_ids, READ_HOLD_REGISTER, 0, 1);  //void handleData(  
                        Modbus::Error err = n.getError();

                        if (err != SUCCESS ) {
                          ModbusError me(err);
                        } else {
                          ModbusError me(err);
                        }  
                      
          } 
         //-------------------------------------

         //-------------------------------------
            lc.setChar(0,0,'S',false);
            lc.setChar(0,1,'E',false);
            lc.setChar(0,2,'C',false);
            lc.setChar(0,3,'H',false);
        
          for (uint8_t scan_ids = 1; scan_ids < scan_max; scan_ids++) { 

                        esp_task_wdt_reset(); 
                        tick4 = !tick4;
                        lc.setChar(0,1,'E',tick4);
                        MB.setTimeout(200);
                        ModbusMessage n = MB.syncRequest(1, scan_ids, READ_HOLD_REGISTER, 0, 1);  //void handleData(  
                        Modbus::Error err = n.getError();

                        if (err != SUCCESS ) {
                              ModbusError me(err);
                              Serial.print("[SE] | None Parity | 2 Stopbits | Baud: " + String(mbus_baud_t) + " | Adresse: ");
                              Serial.printf("%d : %s\n", scan_ids, (const char *)me);

                        } else {
                          ModbusError me(err);
                          Serial.print("[SE] | None Parity | 2 Stopbits | Baud: " + String(mbus_baud_t) + " | Adresse: ");
                          Serial.printf("%d : %s\n", scan_ids, (const char *)me);

                          //String tempstr; 
                          tempstr = "None Parity | 2 Stopbits | Baud: "; 
                          tempstr += String(mbus_baud_t); 
                          tempstr += " | Adresse: "; 
                          tempstr += String(scan_ids);  
                          tempstr += " | ";  
                          tempstr += String((const char *)me);  
                          
                              #ifdef ea_webserver
                              if(disable_server >= 1 && String((const char *)me) == "Success") { 
                                things_list_t_16 = tempstr;
                                answer_s = things_list_t_16;
                                entr_log = true;
                              }
                              #endif
                          tempstr += "\r\n"; 
                          pTxCharacteristic->setValue(tempstr.c_str());
                          pTxCharacteristic->notify();

                        }  
                      
          } 
         //-------------------------------------

            
            //--------------------------------------------------------------
            g_search_start_count = 18;
            ms3 = millis(); 
        }




             
        if(g_search_start_count == 18 && millis() - ms3 > 1000){
            g_search_start_count = 19; 
            //--------------------------------------------------------------


           //-------------------------------------
            Serial1.flush(); // wait for last transmitted data to be sent 
            mbus_baud_t = 9600;
            Serial.println(F(" "));
            Serial.println(F("-----------------------------------------"));
            //Serial.println("[SE] " + p_uhrzeit + " | 2 Stopbits | Baud " + String(mbus_baud_t));

                          //String tempstr; 
                          tempstr = "None Parity | 2 Stopbits | Baud: "; 
                          tempstr += String(mbus_baud_t); 
                          tempstr += "\r\n"; 
                          pTxCharacteristic->setValue(tempstr.c_str());
                          pTxCharacteristic->notify();

            Serial1.begin(mbus_baud_t, SERIAL_8N2, Serial1_RXPIN, Serial1_TXPIN);
            while(Serial1.available()) Serial1.read();
           //-------------------------------------

         //-------------------------------------
          for (uint8_t scan_ids = 1; scan_ids < 5; scan_ids++) { 

                        esp_task_wdt_reset(); 
                        MB.setTimeout(200);
                        ModbusMessage n = MB.syncRequest(1, scan_ids, READ_HOLD_REGISTER, 0, 1);  //void handleData(  
                        Modbus::Error err = n.getError();

                        if (err != SUCCESS ) {
                              ModbusError me(err);
                        } else {
                              ModbusError me(err);
                        }  
                      
          } 
         //-------------------------------------

         //-------------------------------------
            lc.setChar(0,0,'S',false);
            lc.setChar(0,1,'E',false);
            lc.setChar(0,2,'C',false);
            lc.setChar(0,3,'H',false);
        
          for (uint8_t scan_ids = 1; scan_ids < scan_max; scan_ids++) { 

                        esp_task_wdt_reset(); 
                        tick4 = !tick4;
                        lc.setChar(0,2,'C',tick4);
                        MB.setTimeout(200);
                        ModbusMessage n = MB.syncRequest(1, scan_ids, READ_HOLD_REGISTER, 0, 1);  //void handleData(  
                        Modbus::Error err = n.getError();

                        if (err != SUCCESS ) {
                    
                              ModbusError me(err);

                              Serial.print("[SE] | None Parity | 2 Stopbits | Baud: " + String(mbus_baud_t) + " | Adresse: ");
                              Serial.printf("%d : %s\n", scan_ids, (const char *)me);

                        } else {
                    
                          ModbusError me(err);

                          Serial.print("[SE] | None Parity | 2 Stopbits | Baud: " + String(mbus_baud_t) + " | Adresse: ");
                          Serial.printf("%d : %s\n", scan_ids, (const char *)me);

                          //String tempstr; 
                          tempstr = "None Parity | 2 Stopbits | Baud: "; 
                          tempstr += String(mbus_baud_t); 
                          tempstr += " | Adresse: "; 
                          tempstr += String(scan_ids);  
                          tempstr += " | ";  
                          tempstr += String((const char *)me);  
                        
                              #ifdef ea_webserver
                              if(disable_server >= 1 && String((const char *)me) == "Success") { 
                                things_list_t_16 = tempstr;
                                answer_s = things_list_t_16;
                                entr_log = true;
                              }
                              #endif
                          tempstr += "\r\n"; 
                          pTxCharacteristic->setValue(tempstr.c_str());
                          pTxCharacteristic->notify();

                        }  
                      
          } 
         //-------------------------------------
            
            //--------------------------------------------------------------
            g_search_start_count = 20;
            ms3 = millis(); 
        }



             
        if(g_search_start_count == 20 && millis() - ms3 > 1000){
            g_search_start_count = 21; 
            //--------------------------------------------------------------


           //-------------------------------------
            Serial1.flush(); // wait for last transmitted data to be sent 
            mbus_baud_t = 19200;
            Serial.println(F("-----------------------------------------"));
            Serial.println(F(" "));
            //Serial.println("[SE] " + p_uhrzeit + " None Parity | 2 Stopbits | Baud " + String(mbus_baud_t));
                          //String tempstr; 
                          tempstr = "None Parity | 2 Stopbits | Baud: "; 
                          tempstr += String(mbus_baud_t); 
                          tempstr += "\r\n"; 
                          pTxCharacteristic->setValue(tempstr.c_str());
                          pTxCharacteristic->notify();

            Serial1.begin(mbus_baud_t, SERIAL_8N2, Serial1_RXPIN, Serial1_TXPIN);
            while(Serial1.available()) Serial1.read();
           //-------------------------------------

         //-------------------------------------
          for (uint8_t scan_ids = 1; scan_ids < 5; scan_ids++) { 

                        esp_task_wdt_reset(); 
                        MB.setTimeout(200);
                        ModbusMessage n = MB.syncRequest(1, scan_ids, READ_HOLD_REGISTER, 0, 1);  //void handleData(  
                        Modbus::Error err = n.getError();

                        if (err != SUCCESS ) {
                          ModbusError me(err);
                        } else {
                          ModbusError me(err);
                        }  
                      
          } 
         //-------------------------------------

         //-------------------------------------
            lc.setChar(0,0,'S',false);
            lc.setChar(0,1,'E',false);
            lc.setChar(0,2,'C',false);
            lc.setChar(0,3,'H',false);
        
          for (uint8_t scan_ids = 1; scan_ids < scan_max; scan_ids++) { 

                        esp_task_wdt_reset(); 
                        tick4 = !tick4;
                        lc.setChar(0,3,'H',tick4);
                        MB.setTimeout(200);
                        ModbusMessage n = MB.syncRequest(1, scan_ids, READ_HOLD_REGISTER, 0, 1);  //void handleData(  
                        Modbus::Error err = n.getError();

                        if (err != SUCCESS ) {
                              ModbusError me(err);
                              Serial.print("[SE] | None Parity | 2 Stopbits | Baud: " + String(mbus_baud_t) + " | Adresse: ");
                              Serial.printf("%d : %s\n", scan_ids, (const char *)me);

                        } else {
                          ModbusError me(err);
                          Serial.print("[SE] | None Parity | 2 Stopbits | Baud: " + String(mbus_baud_t) + " | Adresse: ");
                          Serial.printf("%d : %s\n", scan_ids, (const char *)me);

                          //String tempstr; 
                          tempstr = "None Parity | 2 Stopbits | Baud: "; 
                          tempstr += String(mbus_baud_t); 
                          tempstr += " | Adresse: "; 
                          tempstr += String(scan_ids);  
                          tempstr += " | ";  
                          tempstr += String((const char *)me);  
                         
                              #ifdef ea_webserver
                              if(disable_server >= 1 && String((const char *)me) == "Success") { 
                                things_list_t_16 = tempstr;
                                answer_s = things_list_t_16;
                                entr_log = true;
                              }
                              #endif
                          tempstr += "\r\n"; 
                          pTxCharacteristic->setValue(tempstr.c_str());
                          pTxCharacteristic->notify();

                        }  
                      
          } 
         //-------------------------------------
            
            //--------------------------------------------------------------
            g_search_start_count = 22;
            ms3 = millis(); 
        }




             
        if(g_search_start_count == 22 && millis() - ms3 > 1000){
            g_search_start_count = 23; 
            //--------------------------------------------------------------




        //************ BAUD **************

                          tempstr += "-------------------- \r\n"; 
                          pTxCharacteristic->setValue(tempstr.c_str());
                          pTxCharacteristic->notify();



       //************ Even Parity SERIAL_5E2 **************
        
           //-------------------------------------
            Serial1.flush(); // wait for last transmitted data to be sent 
            mbus_baud_t = 4800;
            Serial.println(F("-----------------------------------------"));
            Serial.println(F(" "));
            //Serial.println("[SE] " + p_uhrzeit + " | Even Parity | 2 Stopbits | Baud " + String(mbus_baud_t));
                          //String tempstr; 
                          tempstr = "Even Parity | 2 Stopbits | Baud: "; 
                          tempstr += String(mbus_baud_t); 
                          tempstr += "\r\n"; 
                          pTxCharacteristic->setValue(tempstr.c_str());
                          pTxCharacteristic->notify();

            Serial1.begin(mbus_baud_t, SERIAL_5E2, Serial1_RXPIN, Serial1_TXPIN);
            while(Serial1.available()) Serial1.read();
           //-------------------------------------


         //-------------------------------------
          for (uint8_t scan_ids = 1; scan_ids < 5; scan_ids++) { 

                        esp_task_wdt_reset(); 
                        MB.setTimeout(200);
                        ModbusMessage n = MB.syncRequest(1, scan_ids, READ_HOLD_REGISTER, 0, 1);  //void handleData(  
                        Modbus::Error err = n.getError();

                        if (err != SUCCESS ) {
                          ModbusError me(err);
                        } else {
                          ModbusError me(err);
                        }  
                      
          } 
         //-------------------------------------

         //-------------------------------------
            lc.setChar(0,0,'S',false);
            lc.setChar(0,1,'E',false);
            lc.setChar(0,2,'C',false);
            lc.setChar(0,3,'H',false);
        
          for (uint8_t scan_ids = 1; scan_ids < scan_max; scan_ids++) { 

                        esp_task_wdt_reset(); 
                        tick4 = !tick4;
                        lc.setChar(0,0,'S',tick4);
                        MB.setTimeout(200);
                        ModbusMessage n = MB.syncRequest(1, scan_ids, READ_HOLD_REGISTER, 0, 1);  //void handleData(  
                        Modbus::Error err = n.getError();

                        if (err != SUCCESS ) {
                              ModbusError me(err);
                              Serial.print("[SE] | Even Parity | 2 Stopbits | Baud: " + String(mbus_baud_t) + " | Adresse: ");
                              Serial.printf("%d : %s\n", scan_ids, (const char *)me);

                        } else {
                          ModbusError me(err);
                          Serial.print("[SE] | Even Parity | 2 Stopbits | Baud: " + String(mbus_baud_t) + " | Adresse: ");
                          Serial.printf("%d : %s\n", scan_ids, (const char *)me);

                          //String tempstr; 
                          tempstr = "Even Parity | 2 Stopbits | Baud: "; 
                          tempstr += String(mbus_baud_t); 
                          tempstr += " | Adresse: "; 
                          tempstr += String(scan_ids);  
                          tempstr += " | ";  
                          tempstr += String((const char *)me);  
                          
                              #ifdef ea_webserver
                              if(disable_server >= 1 && String((const char *)me) == "Success") { 
                                things_list_t_16 = tempstr;
                                answer_s = things_list_t_16;
                                entr_log = true;
                              }
                              #endif
                          tempstr += "\r\n"; 
                          pTxCharacteristic->setValue(tempstr.c_str());
                          pTxCharacteristic->notify();

                        }  
                      
          } 
         //-------------------------------------
            
            //--------------------------------------------------------------
            g_search_start_count = 24;
            ms3 = millis(); 
        }





        if(g_search_start_count == 24 && millis() - ms3 > 1000){
            g_search_start_count = 25; 
            //--------------------------------------------------------------


           //-------------------------------------
            Serial1.flush(); // wait for last transmitted data to be sent 
            mbus_baud_t = 9600;
            Serial.println(F(" "));
            Serial.println(F("-----------------------------------------"));
            //Serial.println("[SE] " + p_uhrzeit + " | Even Parity | 2 Stopbits | Baud " + String(mbus_baud_t));

                          //String tempstr; 
                          tempstr = "Even Parity | 2 Stopbits | Baud: "; 
                          tempstr += String(mbus_baud_t); 
                          tempstr += "\r\n"; 
                          pTxCharacteristic->setValue(tempstr.c_str());
                          pTxCharacteristic->notify();

            Serial1.begin(mbus_baud_t, SERIAL_5E2, Serial1_RXPIN, Serial1_TXPIN);
            while(Serial1.available()) Serial1.read();
           //-------------------------------------

         //-------------------------------------
          for (uint8_t scan_ids = 1; scan_ids < 5; scan_ids++) { 

                        esp_task_wdt_reset(); 
                        MB.setTimeout(200);
                        ModbusMessage n = MB.syncRequest(1, scan_ids, READ_HOLD_REGISTER, 0, 1);  //void handleData(  
                        Modbus::Error err = n.getError();

                        if (err != SUCCESS ) {
                              ModbusError me(err);
                        } else {
                              ModbusError me(err);
                        }  
                      
          } 
         //-------------------------------------

         //-------------------------------------
            lc.setChar(0,0,'S',false);
            lc.setChar(0,1,'E',false);
            lc.setChar(0,2,'C',false);
            lc.setChar(0,3,'H',false);
        
          for (uint8_t scan_ids = 1; scan_ids < scan_max; scan_ids++) { 

                        esp_task_wdt_reset(); 
                        tick4 = !tick4;
                        lc.setChar(0,1,'E',tick4);
                        MB.setTimeout(200);
                        ModbusMessage n = MB.syncRequest(1, scan_ids, READ_HOLD_REGISTER, 0, 1);  //void handleData(  
                        Modbus::Error err = n.getError();

                        if (err != SUCCESS ) {
                    
                              ModbusError me(err);

                              Serial.print("[SE] | aEven Parity | 2 Stopbits | Baud: " + String(mbus_baud_t) + " | Adresse: ");
                              Serial.printf("%d : %s\n", scan_ids, (const char *)me);

                        } else {
                    
                          ModbusError me(err);

                          Serial.print("[SE] | bEven Parity | 2 Stopbits | Baud: " + String(mbus_baud_t) + " | Adresse: ");
                          Serial.printf("%d : %s\n", scan_ids, (const char *)me);


                          //String tempstr; 
                          tempstr = "Even Parity | 2 Stopbits | Baud: "; 
                          tempstr += String(mbus_baud_t); 
                          tempstr += " | Adresse: "; 
                          tempstr += String(scan_ids);  
                          tempstr += " | ";  
                          tempstr += String((const char *)me);  
                          
                              #ifdef ea_webserver
                              if(disable_server >= 1 && String((const char *)me) == "Success") { 
                                things_list_t_16 = tempstr;
                                answer_s = things_list_t_16;
                                entr_log = true;
                              }
                              #endif
                          tempstr += "\r\n"; 
                          pTxCharacteristic->setValue(tempstr.c_str());
                          pTxCharacteristic->notify();



                        }  
                      
          } 
         //-------------------------------------
            
            //--------------------------------------------------------------
            g_search_start_count = 26;
            ms3 = millis(); 
        }



        if(g_search_start_count == 26 && millis() - ms3 > 1000){
            g_search_start_count = 27; 
            //--------------------------------------------------------------


           //-------------------------------------
            Serial1.flush(); // wait for last transmitted data to be sent 
            mbus_baud_t = 19200;
            Serial.println(F("-----------------------------------------"));
            Serial.println(F(" "));
            //Serial.println("[SE] " + p_uhrzeit + " | Even Parity | 2 Stopbits | Change Baud " + String(mbus_baud_t));
                          //String tempstr; 
                          tempstr = "Even Parity | 2 Stopbits | Baud: "; 
                          tempstr += String(mbus_baud_t); 
                          tempstr += "\r\n"; 
                          pTxCharacteristic->setValue(tempstr.c_str());
                          pTxCharacteristic->notify();

            Serial1.begin(mbus_baud_t, SERIAL_5E2, Serial1_RXPIN, Serial1_TXPIN);
            while(Serial1.available()) Serial1.read();
           //-------------------------------------

         //-------------------------------------
          for (uint8_t scan_ids = 1; scan_ids < 5; scan_ids++) { 

                        esp_task_wdt_reset(); 
                        MB.setTimeout(200);
                        ModbusMessage n = MB.syncRequest(1, scan_ids, READ_HOLD_REGISTER, 0, 1);  //void handleData(  
                        Modbus::Error err = n.getError();

                        if (err != SUCCESS ) {
                          ModbusError me(err);
                        } else {
                          ModbusError me(err);
                        }  
                      
          } 
         //-------------------------------------

         //-------------------------------------
            lc.setChar(0,0,'S',false);
            lc.setChar(0,1,'E',false);
            lc.setChar(0,2,'C',false);
            lc.setChar(0,3,'H',false);
        
          for (uint8_t scan_ids = 1; scan_ids < scan_max; scan_ids++) { 

                        esp_task_wdt_reset(); 
                        tick4 = !tick4;
                        lc.setChar(0,2,'C',tick4);
                        MB.setTimeout(200);
                        ModbusMessage n = MB.syncRequest(1, scan_ids, READ_HOLD_REGISTER, 0, 1);  //void handleData(  
                        Modbus::Error err = n.getError();

                        if (err != SUCCESS ) {
                              ModbusError me(err);
                              Serial.print("[SE] | Even Parity | 2 Stopbits | Baud: " + String(mbus_baud_t) + " | Adresse: ");
                              Serial.printf("%d : %s\n", scan_ids, (const char *)me);

                        } else {
                          ModbusError me(err);
                          Serial.print("[SE] | Even Parity | 2 Stopbits | Baud: " + String(mbus_baud_t) + " | Adresse: ");
                          Serial.printf("%d : %s\n", scan_ids, (const char *)me);

                          //String tempstr; 
                          tempstr = "Even Parity | 2 Stopbits | Baud: "; 
                          tempstr += String(mbus_baud_t); 
                          tempstr += " | Adresse: "; 
                          tempstr += String(scan_ids);  
                          tempstr += " | ";  
                          tempstr += String((const char *)me);  
                          
                              #ifdef ea_webserver
                              if(disable_server >= 1 && String((const char *)me) == "Success") { 
                                things_list_t_16 = tempstr;
                                answer_s = things_list_t_16;
                                entr_log = true;
                              }
                              #endif
                          tempstr += "\r\n"; 
                          pTxCharacteristic->setValue(tempstr.c_str());
                          pTxCharacteristic->notify();

                        }  
                      
          } 
         //-------------------------------------
            
            //--------------------------------------------------------------
            g_search_start_count = 28;
            ms3 = millis(); 
        }



        if(g_search_start_count == 28 && millis() - ms3 > 1000){
            g_search_start_count = 29; 
            //--------------------------------------------------------------




        //************ Even Parity SERIAL_5E2 **************



                          tempstr += "-------------------- \r\n"; 
                          pTxCharacteristic->setValue(tempstr.c_str());
                          pTxCharacteristic->notify();



       //************ Even Parity SERIAL_5O2 **************
        
           //-------------------------------------
            Serial1.flush(); // wait for last transmitted data to be sent 
            mbus_baud_t = 4800;
            Serial.println(F("-----------------------------------------"));
            Serial.println(F(" "));
            //Serial.println("[SE] " + p_uhrzeit + " | Odd Parity | 2 Stopbits | Baud " + String(mbus_baud_t));
                          //String tempstr; 
                          tempstr = "Odd Parity | 2 Stopbits | Baud: "; 
                          tempstr += String(mbus_baud_t); 
                          tempstr += "\r\n"; 
                          pTxCharacteristic->setValue(tempstr.c_str());
                          pTxCharacteristic->notify();

            Serial1.begin(mbus_baud_t, SERIAL_5O2, Serial1_RXPIN, Serial1_TXPIN);
            while(Serial1.available()) Serial1.read();


           //-------------------------------------


         //-------------------------------------
          for (uint8_t scan_ids = 1; scan_ids < 5; scan_ids++) { 

                        esp_task_wdt_reset(); 
                        MB.setTimeout(200);
                        ModbusMessage n = MB.syncRequest(1, scan_ids, READ_HOLD_REGISTER, 0, 1);  //void handleData(  
                        Modbus::Error err = n.getError();

                        if (err != SUCCESS ) {
                          ModbusError me(err);
                        } else {
                          ModbusError me(err);
                        }  
                      
          } 
         //-------------------------------------

         //-------------------------------------
            lc.setChar(0,0,'S',false);
            lc.setChar(0,1,'E',false);
            lc.setChar(0,2,'C',false);
            lc.setChar(0,3,'H',false);
        
          for (uint8_t scan_ids = 1; scan_ids < scan_max; scan_ids++) { 

                        esp_task_wdt_reset(); 
                        tick4 = !tick4;
                        lc.setChar(0,3,'H',tick4);
                        MB.setTimeout(200);
                        ModbusMessage n = MB.syncRequest(1, scan_ids, READ_HOLD_REGISTER, 0, 1);  //void handleData(  
                        Modbus::Error err = n.getError();

                        if (err != SUCCESS ) {
                              ModbusError me(err);
                              Serial.print("[SE] | Odd Parity | 2 Stopbits | Baud: " + String(mbus_baud_t) + " | Adresse: ");
                              Serial.printf("%d : %s\n", scan_ids, (const char *)me);

                        } else {
                          ModbusError me(err);
                          Serial.print("[SE] | Odd Parity | 2 Stopbits | Baud: " + String(mbus_baud_t) + " | Adresse: ");
                          Serial.printf("%d : %s\n", scan_ids, (const char *)me);

                          //String tempstr; 
                          tempstr = "Odd Parity | 2 Stopbits | Baud: "; 
                          tempstr += String(mbus_baud_t); 
                          tempstr += " | Adresse: "; 
                          tempstr += String(scan_ids);  
                          tempstr += " | ";  
                          tempstr += String((const char *)me);  
                          
                              #ifdef ea_webserver
                              if(disable_server >= 1 && String((const char *)me) == "Success") { 
                                things_list_t_16 = tempstr;
                                answer_s = things_list_t_16;
                                entr_log = true;
                              }
                              #endif
                          tempstr += "\r\n"; 
                          pTxCharacteristic->setValue(tempstr.c_str());
                          pTxCharacteristic->notify();
                          size_t message_length = strlen(tempstr.c_str());
                          sentTraffic += message_length;  

                        }  
                      
          } 
         //-------------------------------------
            
            //--------------------------------------------------------------
            g_search_start_count = 30;
            ms3 = millis(); 
        }




        if(g_search_start_count == 30 && millis() - ms3 > 1000){
            g_search_start_count = 31; 
            //--------------------------------------------------------------



           //-------------------------------------
            Serial1.flush(); // wait for last transmitted data to be sent 
            mbus_baud_t = 9600;
            Serial.println(F(" "));
            Serial.println(F("-----------------------------------------"));
            //Serial.println("[SE] " + p_uhrzeit + " | Odd Parity | 2 Stopbits | Baud " + String(mbus_baud_t));

                          //String tempstr; 
                          tempstr = "Odd Parity | 2 Stopbits | Baud: "; 
                          tempstr += String(mbus_baud_t); 
                          tempstr += "\r\n"; 
                          pTxCharacteristic->setValue(tempstr.c_str());
                          pTxCharacteristic->notify();
                          size_t message_length = strlen(tempstr.c_str());
                          sentTraffic += message_length;  

            Serial1.begin(mbus_baud_t, SERIAL_5O2, Serial1_RXPIN, Serial1_TXPIN);
            while(Serial1.available()) Serial1.read();
           //-------------------------------------

         //-------------------------------------
          for (uint8_t scan_ids = 1; scan_ids < 5; scan_ids++) { 

                        esp_task_wdt_reset(); 
                        MB.setTimeout(200);
                        ModbusMessage n = MB.syncRequest(1, scan_ids, READ_HOLD_REGISTER, 0, 1);  //void handleData(  
                        Modbus::Error err = n.getError();

                        if (err != SUCCESS ) {
                              ModbusError me(err);
                        } else {
                              ModbusError me(err);
                        }  
                      
          } 
         //-------------------------------------
         //-------------------------------------
            lc.setChar(0,0,'S',false);
            lc.setChar(0,1,'E',false);
            lc.setChar(0,2,'C',false);
            lc.setChar(0,3,'H',false);
        
          for (uint8_t scan_ids = 1; scan_ids < scan_max; scan_ids++) { 

                        esp_task_wdt_reset(); 
                        tick4 = !tick4;
                        lc.setChar(0,0,'S',tick4);
                        MB.setTimeout(200);
                        ModbusMessage n = MB.syncRequest(1, scan_ids, READ_HOLD_REGISTER, 0, 1);  //void handleData(  
                        Modbus::Error err = n.getError();

                        if (err != SUCCESS ) {
                    
                              ModbusError me(err);

                              Serial.print("[SE] | Odd Parity | 2 Stopbits | Baud: " + String(mbus_baud_t) + " | Adresse: ");
                              Serial.printf("%d : %s\n", scan_ids, (const char *)me);

                        } else {
                    
                          ModbusError me(err);

                          Serial.print("[SE] | Odd Parity | 2 Stopbits | Baud: " + String(mbus_baud_t) + " | Adresse: ");
                          Serial.printf("%d : %s\n", scan_ids, (const char *)me);


                          //String tempstr; 
                          tempstr = "Odd Parity | 2 Stopbits | Baud: "; 
                          tempstr += String(mbus_baud_t); 
                          tempstr += " | Adresse: "; 
                          tempstr += String(scan_ids);  
                          tempstr += " | ";  
                          tempstr += String((const char *)me);  
                          
                              #ifdef ea_webserver
                              if(disable_server >= 1 && String((const char *)me) == "Success") { 
                                things_list_t_16 = tempstr;
                                answer_s = things_list_t_16;
                                entr_log = true;
                              }
                              #endif
                          tempstr += "\r\n"; 
                          pTxCharacteristic->setValue(tempstr.c_str());
                          pTxCharacteristic->notify();
                          size_t message_length = strlen(tempstr.c_str());
                          sentTraffic += message_length;  



                        }  
                      
          } 
         //-------------------------------------
            
            //--------------------------------------------------------------
            g_search_start_count = 32;
            ms3 = millis(); 
        }


        if(g_search_start_count == 32 && millis() - ms3 > 1000){
            g_search_start_count = 33; 
            //--------------------------------------------------------------



           //-------------------------------------
            Serial1.flush(); // wait for last transmitted data to be sent 
            mbus_baud_t = 19200;
            Serial.println(F("-----------------------------------------"));
            Serial.println(F(" "));
            //Serial.println("[SE] " + p_uhrzeit + " | Odd Parity | 2 Stopbits | Change Baud " + String(mbus_baud_t));
                          //String tempstr; 
                          tempstr = "Odd Parity | 2 Stopbits | Baud: "; 
                          tempstr += String(mbus_baud_t); 
                          tempstr += "\r\n"; 
                          pTxCharacteristic->setValue(tempstr.c_str());
                          pTxCharacteristic->notify();
                          size_t message_length = strlen(tempstr.c_str());
                          sentTraffic += message_length;  

            Serial1.begin(mbus_baud_t, SERIAL_5O2, Serial1_RXPIN, Serial1_TXPIN);
            while(Serial1.available()) Serial1.read();
             
                          tempstr += " "; 
                          pTxCharacteristic->setValue(tempstr.c_str());
                          pTxCharacteristic->notify();
                          message_length = strlen(tempstr.c_str());
                          sentTraffic += message_length;  
           //-------------------------------------

         //-------------------------------------
          for (uint8_t scan_ids = 1; scan_ids < 5; scan_ids++) { 

                        esp_task_wdt_reset(); 
                        MB.setTimeout(200);
                        ModbusMessage n = MB.syncRequest(1, scan_ids, READ_HOLD_REGISTER, 0, 1);  //void handleData(  
                        Modbus::Error err = n.getError();

                        if (err != SUCCESS ) {
                          ModbusError me(err);
                        } else {
                          ModbusError me(err);
                        }  
                      
          } 
         //-------------------------------------

         //-------------------------------------
            lc.setChar(0,0,'S',false);
            lc.setChar(0,1,'E',false);
            lc.setChar(0,2,'C',false);
            lc.setChar(0,3,'H',false);
        
          for (uint8_t scan_ids = 1; scan_ids < scan_max; scan_ids++) { 

                        esp_task_wdt_reset(); 
                        tick4 = !tick4;
                        lc.setChar(0,1,'E',tick4);
                        MB.setTimeout(200);
                        ModbusMessage n = MB.syncRequest(1, scan_ids, READ_HOLD_REGISTER, 0, 1);  //void handleData(  
                        Modbus::Error err = n.getError();

                        if (err != SUCCESS ) {
                              ModbusError me(err);
                              Serial.print("[SE] | Odd Parity | 2 Stopbits | Baud: " + String(mbus_baud_t) + " | Adresse: ");
                              Serial.printf("%d : %s\n", scan_ids, (const char *)me);

                        } else {
                          ModbusError me(err);
                          Serial.print("[SE] | Odd Parity | 2 Stopbits | Baud: " + String(mbus_baud_t) + " | Adresse: ");
                          Serial.printf("%d : %s\n", scan_ids, (const char *)me);

                          //String tempstr; 
                          tempstr = "Odd Parity | 2 Stopbits | Baud: "; 
                          tempstr += String(mbus_baud_t); 
                          tempstr += " | Adresse: "; 
                          tempstr += String(scan_ids);  
                          tempstr += " | ";  
                          tempstr += String((const char *)me);  
                         
                              #ifdef ea_webserver
                              if(disable_server >= 1 && String((const char *)me) == "Success") { 
                                things_list_t_16 = tempstr;
                                answer_s = things_list_t_16;
                                entr_log = true;
                              }
                              #endif
                          tempstr += "\r\n"; 
                          pTxCharacteristic->setValue(tempstr.c_str());
                          pTxCharacteristic->notify();
                          size_t message_length = strlen(tempstr.c_str());
                          sentTraffic += message_length;  

                        }  
                      
          } 
         //-------------------------------------

        //************ Odd Parity SERIAL_5O2 **************




     //-------------------------------------
                          tempstr += "-------------------- \r\n"; 
                          pTxCharacteristic->setValue(tempstr.c_str());
                          pTxCharacteristic->notify();
                          size_t message_lengthb = strlen(tempstr.c_str());
                          sentTraffic += message_lengthb;  

                          tempstr = "Search Ende"; 
                          tempstr += "\r\n"; 
                          pTxCharacteristic->setValue(tempstr.c_str());
                          pTxCharacteristic->notify();
                          message_lengthb = strlen(tempstr.c_str());
                          sentTraffic += message_lengthb;  
                          
                          
                          
            // zurückstellen
            Serial1.begin(mbus_baud, SERIAL_8N1, Serial1_RXPIN, Serial1_TXPIN);
            while(Serial1.available()) Serial1.read();


            g_search_start = false;
            entr_log = true;

            
            //--------------------------------------------------------------
            g_search_start_count = 0;
            ms3 = millis(); 
        }



    }  
    //------------------------------------------------------------------------------------------------      




       //-----------------------------------------------------------------------------------------------
    if(g_scan_start2 == true){
           g_scan_start2 = false;
           g_scan_alternative = true;

                 // readAndSendData(0); // Nur die Anzahl der Zeilen Seriell ausgeben
                  //readAndSendData(1); // Daten nur seriell ausgeben
                  readAndSendData(2); // Daten seriell und per Bluetooth ausgeben
                 // readAndSendData(3); // Anzahl der gefundenen WLANs seriell und per Bluetooth ausgeben


    }  
    //------------------------------------------------------------------------------------------------      





       //-----------------------------------------------------------------------------------------------

      if (g_scan_start == true) {
          g_scan_start = false;
          g_search_start = false;

          WLAN_DEBUG_PRINTLN(F("[BT] Scan start"));

          if (WiFi.status() != WL_CONNECTED) {
              WiFi_status = WL_CONNECT_FAILED;
              WiFi.disconnect();
          }

          if (heap_caps_get_largest_free_block(MALLOC_CAP_DEFAULT) > 5000) {
              g_scan_alternative = false;
              int n = WiFi.scanNetworks();
              int nf = n;
              wlan_found = n;
              WLAN_DEBUG_PRINT(F("[BT] Scan done. WLAN Found: "));
              WLAN_DEBUG_PRINTLN(n);

              String tempstr;

              tempstr = "Found:";
              tempstr += String(wlan_found);
              tempstr += "\r\n";

              int length2 = tempstr.length();
              tempstr.toCharArray(find_wlan, length2 + 1);
              pTxCharacteristic->setValue(find_wlan);
              pTxCharacteristic->notify();

              if (n > 0) {
                  if (nf > 0) {
                      for (int i = 0; i < n; i++) {
                          // wlan_ssids[30][50]
                          tempstr = WiFi.SSID(i);
                          int length0 = tempstr.length();
                          tempstr.toCharArray(wlan_ssids[i], length0 + 1);

                          tempstr = String(i);
                          tempstr += ",|";
                          tempstr += WiFi.SSID(i);
                          tempstr += ",|";
                          tempstr += WiFi.BSSIDstr(i);
                          tempstr += ",|";
                          tempstr += WiFi.RSSI(i);
                          tempstr += " dBm, ";
                          tempstr += constrain(2 * (WiFi.RSSI(i) + 100), 0, 100);
                          tempstr += "%,|";
                          byte encryption = WiFi.encryptionType(i);

                          if (encryption == 0) {
                              tempstr += "OPEN";
                              strcpy(wlan_encryptionType[i], "OPEN");
                          } else if (encryption == 1) {
                              tempstr += "WEP";
                              strcpy(wlan_encryptionType[i], "WEP");
                          } else if (encryption == 2) {
                              tempstr += "WPA";
                              strcpy(wlan_encryptionType[i], "WPA");
                          } else if (encryption == 3) {
                              tempstr += "WPA2";
                              strcpy(wlan_encryptionType[i], "WPA2");
                          } else if (encryption == 4) {
                              tempstr += "WPA+WPA2";
                              strcpy(wlan_encryptionType[i], "WPA+WPA2");
                          } else if (encryption == 5) {
                              tempstr += "WEP";
                              strcpy(wlan_encryptionType[i], "WEP");
                          } else if (encryption == 7) {
                              tempstr += "NONE";
                              strcpy(wlan_encryptionType[i], "NONE");
                          } else if (encryption == 8) {
                              tempstr += "AUTO";
                              strcpy(wlan_encryptionType[i], "AUTO");
                          } else {
                              tempstr += "unknown";
                              strcpy(wlan_encryptionType[i], "unknown");
                          }

                          tempstr += "\r\n";

                          //WLAN_DEBUG_PRINT(F("[BF] "));
                          //WLAN_DEBUG_PRINTLN(tempstr);

                          if (strcmp(WiFi.SSID(i).c_str(), wIFI_SSID_c) == 0) {
                              Preferences preferences;
                              preferences.begin("eenvs", false);
                              preferences.putBytes("encryption", wlan_encryptionType[i], strlen(wlan_encryptionType[i]) + 1);
                              preferences.end();
                              strncpy(wIFI_encryptionType_c, wlan_encryptionType[i], sizeof(wIFI_encryptionType_c) - 1);
                              wIFI_encryptionType_c[sizeof(wIFI_encryptionType_c) - 1] = '\0';
                          }

                          int length = tempstr.length();
                          tempstr.toCharArray(find_wlan, length + 1);

                          pTxCharacteristic->setValue(find_wlan);
                          pTxCharacteristic->notify();
                          delay(100); // bluetooth stack will go into congestion, if too many packets are sent

                          WLAN_DEBUG_PRINT(F("-> BT: "));
                          WLAN_DEBUG_PRINTLN(find_wlan);
                      }

                      WiFi.scanDelete();
                      g_scan_start = false;
                      g_connect_WLAN = false;
                      nf = 0;
                      n = 0;
                  }
              }
          } else {
              char tempstr[100];
              snprintf(tempstr, sizeof(tempstr), "ERROR Search\r\n");
              pTxCharacteristic->setValue(tempstr);
              pTxCharacteristic->notify();
              size_t message_length = strlen(tempstr);
              sentTraffic += message_length;
              WLAN_DEBUG_PRINT(F("[BT] Nicht genug Speicher !! Aktuell: "));
              WLAN_DEBUG_PRINTLN(heap_caps_get_largest_free_block(MALLOC_CAP_DEFAULT));
              WLAN_DEBUG_PRINTLN(F("[BT] Alternative !!"));
              g_scan_start2 = true;
              g_scan_alternative = true;
          }

          g_search_start = false;

          // Ausgabe der gespeicherten WLAN-SSIDs und Verschlüsselungstypen
          WLAN_DEBUG_PRINTLN(F("Gespeicherte WLAN-SSIDs und Encrypt typen:"));
          #ifdef WLAN_DEBUG
          for (int i = 0; i < wlan_found; i++) {
              WLAN_DEBUG_PRINT(String(i) + ": ");
              WLAN_DEBUG_PRINT(wlan_ssids[i]);
              WLAN_DEBUG_PRINT(F(", Encrypt: "));
              WLAN_DEBUG_PRINTLN(wlan_encryptionType[i]);
          }
          #endif


      } // g_scan_start == true


     //-----------------------------------------------------------------------------------------------





   if(g_connect_WLAN == true && wlan_found > 0){
      
      //Serial.println(g_connect_WLAN); 
      //Serial.println(wlan_found); 
      g_connect_WLAN = false;
        
        //  ---- CONNECT to WLAN

       Serial.println(F("[BT] Verbinde zu neuem Netzwerk.")); 
        Serial.print(F("[BT] SSID: ")); Serial.println(wlan_ssids[ist_wlan]); 
        Serial.print(F("[BT] PW: ")); Serial.println(ist_pw);  

        strncpy(wIFI_SSID_c, wlan_ssids[ist_wlan], sizeof(wIFI_SSID_c) - 1);
        wIFI_SSID_c[sizeof(wIFI_SSID_c) - 1] = '\0'; // Sicherstellen, dass es null-terminiert ist

        ist_pw.toCharArray(wIFI_PASSWORD_c, sizeof(wIFI_PASSWORD_c));

        // Serial.print("[BT] ");Serial.println(wIFI_SSID_c);
        // Serial.print("[BT] ");Serial.println(wIFI_PASSWORD_c);

        // in order to send the value we must convert it to characteristic
        // char txString[8];
        // dtostrf(sensorvalue, 1, 2, txString);
        pTxCharacteristic->setValue("\r\n");
        pTxCharacteristic->notify();
        delay(100); // bluetooth stack will go into congestion, if too many packets are sent
        pTxCharacteristic->setValue("Connect Success");
        pTxCharacteristic->notify();
        // delay(100); // bluetooth stack will go into congestion, if too many packets are sent

        Preferences preferences;
        preferences.begin("eenvs", false); // Ordner eenvs anlegen/verwenden       
        preferences.putBytes("wSSID_s", wIFI_SSID_c, strlen(wIFI_SSID_c) + 1); 
        preferences.putBytes("wPWD_s", wIFI_PASSWORD_c, strlen(wIFI_PASSWORD_c) + 1); 
        preferences.putBytes("encryption", wlan_encryptionType[ist_wlan], strlen(wlan_encryptionType[ist_wlan]) + 1);
        preferences.end(); 

        WiFi.disconnect();
        delay(1000); // Warte eine Sekunde
        InitWiFi();
        WiFi.mode(WIFI_STA);




   }






  //TB#*****


  //if(disable_server >= 1) {
    if(tb_task == true) {
        tb_task = false;
        

         WiFi_status = WiFi.status();

          if (WiFi_status != WL_CONNECTED) {
              wlanConnected = false; // WLAN ist nicht verbunden
              count_reconn = 0;
              WiFi_status = WL_CONNECT_FAILED;    
          } else {
              wlanConnected = true; // WLAN ist verbunden
              count_reconn = 1;
          }


          if (!wlanConnected) {
              if (g_bl_connect == false && g_connect_start == false) {

                if (!nightModeActive) {
                    // Überprüfe, ob 15 Minuten (900000 Millisekunden) seit dem letzten Versuch vergangen sind
                    if (millis() - lastReconnectAttempt >= reconnectInterval) {
                        reconnect();
                        lastReconnectAttempt = millis(); // Aktualisiere den Zeitstempel
                    }
                } else {
                    // Überprüfe, ob eine Stunde (3600000 Millisekunden) seit dem letzten Versuch vergangen sind
                    if (millis() - lastReconnectAttempt >= requiredNightConnectedTime2) {
                        reconnect();
                        lastReconnectAttempt = millis(); // Aktualisiere den Zeitstempel
                    }
                }

              }
          }



        
      //if(disable_server >= 1) {
      if (wlanConnected) { 

        count_reconn = 0;
        //WiFi_status = WL_CONNECTED;

        //Serial.println(F("reconnect"));

        if (!provisionRequestSent) {
          if (!tb.connected()) {
            // Connect to the ThingsBoard server as a client wanting to provision a new device
            count_InitTB ++;
            
            Serial.printf("[IF] P-Connecting to: (%s)\n", THINGSBOARD_SERVER);
          
            if (!tb.connect(THINGSBOARD_SERVER, "provision", THINGSBOARD_PORT)) {

              Serial.println(F("[IF] P-Failed to connect"));

              return;
            }
     
         

            Serial.println(F("[IF] Sending provisioning request"));


            // Send a claiming request without any device name (access token will be used as the device name)
            // if the string is empty or null, automatically checked by the sendProvisionRequest method
            const Provision_Callback provisionCallback(Access_Token(), &processProvisionResponse, PROVISION_DEVICE_KEY, PROVISION_DEVICE_SECRET, DEVICE_NAME);

            provisionRequestSent = tb.Provision_Request(provisionCallback);
          }
        }
        else if (provisionResponseProcessed) {
         

         
           //----- shared -----------

            if(subscribedSHARED == false || requestedShared == false || requestedShared1 == false || requestedShared2 == false || requestedShared3 == false || requestedShared4 == false || requestedClient == false){    
            
                      if (WiFi.status() == WL_CONNECTED) {
                        TB_connect();
                      }

              if( g_TB_connect_Status == true){  


                
                 start_Shared_Attributes();

            

                  if (!requestedShared) {
                      #if TB_DEBUG_LEVEL >= TB_DEBUG_MAX
                      Serial.println(F("[IF] Requesting shared attributes a..."));
                      #endif
                      //requestedShared = tb.Shared_Attributes_Request(sharedCallback);delay(200);
                      requestedShared = 1;
                      if (!requestedShared) {
                        #if TB_DEBUG_LEVEL >= TB_DEBUG_MAX
                        Serial.println(F("[IF] Failed to request shared attributes"));
                        #endif
                      }
                  }
                


                  if(disable_server >= 1) {
                  if (!requestedClient) {
                      #if TB_DEBUG_LEVEL >= TB_DEBUG_MAX 
                      Serial.println(F("[IF] Requesting client-side attributes..."));
                      #endif

                      //requestedClient = tb.Client_Attributes_Request(clientCallback);delay(200);
                      requestedClient = 1;
                      if (!requestedClient) {

                        Serial.println(F("[IF] Failed to request client-side attributes"));
                        g_fail_requestedClient ++;
                        requestedClient = 1;

                      }
                  }
                  }

                    if (disable_server >= 1) {
                        if (!requestedClient2) {
                          #if TB_DEBUG_LEVEL >= TB_DEBUG_MAX
                            Serial.println(F("[IF] Requesting client-side2 attributes..."));
                            #endif

                            //requestedClient2 = tb.Client_Attributes_Request(clientCallback2);delay(200);
                            requestedClient2 = 1;
                            if (!requestedClient2) {
                                Serial.println(F("[IF] Failed to request client-side2 attributes"));
                                g_fail_requestedClient++;
                                requestedClient2 = 1;
                            }
                        }
                    }

                    if (disable_server >= 1) {
                        if (!requestedClient3) {
                          #if TB_DEBUG_LEVEL >= TB_DEBUG_MAX
                            Serial.println(F("[IF] Requesting client-side3 attributes..."));
                            #endif

                            //requestedClient3 = tb.Client_Attributes_Request(clientCallback2);delay(200);
                            requestedClient3 = 1;
                            if (!requestedClient3) {
                                Serial.println(F("[IF] Failed to request client-side3 attributes"));
                                g_fail_requestedClient++;
                                requestedClient3 = 1;
                            }
                        }
                    }



                   /*
                  if (!subscribedRPC) {

                    Serial.println(F("Requesting RPC..."));

                    // Perform a request of the given RPC method. Optional responses are handled in processTime
                    if (!tb.RPC_Request(callbackrpc)) {
                      Serial.println(F("Failed to request for RPC"));
                    }else{
                      Serial.println(F("Request done"));
                      subscribedRPC = true;
                    }

                  }
                   */


              } 
              //} // Webserver für FW
            }  // g_TB_connect_Status 
        


              //----- shared -----------
         
         
         
         
         
            //----- telemetry --------

              if(sperre_10Time3 == false && sperre_10Time2 == false){  
                if (currentmin == 0 || currentmin == 10 || currentmin == 20 || currentmin == 30 || currentmin == 40 || currentmin == 50) {
                  //Serial.println(F("sperre_10Time2 on"));
                  sperre_10Time2 = true;
                  Preferences preferences;
                  preferences.begin("eenvs", false);                        
                  preferences.putBool("sperre_10Time2", sperre_10Time2);
                  preferences.end(); 
                } 
              }


              if(sperre_10Time3 == true){  
                if (currentmin != 0 && currentmin != 10 && currentmin != 20 && currentmin != 30 && currentmin != 40 && currentmin !=50) {
                  sperre_10Time3 = false;
                  //Serial.println(F("sperre_10Time2 off"));
                    Preferences preferences;
                    preferences.begin("eenvs", false);                       
                    preferences.putBool("sperre_10Time3", sperre_10Time3);
                    preferences.end(); 
                }
              }


          //if(subscribedSHARED == true){  
             //     Radonabfrage      oder über zeit nur zum testen
            //if(g_radon_send_tb == true || tb_upload == true){   //gespeichert, jetzt freigabe für gesendet
            //TB_DEBUG_MAX_PRINT(F("g_radon_send_tb..."));TB_DEBUG_MAX_PRINTLN(g_radon_send_tb);
            //TB_DEBUG_MAX_PRINT(F("sperre_10Time2..."));TB_DEBUG_MAX_PRINTLN(sperre_10Time2);

            //Serial.print(F(" g_radon_send_tb"));Serial.println(g_radon_send_tb); 
            //Serial.print(F(" sperre_10Time2"));Serial.println(sperre_10Time2); 

            if(g_radon_send_tb == true && sperre_10Time2 == true){   //gespeichert, jetzt freigabe für gesendet

              sperre_10Time2 = false;
              sperre_10Time3 = true;

              //Serial.println(F("g_radon_send_tb on"));
                
                  Preferences preferences;
                  preferences.begin("eenvs", false);                         
                  preferences.putBool("sperre_10Time2", sperre_10Time2);
                  preferences.putBool("sperre_10Time3", sperre_10Time3);
                  preferences.end(); 
                  
                 
                  if (loggingEnabled) {
                     //things_list_t_16 = p_uhrzeit + "  [IF] Daten Senden"; 
                    write_to_log(things_list_t_16);
                    }

              tb_upload = false;
              g_radon_send_tb = false;

              TB_DEBUG_MAX_PRINTLN(F("[IF] Sending subscribed attributes..."));
              


              g_TB_connect_Status = false;
              WiFi_status = WiFi.status();
              TB_status = tb.connected();
              //Serial.println("[IF] TB_status_a: " + String(TB_status));


              if(TB_status == 0){ 

                      if (WiFi.status() == WL_CONNECTED) {
                        TB_connect();
                        TB_status = tb.connected();
                      }else{
                        TB_status = 0;
                      }
                //Serial.println("[IF] TB connected: " + String(TB_status));
              }

              g_TB_connect_Status = TB_status;

              if(g_TB_connect_Status == false){  

                TB_DEBUG_MAX_PRINTLN(F("[IF] Failed to connect"));

              } else {


                TB_DEBUG_MAX_PRINTLN(F("[IF] Start send telemetry values")); 
                mQTT_VAR_Send = true;  // jetzt gesendet
                send_client2_attributee_set = true;
                //g_shared_empf_send_to_TB = true;
               
                //tb.Shared_Attributes_Unsubscribe(); Serial.println("[IF] Shared Attributes Unsubscribe done");
                   

                start_Shared_Attributes();

              

              } // TB_connect


            }
          //}
            //----- telemetry --------

              
          //---------------------------------------
          if(tb_FW_update == true){
            tb_FW_update = false;
           
                      
             // if(TB_new_FW_available == true){
              //Serial.println("A new Firmware is available.");
              //TB_new_FW_available = false;
              //}else{
              //Serial.println("Firmware up to date."); 
             // } 


             /*
               if (!currentFWSent) {
              Firmware-Status beim Start der Firmware senden, 
              um die Cloud über die aktuelle Firmware und die korrekte Installation zu informieren,
              besonders wichtig bei Verwendung von OTA-Update, 
              da das OTA-Update den letzten Firmware-Status als UPDATING sendet, was bedeutet, dass das Gerät neu startet
              Wenn das Gerät korrekt neu gestartet wurde und über den neu angegebenen Firmware-Titel 
              und die neue Firmware-Version verfügt, sollte es diese mit dem Status „AKTUALISIERT“ an die Cloud senden.
              um jeden Endbenutzer darüber zu informieren, 
              dass das Gerät erfolgreich neu gestartet wurde und tatsächlich auch die Version enthält, 
              in der es geflasht wurde

              currentFWSent = tb.Firmware_Send_Info(CURRENT_FIRMWARE_TITLE, CURRENT_FIRMWARE_VERSION) && tb.Firmware_Send_State(FW_STATE_UPDATED);
             */

                      
          
            //----- UPDATE --------
            if(!currentFWSent && subscribedSHARED == true && g_TB_connect_Status == false){ 
                //Serial.println(F("[IF] TB-Update-Connecting..."));
                      if (WiFi.status() == WL_CONNECTED) {
                        TB_connect();
                      }
            } 
            
            if (!currentFWSent && subscribedSHARED == true && g_TB_connect_Status == true) {
                    #if TB_DEBUG_LEVEL >= TB_DEBUG_MAX
                    Serial.println(F(" "));
                    Serial.println(F("-----------------------------------------"));
                    Serial.println(F("[IF] Firwmare current FW Sent..."));
                    #endif
              // printf("[AP] FREE HEAP: now: %u, contiguous: %u, lowest: %u\n",xPortGetFreeHeapSize(),heap_caps_get_largest_free_block(MALLOC_CAP_DEFAULT),xPortGetMinimumEverFreeHeapSize());
     
              //#ifdef sPACE_DEBUG
              //printf("[AP] FREE HEAP: now: %u, contiguous: %u, lowest: %u\n",xPortGetFreeHeapSize(),heap_caps_get_largest_free_block(MALLOC_CAP_DEFAULT),xPortGetMinimumEverFreeHeapSize());
              //#endif
              currentFWSent = tb.Firmware_Send_Info(CURRENT_FIRMWARE_TITLE, CURRENT_FIRMWARE_VERSION) && tb.Firmware_Send_State(FW_STATE_UPDATED);
              //#ifdef sPACE_DEBUG
              //printf("[AP] FREE HEAP: now: %u, contiguous: %u, lowest: %u\n",xPortGetFreeHeapSize(),heap_caps_get_largest_free_block(MALLOC_CAP_DEFAULT),xPortGetMinimumEverFreeHeapSize());
              //#endif
             // printf("[AP] FREE HEAP: now: %u, contiguous: %u, lowest: %u\n",xPortGetFreeHeapSize(),heap_caps_get_largest_free_block(MALLOC_CAP_DEFAULT),xPortGetMinimumEverFreeHeapSize());
     
            }

            if (!updateRequestSent && currentFWSent == true) {
              #if TB_DEBUG_LEVEL >= TB_DEBUG_MAX
                      Serial.println(F(" "));
                       Serial.println(F("-----------------------------------------"));
              Serial.println(F("[IF] Firwmare Update Subscription..."));
              #endif
            // printf("[AP] FREE HEAP: now: %u, contiguous: %u, lowest: %u\n",xPortGetFreeHeapSize(),heap_caps_get_largest_free_block(MALLOC_CAP_DEFAULT),xPortGetMinimumEverFreeHeapSize());
   
              //#ifdef sPACE_DEBUG
              //printf("[AP] FREE HEAP: now: %u, contiguous: %u, lowest: %u\n",xPortGetFreeHeapSize(),heap_caps_get_largest_free_block(MALLOC_CAP_DEFAULT),xPortGetMinimumEverFreeHeapSize());
              //#endif
              // See https://thingsboard.io/docs/user-guide/ota-updates/
              // to understand how to create a new OTA pacakge and assign it to a device so it can download it.
              //updateRequestSent = tb.Subscribe_Firmware_Update(callbackota);
              updateRequestSent = tb.Subscribe_Firmware_Update(callback);
              //#ifdef sPACE_DEBUG
              //printf("[AP] FREE HEAP: now: %u, contiguous: %u, lowest: %u\n",xPortGetFreeHeapSize(),heap_caps_get_largest_free_block(MALLOC_CAP_DEFAULT),xPortGetMinimumEverFreeHeapSize());
              //#endif
              //printf("[AP] FREE HEAP: now: %u, contiguous: %u, lowest: %u\n",xPortGetFreeHeapSize(),heap_caps_get_largest_free_block(MALLOC_CAP_DEFAULT),xPortGetMinimumEverFreeHeapSize());
     
            }

            if (!updateRequestSentu && updateRequestSent == true) {
              #if TB_DEBUG_LEVEL >= TB_DEBUG_MAX
              Serial.println(F("[IF] Firwmare Update..."));
              #endif
             //printf("[AP] FREE HEAP: now: %u, contiguous: %u, lowest: %u\n",xPortGetFreeHeapSize(),heap_caps_get_largest_free_block(MALLOC_CAP_DEFAULT),xPortGetMinimumEverFreeHeapSize());
   
              //#ifdef sPACE_DEBUG
              //printf("[AP] FREE HEAP: now: %u, contiguous: %u, lowest: %u\n",xPortGetFreeHeapSize(),heap_caps_get_largest_free_block(MALLOC_CAP_DEFAULT),xPortGetMinimumEverFreeHeapSize());
              //#endif
              // See https://thingsboard.io/docs/user-guide/ota-updates/
              // to understand how to create a new OTA pacakge and assign it to a device so it can download it.
              //updateRequestSentu = tb.Start_Firmware_Update(callbackota);
              updateRequestSent = tb.Start_Firmware_Update(callback);
              //Serial.print(F("Firmware Status:"));Serial.println(updateRequestSent);
              //#ifdef sPACE_DEBUG
              //printf("[AP] FREE HEAP: now: %u, contiguous: %u, lowest: %u\n",xPortGetFreeHeapSize(),heap_caps_get_largest_free_block(MALLOC_CAP_DEFAULT),xPortGetMinimumEverFreeHeapSize());
              //#endif
             //printf("[AP] FREE HEAP: now: %u, contiguous: %u, lowest: %u\n",xPortGetFreeHeapSize(),heap_caps_get_largest_free_block(MALLOC_CAP_DEFAULT),xPortGetMinimumEverFreeHeapSize());
     
            }
            //----- UPDATE --------


          }
          //---------------------------------------


          //---------------------------------------
          if(tb_shared_update == true){
            tb_shared_update = false;
         

            TB_DEBUG_MAX_PRINTLN(F("[IF] Requesting shared 5 attributes..."));
            /*
            const int myArraySize = sizeof(REQUESTED_SHARED_ATTRIBUTES5)/sizeof(REQUESTED_SHARED_ATTRIBUTES5[0]);
            Serial.print("[IF] | ");
            for (int i = 0; i < myArraySize;i++) 
            { 
              Serial.print(REQUESTED_SHARED_ATTRIBUTES5[i]);
              Serial.print(" | ");
            }
            Serial.println(F(" "));

            */
            requestedShared5 = false;
            requestedShared5 = tb.Shared_Attributes_Request(sharedCallback5);delay(200);
            requestedShared5_fail = false;
            requestedShared5_fail_count ++;
            //Serial.print("requestedShared5_fail_count: ");Serial.println(requestedShared5_fail_count);

            if (!requestedShared5) {

              Serial.println(F("[IF] Failed to request shared 5 attributes"));
              requestedShared5 = true;
              requestedShared5_fail = true;  // wenn fehler dann reboot
              requestedShared5_fail_count = 0;

              //------------------------------
                  failCounter++; // Erhöhe den Counter

                  if (failCounter >= 2) { // Überprüfe, ob der Counter 2 erreicht hat
                      if (WiFi.status() == WL_CONNECTED) {
                          if (Ping.ping(hostping2)) {
                              Internt_online = true;
                          } else {
                              Internt_online = false;
                          }
                      }
                      
                      // Führe den Neustart nur aus, wenn WiFi verbunden und Ping erfolgreich ist
                      if (Internt_online) {
                          g_esp_soft_restart = true;
                          Serial.println(F("[IF] Performing ESP restart due to request failures and confirmed online status"));
                      }
                  }
              //------------------------------


            }else{
              requestedShared5_fail_count = 0;
              requestedShared5_fail = false;  
              failCounter = 0;
            }

            if(g_kalibrieren_ist == 1){   // kal aktiv
              requestedShared5_fail = false; // umschreiben
              requestedShared5_fail_count = 0;
            }


          }
          //---------------------------------------

          


        } // provisionResponseProcessed ok

      } // (!reconnect() 
    } // tb_task = true
  //} // Webserver disable wegen FW update
    //---------------------------------------------------------------------
        

        tb.loop();

  //TB#*****



   //-----------------------------------------------------------------------
   // if(g_shared_empf_send_to_TB == true && wait_bot_time > 60){
   if(g_shared_empf_send_to_TB == true && WiFi.status() == WL_CONNECTED){
      g_shared_empf_send_to_TB = false;
       


              
              //Serial.print("[IF] Installierte FW.: ");
              //Serial.println(TB_currFwVersion); // CURRENT_FIRMWARE_VERSION     aktuall    Get_Firmware_Version()
              
              //Serial.print("[IF] Neue FW in Cloud.: ");
              //Serial.println(TB_newFwVersion); // new


            save_Shared_data();


             // Connect to the ThingsBoard server as a client wanting to provision a new device
              TB_DEBUG_MAX_PRINTLN(F("[SA] Send Client Data attributes after change Shared attributes"));
              TB_DEBUG_MAX_PRINTF("[IF] Connecting to: (%s)\n", THINGSBOARD_SERVER);

             
          
            //----------------------
            if (!tb.connected()) {

              count_InitTB ++;
              TB_DEBUG_MAX_PRINTLN(F("[IF] 1. Not connect"));

              TB_connect();
              if (!tb.connected()) {
                  count_InitTB++;
                  TB_DEBUG_MAX_PRINTLN(F("[IF] 2. Not connect"));
              }else{


                  /*
                  tb.sendAttributes(attributes26, 5);
                  delay(100);
                  tb.sendAttributes(attributes25, 5);
                  delay(100);
                  tb.sendAttributes(attributes27, 3);
                  delay(100);
                  tb.sendAttributes(attributes28, 5);
                  delay(100);
                  tb.sendAttributes(attributes29, 4);
                  */

                    //Serial.println("[SA] Sending Client Connect 3"); 

                  //send_client_attribute();





                  //tb.disconnect();
              }

            }else{



                  /*
                  tb.sendAttributes(attributes26, 5);
                  delay(100);
                  tb.sendAttributes(attributes25, 5);
                  delay(100);
                  tb.sendAttributes(attributes27, 3);
                  delay(100);
                  tb.sendAttributes(attributes28, 5);
                  delay(100);
                  tb.sendAttributes(attributes29, 4);
                  */

          
                    //Serial.println("[SA] Sending Client Connect"); 
          
                  //if(requestedShared_client == true){
                    //10minSenden
                    //send_client_attribute();
                    //send_client_attribute_set = true;
                  //}

                if (send_client_attribute_start_send == false) {
                    send_client_attribute_start_send = true;
                    
                    TB_DEBUG_MAX_PRINTLN(F("-----------------------------------------"));
                    TB_DEBUG_MAX_PRINTLN(F("[SA] Sending Client attributes..."));

    
                    send_client_attribute();
     
                    send_client2_attribute();
      
                    TB_DEBUG_MAX_PRINTLN(F("-----------------------------------------"));
                }



            }
            //----------------------

   

              //if(TB_FW_up_to_date == true && TB_status == true){
              if(TB_FW_up_to_date == false){   // 0 = neue FW verfügbar
                //             verschieden                    zeit                 kein upload mehr, das bit wird bei abbruch temporär gelöscht
                if(TB_currFwVersion != TB_newFwVersion && wait_bot_time > 60 && gFW_Update_start == 0 && gFW_counter <= 3){

                 
                    Preferences preferences;
                    preferences.begin("eenvs", false);                         //Ordner eenvs anlegen/verwenden
                    gFW_Update_start = 1;
                    preferences.putUChar("fw_s_upd", gFW_Update_start);    //  0=Standard  aus 
                    gFW_counter ++;
                    preferences.putUChar("fw_counter", gFW_counter);        
                    
                    #ifdef ea_webserver
                    if(disable_server >= 1) { 
                    
                    if (loggingEnabled) {
                      //things_list_t_16 = p_uhrzeit + "  [IF] ESP Reeboot new Fw Version";
                      write_to_log(things_list_t_16);
                      }
                    }
                    #endif

                    preferences.end();
                   
                   Serial.print(F("[IF] ESP Reboot!! Counter: "));
                   Serial.println(gFW_counter);

                    
                    delay(500);
                    ESP.restart(); 

                }
              }


      // lesen nach booten
      if(disable_server >= 1) {
        if(g_MB_abfrage_boot == true){
          g_MB_abfrage_boot = false;
          //Serial.println("[MB] mb_read_radon  --  Sensor 3"); 
          
          mb_read_radon();
        }
      }
        


   } // g_shared_empf_send_to_TB
   //-----------------------------------------------------------------------





  if(g_other_attr == true){
    
    Serial.println(F("[IF] Other attributes")); 
    g_other_attr = false;
    Serial.println(buffer_other);

  }



            // alle 1min
            if(uhrzeit_update == true){
              

              
                //printLocalTime();
                //printLocalEpoch();

                uhrzeit_update = false;




            }


          if (p_timeon == 0 || epochTime_start == 0){
            if (epochTime_esp > 1577833200){ // > 2020.1.1
              if (epochTime_start < 1577833200){
                epochTime_start = epochTime_esp;
                #if TM_DEBUG_LEVEL >= TM_DEBUG_MAX
                Serial.println("[IF] UNIX Start Timestamp: " + String(epochTime_start));  
                #endif
               
                #ifndef  RTC_Clock_DS3231
                  WriteTimeValue();
                #endif

                epochTime_diff = epochTime_esp - epochTime_start;
                //Serial.println("--> UNIX Time diff: " + String(epochTime_diff)); 
              }
            }
          }



        
        // save uhrzeit
        if (p_timeon == 1 && epoch_task == true){
          epoch_task = false;
          #ifndef  RTC_Clock_DS3231
            WriteepochTime();
          #endif
          //Serial.println("[IF] Save Timestamp: " + String(epochTime)); 
        }


    //---------------------------------------------------------------------------------
    //Serial.println(g_kalibrieren_ist); Serial.println(g_checken_ist); Serial.println(g_kal_write_ist); Serial.println(akt_fw_load); 
    if(g_kalibrieren_ist == 0 && g_checken_ist == 0 && g_kal_write_ist == 0 && akt_fw_load == false){

      if(g_LEDT_T_KNX == 0){
        if(g_LEDT_T_ist == 0){
          if(g_t_led_off == true){
            for( int i = 0; i<NUM_PIXELS; i++){
              strip.setPixelColor(i, 0x000000); strip.show();
            }
            g_t_led_off = false;
          }
        }
      }


     


      //                                                                           shared fertig
      bool temp_bit = false;
      

      if(ani_segment_finish == true){
         temp_bit = true;   // damit farbig led aktiviert wird
      }
      //Serial.println("led"); 
      // Serial.println(g_bl_connect); Serial.println(g_sensor_online);  Serial.println(g_LEDT_T_ist); Serial.println(temp_bit); 
      if(g_bl_connect == false && g_sensor_online <= 2 && g_LEDT_T_ist == 1 && g_LEDT_T_KNX == 0 && temp_bit == true){

        if(g_sensor_boot == true){
            if( g_radon_new_led == true || g_t_led_change == true){ 

                //Serial.println(g_radon_new_led); Serial.println(g_t_led_change); 
                g_t_led_change = false;
                g_radon_new_led = false;
                var_led_t = mb_radon_ist_word;
              if(var_led_t < g_Range_U_ist){
                  #ifdef LEDDebug
                    Serial.println("IF] LED 50. green");  
                  #endif

                  bgcolor_vorgabe = bgcolor_g;
                  val3_color = "0, 250, 0, 0.3";  //grün
                  s_Color = 2;
                  g_LEDT_T_color = s_Color;
                  s_Brightness = 5; 
                  showcolor(s_Color,s_Brightness);
                  led_farbe = 1;


              }else if(var_led_t < g_Range_M_ist){
                  #ifdef LEDDebug
                    Serial.println("IF] LED Green");  
                  #endif

                  bgcolor_vorgabe = bgcolor_g;
                  val3_color = "0, 250, 0, 0.3";  //grün
                  s_Color = 2;
                  g_LEDT_T_color = s_Color;
                  s_Brightness = v_Brightness; 
                  showcolor(s_Color,s_Brightness);
                  led_farbe = 1;

              }else if(var_led_t < g_Range_T_ist){
                  #ifdef LEDDebug
                    Serial.println("IF] LED Orange");  
                  #endif

                  bgcolor_vorgabe = bgcolor_o;
                  val3_color = "250, 200, 0, 0.3"; //orange
                  s_Color = 5;
                  g_LEDT_T_color = s_Color;
                  s_Brightness = v_Brightness; 
                  showcolor(s_Color,s_Brightness);
                  led_farbe = 2;

              }else{

                  #ifdef LEDDebug
                    Serial.println("IF] LED Red");  
                  #endif
                  //Turn on LEDs RED

                  bgcolor_vorgabe = bgcolor_r;
                  val3_color = "250, 0, 0, 0.3"; //rot
                  s_Color = 1;
                  g_LEDT_T_color = s_Color;
                  s_Brightness = v_Brightness; 
                  showcolor(s_Color,s_Brightness);
                  led_farbe = 3;

              }

                  
                    
                      byte getrow0,getrow1,getrow2,getrow3;
                      getrow0 = lc.getRow(0,0);
                      getrow1 = lc.getRow(0,1);
                      getrow2 = lc.getRow(0,2);
                      getrow3 = lc.getRow(0,3);


                      Preferences preferences;
                      preferences.begin("eenvs", false);
                      preferences.getUChar("getrow0", getrow0); 
                      preferences.getUChar("getrow1", getrow1); 
                      preferences.getUChar("getrow2", getrow2); 
                      preferences.getUChar("getrow3", getrow3); 
                      preferences.end();

                    /*
                    if(boot_ani_off2 == false){   // false = led pulsen
                        for (byte i = g_LEDT_FB_ist; i > 0; i--)  
                        {  
                        
                              lc.setIntensity(i); //5=Standard   Helligkeit forne
                              lc.setRow(0,0,getrow0);
                              lc.setRow(0,1,getrow1);
                              lc.setRow(0,2,getrow2);
                              lc.setRow(0,3,getrow3);
                              delay(50);
                        }
                              lc.setIntensity(0); //5=Standard   Helligkeit forne
                              lc.setRow(0,0,getrow0);
                              lc.setRow(0,1,getrow1);
                              lc.setRow(0,2,getrow2);
                              lc.setRow(0,3,getrow3);
                              delay(50);
                    }
                    */

                    g_radon_new_seg = true;

                    //Serial.println("[IF] ------------- LED ani");  
                    if(boot_ani_off2 == true){g_view_fw = false;}  // bei geziehltem reboot FW nicht anzeigen
                    boot_ani_off2 = false;   // kein animation bei geziehltem reboot rücksetzen
                    boot_ani_off = false;    // kein animation bei geziehltem reboot rücksetzen
    


            }

        }else{  //noch kein Radon

            // noch kein Radon dann weißes Licht.
            if( g_radon_new_led == true || g_t_led_change == true){ 
                g_t_led_change = false;
                g_radon_new_led = false;
                s_Color = 4;
                g_LEDT_T_color = s_Color;
                s_Brightness = v_Brightness; 
                showcolor(s_Color,s_Brightness);
                led_farbe = 0;
            }


        }
       //--------------------------------------



      }
      
    }else{

           /*
          strip.setBrightness(v_Brightness);
          strip.setPixelColor(0, m_color[v_Color][0], m_color[v_Color][1], m_color[v_Color][2]);

          for( int i = 0; i<NUM_PIXELS; i++){
            strip.setPixelColor(i, 0x000000); strip.show();
          }

             g_kalibrieren_ist == 0 || g_checken_ist == 0 || g_kal_write_ist == 0

           */


            

            if(cal_lcd == true && akt_fw_load == false){
              cal_lcd = false;

              tick = !tick;

              if(g_bl_connect == true){

                lc.setChar(0,0,' ',false);
                lc.setChar(0,1,'A',false);
                lc.setChar(0,2,'P',false);
                //lc.setRow(0,2,0);
                lc.setChar(0,3,'P',tick);

                strip.setBrightness(150);
                colorWipe(strip.Color(m_color[3][0], m_color[3][1], m_color[3][2]), 5);  

              }


              if(g_kalibrieren_ist == 1 && g_bl_connect == false){

                lc.setChar(0,0,' ',false);
                lc.setChar(0,1,'C',false);
                lc.setChar(0,2,'A',false);
                //lc.setRow(0,2,0);
                lc.setChar(0,3,'L',tick);

                strip.setBrightness(150);
                colorWipe(strip.Color(m_color[6][0], m_color[6][1], m_color[6][2]), 5);  

              }

              if(g_checken_ist == 1 && g_bl_connect == false){

                lc.setChar(0,0,'C',false);
                lc.setChar(0,1,'H',false);
                lc.setChar(0,2,'E',false);
                //lc.setRow(0,2,0);
                lc.setChar(0,3,'C',tick);

                strip.setBrightness(150);
                colorWipe(strip.Color(105, 52, 52), 5);  

              }


              if(g_kal_write_ist == 1 && g_bl_connect == false){

                lc.setChar(0,0,'S',false);
                lc.setChar(0,1,'A',false);
                lc.setChar(0,2,'V',false);
                //lc.setRow(0,2,0);
                lc.setChar(0,3,'E',tick);

                strip.setBrightness(150);
                colorWipe(strip.Color(255, 255, 0), 5);  

              }


            }


    }
   //---------------------------------------------------------------------------------





    //---------------------------------------------------------------------------------
    if(g_kalibrieren_ist == 0 && g_checken_ist == 0 && g_kal_write_ist == 0 && gFW_Update_start == 0 && g_identify == false){
      if(g_showani == false && boot_ani_off == false){  // animation zu ende, aber nicht aktivieren bei schnellem booten
          if(currentPinStateknx == LOW){  

            if(g_bl_connect == true){

                if(g_LEDT_TF_ist != 0 && g_wlan_read == false){
                  if (millis() - ms1 > 1 * ms1v) {

                      uint8_t v_Color = 3; 
                      fire_color = strip.Color (m_color[v_Color][0]/2.3, m_color[v_Color][1]/2.3, m_color[v_Color][2]/2.3); 
                    esp_task_wdt_reset(); 
                    fire.Draw();
                    esp_task_wdt_reset(); 
                    ms1v = random(50,190);
                    ms1 = millis();
                  }
                }

            }else{

                  //#ifdef LEDDebug
                    // Serial.println("[IF] LED ani");  
                  //#endif

              if(g_sensor_online < 2 && g_LEDT_T_ist == 1 && g_LEDT_T_KNX == 0 && g_wlan_read == false){

                if(g_LEDT_TF_ist != 0){
                  if (millis() - ms1 > 1 * ms1v) {
                    if(s_Color == 5){ // nicht so viel rot bei orange
                      fire_color = strip.Color (m_color[v_flamme][0]/2.8, m_color[v_flamme][1]/1.5, m_color[v_flamme][2]/2); 
                    }else{
                      fire_color = strip.Color (m_color[v_flamme][0]/2.3, m_color[v_flamme][1]/2.3, m_color[v_flamme][2]/2.3); 
                    }
                    esp_task_wdt_reset(); 
                    //strip.setBrightness(v_Brightness);
                    fire.Draw();
                    esp_task_wdt_reset(); 
                    ms1v = random(50,190);
                    ms1 = millis();
                  }
                }
              }


            }

          }else{
            g_progLedOn();
          }
      }

    }
    if(gFW_Update_start == 1){

      strip.setBrightness(150);
      colorWipe(strip.Color(m_color[4][0], m_color[4][1], m_color[4][2]), 5);  

    }
    //---------------------------------------------------------------------------------





    //---------------------------------------------------------------------------------
    if(g_Seg__boot_ani == true && g_LEDT_F_ist == 1 && g_LEDT_T_KNX == 0){


       //Serial.println("g_Seg__boot_ani");    
       esp_task_wdt_reset(); 
       
 
        transferCompleteTime = millis();
      

             uint8_t v_delay = 60;
             //lc.setIntensity(g_LEDT_FB_ist);
             lc.setIntensity(15);

              lc.setRow(0,0,64);
              delay(v_delay);
           
              lc.setRow(0,0,0);
              lc.setRow(0,1,64);
              delay(v_delay);
           
              esp_task_wdt_reset(); 
             
              lc.setRow(0,0,0);
              lc.setRow(0,1,0);
              lc.setRow(0,2,64);
              delay(v_delay);

              lc.setRow(0,0,0);
              lc.setRow(0,1,0);
              lc.setRow(0,2,0);
              lc.setRow(0,3,64);
              delay(v_delay);

              esp_task_wdt_reset(); 
            
              lc.setRow(0,3,32);
              delay(v_delay);

              lc.setRow(0,3,16);
              delay(v_delay);

              lc.setRow(0,3,8);
              delay(v_delay);

              esp_task_wdt_reset(); 

              lc.setRow(0,3,0);
              lc.setRow(0,2,8);
              delay(v_delay);             

              lc.setRow(0,3,0);
              lc.setRow(0,2,0);
              lc.setRow(0,1,8);
              delay(v_delay);   


              lc.setRow(0,3,0);
              lc.setRow(0,2,0);
              lc.setRow(0,1,0);
              lc.setRow(0,0,8);
              delay(v_delay);   

              lc.setRow(0,0,4);
              delay(v_delay);  

              lc.setRow(0,0,2);
              delay(v_delay); 
              esp_task_wdt_reset(); 
             //-------------------

              lc.setRow(0,0,64);
              delay(v_delay);
           
              lc.setRow(0,0,0);
              lc.setRow(0,1,64);
              delay(v_delay);
           
              esp_task_wdt_reset(); 
             
              lc.setRow(0,0,0);
              lc.setRow(0,1,0);
              lc.setRow(0,2,64);
              delay(v_delay);

              lc.setRow(0,0,0);
              lc.setRow(0,1,0);
              lc.setRow(0,2,0);
              lc.setRow(0,3,64);
              delay(v_delay);

              esp_task_wdt_reset(); 
            
              lc.setRow(0,3,32);
              delay(v_delay);

              lc.setRow(0,3,16);
              delay(v_delay);

              lc.setRow(0,3,8);
              delay(v_delay);

              esp_task_wdt_reset(); 

              lc.setRow(0,3,0);
              lc.setRow(0,2,8);
              delay(v_delay);             

              lc.setRow(0,3,0);
              lc.setRow(0,2,0);
              lc.setRow(0,1,8);
              delay(v_delay);   
    

              lc.setRow(0,3,0);
              lc.setRow(0,2,0);
              lc.setRow(0,1,0);
              lc.setRow(0,0,8);
              delay(v_delay);   

              lc.setRow(0,0,4);
              delay(v_delay); 

              esp_task_wdt_reset(); 

            //------------------------


              lc.setChar(0,0,'-',false);
              delay(v_delay); 
              lc.setChar(0,1,'-',false);
              delay(v_delay); 
              lc.setChar(0,2,'-',false);
              delay(v_delay); 
              lc.setChar(0,3,'-',false);
              delay(v_delay);
              delay(v_delay);
             esp_task_wdt_reset(); 

              lc.setRow(0,0,64);
              lc.setRow(0,1,64);
              lc.setRow(0,2,64);
              lc.setRow(0,3,64);
              delay(v_delay);
              delay(v_delay);
              lc.setChar(0,0,'-',false);
              lc.setChar(0,1,'-',false);
              lc.setChar(0,2,'-',false);
              lc.setChar(0,3,'-',false);
              esp_task_wdt_reset(); 
              delay(v_delay);
              delay(v_delay);
              lc.setRow(0,0,8);
              lc.setRow(0,1,8);
              lc.setRow(0,2,8);
              lc.setRow(0,3,8);
              delay(v_delay); 
              delay(v_delay); 
              esp_task_wdt_reset();  
              lc.setRow(0,0,0);
              lc.setRow(0,1,0);
              lc.setRow(0,2,0);
              lc.setRow(0,3,0);
              delay(v_delay);


             set_bit_wait_front_view = true;
             g_Seg__boot_ani = false;
             //Serial.println("--> g_Seg__boot_ani end ");

             displayFirmwareVersion(TB_currFwVersion);
             

             /*
             Preferences preferences;
             preferences.begin("eenvs", false);                    
             preferences.putBool("boot_ani", true);  // boot ani LCD  für nächstes mal wieder temporär aktivieren
             preferences.end();
             */
             g_t_led_off = true;
             ani_segment_finish = true;   // damit farbig led aktiviert wird
            // lc.setIntensity(g_LEDT_FB_ist);
    

    }
    //---------------------------------------------------------------------------------





    //*******************************************************************
    // handleData


    /*
      // anforderung von TB wird gelöscht beim reboot
      g_kalibriert_ist
      g_checked_ist


      // speichern wenn final fertig
        g_kalibriert   preferences.getUInt("s_kalibriert",        preferences.putUInt("s_kalibriert", g_kalibriert);   //kalibrierter Sensor
        g_checked        preferences.getUInt("s_checked"            preferences.putUInt("s_checked", g_checked);  
        tb.sendAttributeInt(C_s_checked_KEY, g_check);           // Sensor getschecked
        tb.sendAttributeInt(C_s_kalibriert_KEY, g_kalibriert);   // Sensor kalibriert


      g_start_kalibireung == 1   starten Sensor öffnen
      g_start_kalibireung == 8   lesen der Werte

      g_kal_write_ist == 1  schreibe Kal Werte in Sensor

      if(b_calibrieren == true){


    */

    if(g_start_kalibireung == 1){    //1-12

      g_start_kalibireung = 2;

      mb_read_time();

    }

    if(g_start_kalibireung == 3){ // PW gerneriert

      g_start_kalibireung = 4;


      mb_write_pwd();
      //mb_read_byte = 9;
      //mb_read_pwd();

    }



    if(g_start_kalibireung == 5){ // PW gerneriert

      g_start_kalibireung = 6;

      mb_read_calibrierung();


    }

    if(g_start_kalibireung == 7){ // 

      g_start_kalibireung = 8;

            #ifdef MB_DETAIL_DEBUG
            /*
            mb_cal01 = word(mb_arry_byte[3], mb_arry_byte[4]);     // Impuls_o_abzug         G12
            mb_cal02 = word(mb_arry_byte[5], mb_arry_byte[6]);     // Radon_kalibri_word     G00
            mb_cal03 = word(mb_arry_byte[7], mb_arry_byte[8]);     // Radon_count_max        G01
            mb_cal04 = word(mb_arry_byte[9], mb_arry_byte[10]);    // Wrdadc_vorgabe         G02

            mb_cal05 = word(mb_arry_byte[11], mb_arry_byte[12]);   // Count_long_ist_over(2)
            mb_cal06 = word(mb_arry_byte[13], mb_arry_byte[14]);   // Count_long_ist_over(1)
            Count_long_ist_over = mb_cal05 + mb_cal06;             // Counts ab start 

            mb_cal07 = word(mb_arry_byte[15], mb_arry_byte[16]);   // Glaettung_faktor_word   G18
            mb_cal08 = word(mb_arry_byte[17], mb_arry_byte[18]);   // Impuls_leerwert         G19
            */
                                                                   //Impuls_leerwertu         G21



            //Serial.print("--> Impuls send : "); Serial.println(mb_cal01);  
            //Serial.print("--> kalibrierung: "); Serial.println(mb_cal02);  
            //Serial.print("--> count_max   : "); Serial.println(mb_cal03);  
            //Serial.print("--> Wrdadc      : "); Serial.println(mb_cal04);  

            //Serial.print("--Count: "); Serial.println(Count_long_ist_over);   
  
            //Serial.print("--> Glaettung   : "); Serial.println(mb_cal07);  
            //Serial.print("--> leerwert    : "); Serial.println(mb_cal08);
            //Serial.print("--> leerwert u  : "); Serial.println(mb_cal09);      

            #endif 

            String tempstr = "";

            //tempstr = "G12: "; tempstr += String(mb_cal01); tempstr += "\r";           //   G12
            //pTxCharacteristic->setValue(tempstr.c_str());
            //pTxCharacteristic->notify();
            //-----
            tempstr = "Kalibrierfaktor\t\t| G00: "; tempstr += String(mb_cal02); tempstr += "\r";    //*10    G00
            pTxCharacteristic->setValue(tempstr.c_str());
            pTxCharacteristic->notify();
            size_t message_length = strlen(tempstr.c_str());
            sentTraffic += message_length;   
            //-----
            tempstr = "Radon count\t\t\t| G01: "; tempstr += String(mb_cal03); tempstr += "\r";          // G01
            pTxCharacteristic->setValue(tempstr.c_str());
            pTxCharacteristic->notify();
            message_length = strlen(tempstr.c_str());
            sentTraffic += message_length;   
            //-----
            tempstr = "Darkkount\t\t\t| G02: "; tempstr += String(mb_cal04); tempstr += "\r";          // G02
            pTxCharacteristic->setValue(tempstr.c_str());
            pTxCharacteristic->notify();
            message_length = strlen(tempstr.c_str());
            sentTraffic += message_length;   
            //-----
            tempstr = "Glaettung\t\t\t| G18: "; tempstr += String(mb_cal07); tempstr += "\r";  // *10   G18
            pTxCharacteristic->setValue(tempstr.c_str());
            pTxCharacteristic->notify();
            message_length = strlen(tempstr.c_str());
            sentTraffic += message_length;   
            //-----
            tempstr = "Leerwert\t\t\t| G19: "; tempstr += String(mb_cal08); tempstr += "\r";    //*10    G19
            pTxCharacteristic->setValue(tempstr.c_str());
            pTxCharacteristic->notify();
            message_length = strlen(tempstr.c_str());
            sentTraffic += message_length;   
            //-----
            tempstr = "Leerwert unten\t\t| G21: "; tempstr += String(mb_cal09); tempstr += "\r\n";  //*10    G21
            pTxCharacteristic->setValue(tempstr.c_str());
            pTxCharacteristic->notify();
            message_length = strlen(tempstr.c_str());
            sentTraffic += message_length;   
            //-----
            tempstr = "Sensor Reset\t\t| G52: "; tempstr += String(mb_sreset); tempstr += "\r\n";  //*10    G21
            pTxCharacteristic->setValue(tempstr.c_str());
            pTxCharacteristic->notify();
            message_length = strlen(tempstr.c_str());
            sentTraffic += message_length;   
            //-----



            //tb.sendAttributeInt(G00_KEY, mb_cal02);  //  calibration value
            //tb.sendAttributeInt(G01_KEY, mb_cal03);  //  Radon count average
            //tb.sendAttributeInt(G02_KEY, mb_cal04);  //  Darkcount setting 
            //tb.sendAttributeInt(G18_KEY, mb_cal07);  //  Glaettung Faktor 
            //tb.sendAttributeInt(G19_KEY, mb_cal08);  //  Leerwert
            //tb.sendAttributeInt(G21_KEY, mb_cal09);  //  Leerwert unten 

              //----------------------------
                //Serial.println("-------attribute_items_t 6------");
                //const int attribute_items_t = 6;
                Attribute attributes[6] = {
                  { G00_KEY,  mb_cal02 },
                  { G01_KEY,  mb_cal03 },
                  { G02_KEY,  mb_cal04 },
                  { G18_KEY,  mb_cal07 },
                  { G19_KEY,  mb_cal08 },
                  { G21_KEY,  mb_cal09 },
                };
                tb.sendAttributes(attributes, 6);delay(200);
              //----------------------------

    }











    if(g_start_kalibireung == 8){ // 

      g_start_kalibireung = 9;

      mb_read_cal_vals();

    }

    if(g_start_kalibireung == 10){ // 

      g_start_kalibireung = 11;

            String tempstr = "";

            tempstr = "Radon live\t\t\t| G08: "; tempstr += String(Radon_live_value); tempstr += "\r";           //   G08
            pTxCharacteristic->setValue(tempstr.c_str());
            pTxCharacteristic->notify();
            size_t message_length = strlen(tempstr.c_str());
            sentTraffic += message_length;   
            //-----
            tempstr = "Impulse mit Abzug\t| G09: "; tempstr += String(mb_cal12); tempstr += "\r";    //    G09
            pTxCharacteristic->setValue(tempstr.c_str());
            pTxCharacteristic->notify();
            message_length = strlen(tempstr.c_str());
            sentTraffic += message_length;   
            //-----
            tempstr = "Impulse mit Abzug\t| G12: "; tempstr += String(mb_cal13); tempstr += "\r";    //    G12
            pTxCharacteristic->setValue(tempstr.c_str());
            pTxCharacteristic->notify();
            message_length = strlen(tempstr.c_str());
            sentTraffic += message_length;   
            //-----
            tempstr = "Radon 12h\t\t\t| G30: "; tempstr += String(Radon_12h_ist); tempstr += "\r\n";   //  Gxx
            pTxCharacteristic->setValue(tempstr.c_str());
            pTxCharacteristic->notify();
            message_length = strlen(tempstr.c_str());
            sentTraffic += message_length;   
            //-----      

    }

    

    if(g_start_kalibireung == 11){ // 

      g_start_kalibireung = 12;

        /*
        Preferences preferences;
        preferences.begin("eenvs", false);                         //Ordner eenvs anlegen/verwenden
        preferences.putUInt("s_kalibriert", g_kalibriert);      //kalibrierter Sensor
        preferences.putUInt("s_checked", g_checked);  
        */
      

      //if(g_sensor_online <= 1){

        //tb.sendTelemetryFloat(G08_KEY, Radon_live_value);
        //tb.sendTelemetryFloat(G09_KEY, mb_cal12);   
        //tb.sendTelemetryFloat(G12_KEY, mb_cal13);   
        //tb.sendTelemetryFloat(G30_KEY, Radon_12h_ist);  


        //tb.sendAttributeInt(G08_KEY, Radon_live_value); 
        //tb.sendAttributeInt(G09_KEY, mb_cal12); 
        //tb.sendAttributeInt(G12_KEY, mb_cal13); 
        //tb.sendAttributeInt(G30_KEY, Radon_12h_ist); 
        //tb.sendAttributeInt(G31_KEY, mb_radon_F3_eintrarge_last); 


    
      //}

    }
      //********************************************************************







  //-------------------- nur gesendet wenn online -----------------------------------
  if (mQTT_VAR_Send == true){  // jetzt gesendet

    mQTT_VAR_Send = false;
     
              #ifdef sPACE_DEBUG
               Serial.println("[AP] min Free memory  : " + String(esp_get_minimum_free_heap_size()) + " bytes");
              #endif
      

 
        TB_DEBUG_MAX_PRINTLN(F("[SA] Telemetry Send Data start"));               





      send_telemetry_step_data();

       // erst mal lesen was in der Datei ist.
       datei_lesen_line13();
       
        Preferences preferences;
        preferences.begin("eenvs", false);                         //Ordner eenvs anlegen/verwenden
        g13FileRead = preferences.getUShort("p_13file", 0);     // in datei gespeicherte zeilen lesen   //lese ab dieser zeile 
        //must_transfer3 = preferences.getUInt("must_transfer3", 0);     // in datei gespeicherte zeilen lesen   //lese ab dieser zeile 
        preferences.end(); 

        charcount13_w = charcount13;    // soviel in der datei
        must_transfer3 = charcount13_w;

        #ifdef MQTT_DEBUG_last
          Serial.println("[FI] " + String(must_transfer3) + " MQTT Zeilen gespeichert."); 
        #endif

     

        must_transfer3 = must_transfer3 - g13FileRead;
        //#ifdef MQTT_DEBUG_last
          //Serial.println("[FI] ab der Zeile " + String(g13FileRead) + " lesen.");  
          //Serial.println("[FI] lese noch " + String(must_transfer3) + " MQTT Zeilen.");  
        //#endif

        if(must_transfer3 > 1){ // 1 steht immer drin, weil erst dorthin gespeichert wird
            gLostvaluesFlag = true;
            #ifdef MQTT_DEBUG
              Serial.print(F("[IF] "));
              Serial.print(must_transfer3);
              Serial.println(F(" alte Daten gesendet + aktuelle"));

            #endif
        }else{
            gLostvaluesFlag = false;
            #ifdef MQTT_DEBUG
              Serial.println(F("[IF] aktuelle Daten gesendet"));
              init_wifi_counter = 0;
            #endif
        }


        //sendTelemetryJson2_ok = false; 
        uint16_t zeilenZaehler = 0;
        bool zeitcalculate = true;
        
        if(gLostvaluesFlag == true){    // lost ab 2 zeilen in Datei                         
            //==================================            
              char data[200];
              char data2[20];
              t_time_ts_v = 0;
              t_time_ts_n = 0;

              int ir13 = 0;
              File file = SPIFFS.open(dateiGr13, "r"); 
              sendTelemetryJson2_ok = true;      

              while (file.available()) {
                  int len = file.readBytesUntil('\n', data, sizeof(data) - 1);
                  data[len] = '\0';  // Null-terminate the string

                  if (ir13 >= g13FileRead) {  // Erst ab bestimmter Zeile lesen
                      char attributes[200];
                      strncpy(attributes, data, sizeof(attributes) - 1);
                      attributes[sizeof(attributes) - 1] = '\0';

                      //--------------------------------
                      char* tsPos = strstr(data, "ts");
                      if (tsPos) {  // Search string exists
                          positionts1 = (tsPos - data) + 4;
                          char* valuesPos = strstr(data, "values");
                          if (valuesPos) {
                              positionts2 = (valuesPos - data) - 5;
                              strncpy(data2, data + positionts1, positionts2 - positionts1);
                              data2[positionts2 - positionts1] = '\0';
                              if (positionts1 == 6 && positionts2 == 16) {  
                                  t_time_ts = strtoul(data2, NULL, 10);  
                                  t_time_ts_t = t_time_ts;   // gesendete Zeit    
                              }
                          }
                      }

                      if (t_time_ts_t >= t_time_ts_n || t_time_ts_t <= t_time_ts_v) { 
                          zeitcalculate = true;
                          Serial.println(F("[IF] MQTT Timestamp ok"));
                      } else {
                          zeitcalculate = false;
                          Serial.println(F("[IF] MQTT Timestamp fail -> doppelt !!! nichts gesendet !!!"));
                      }
                      if (t_time_ts_n == 0 || t_time_ts_v == 0) {
                          zeitcalculate = true;  // Erstes Mal durchlassen
                      }
                      //--------------------------------

                      if (sendTelemetryJson2_ok && zeitcalculate) {   // Selbsthaltung, erst beim nächsten Mal wieder gesendet
                          sendTelemetryJson2_ok = tb.sendTelemetryJson(attributes);
                          delay(200);

                          send_ueberw_counter_t_start++;
                          if (sendTelemetryJson2_ok) {
                              Serial.println(F("[SA] Sending Telemetry Data 4 success"));
                              send_ueberw_counter_t_success++;
                          } else {
                              Serial.println(F("[SA] Sending Telemetry Data 4 fail"));
                              send_ueberw_counter_t_error++;
                          }
                      }
                      //--------------------------------
                      t_time_ts_v = t_time_ts - 300;  // 5 Minuten
                      t_time_ts_n = t_time_ts + 300;  // 5 Minuten
                      //--------------------------------

                      if (sendTelemetryJson2_ok) {
                          Serial.print(F("[IF] MQTT publish OLD Data: "));Serial.println(data);
                          if (must_transfer3 > 0) {
                              must_transfer3--;
                          }
                      } else {
                          Serial.println(F("[IF] MQTT publish OLD Data fail !!!!"));
                      }

                      if (sendTelemetryJson2_ok) {
                          zeilenZaehler++;
                      }
                      Serial.print(F("[IF] zeilenZaehler: "));Serial.println(zeilenZaehler);
                  } // ir13 >= g13FileRead

                  esp_task_wdt_reset();
                  ir13++;
              }  // while(file.available())



                      preferences.begin("eenvs", false);                         //Ordner eenvs anlegen/verwenden                  
                      preferences.putUInt("must_transfer3", must_transfer3);            //schreibe      ab dieser zeile lesen
       
                

                      // jetzt noch die letze Datenreihe gesendet
                      if(g_sensor_online <= 1){

                        if(must_transfer3 < 1){  // nur bei nichts in Datei gespeichert
                        
                          //send_telemetry_data_json();
                          send_telemetry_data_json_step();
     
                          

                        }
                      }
                      //tb.sendTelemetryString(SERIAL_KEY, mb_Seriennummer_char);
                                          
                  //#ifdef MQTT_DEBUG
                     
                  //#endif

                 
                                          
        }else{  // gLostvaluesFlag == true  lost Daten
        
        
                 sendTelemetryJson2_ok = true; //skip

                      // jetzt noch die letze Datenreihe gesendet
                      if(g_sensor_online <= 1){
                        //tb.sendTelemetryFloat(RADON_KEY, mb_radon_live_32bit); // mb_radon_live_32bit
                        //tb.sendTelemetryData(RADON_KEY, mb_radon_live_32bit);
                        //send_telemetry_data();

                        send_telemetry_data_set = true;
                        //delay(100);
                        //dw_nr_KEY
                      }


                      #ifdef MQTT_DEBUG
                        Serial.println(F("[IF] MQTT publish new Data. Keine alten Daten gespeichert"));
                      #endif

        
        
        }    // gLostvaluesFlag == false   nur aktuelle Daten gesendet
                                          
                  //-----------------------------------    
                  if(sendTelemetryJson2_ok == true){ 
                    File filew = SPIFFS.open(dateiGr13, FILE_WRITE);
                        #ifdef MQTT_DEBUG
                          Serial.print(F("[IF] Datei "));
                          Serial.print(dateiGr13);
                          Serial.println(F(" entfernen. MQTT alles gesendet."));

                        #endif
                    filew.close(); 
                                
                      g13FileRead = 0; 

                      //Preferences preferences;

                  }else{
                    g13FileRead = zeilenZaehler; // es wurde nicht alles gesendet
                  }
                      
                      //Serial.println("[IF] " + String(g13FileRead));   // send_telemetry_data_json  Data 2 fail
                      count13fehlt = 0; 
                      
                      charcount13_w = 0; 
                      if(g13FileRead >800){g13FileRead=800;must_transfer3=800;}
                      preferences.begin("eenvs", false);                         //Ordner eenvs anlegen/verwenden                  
                      preferences.putUShort("p_13file", g13FileRead);            //schreibe      ab dieser zeile lesen
                      
                  //-----------------------------------      

 
                    if (g13FileRead > 0) {
                       #ifdef MQTT_DEBUG
                        Serial.print(F("[IF] Anzahl der gesendeten Daten aus der TB Datei: "));
                        Serial.println(g13FileRead); 
                       #endif
                    }
                     #ifdef MQTT_DEBUG
                      Serial.print(F("[IF] Anzahl der Daten aus dem Speicher und dem aktuellem: "));
                      Serial.println(must_transfer3); 
                      Serial.println(F("--------------------------------------------------------"));
                    #endif


              if(must_transfer3>3){
                  g_check_send_ueberwachung = true;
              }

              must_transfer3 = 0;  


              /*
              Das müsste ich nicht machen wenn nicht gesendete Daten übermittelt werden, weil sont der letzzte zweimal gesendet wird.
              Der aktuelle wird ja immer in dem File auch gespeichert.
              
              [SA] Sending Telemetry Data 3...
              [SA] Sending Telemetry Data 3 success
              [IF] MQTT publish last Data: 
              */


            //#endif

          
         
            #ifdef MQTT_DEBUG
              //Serial.println("[IF] " + payload8);                  
            #endif

     
          if(g_Cloud_ea_ist == 1){
          //if(p_cloudonoff == "on"){
            gReboot_TOKENFlag = 1;  // nur neu Speichern wenn Zeit abgelaufen ist
            SendCloudData();
          }


          g_send_end_wlan_aus = true; startMillisw = millis(); // Startzeit speichern

          internetTransferComplete = true;


  }




       //*************************

            // 1.  g_radon_new_tb     //radonwert erhalten und speichern
            // 2.  g_radon_send_tb    //gespeichert, jetzt freigabe für gesendet
            // 3.  mQTT_VAR_Send      // jetzt gesendet
            
                
            // tb_upload              // alle 10 min versuchen       nur zum testen

            // String payload8 = "{\"params\":\"lastSync,lastConnectTime,provisionState\"}"; 
            // String payload8 = "{\"clientKeys\":\"uptime\",\"sharedKeys\":\"shared1,shared2\"}";
            // payload8 = "{\"availableKeys\":\"['radon1','radon2','radon3','radon4']\",\"uptime\":\"";  

            //----------- sichern in file vor dem gesendet ----------------
            if (g_radon_new_tb == true && epochTime_mqtt > 1672527600){ 

              send_ueberw_counter = 1;    //zurücksetzten
              send_ueberw_counter_success = 1;
              send_ueberw_counter_start = 1;
              send_ueberw_counter_t_start = 1;
              send_ueberw_counter_t_success = 1;


              //-------------------------------------
              // Spezifische Indizes, die auf 1 gesetzt werden sollen
              int indicesToSetOne[] = {4, 3, 2, 1, 15, 14, 13, 12, 11, 19, 30, 33, 32, 31, 29, 28, 27, 25, 26};

              for (int i = 0; i < sizeof(indicesToSetOne) / sizeof(indicesToSetOne[0]); i++) {
                  int index = indicesToSetOne[i];
                  send_ueberw_counter_start_[index] = 1;
                  send_ueberw_counter_success_[index] = 1;
                  send_ueberw_counter_error_[index] = 1;
              }
              // Setze alle anderen Indizes von send_ueberw_counter_error_ auf 0
              for (int i = 0; i < 40; i++) {
                bool isInIndicesToSetOne = false;
                for (int j = 0; j < sizeof(indicesToSetOne) / sizeof(indicesToSetOne[0]); j++) {
                  if (i == indicesToSetOne[j]) {
                    isInIndicesToSetOne = true;
                    break;
                  }
                }
                if (!isInIndicesToSetOne) {
                  send_ueberw_counter_error_[i] = 0;
                }
              }
              //-------------------------------------


              //Serial.println("[IF] send_ueberw_counter_t_start: " + String(send_ueberw_counter_t_start));   
              
              g_radon_new_tb = false;


              //--------------------
              if(g_sensor_online <= 2){

              
              //----------------------------
                /*
                String payload3 = "{\"";
                                                            
                payload3 += "ts";  //topic
                payload3 += "\":";
                payload3 += String(epochTime_mqtt);
                                          
                payload3 += "0";
                payload3 += String(random(10, 99));
                payload3 += ",";

                payload3 += "\"values\":{\"";
                payload3 += "devicenumber";  
                payload3 += "\":";
                payload3 += mb_Seriennummer;
                                              
                payload3 += ",";
                payload3 += "\"";
                payload3 += "radon";  
                payload3 += "\":";
                payload3 += mb_radon_live_32bit;// String(random(0,1500));  // mb_radon_live_32bit

                payload3 += "}}"; 
                things_list_t = payload3;
              
                char attributes[200];
                payload3.toCharArray(attributes, 200);
                */
               //----------------------------

                 /*
                char payload3[200]; // Puffer für das Payload
                // snprintf Format-Spezifizierer:
                // %lu für unsigned long (epochTime_mqtt)
                // %02u für zweistellige unsigned int (cast von random(10, 99))
                // %s für char Array (mb_Seriennummer)
                // %u für uint32_t (mb_radon_live_32bit)
                snprintf(payload3, sizeof(payload3), "{\"ts\":%lu0%02u,\"values\":{\"devicenumber\":\"%s\",\"radon\":%u}}",
                        epochTime_mqtt, (unsigned int)random(10, 99), mb_Seriennummer, mb_radon_live_32bit);

                datei_schreiben13c(payload3);
                */


                // Allokiere Speicher im PSRAM
                char* payload3 = (char*) heap_caps_malloc(200 * sizeof(char), MALLOC_CAP_SPIRAM);
                if (payload3 == NULL) {
                    Serial.println("Failed to allocate memory in PSRAM");
                    return;
                }

                // snprintf Format-Spezifizierer verwenden
                snprintf(payload3, 200, "{\"ts\":%lu0%02u,\"values\":{\"devicenumber\":\"%s\",\"radon\":%u}}",
                        epochTime_mqtt, (unsigned int)random(10, 99), mb_Seriennummer, mb_radon_live_32bit);

                datei_schreiben13c(payload3);

                // Gib den PSRAM-Speicher frei, wenn er nicht mehr benötigt wird
                heap_caps_free(payload3);



                previousSeconds = pgm_read_dword(&scanInterval)-30;



              }


              g_radon_send_tb = true; //gespeichert, jetzt freigabe für gesendet


            }



          //*************************
      


          //--------------------------------------------------
          if(g_esp_restsrt == true){
            g_esp_restsrt = false;
          
                Preferences preferences;
                preferences.begin("eenvs", false);                         //Ordner eenvs anlegen/verwenden       
                g_boot_fail = 1;
                preferences.putUChar("boot_g_fail", g_boot_fail);    // 
               
                  #ifdef ea_webserver 
                  if(disable_server >= 1) { 
                  
                  if (loggingEnabled) {
                   // things_list_t_16 = p_uhrzeit + "  [IF] ESP Reeboot";
                    write_to_log(things_list_t_16);
                    }
                  }
                  #endif
                              
                preferences.end(); 
          
            delay(2000);
            ESP.restart(); 
          }
          //--------------------------------------------------





          if(p_fw_success == 1){
            if (WiFi.status() == WL_CONNECTED) { 
            
                  WiFi_status = WL_CONNECTED;
                  p_fw_success = 0;
                  Preferences preferences;
                  preferences.begin("eenvs", false);                         //Ordner eenvs anlegen/verwenden
                  preferences.putUChar("fw_success", p_fw_success);                         //Variable speichern
                  //preferences.end(); 

                  //Serial.println("[SA] Sending Client attributes..."); 
                  //tb.sendAttributes(attributes, attribute_items);
                  //delay(100);
                  //tb.sendAttributes(attributes2, attribute_items2);
         
                    Serial.println(F("[SA] Sending Client Connect 1")); 
        
                  send_client_attribute();

            }  
          }

    //---------------------------------------------------------------------------------





    //---------------------------------------------------------------------------------
    
      #ifdef BLEbeacon_space
        if(g_end_pAdvertising == true){
          if(millis() > end_pAdvertising){
            g_end_pAdvertising = false;
            //pAdvertising->stop();
          }
        }
      #endif

    //---------------------------------------------------------------------------------





      //-----------------------
      if(b_bit_st_kal == true && g_kalibriert == 0){
        if(g_time_set_kal_val == 0 && g_kal_write_ist == 1){
          
          b_bit_st_kal = false;         
          
            #ifdef MB_KAL_DEBUG
                Serial.print(F("--> Kalibrierung: ")); 
                Serial.print(mb_cal02); 
                Serial.print(F("\t neu: "));
                Serial.println(g_S00_soll);    

                Serial.print(F("--> Count_max   : ")); 
                Serial.print(mb_cal03); 
                Serial.print(F("\t neu: "));
                Serial.println(g_S01_soll);    

                Serial.print(F("--> Darkkount   : ")); 
                Serial.print(mb_cal04); 
                Serial.print(F("\t neu: "));
                Serial.println(g_S02_soll);     

                Serial.print(F("--> Glaettung   : ")); 
                Serial.print(mb_cal07); 
                Serial.print(F("\t neu: "));
                Serial.println(g_S18_soll);    

                Serial.print(F("--> Leerwert    : ")); 
                Serial.print(mb_cal08); 
                Serial.print(F("\t neu: "));
                Serial.println(g_S19_soll);    

                Serial.print(F("--> Leerwert u  : ")); 
                Serial.print(mb_cal09); 
                Serial.print(F("\t neu: "));
                Serial.println(g_S21_soll);

            #endif 

            g_kalibriert = 1;
            //tb.sendAttributeInt(C_s_kalibriert_KEY, g_kalibriert);      // Sensor kalibriert
            //----------------------------
              //const int attribute_items_t = 1;
              Attribute attributes[1] = {
                { C_s_kalibriert_KEY,  g_kalibriert },
              };
              tb.sendAttributes(attributes, 1);delay(200);

            //----------------------------

            Preferences preferences;
            preferences.begin("eenvs", false);                          //Ordner eenvs anlegen/verwenden
            preferences.putUChar("s_kalibriert", g_kalibriert);          //kalibrierter Sensor

          mb_write_cal();

          b_cal_write = false; 
          g_kal_write_ist = 0; 

        }
      }
      //-----------------------

      //-----------------------
      if(b_checken == true && g_checked == 0){
        if(g_time_set_check_val == 0){
              g_checken_ist = 0;
              b_checken = false; 

              g_checked = 1;
              //tb.sendAttributeInt(C_s_checked_KEY, g_checked);           // Sensor getschecked
              //----------------------------
                //const int attribute_items_t = 1;
                Attribute attributes[1] = {
                  { C_s_checked_KEY,  g_checked },
                };
                tb.sendAttributes(attributes, 1);delay(200);
   
              //----------------------------
              Preferences preferences;
              preferences.begin("eenvs", false);                          //Ordner eenvs anlegen/verwenden
              preferences.putUChar("s_checked", g_checked);                //checked Sensor
        }
      }
      //-----------------------

      //-----------------------
      if(b_re_checked == true){
        b_re_checked = false;

              b_checken = false; 
              g_checked = 0;
              //tb.sendAttributeInt(C_s_checked_KEY, g_checked);           // Sensor getschecked
              //----------------------------
                //const int attribute_items_t = 1;
                Attribute attributes[1] = {
                  { C_s_checked_KEY,  g_checked },
                };
                tb.sendAttributes(attributes, 1);delay(200);
           
              //----------------------------
              Preferences preferences;
              preferences.begin("eenvs", false);                          //Ordner eenvs anlegen/verwenden
              preferences.putUChar("s_checked", g_checked);                //checked Sensor
      }
      //-----------------------

      //-----------------------
      if(b_re_kalibrieren == true){   // Sensor ent kalibrieren
        b_re_kalibrieren = false;

              g_kalibrieren_ist = 0; 
              b_calibrieren = false;
              g_kalibriert = 0;
              //tb.sendAttributeInt(C_s_kalibriert_KEY, g_kalibriert);      // Sensor ent kalibrieren
              Preferences preferences;
              preferences.begin("eenvs", false);                          //Ordner eenvs anlegen/verwenden
              preferences.putUChar("s_kalibriert", g_kalibriert);          //kalibrierter Sensor

              g_checked = 0;
              //tb.sendAttributeInt(C_s_checked_KEY, g_checked);           // Sensor getschecked

              //----------------------------
                //const int attribute_items_t = 2;
                Attribute attributes[2] = {
                  { C_s_kalibriert_KEY,  g_kalibriert },
                  { C_s_checked_KEY,  g_checked },
                };
                tb.sendAttributes(attributes, 2);delay(200);
       
              //----------------------------

              preferences.begin("eenvs", false);                          //Ordner eenvs anlegen/verwenden
              preferences.putUChar("s_checked", g_checked);                //checked Sensor

      }
      //-----------------------


      if(disable_server >= 1) {
        if(sperre_10Time == false && gFW_Update_start == 0){
          if (currentmin == 0 || currentmin == 10 || currentmin == 20 || currentmin == 30 || currentmin == 40 || currentmin == 50) {
            if (currentSec <= 50 && sperre_10Time == false) {
              
                //stopBLEserver_not_Beacon();
                sperre_10Time = true;
                Serial.print(F("[MB] ["));
                Serial.print(p_uhrzeit);
                Serial.println(F("] Abfrage Radonwerte"));

                transferCompleteTime = millis(); //internetTransferComplete = false;  stopBeacon();

                mb3_request();
                
                if(g_kalibrieren_ist == 1){   // kal aktiv
                  mb_read_cal_vals();        // READ_INPUT_REGISTER, 26, 6); 
                }
                
                mb3Callback();               // READ_HOLD_REGISTER, 20, 8); 
                save_long_24h_values = true;
 

          } 
          }
        }
      }

      if (currentmin != 0 && currentmin != 10 && currentmin != 20 && currentmin != 30 && currentmin != 40 && currentmin !=50) {

       sperre_10Time = false;

      }








    //*************************************************************************************
    //g_requestedShared_x true aktiviert das lesen  und kein FW update
    if(g_requestedShared_sq == true && gFW_Update_start == 0){
      g_requestedShared_sq = false;

      if(g_requestedShared_x == true){   // TB_status = tb.connected();
        g_requestedShared_x = false; 


              WiFi_status = WiFi.status();   // 3= WL_CONNECTED
              TB_status = tb.connected();
              //Serial.println("[IF] TB_status_a: " + String(TB_status));
              //Serial.println("[IF] WiFi_status: " + String(WiFi_status));

              if (!tb.connected() && WiFi.status() == WL_CONNECTED) {
                count_InitTB ++;
                TB_connect();
                TB_status = tb.connected();
              }
              //Serial.println("[IF] TB_status_b: " + String(TB_status));



                if (!requestedShared4) {
                    TB_DEBUG_MAX_PRINTLN(F("[IF] Requested Shared ... Start lesen.. "));
                    g_now_ani_led = true;
                    transferCompleteTime = millis();
                }

                
              //reihenfolge wichtig wegen Schrittkette.

                if(requestedShared3 == true){
                  if (!requestedShared4) {

                      TB_DEBUG_MAX_PRINTLN(F(" "));
                      TB_DEBUG_MAX_PRINTLN(F("--------------------------------------"));
                      TB_DEBUG_MAX_PRINTLN(F("[IF] Requesting shared 4 attributes..."));
                      g_now_ani_led = true;
                      /*
                      const int myArraySize4 = sizeof(REQUESTED_SHARED_ATTRIBUTES4)/sizeof(REQUESTED_SHARED_ATTRIBUTES4[0]);
                      TB_DEBUG_MAX_PRINT(F("[IF] | "));
                      for (int i = 0; i < myArraySize4; i++) { 
                          TB_DEBUG_MAX_PRINT(REQUESTED_SHARED_ATTRIBUTES4[i]);
                          TB_DEBUG_MAX_PRINT(F(" | "));
                      }
                      TB_DEBUG_MAX_PRINTLN(F(" "));
                      */
                      sendRequestedShared4_ok = true;
                      requestedShared4 = tb.Shared_Attributes_Request(sharedCallback4); 
                      delay(300);
                      sendRequestedShared4_ok = requestedShared4;
                      if (sendRequestedShared4_ok == false) {
                          TB_DEBUG_MAX_PRINTLN(F("[SA] Sending Shared Attributes 4 fail")); 
                      }

                      TB_DEBUG_MAX_PRINTLN(F("[IF] Requesting shared 6 attributes..."));
                      g_now_ani_led = true;

                      /*
                      const int myArraySize6 = sizeof(REQUESTED_SHARED_ATTRIBUTES6)/sizeof(REQUESTED_SHARED_ATTRIBUTES6[0]);
                      Serial.print("[IF] | ");
                      for (int i = 0; i < myArraySize6;i++) 
                      { 
                        Serial.print(REQUESTED_SHARED_ATTRIBUTES6[i]);
                        Serial.print(" | ");
                      }
                      Serial.println(F(" "));
                      */
                        sendRequestedShared6_ok = true;
                        requestedShared6 = tb.Shared_Attributes_Request(sharedCallback6); 
                        delay(300);
                        esp_task_wdt_reset(); 
                        sendRequestedShared6_ok = requestedShared6;
                        if (sendRequestedShared6_ok == false) {
                            TB_DEBUG_MAX_PRINTLN(F("[SA] Sending Shared Attributes 6 fail")); 
                        }

                        TB_DEBUG_MAX_PRINTLN(F("[IF] Requesting shared 7 attributes..."));
                        g_now_ani_led = true;
                        /*
                        const int myArraySize7 = sizeof(REQUESTED_SHARED_ATTRIBUTES7)/sizeof(REQUESTED_SHARED_ATTRIBUTES7[0]);
                        TB_DEBUG_MAX_PRINT(F("[IF] | "));
                        for (int i = 0; i < myArraySize7; i++) { 
                            TB_DEBUG_MAX_PRINT(REQUESTED_SHARED_ATTRIBUTES7[i]);
                            TB_DEBUG_MAX_PRINT(F(" | "));
                        }
                        TB_DEBUG_MAX_PRINTLN(F(" "));
                        */
                        sendRequestedShared7_ok = true;
                        requestedShared7 = tb.Shared_Attributes_Request(sharedCallback7); 
                        delay(300);
                        sendRequestedShared7_ok = requestedShared7;
                        if (sendRequestedShared7_ok == false) {
                            TB_DEBUG_MAX_PRINTLN(F("[SA] Sending Shared Attributes 7 fail")); 
                        }


                      //-------------------------------------------------


                    //-------------------------------------------------
                    TB_DEBUG_MAX_PRINTLN(F("[IF] Requesting shared 8 attributes..."));
                    g_now_ani_led = true;
                    /*
                    const int myArraySize8 = sizeof(REQUESTED_SHARED_ATTRIBUTES8)/sizeof(REQUESTED_SHARED_ATTRIBUTES8[0]);
                    TB_DEBUG_MAX_PRINT("[IF] | ");
                    for (int i = 0; i < myArraySize8; i++) { 
                        TB_DEBUG_MAX_PRINT(REQUESTED_SHARED_ATTRIBUTES8[i]);
                        TB_DEBUG_MAX_PRINT(" | ");
                    }
                    TB_DEBUG_MAX_PRINTLN(F(" "));
                    */
                    sendRequestedShared8_ok = true;
                    requestedShared8 = tb.Shared_Attributes_Request(sharedCallback8); 
                    delay(300);
                    esp_task_wdt_reset(); 
                    sendRequestedShared8_ok = requestedShared8;
                    if (sendRequestedShared8_ok == false) {
                        TB_DEBUG_MAX_PRINTLN(F("[SA] Sending Shared Attributes 8 fail")); 
                    }
                    //-------------------------------------------------

                    //-------------------------------------------------
                    TB_DEBUG_MAX_PRINTLN(F("[IF] Requesting shared t attributes..."));
                    //g_now_ani_led = true;
                    /*
                    const int myArraySize8 = sizeof(REQUESTED_SHARED_ATTRIBUTES8)/sizeof(REQUESTED_SHARED_ATTRIBUTES8[0]);
                    TB_DEBUG_MAX_PRINT("[IF] | ");
                    for (int i = 0; i < myArraySize8; i++) { 
                        TB_DEBUG_MAX_PRINT(REQUESTED_SHARED_ATTRIBUTES8[i]);
                        TB_DEBUG_MAX_PRINT(" | ");
                    }
                    TB_DEBUG_MAX_PRINTLN(F(" "));
                    */
                    sendRequestedSharedt_ok = true;
                    requestedSharedt = tb.Shared_Attributes_Request(sharedCallbackt); 
                    delay(300);
                    esp_task_wdt_reset(); 
                    sendRequestedSharedt_ok = requestedSharedt;
                    if (sendRequestedSharedt_ok == false) {
                        TB_DEBUG_MAX_PRINTLN(F("[SA] Sending Shared Attributes t fail")); 
                    }

                      //set_bit_wait_front_view = false;
                      //-------------------------------------------------



                    //-------------------------------------------------
                      requestedShared4_fail = false;
                      //requestedShared4_end = false;
                      if (!requestedShared4) {
                          TB_DEBUG_MAX_PRINTLN(F("[IF] Failed to request 4 shared attributes"));
                          requestedShared4 = true;
                          g_requestedShared_x = true;
                          requestedShared4_fail = true;
                          //requestedShared4_end = true;
                      }

                      TB_DEBUG_MAX_PRINTLN(F("--------------------------------------"));

                      transferCompleteTime = millis();

                     /*
                      sendRequestedShared9_ok = true;
                      requestedShared9 = tb.RPC_Request(sharedCallback9);
                      sendRequestedShared9_ok = requestedShared9;
                      if(sendRequestedShared9_ok == false){
                        Serial.println("[SA] Sending RPC Request 9 fail"); 
                      }
                      */
                       /*
                        sendRequestedShared9_ok = true;
                        requestedShared9 = tb.RPC_Subscribe(callbackrpcs.cbegin(), callbackrpcs.cend());
                        sendRequestedShared9_ok = requestedShared9;

                        if (sendRequestedShared9_ok == false) {
                          Serial.println("Failed to subscribe for RPC");
                        }else{
                          Serial.println("[IF] Subscribe for RPC done");
                        }

                        sendRequestedShared9_ok = true;
                        requestedShared9 = tb.RPC_Subscribe(callbackrpcs2.cbegin(), callbackrpcs2.cend());
                        sendRequestedShared9_ok = requestedShared9;

                        if (sendRequestedShared9_ok == false) {
                          Serial.println("Failed to subscribe for RPC2");
                        }else{
                          Serial.println("[IF] Subscribe for RPC2 done");
                        }
                       */
                      g_sperr_bit_time = false;
                  }
                 
                }
           


                     
           
                if(requestedShared2 == true){
                  if (!requestedShared3) {

                    TB_DEBUG_MAX_PRINTLN(F("[IF] Requesting shared 3 attributes..."));
                    g_now_ani_led = true;
                    /*
                    const int myArraySize3 = sizeof(REQUESTED_SHARED_ATTRIBUTES3)/sizeof(REQUESTED_SHARED_ATTRIBUTES3[0]);
                    TB_DEBUG_MAX_PRINT("[IF] | ");
                    for (int i = 0; i < myArraySize3; i++) { 
                        TB_DEBUG_MAX_PRINT(REQUESTED_SHARED_ATTRIBUTES3[i]);
                        TB_DEBUG_MAX_PRINT(" | ");
                    }
                    TB_DEBUG_MAX_PRINTLN(F(" "));
                    */
                    sendRequestedShared3_ok = true;
                    requestedShared3 = tb.Shared_Attributes_Request(sharedCallback3); 
                    delay(200);
                    sendRequestedShared3_ok = requestedShared3;
                    if (sendRequestedShared3_ok == false) {
                        TB_DEBUG_MAX_PRINTLN(F("[SA] Sending Shared Attributes 3 fail")); 
                    }

                    requestedShared3_fail = false;
                    if (!requestedShared3) {
                        TB_DEBUG_MAX_PRINTLN(F("[IF] Failed to request 3 shared attributes"));
                        requestedShared3 = true;
                        g_requestedShared_x = true;
                        requestedShared3_fail = true;
                    }

                  }  
                }
                              
                if (requestedShared1 == true) {
                    if (!requestedShared2) {
                        g_sperr_bit_time = true;
                        TB_DEBUG_MAX_PRINTLN(F("[IF] Requesting shared 2 attributes..."));
                        g_now_ani_led = true;
                        /*
                        const int myArraySize2 = sizeof(REQUESTED_SHARED_ATTRIBUTES2)/sizeof(REQUESTED_SHARED_ATTRIBUTES2[0]);
                        TB_DEBUG_MAX_PRINT("[IF] | ");
                        for (int i = 0; i < myArraySize2; i++) { 
                            TB_DEBUG_MAX_PRINT(REQUESTED_SHARED_ATTRIBUTES2[i]);
                            TB_DEBUG_MAX_PRINT(" | ");
                        }
                        TB_DEBUG_MAX_PRINTLN(F(" "));
                        */
                        sendRequestedShared2_ok = true;
                        requestedShared2 = tb.Shared_Attributes_Request(sharedCallback2); 
                        delay(200);
                        esp_task_wdt_reset(); 
                        sendRequestedShared2_ok = requestedShared2;
                        if (sendRequestedShared2_ok == false) {
                            TB_DEBUG_MAX_PRINTLN(F("[SA] Sending Shared Attributes 2 fail")); 
                        }

                        requestedShared2_fail = false;
                        if (!requestedShared2) {
                            TB_DEBUG_MAX_PRINTLN(F("[IF] Failed to request 2 shared attributes"));
                            requestedShared2 = true;
                            g_requestedShared_x = true;
                            requestedShared2_fail = true;
                        }
                    }
                }

           
                          
                if(requestedShared == true) {
                    if (!requestedShared1) {
                        TB_DEBUG_MAX_PRINTLN(F(" "));
                        TB_DEBUG_MAX_PRINTLN(F("--------------------------------------"));

                        if(update_ntp_ready == 0) {
                            g_new_search_ntp = true;
                        }
                        
                        TB_DEBUG_MAX_PRINTLN(F("[IF] Requesting shared 1 attributes..."));
                        g_now_ani_led = true;
                        /*
                        const int myArraySize1 = sizeof(REQUESTED_SHARED_ATTRIBUTES1)/sizeof(REQUESTED_SHARED_ATTRIBUTES1[0]);
                        TB_DEBUG_MAX_PRINT("[IF] | ");
                        for (int i = 0; i < myArraySize1; i++) { 
                            TB_DEBUG_MAX_PRINT(REQUESTED_SHARED_ATTRIBUTES1[i]);
                            TB_DEBUG_MAX_PRINT(" | ");
                        }
                        TB_DEBUG_MAX_PRINTLN(F(" "));
                        */
                        sendRequestedShared1_ok = true;
                        requestedShared1 = tb.Shared_Attributes_Request(sharedCallback1); 
                        delay(200);
                        esp_task_wdt_reset(); 
                        sendRequestedShared1_ok = requestedShared1;
                        if (sendRequestedShared1_ok == false) {
                            TB_DEBUG_MAX_PRINTLN(F("[SA] Sending Shared Attributes 1 fail")); 
                        }

                        requestedShared1_fail = false;
                        if (!requestedShared1) {
                            TB_DEBUG_MAX_PRINTLN(F("[IF] Failed to request 1 shared attributes"));
                            requestedShared1 = true;
                            g_requestedShared_x = true;
                            requestedShared1_fail = true;
                        }
                    }
                }



                   // Lesen Shared beim Booten
                if (!requestedShared) {
                    TB_DEBUG_MAX_PRINTLN(F("[IF] Requesting shared attributes b..."));
                    /*
                    const int myArraySize = sizeof(REQUESTED_SHARED_ATTRIBUTES)/sizeof(REQUESTED_SHARED_ATTRIBUTES[0]);
                    TB_DEBUG_MAX_PRINT("[IF] | ");
                    for (int i = 0; i < myArraySize; i++) { 
                        TB_DEBUG_MAX_PRINT(REQUESTED_SHARED_ATTRIBUTES[i]);
                        TB_DEBUG_MAX_PRINT(" | ");
                    }
                    TB_DEBUG_MAX_PRINTLN(F(" "));
                    */
                    sendRequestedShared0_ok = true;
                    requestedShared = tb.Shared_Attributes_Request(sharedCallback); 
                    delay(200);
                    esp_task_wdt_reset(); 
                    sendRequestedShared0_ok = requestedShared;
                    if (sendRequestedShared0_ok == false) {
                        TB_DEBUG_MAX_PRINTLN(F("[SA] Sending Shared Attributes 0 fail")); 
                    }

                    requestedShared_fail = false;
                    if (!requestedShared) {
                        TB_DEBUG_MAX_PRINTLN(F("[IF] Failed to request shared attributes"));
                        requestedShared = true;
                        g_requestedShared_x = true;
                        requestedShared_fail = true;
                    }
                }


          requestedSharedx_fail = false;
          if(requestedShared_fail == true || requestedShared1_fail == true || requestedShared2_fail == true || requestedShared3_fail == true || requestedShared4_fail == true){
              requestedSharedx_fail = true;
          }

                  
      }
    }
    //*************************************************************************************


    //*************************************************************************************
    // kein FW update
    if(gFW_Update_start == 0){

    //   fehler bei shared lesen           abbonieren fehler            TB connect fail       kein WLAN 35min          test update shared          subscriptions, increase MaxFieldsAmt   
    //if(requestedSharedx_fail == true || count_subscribedSHARED >= 1 || count_InitTB >= 6 || count_InitWiFi >= 35 || requestedShared5_fail_count >= 3 || g_fail_requestedClient > 255){
      if(requestedSharedx_fail == true || count_subscribedSHARED >= 1 ||                                              requestedShared5_fail_count >= 3 || g_fail_requestedClient > 255){  
              if (second >= 30 && second <= 40) {
                if (!rebootScheduled) {
                  rebootStartMillis = millis();
                  rebootScheduled = true;
                }
              }
            }
        

          if (rebootScheduled && millis() - rebootStartMillis >= 180000) { // 180000 ms = 3 Minuten
            Preferences preferences;
            preferences.begin("eenvs", false); // Ordner eenvs anlegen/verwenden       
            g_boot_fail = 1;
            preferences.putUChar("boot_g_fail", g_boot_fail); 

            #ifdef ea_webserver
            if (disable_server >= 1) { 

              if (loggingEnabled) {
               //things_list_t_16 = p_uhrzeit + "  [IF] ESP Reeboot Error subscribed: " + String(requestedSharedx_fail) + String(count_subscribedSHARED) + String(count_InitTB) + String(count_InitWiFi) + String(requestedShared5_fail_count) + String(g_fail_requestedClient);
              
                write_to_log(things_list_t_16);
                }
            }
            #endif

            preferences.end(); 

            tb.sendTelemetryData("Night", "ESP Reboot Error subscribed");
            delay(200);
              Serial.print(F("[IF] requestedSharedx_fail: ")); 
              Serial.println(requestedSharedx_fail);   

              Serial.print(F("[IF] count_subscribedSHARED: ")); 
              Serial.println(count_subscribedSHARED);  

              Serial.print(F("[IF] count_InitTB: ")); 
              Serial.println(count_InitTB);  

              Serial.print(F("[IF] count_InitWiFi: ")); 
              Serial.println(count_InitWiFi);  

              Serial.print(F("[IF] requestedShared5_fail: ")); 
              Serial.println(requestedShared5_fail_count);  

              Serial.print(F("[IF] increase MaxFieldsAmt: ")); 
              Serial.println(g_fail_requestedClient);  

              Serial.println(F("[IF] ESP Reeboot!!"));
                

              g_esp_soft_restart = true;

          }

    }
    //*************************************************************************************




      if(gFW_Update_start == 1 ){
      ledcWrite(ledChannel, 0); //dp
      }

            //if(g_Seg__boot_ani == false && gFW_Update_start == 0 && g_LEDT_F_ist == 0){
            if(gFW_Update_start == 0 && g_LEDT_F_ist == 0 && akt_fw_load == false && g_LEDT_T_KNX == 0){
              lc.setRow(0,0,0);
              lc.setRow(0,1,0);
              lc.setRow(0,2,0);
              lc.setRow(0,3,0);
              
              //dutyCycle = 0;
              ledcWrite(ledChannel, 0);//dp
            }



    //*************************************************************************************
     if(g_beacon_reset == true && g_beacon_time == 0){

          g_beacon_time = 10;
          g_beacon_reset = false;

          Preferences preferences;
          preferences.begin("eenvs", false);                         //Ordner eenvs anlegen/verwenden       
          preferences.end(); 
          Serial.print(F("[IF] Beacon: "));
          Serial.println(g_u_beacon_soll);  
          Serial.println(F("[IF] ESP Reeboot!!"));
          
          g_esp_soft_restart = true;
           

     }        
    //*************************************************************************************






     //-------------------------------------------------------------------------------------------------------
     if(write_to_file == true){
                  #ifdef IF_14_15_DEBUG
                      Serial.println(F(" "));
                      Serial.println(F("-----------------------------------------"));
                  #endif


      write_to_file = false;

      write_to_file_count ++;

        // 24.05.09 13:50:00,xx
        //things_list_t_14 += String(radon_1h_ist);
        //things_list_t_15 = things_list_t_14;
        //strcpy(things_list_t_15, things_list_t_14);


          if(g1415Side == 0){
           
            g14Filewrite ++;
            Preferences preferences;
            preferences.begin("eenvs", false);                         //Ordner eenvs anlegen/verwenden
            preferences.putUShort("g14Filewr", g14Filewrite);  

            
            if(g14Filewrite >= v_count_gh){
              
              #ifdef IF_14_15_DEBUG
                Serial.println(F("[GR] 1 Jahr voll nun 15er datei"));
              #endif
              
              g1415Side = 1; // andere Seite
              preferences.putUShort("g1415Side", g1415Side);  
              
              g15Filewrite = 0;
              preferences.putUShort("g15Filewr", g15Filewrite);  
             
              g1415_full = 1;  // 1o.2 jahre voll
              preferences.putUShort("g1415_full", g1415_full);  

             //-----------------------------------    
                File filew = SPIFFS.open(dateiGr15, FILE_WRITE);
                  #ifdef IF_14_15_DEBUG
                    Serial.println("[GR] Datei " + String(dateiGr15) + " entfernen.");
                  #endif
                filew.close(); 
             //-----------------------------------  

            }
              //things_list_t_14 = p_uhrzeit;  // [TM] Uhrzeit
              #ifdef IF_14_15_DEBUG
                 Serial.print("[GR] Schreibe in BT Datei Nr.14 Anzahl der geschriebenen Zeilen: " + String(g14Filewrite));
                 Serial.println(" | Nr.15 Anzahl der geschriebenen Zeilen: " + String(g15Filewrite));
              #endif

              datei_schreiben14(things_list_t_14);


              #ifdef ea_webserver
              //things_list_t_16 = p_uhrzeit + "  [GR] Schreibe in Datei Nr.14 Anzahl der geschriebenen Zeilen: " + String(g14Filewrite) + " | Nr.15 Anzahl der geschriebenen Zeilen: " + String(g15Filewrite);
              //if (loggingEnabled) {write_to_log(things_list_t_16);}
              #endif

          }else{

            g15Filewrite ++;
            Preferences preferences;
            preferences.begin("eenvs", false);                         //Ordner eenvs anlegen/verwenden
            preferences.putUShort("g15Filewr", g15Filewrite);  

           
            if(g15Filewrite >= v_count_gh){
              
              #ifdef IF_14_15_DEBUG
                Serial.println("[GR] 1 Jahr voll nun 14er datei");
              #endif
              
              g1415Side = 0; // andere Seite
              preferences.putUShort("g1415Side", g1415Side);  
             
              g14Filewrite = 0;
              preferences.putUShort("g14Filewr", g14Filewrite);  

              g1415_full = 1;  //  1o.2 jahre voll
              preferences.putUShort("g1415_full", g1415_full);  
             
             //-----------------------------------    
                File filew = SPIFFS.open(dateiGr14, FILE_WRITE);
                  #ifdef IF_14_15_DEBUG
                    Serial.println("[GR] Datei " + String(dateiGr14) + " entfernen.");
                  #endif
                filew.close(); 
             //-----------------------------------  

            }
              //things_list_t_15 = p_uhrzeit;
              #ifdef IF_14_15_DEBUG
                Serial.print("[GR] Schreibe in BT Datei Nr.15 Anzahl der geschriebenen Zeilen: " + String(g15Filewrite));
                Serial.println(" | Nr.14 Anzahl der geschriebenen Zeilen: " + String(g14Filewrite));
              #endif
              datei_schreiben15(things_list_t_14);
              #ifdef ea_webserver
              if(disable_server >= 1 && TB_currFwVersion == TB_newFwVersion) {

              if (loggingEnabled) {
                //things_list_t_16 = p_uhrzeit + "  [GR] Schreibe in Datei Nr.15 Anzahl der geschriebenen Zeilen: " + String(g15Filewrite) + " | Nr.14 Anzahl der geschriebenen Zeilen: " + String(g14Filewrite);
              
                write_to_log(things_list_t_16);
                }
              }
              #endif
          }

               
             //b_file_read14 = true;
           
                      
                      Serial.println("-------------------- ------------------");
                      //Serial.println(F(" "));
     }
     //-------------------------------------------------------------------------------------------------------






     //-------------------------------------------------------------------------------------------------------
     if(b_file_read14 == true){

          b_file_read14 = false;

            lc.setChar(0,0,'r',false);
            lc.setChar(0,1,'E',false);
            lc.setChar(0,2,'a',false);
            lc.setChar(0,3,'d',false);

            ledcWrite(ledChannel, 0);//dp

           b_file_send = true; 

           //int correctionCount = 0;


          //---------------- länge -------------------------
          String tempstr = "";
          //uint8_t loop_c = 0;
     
          if(g1415_full == 1){
            g1415_Sum_Counter = v_count_gh;
          }else{
            g1415_Sum_Counter = g14Filewrite;
          }

          bl_send_init();
          //---------------------------------------------


           // arraycounter;resultarrycounter;

            arraycounter = 0;
            if(g1415_Sum_Counter > 10){
            arraycounter = g1415_Sum_Counter / 10; 
            }
            //#ifdef IF_14_15_DEBUG
              //Serial.println("[GR] Lese Daten aus Dateien für Grafik");
              //Serial.print("[GR] Aufzeichnungen ");Serial.print(g1415_Sum_Counter);Serial.print(" | Jahr voll ");Serial.print(g1415_full);Serial.print(" | Seite ");Serial.println(g1415Side); 
            //#endif



         
          startTime=millis();

          if(g1415_full != 0){ // ein Jahr voll
             //                                                                            800           5         795  also 5 nicht übertaregn und dann alle anderen
             // wenn g1415Side = 0 dann lese g14Filewrite wenn wert >0 und dann noch    g15Filewrite-g14Filewrite= xx
             
             
             //Serial.print("g1415Side ");Serial.print(g1415Side);Serial.print("  g1415_full ");Serial.println(g1415_full);
             if(g1415Side == 0){
               g1415_Sum_Counter = g15Filewrite-g14Filewrite;
               start_counter = g1415_Sum_Counter;
               
               //Serial.print("start_counter ");Serial.print(start_counter);Serial.print(" ");Serial.print(g15Filewrite);Serial.print(" ");Serial.println(g14Filewrite);

               // lese ab g1415_Sum_Counter bis ende

               //--------------------------------------------------
               // alles aus der neuen Datei
               datei_lesen_line15b();
                if(g1415Side == 0){ 
                  #ifdef IF_14_15_DEBUG
                    start_counter ++;
                    Serial.print("[GR] Lese Daten aus Datei Nr.15b ab zeile "); Serial.println(start_counter);   //start_counter = g14Filewrite;
                    start_counter --;
                    Serial.print("[GR] Aufzeichnungen ");Serial.print(g1415_Sum_Counter);Serial.print(" | g1415_full ");Serial.print(g1415_full);Serial.print(" | g1415Side ");Serial.println(g1415Side); 
                  #endif
                }else{
                  #ifdef IF_14_15_DEBUG
                  Serial.print("[GR] Lese alle Daten aus Datei Nr.15b    Aufzeichnungen vorhanden: "); Serial.println(g15Filewrite); 
                  Serial.print("[GR] g1415_full ");Serial.print(g1415_full);Serial.print(" | g1415Side ");Serial.println(g1415Side);  
                  #endif
                } 
                //-------------------------------------------------- 
              
               //--------------------------------------------------
                // alles aus der neuen Datei
               datei_lesen_line14b();
                if(g1415Side != 0){ 
                  #ifdef IF_14_15_DEBUG
                      start_counter ++;
                      Serial.print("[GR] Lese Daten aus Datei Nr.14b ab zeile "); Serial.println(start_counter);   //start_counter = g14Filewrite;
                      start_counter --;
                      Serial.print("[GR] Aufzeichnungen ");Serial.print(g1415_Sum_Counter);Serial.print(" | g1415_full ");Serial.print(g1415_full);Serial.print(" | g1415Side ");Serial.println(g1415Side);  
                  #endif
                }else{
                  start_counter = 0;
                  #ifdef IF_14_15_DEBUG
                    Serial.print("[GR] Lese alle Daten aus Datei Nr.14b    Aufzeichnungen vorhanden: "); Serial.println(g14Filewrite); 
                    Serial.print("[GR] g1415_full ");Serial.print(g1415_full);Serial.print(" | g1415Side ");Serial.println(g1415Side);  
                  #endif
                }   
               //--------------------------------------------------

             }else{

               g1415_Sum_Counter = g14Filewrite-g15Filewrite;
               start_counter = g1415_Sum_Counter;
               //Serial.print("start_counter ");Serial.print(start_counter);Serial.print(" ");Serial.print(g14Filewrite);Serial.print(" ");Serial.println(g15Filewrite);
               // lese ab g1415_Sum_Counter bis ende
               start_counter = g15Filewrite;
               
               //--------------------------------------------------
               datei_lesen_line14b();
                if(g1415Side != 0){ 
                  #ifdef IF_14_15_DEBUG
                      start_counter ++;
                      Serial.print("[GR] Lese Daten aus Datei Nr.14b ab zeile "); Serial.println(start_counter);   //start_counter = g14Filewrite;
                      start_counter --;
                      Serial.print("[GR] Aufzeichnungen ");Serial.print(g1415_Sum_Counter);Serial.print(" | g1415_full ");Serial.print(g1415_full);Serial.print(" | g1415Side ");Serial.println(g1415Side);  
                  #endif
                }else{
                  start_counter = 0;
                  #ifdef IF_14_15_DEBUG
                    Serial.print("[[GR] Lese alle Daten aus Datei Nr.14b    Aufzeichnungen vorhanden: "); Serial.println(g14Filewrite); 
                    Serial.print("[GR] g1415_full ");Serial.print(g1415_full);Serial.print(" | g1415Side ");Serial.println(g1415Side);  
                  #endif
                }   
               //--------------------------------------------------

               //--------------------------------------------------
               // alles aus der neuen Datei
               datei_lesen_line15b();
                if(g1415Side == 0){ 
                  #ifdef IF_14_15_DEBUG
                    start_counter ++;
                    Serial.print("[GR] Lese Daten aus Datei Nr.15b ab zeile "); Serial.println(start_counter);   //start_counter = g14Filewrite;
                    start_counter --;
                    Serial.print("[GR] Aufzeichnungen ");Serial.print(g1415_Sum_Counter);Serial.print(" | g1415_full ");Serial.print(g1415_full);Serial.print(" | g1415Side ");Serial.println(g1415Side); 
                  #endif
                }else{
                  #ifdef IF_14_15_DEBUG
                  Serial.print("[GR] Lese alle Daten aus Datei Nr.15b    Aufzeichnungen vorhanden: "); Serial.println(g15Filewrite); 
                  Serial.print("[GR] g1415_full ");Serial.print(g1415_full);Serial.print(" | g1415Side ");Serial.println(g1415Side);  
                  #endif
                } 
                //-------------------------------------------------- 

             }




          }else{

              start_counter = 0;
              //if(g1415_full == 0){
                datei_lesen_line14b();
              //}else{
                //datei_lesen_line15b();
              //}
                  #ifdef IF_14_15_DEBUG
                      //start_counter ++;
                      //Serial.print("[GR] Lese Daten aus Datei Nr.14b ab zeile "); Serial.println(start_counter);   //start_counter = g14Filewrite;
                      //start_counter --;
                  #endif

          }
              
              //#ifdef IF_14_15_DEBUG
                deltaTime=millis()-startTime;

                if(arraycounter > 1){
                startTime = deltaTime/arraycounter;
                }else{
                 startTime = deltaTime;
                }
                //Serial.print("[GR] Zeit für Daten lesen: ");Serial.print(deltaTime);Serial.println(" ms");
                //Serial.print("[GR] Zeit für Array lesen: ");Serial.print(startTime);Serial.println(" ms");
              //#endif


       b_file_send = false; 

     }
     //-------------------------------------------------------------------------------------------------------





     //-------------------------------------------------------------------------------------------------------
     if(b_file_delete == true){

       b_file_delete = false;

            lc.setChar(0,0,'d',false);
            lc.setChar(0,1,'E',false);
            lc.setChar(0,2,'l',false);
            lc.setChar(0,3,' ',false);
            
            ledcWrite(ledChannel, 0);//dp
            
                  //-----------------------------------    
                    File filew = SPIFFS.open(dateiGr14, FILE_WRITE);
                        #ifdef IF_14_15_DEBUG
                          Serial.println("[IF] Datei " + String(dateiGr14) + " entfernen.");
                        #endif
                    filew.close(); 
                                
                    File filew2 = SPIFFS.open(dateiGr15, FILE_WRITE);
                        #ifdef IF_14_15_DEBUG
                          Serial.println("[IF] Datei " + String(dateiGr15) + " entfernen.");
                        #endif
                    filew2.close(); 

                      Preferences preferences;
                      preferences.begin("eenvs", false);                         //Ordner eenvs anlegen/verwenden                  
                                   
                      g1415_full = 0; // 2 Jahre
                      preferences.putUShort("g1415_full", g1415_full);  
                      g1415Side = 0; // andere Seite
                      preferences.putUShort("g1415Side", g1415Side);  
                      g14Filewrite = 0; // erste Seite counter rücksetzen
                      preferences.putUShort("g14Filewr", g14Filewrite);  
                      g15Filewrite = 0; // erste Seite counter rücksetzen
                      preferences.putUShort("g15Filewr", g15Filewrite); 
              
                  //-----------------------------------    


     }
     //-------------------------------------------------------------------------------------------------------









          //------------------------------------------------





          //------------------------------------------------



                

      // if (mQTT_VAR_Send == true){  // jetzt gesendet

      // auto randomNumber10_20 = random(10, 20); // random number between 10-20
      // auto randomNumber0_10 = random(10); // random number between 0-10
      // Debug-Ausgaben, um die Werte vor der Abfrage zu überprüfen
      unsigned long tcurrentMillis = millis();
      if (tcurrentMillis - t_previousMillis >= t_interval) {
          t_previousMillis = tcurrentMillis;

          MB_KAL_DEBUG_PRINT(F("Vor der Abfrage - currentSec: "));
          MB_KAL_DEBUG_PRINTLN(currentSec);
          MB_KAL_DEBUG_PRINT(F("Vor der Abfrage - randomNumber10_20: "));
          MB_KAL_DEBUG_PRINTLN(randomNumber10_20);
      }


      if(currentSec >= randomNumber10_20 && currentSec <= 45){
    
          //-------------------------
          if(send_telemetry_data_set == true){
            
            sprintf(tbuf,"%02d:%02d:%02d",v_currenthour,v_currentmin,v_currentSec); 
            if (loggingEnabled) {
              things_list_t_16 = String(tbuf) + "  [SA] Sending Telemetry Data"; 
              write_to_log(things_list_t_16);
            }

            #if TB_DEBUG_LEVEL >= TB_DEBUG_MIN
            Serial.println(F("-----------------------------------------"));
            float usedRAM = (ESP.getHeapSize() - ESP.getFreeHeap()) / (1024.0 * 1024.0);
            Serial.print(F("Used RAM: "));Serial.print(usedRAM, 3);Serial.println(F(" MB"));
            Serial.print(F("[SA] Sending Telemetry Data at random time: ")); 
            Serial.println(tbuf); 
            #endif
            
            send_telemetry_data_set = false;
            //send_telemetry_data_json();
            send_telemetry_data_json_step();

            randomNumber10_20 = random(0, 40);

            if(sendTelemetryJson_ok == false){
              #if TB_DEBUG_LEVEL >= TB_DEBUG_MAX
              Serial.println(F("[SA] ERROR Data save to TB, now save to file")); 
              #endif

               //----------------------------
               /*
                String payload3 = "{\"";                                     
                payload3 += "ts";  //topic
                payload3 += "\":";
                payload3 += String(epochTime_mqtt);
                                          
                payload3 += "0";
                payload3 += String(random(10, 99));
                payload3 += ",";

                payload3 += "\"values\":{\"";
                payload3 += "devicenumber";  
                payload3 += "\":";
                payload3 += mb_Seriennummer;
                                              
                payload3 += ",";
                payload3 += "\"";
                payload3 += "radon";  
                payload3 += "\":";
                payload3 += mb_radon_live_32bit;// String(random(0,1500));  // mb_radon_live_32bit

                payload3 += "}}"; 
                //Serial.println("[IF] MQTT publish last Data: " +  payload3);

                things_list_t = payload3;
               //----------------------------
                char attributes[200];
                payload3.toCharArray(attributes, 200);
                datei_schreiben13(); 
                */

                /*
                char payload3[200]; // Puffer für das Payload
                // snprintf Format-Spezifizierer:
                // %lu für unsigned long (epochTime_mqtt)
                // %02u für zweistellige unsigned int (cast von random(10, 99))
                // %s für char Array (mb_Seriennummer)
                // %u für uint32_t (mb_radon_live_32bit)
                snprintf(payload3, sizeof(payload3), "{\"ts\":%lu0%02u,\"values\":{\"devicenumber\":\"%s\",\"radon\":%u}}",
                        epochTime_mqtt, (unsigned int)random(10, 99), mb_Seriennummer, mb_radon_live_32bit);

                datei_schreiben13c(payload3);
                */

                // Allokiere Speicher im PSRAM
                char* payload3 = (char*) heap_caps_malloc(200 * sizeof(char), MALLOC_CAP_SPIRAM);
                if (payload3 == NULL) {
                    Serial.println("Failed to allocate memory in PSRAM");
                    return;
                }

                // snprintf Format-Spezifizierer verwenden
                snprintf(payload3, 200, "{\"ts\":%lu0%02u,\"values\":{\"devicenumber\":\"%s\",\"radon\":%u}}",
                        epochTime_mqtt, (unsigned int)random(10, 99), mb_Seriennummer, mb_radon_live_32bit);

                datei_schreiben13c(payload3);

                // Gib den PSRAM-Speicher frei, wenn er nicht mehr benötigt wird
                heap_caps_free(payload3);



            }
              
          }
          //-------------------------

          //-------------------------
          if(send_client2_attributee_set == true){

            send_client2_attributee_set = false;
            //send_client2_attribute();   

          }
          //-------------------------

         fertig_uebertragen = true;
         send_client_attribute_set = false;

           // send_client_attribute();
           // send_client2_attribute(); 


      }


      // not senden
      if(currentSec > 54){

         //-------------------------
          if(send_telemetry_data_set == true){

            send_telemetry_data_set = false;
            //Serial.println("[GR] currentSec > 54: ");
            send_telemetry_data_json_step();
            sprintf(tbuf,"%02d:%02d:%02d",v_currenthour,v_currentmin,v_currentSec);
            
            if (loggingEnabled) {
              things_list_t_16 = String(tbuf) + "  [SA] Sending Telemetry Data";  
              write_to_log(things_list_t_16);
            }

            randomNumber10_20 = random(0, 40);
              
          }
          //-------------------------
          if(send_client_attribute_set == false){

            send_client_attribute_set = true;
            //Serial.println("[SA] Sending Client Attribute"); 

              
          }
          //-------------------------
          if(send_client2_attributee_set == true){

            send_client2_attributee_set = false;
              

          }
          //-------------------------


      }





        // setenv
      if(calc_diff_timestamp == true){

            calc_diff_timestamp = false;

                 /*
                 
                 Serial.println(timeClient.getEpochTime());

                  time_t now;
                  char strftime_buf[64];
                  struct tm timeinfo;
                  time(&now);
                  localtime_r(&now, &timeinfo);
                  strftime(strftime_buf, sizeof(strftime_buf), "%c", &timeinfo);
                  printf("[IF] The current date/time is: %s\n", strftime_buf);

                 */
                  printTimeAndDifference();


            // 1723310875
            // [IF] The current date/time is: Sat Aug 10 19:27:55 2024

          //Lokale Zeit: 2024-08-10 19:13:04.687846   UTC Zeit: 2024-08-10 19:13:04.687846  Die Differenz zwischen UTC und lokaler Zeit betrÃ¤gt: 0.00 Stunden


      }



       



        //-------------------------------------
 
        if (boot_fertig == true && disable_server >= 1 && TB_currFwVersion == TB_newFwVersion) {
           if (millis() - startMillis >=  pgm_read_dword(&waitTime)) {

            boot_fertig = false;

            #ifdef einzel_auswertung
            aktualisiereMesswerte24_2(0, false);
            aktualisiereMesswertelong(0, false);
            leseMittelwerteMonate();
            #endif

            //printHeapInfo();

          }
        }




      
        if(fertig_uebertragen == true && alles_senden_fertig == true && TB_currFwVersion == TB_newFwVersion){
            
            //save_long_24h_values2 = false;
            fertig_uebertragen = false;
            alles_senden_fertig = false;
            
            //aufrufZaehler++;
            //bool aktualisieren = (aufrufZaehler % 6 == 0);

            

      

                      

                        
                //unsigned long startTime1 = millis();
                //aktualisiereMesswerte24(mb_radon_live_32bit, true);  // Erste Funktion aufrufen
                //unsigned long endTime1 = millis();  // Endzeit für die erste Funktion erfassen
                //unsigned long duration1 = endTime1 - startTime1;  // Dauer der ersten Funktion berechnen

                // Startzeit für die zweite Funktion erfassen
                unsigned long startTime2 = millis();
                #ifdef einzel_auswertung
                aktualisiereMesswerte24_2(mb_radon_live_32bit, true);  // Zweite Funktion aufrufen
                #endif
                unsigned long endTime2 = millis();  // Endzeit für die zweite Funktion erfassen
                unsigned long duration2 = endTime2 - startTime2;  // Dauer der zweiten Funktion berechnen

                // Differenz der Ausführungszeiten berechnen
                //long diff2 = duration2 - previousDuration2;


                //Serial.print("Differenz der Ausführungszeit für aktualisiereMesswerte24_2: ");
                //Serial.print(diff2);
                //Serial.println(" ms");

                // Vorherige Dauer aktualisieren
                previousDuration2 = duration2;


                // Letzte Messzeiten ausgeben
                //Serial.print("[IF] Letzte Messzeit von aktualisiereMesswerte24_2: ");
                //Serial.print(previousDuration2);
                //Serial.println(" ms");


                // Min und Max Zeiten ermitteln
                if (duration2 < minDuration2) minDuration2 = duration2;
                if (duration2 > maxDuration2) maxDuration2 = duration2;
                /*
                Serial.print("Minimale Messzeit für aktualisiereMesswerte24_2: ");
                Serial.print(minDuration2);
                Serial.println(" ms");

                Serial.print("Maximale Messzeit für aktualisiereMesswerte24_2: ");
                Serial.print(maxDuration2);
                Serial.println(" ms");
                */
        


              #ifdef einzel_auswertung
              aktualisiereMesswertelong(mb_radon_live_32bit, true);
              aktualisiereMesswertemonate(mb_radon_live_32bit, month-1);
              #endif




            
            //Serial.print("[IF] Radonwert live: ");Serial.println(mb_radon_live_32bit);

            //Serial.print("[IF] Radonwert 24h "); Serial.println(radon_mittelwert_24h);             //ok
           
            //Serial.println("[IF] Radon Jahresmittelwert: " + String(radon_jahr));             //ok    aus monatsdaten         
            //Serial.println("[IF] Radon Jahresmittelwert von Monate: " + String(mittelwert_jahr));
            
            //Serial.print("[IF] Radonwert Long "); Serial.println(radon_mittelwert_long);    //ok

            //Serial.print("[IF] Messgerät Messungen "); Serial.println(radon_zaehler_long);  
            
            MB_DEBUG_PRINT(F("[IF] Sensor Laufzeit [h] "));
            MB_DEBUG_PRINTLN(mb_radon_save_eintrarge);

            
            if (loggingEnabled) {
              //things_list_t_16 = p_uhrzeit + "  [IF] Sensor Laufzeit [h] " + String(mb_radon_save_eintrarge); 
              write_to_log(things_list_t_16);
              } 
           
            //printf("[AP] FREE HEAP: now: %u, contiguous: %u, lowest: %u\n",xPortGetFreeHeapSize(),heap_caps_get_largest_free_block(MALLOC_CAP_DEFAULT),xPortGetMinimumEverFreeHeapSize());  
            //Serial.println("[IF] Mittelwert für Monat Juli " +  String(radon_mittelwert_monat[6]));


          //leseMittelwerteMonate();
       
            //printHeapInfo();



              if (Sending_data_2 == true) {
             
                if (Sending_Client_attributes_2 == false || Sending_Telemetry_Data_2 == false || Sending_Telemetry_Data_3 == false || Sending_Telemetry_Data_4 == false) {
                   
                  
                    // Debug-Ausgaben hinzufügen, um herauszufinden, welches Bit verantwortlich ist
                    if (Sending_Client_attributes_2 == false) {
                        Serial.println("Sending_Client_attributes_2 ist false");
                        loopCount_vorgabe = 5;
                    }
                    if (Sending_Telemetry_Data_2 == false) {
                        Serial.println("Sending_Telemetry_Data_2 ist false");
                        loopCount_vorgabe = 2;
                    }
                    if (Sending_Telemetry_Data_3 == false) {
                        Serial.println("Sending_Telemetry_Data_3 ist false");
                        loopCount_vorgabe = 2;
                    }
                    if (Sending_Telemetry_Data_4 == false) {
                        Serial.println("Sending_Telemetry_Data_4 ist false");
                        loopCount_vorgabe = 2;
                    }
                  
                  
                   if (WiFi.status() == WL_CONNECTED) {
                        loopCount++;
                        if (loopCount >= loopCount_vorgabe) {
                            
                            Preferences preferences;
                            preferences.begin("eenvs", false);                         //Ordner eenvs anlegen/verwenden       
                            g_boot_fail = 1;
                            preferences.putUChar("boot_g_fail", g_boot_fail);    // 
                            preferences.end(); 
                            
                            Serial.println("[WL][  ] Schleife " + String(loopCount) + " mal durchlaufen. Neustart des ESP32.........");
                            tb.sendTelemetryData("Night", "Schleife " + String(loopCount) + " mal durchlaufen. Neustart des ESP32");delay(200);
                            
                            g_esp_soft_restart = true;
                        }
                    }

                    Sending_Client_attributes_2 = true;  // ok vorladen
                    Sending_Telemetry_Data_2 = true;     // ok vorladen
                    Sending_Telemetry_Data_3 = true;     // ok vorladen
                    Sending_Telemetry_Data_4 = true;     // ok vorladen

                } else {
                    loopCount = 0; // Zähler zurücksetzen, wenn die Bedingung nicht erfüllt ist
                }

                Sending_data_2 = false;
                if(loopCount == 0){
                  Serial.println("[WL][oo] Kein Neustart des ESP32 in erforderlich.");
                  Serial.printf("[WL][  ] Der Status des Nachtmodus: %s. Nachtschaltung: Start um %02d:00 Uhr, Ende um %02d:00 Uhr\n", nightModeActive ? "Aktiv (WLAN-Verbindung wird nicht überprüft)" : "Nicht aktiv (WLAN-Verbindung wird überprüft)", nightStartHour, nightEndHour);
                }else{
                  Serial.printf("[WL][xx] Schleife %d mal durchlaufen. Neustart des ESP32 beim nächsten mal...\n", loopCount);
                }

              }

        }
        //-------------------------------------



        //-------------------------------------
          //  reconnect               WL_NO_SSID_AVAIL
         if(init_wifi_counter >= 28 && count_InitWiFi >=26){
    
              
              //die Aktion für die Minuten 0, 9, 10, 11, 19, 20, 21, 29, 30, 31, 39, 40, 41, 49, 50 und 51 nicht ausgeführt. 
              //Für alle anderen Minuten wird die Aktion ausgeführt.

              // currentmin % 10 == 0: Die Minute ist ein Vielfaches von 10 (z.B. 0, 10, 20, 30, 40, 50).
              // (currentmin - 1) % 10 == 0: Die Minute ist eine Minute vor einem Vielfachen von 10 (z.B. 9, 19, 29, 39, 49, 59).
              // (currentmin + 1) % 10 == 0: Die Minute ist eine Minute nach einem Vielfachen von 10 (z.B. 1, 11, 21, 31, 41, 51).
              for (int currentmin = 0; currentmin < 60; ++currentmin) {
                  if (currentmin % 10 == 0 || (currentmin - 1) % 10 == 0 || (currentmin + 1) % 10 == 0) {
                      continue; // Aktion wird nicht ausgeführt
                  }
                  // Hier kommt die Aktion, die ausgeführt werden soll
                  g_esp_restsrt = true;
                  init_wifi_counter = 0;
                  count_InitWiFi = 0;

              }

         }
        //-------------------------------------



      //------ WLAN Überwachung ------------------
      if (wifiCheckEnabled) {
        if (g_Seg__boot_ani == false && g_wlan_check_start == true && start_wlan_auswertung == true) {  
          
          //mainEvaluation();
          
          //Serial.print("[WL] wifiCheckEnabled ");Serial.println(wifiCheckEnabled);

          mainEvaluation1();
          esp_task_wdt_reset();

          mainEvaluation2();
          esp_task_wdt_reset();

          mainEvaluation3();
          esp_task_wdt_reset();


          start_wlan_auswertung = false;

        }
      }
      //------------------------------------------



    if(dataFirmwareUpdate == true){
        dataFirmwareUpdate = false;
        unsigned long newRandomDelay = randomDelay / 1000;
        tb.sendTelemetryData("update__in", newRandomDelay);delay(200);

        tb.sendTelemetryData("update__status", "waiting");delay(200);

        Serial.print(F("Der FW-Start beginnt in "));
        Serial.print(newRandomDelay);
        Serial.println(F(" Sekunden."));

    }


  if (startFirmwareUpdate && (millis() - delayStartTime >= randomDelay)) {
    
      startFirmwareUpdate = false;
      tb.sendTelemetryData("update__status", "Reboot");delay(200);

      actualDelay = millis() - delayStartTime;


                            Preferences preferences;
                            preferences.begin("eenvs", false);                      
                           
                            g_boot_fail = 1;
                            preferences.putUChar("boot_g_fail", g_boot_fail);    // 
                                                    
                            disable_server = 0; 
                            preferences.putUChar("g_server", disable_server);    //  1=Standard   AN 

                            verzoegerung_fw_update = 2; 
                            preferences.putUChar("fw_verz_update", verzoegerung_fw_update);    //  1=Standard   AN 

                            gFW_Update_start = 1;  // neue FW verfügbar
                            preferences.putUChar("fw_s_upd", gFW_Update_start);    //  0=Standard  aus 

                            schreib_sperre = false;

                            preferences.end(); 
                            
                            Serial.println(F("[TB][  ] FW update. Neustart des ESP32........."));
                            
                            delay(2000); // Kurze Verzögerung vor dem Neustart
                            ESP.restart();


    
      //tb.Start_Firmware_Update(callback);

  }
  //------------------------------------------------------------------------ 



    if (g_send_end_wlan_aus && !timerStartedw) {
        startMillisw = millis(); // Startzeit speichern
        timerStartedw = true; // Timer als gestartet markieren
    }

    if (timerStartedw && (millis() - startMillisw >= 20000)) { // 20 Sekunden warten
        //ausloesenw(); // Deine Funktion auslösen
        timerStartedw = false; // Timer zurücksetzen
        g_send_end_wlan_aus = false; // Optional: Variable zurücksetzen
    }


}  //knx_program_mode == 0    ca. 38863





    
    
    
       bool temp_deaktivieren = false;

      // Überprüfe, ob die Internetübertragungen abgeschlossen sind
      if(temp_deaktivieren == false && ble_start_aktivieren == false){
        if (internetTransferComplete || knx_program_mode == 1) {
          if(TB_currFwVersion == TB_newFwVersion && verzoegerung_fw_update == 0 && disable_server >= 1){

              // Überprüfe, ob 5 Sekunden seit dem Abschluss der Übertragungen vergangen sind
              if (millis() - transferCompleteTime >= 10000) {
                  // Starte BLE nur einmal
                              
                  if (!BLEDevice::getInitialized()) {
                    BT_DEBUG_MAX_PRINTLN(F("-----------------------------------------"));
                    // printf("[AP] FREE HEAP: now: %u, contiguous: %u, lowest: %u\n", xPortGetFreeHeapSize(), heap_caps_get_largest_free_block(MALLOC_CAP_DEFAULT), xPortGetMinimumEverFreeHeapSize()); // Serial.println(F(" "));
                    //printf("[AP] FREE RAM: now: %.2f MB\n", getUsedRAMMB());

                    esp_bt_controller_config_t bt_cfg = BT_CONTROLLER_INIT_CONFIG_DEFAULT();
                    esp_err_t ret;

                    ret = esp_bt_controller_init(&bt_cfg);
                    if (ret != ESP_OK) {
                        BT_DEBUG_MAX_PRINTLN(F("Bluetooth-Controller konnte nicht initialisiert werden"));
                        return;
                    } else {
                        BT_DEBUG_MAX_PRINTLN(F("[BT] Bluetooth-Controller wurde initialisiert."));
                    }

                    ret = esp_bt_controller_enable(ESP_BT_MODE_BLE); // Ändere den Modus hier
                    if (ret != ESP_OK) {
                        BT_DEBUG_MAX_PRINT(F("[BT] Bluetooth-Controller konnte nicht aktiviert werden: "));
                        BT_DEBUG_MAX_PRINTLN(esp_err_to_name(ret));
                        if (loggingEnabled) {
                            // things_list_t_16 = p_uhrzeit + "  [IF] Bluetooth-Controller konnte nicht aktiviert werden";
                            write_to_log(things_list_t_16);
                        }
                    } else {
                        BT_DEBUG_MED_PRINTLN(F("[BT] Bluetooth-Controller wurde aktiviert."));
                        if (loggingEnabled) {
                            // things_list_t_16 = p_uhrzeit + "  [IF] Bluetooth-Controller wurde aktiviert";
                            write_to_log(things_list_t_16);
                        }
                    }

                    //printf("[AP] FREE RAM: now: %.2f MB\n", getUsedRAMMB());

                    startBeacon2();

                    //printf("[AP] FREE RAM: now: %.2f MB\n", getUsedRAMMB());


              startBLEserver();

                    if (ret == ESP_OK && BLE_Server_enabled == true) {
                      displayFirmwareVersion(TB_currFwVersion);
                      startBLEScan(); // Starte den initialen BLE-Scan
                    }


                    esp_task_wdt_reset();
                    //printf("[AP] FREE RAM: now: %.2f MB\n", getUsedRAMMB());
                    // BT_DEBUG_MAX_PRINTF("[AP] FREE HEAP: now: %u, contiguous: %u, lowest: %u\n", xPortGetFreeHeapSize(), heap_caps_get_largest_free_block(MALLOC_CAP_DEFAULT), xPortGetMinimumEverFreeHeapSize()); // Serial.println(F(" "));
                    BT_DEBUG_MAX_PRINTLN(F("-----------------------------------------"));

                    
                  //}else{
                    //Serial.println("[BT] Bluetooth-Controller wurde schon initialisiert.");
                  }
              

              }
          }
        }
      }else{
        //set_bit_wait_front_view = false;
      }

        // BLE-Scan nach 20 Sekunden stoppen
        //if (bleScanActive && (millis() - scanStartTime > 20000)) {
            //stopBLEScan();
        //}







    //----------------------------------------------------------------------------------------------
     if(ntp_update_start == true){

      ntp_update_start = false;

      if (WiFi.status() == WL_CONNECTED) {
        call_time_set_ntp(); //nur das!!!!!!!!!!!!!!
      }

      /*
                // Initialisiere den NTP-Client und aktualisiere die Zeit
                timeClient.begin();
                unsigned long epochTimet;

                if (timeClient.forceUpdate()) {
                    Serial.println("NTP-Client initialisiert und Zeit erfolgreich abgerufen");

                    // Aktualisiere die interne Uhr des ESP
                    epochTimet = timeClient.getEpochTime(); // Hier wird epochTime direkt aktualisiert
                    struct timespec tp;
                    tp.tv_sec = epochTimet;
                    tp.tv_nsec = 0;

                  tp.tv_sec = epochTimet;  //hier die Uhrzeit stellen
                  clock_settime(CLOCK_REALTIME, &tp);

                  Set_RTC_clock_after_ntp();

                    // Debugging: Vor dem Setzen der Uhrzeit
                    Serial.printf("Setting time to: %lu\n", epochTimet);
                    Serial.printf("Setting timespec: tv_sec = %ld, tv_nsec = %ld\n", tp.tv_sec, tp.tv_nsec);

                    if (clock_settime(CLOCK_REALTIME, &tp) == 0) {
                        Serial.println("Uhrzeit erfolgreich gesetzt");

                        // Debugging: Aktuelle Zeit nach dem Setzen überprüfen
                        time_t now;
                        struct tm timeinfo;
                        time(&now);
                        localtime_r(&now, &timeinfo);

                        // Zeit und Datum formatieren
                        char timeBuffer[9];
                        strftime(timeBuffer, sizeof(timeBuffer), "%H:%M:%S", &timeinfo);
                        char dateBuffer[11];
                        strftime(dateBuffer, sizeof(dateBuffer), "%d.%m.%Y", &timeinfo);

                        // Ausgabe der aktuellen Zeit und des Datums
                        Serial.printf("Aktuelle Zeit: %s\n", timeBuffer);
                        Serial.printf("Aktuelles Datum: %s\n", dateBuffer);
                    } else {
                        Serial.println("Fehler beim Setzen der Uhrzeit");
                    }

                    Serial.printf("Uhrzeit vom NTP-Server aktualisiert: %lu\n", epochTimet);

                 //timeClient.setEpochTime(epochTimet);

                   //+++++++++++++++
                  //struct timespec tp;
                  tp.tv_sec = epochTimet;  //hier die Uhrzeit stellen
                  //clock_settime(CLOCK_REALTIME, &tp);
                  Serial.print("[IF] ESP32 Uhr Stellen von RTC Uhr | ");Serial.println(epochTimet);
                  time_t nowt;
                  char strftime_buf[64];
                  struct tm timeinfot;
                  time(&nowt);
                  Serial.print("[TM] Load Timezone: ");Serial.println(g_u_timezone_ist);
                  setenv("TZ",g_u_timezone_ist.c_str(),1); 
                  tzset();
                  localtime_r(&nowt, &timeinfot);
                   esp_task_wdt_reset(); 

                  strftime(strftime_buf, sizeof(strftime_buf), "%c", &timeinfot);
                  //ESP_LOGI(TAG, "The current date/time in Germany is: %s", strftime_buf);
                  printf("[IF] The current date/time is: %s\n", strftime_buf);
                //+++++++++++++++


                time_t rtc = epochTimet;
                timeval tv = { rtc, 0 };
                settimeofday(&tv, nullptr);


                struct tm timeinfo;
                if(!getLocalTime(&timeinfo)){
                  Serial.println("Failed to obtain time");
                }
                
           
                Serial.print("[TM] get Stunde     from ESP: ");Serial.println(timeClient.getHours());
                Serial.print("[TM] get minute     from ESP: ");Serial.println(timeClient.getMinutes());
                Serial.print("[TM] get Sekunde    from ESP: ");Serial.println(timeClient.getSeconds());
                Serial.print("[TM] get Epoch Time from ESP: ");Serial.println(timeClient.getEpochTime());


                } else {
                    Serial.println("Fehler beim Abrufen der Zeit vom NTP-Server");
                }
      */
                printTimeAndDifference();

              

     }
     //----------------------------------------------------------------------------------------------------



        //----------------------------------------------
        if(ntp_min_akualisieren == true){

          ntp_min_akualisieren = false;

          if(gFW_Update_start != 1){   

              #ifdef RTC_Clock_DS3231

                        sommerzeit = summertime_EU(2000 +currentYearTwoDigits, v_currentmonth, v_currentdate, v_currenthour, 1);  //(0=UTC, 1=MEZ)  //0 = Winterzeit in Jan, Feb, Nov, Dez      1= Sommerzeit in Apr, Mai, Jun, Jul, Aug, Sep
                        #ifdef RTCDebug
                        if(sommerzeit == 1){  
                            Serial.print("[TM] ESP Es ist Sommer | MESZ | ");Serial.println(v_currenthour); 
                        }else{
                            Serial.print("[TM] ESP Es ist Winter | MEZ  | ");Serial.println(v_currenthour); 
                        } 
                        #endif

                        if(sommerzeit == 1 && Set_mesz == false){  //bei unterschied ausführen       sommerzeit = 1 = Sommer     Set_mesz = false = Winter
                            if(sommerzeit == 1){
                                //#ifdef RTCDebug
                                Serial.println("[TM] !!! Es ist Sommer, bit falsch - set | MESZ");
                                //#endif
                                Set_mesz = true;
                                g_Set_mesz = 0;
                            }else{
                                //#ifdef RTCDebug
                                Serial.println("[TM] !!! Es ist Winter, bit falsch - set | MEZ");
                                //#endif
                                Set_mesz = false;  //Winter
                                g_Set_mesz = 1;    //Winter
                            }

                              if(update_ntp_ready == 1 || set_BT_RTC_Time == true){
                                update_bl_clock = 1; // damit ohne NTP ok die Uhr gestellt werden kann
                                set_BT_RTC_Time = false;
                              }
                              set_manual_time = true;
                              
                              call_time_set_g();

                              //Serial.print("g_Set_mesz a: ");Serial.println(g_Set_mesz);
                              Preferences preferences;
                              preferences.begin("eenvs", false);                         //Ordner eenvs anlegen/verwenden
                              preferences.putUInt("g_Set_mesz", g_Set_mesz);             //Variable speichern  
                              preferences.end();
                              //----------------------------
                        }
                      
                        if(sommerzeit == 0 && Set_mesz == true){   //bei unterschied ausführen          sommerzeit = 0 = Winter     Set_mesz = true = Sommer
                            if(sommerzeit == 1){
                                //#ifdef RTCDebug
                                Serial.println(F("[TM] !! Es ist Sommer - set | MESZ"));
                                //#endif
                                Set_mesz = true;
                                g_Set_mesz = 0;
                            }else{
                                //#ifdef RTCDebug
                                Serial.println(F("[TM] !! Es ist Winter - set | MEZ"));
                                //#endif
                                Set_mesz = false;
                                g_Set_mesz = 1;
                            }

                              if(update_ntp_ready == 1 || set_BT_RTC_Time == true){
                                update_bl_clock = 1; // damit ohne NTP ok die Uhr gestellt werden kann
                                set_BT_RTC_Time = false;
                              }
                              set_manual_time = true;
                              //Serial.println("call_time_set_g 2");
                              call_time_set_g();

                              //Serial.print("g_Set_mesz c: ");Serial.println(g_Set_mesz);
                              Preferences preferences;
                              preferences.begin("eenvs", false);                         //Ordner eenvs anlegen/verwenden
                              preferences.putUInt("g_Set_mesz", g_Set_mesz);             //Variable speichern  
                              preferences.end();
                              //----------------------------
                        }


                  if(rtc_time_valid == 1){
                    read_clock_RTC();
                  }else{
                      unsigned long rtc_currentMillis4 = millis();
                      if (rtc_currentMillis4 - rtc_previousMillis4 >= rtc_interval) {
                        rtc_previousMillis4 = rtc_currentMillis4;
                        read_clock_RTC();
                      }
                  }


                    read_clock_esp32();


                    echo_clock_info();


                if(update_ntp_ready == 0){
                  if(rtc_hour != v_currenthour){
                    //Serial.println("[TM] Hour diff"); 
                    //Serial.println("-----STELLEN-----"); 
                    g_set_esp_clock = true;  // RTC stellen

                    if(set_BT_RTC_Time == true){
                      update_bl_clock = 1; // damit ohne NTP ok die Uhr gestellt werden kann  
                      set_BT_RTC_Time = false;
                    }

                    //call_time_set_g();
                  }
                }


              #endif 



          }
        }
        //---------------------------------------------------------


        //---------------------------------------------------------


        uint32_t mb_currentTime = millis();

          // Alle 1 Sekunde den Zähler für diese Sekunde aktualisieren
          if (mb_currentTime - lastSecondTime >= 1000) {
              lastSecondTime = mb_currentTime;

              // Index für die aktuelle Sekunde erhöhen (im Kreis)
              requestIndex = (requestIndex + 1) % INTERVAL;
              requestTimes[requestIndex] = 0; // Zähler für die aktuelle Sekunde zurücksetzen
          }

          uint32_t received_countg = MB.getMessageCount() - MBbridge.getMessageCount();
          uint32_t received_count = received_countg + MBbridge.getMessageCount();

          // RTU Verkehr
          if (received_countg != previousReceivedCountRTU) {
              previousReceivedCountRTU = received_countg;
              requestCounterRTU++;
              totalBytesReceivedRTU += mb_byte_size;
          }

          // TCP Verkehr
          if (received_count != previousReceivedCount) {
              previousReceivedCount = received_count;
              requestCounterTCP++;
              uint32_t bytesReadTCP = 12;
              totalBytesReceivedTCP += bytesReadTCP;

              // Anfrage für die aktuelle Sekunde erhöhen
              requestTimes[requestIndex]++;
              String ledOnData = "{\"ledOn\": true}";
              
              // Überprüfen, ob mindestens ein WebSocket-Client verbunden ist
              if (webSocket.connectedClients() > 0 && isUserOnModbusPage == true) {
                  webSocket.broadcastTXT(ledOnData);
                  Serial.printf("LED Anfragen Connect");
              }
          }

          // Berechnung der gleitenden Anzahl der Anfragen pro Stunde
          if (mb_currentTime - lastPrintTime >= 10000) {  // 10 Sekunden Intervall
              lastPrintTime = mb_currentTime;
              uint32_t totalRequestsLastMinute = 0;

              // Summe der Anfragen der letzten 60 Sekunden berechnen
              for (uint32_t i = 0; i < INTERVAL; i++) {
                  totalRequestsLastMinute += requestTimes[i];
              }

              // Hochrechnung auf eine Stunde (totalRequestsLastMinute * 60 Minuten)
              float projectedRequestsPerHour = (float)totalRequestsLastMinute * 60.0;

              // JSON-Daten erstellen
              String data = "{\"projectedRequestsTCP\": " + String(projectedRequestsPerHour) + "}";

              // Überprüfen, ob mindestens ein WebSocket-Client verbunden ist
              if (webSocket.connectedClients() > 0 && isUserOnModbusPage == true) {
                  webSocket.broadcastTXT(data);
                  Serial.printf("Hochrechnung TCP Anfragen pro Stunde: %.2f\n", projectedRequestsPerHour);
              }
              
          }

          // Überprüfen, ob die Reset-Periode ohne Datenverkehr vergangen ist
          if (mb_currentTime - lastResetTime >= resetInterval) {
              requestCounterRTU = 0;
              requestCounterTCP = 0;
              totalBytesReceivedRTU = 0;
              totalBytesReceivedTCP = 0;
              lastResetTime = mb_currentTime;
          }

        //---------------------------------------------------------
            






    if (isUserOnSensorPage == true) {
      if (isUserOnSensorPage) {
          if (currentSec != previousSec) {
              sendData();     //  void webSocketEvent(    sendData()    const char sensor_html_template[]   handle_sensor()
              previousSec = currentSec; // Aktualisieren des vorherigen Sekundenwerts
          }
          lastUserOnSensorPage = true; // Benutzer auf der Sensorseite
      } else {
          if (lastUserOnSensorPage) {
              // Sende letzte Datenübertragung, wenn Benutzer die Seite verlässt
              sendData();    //  void webSocketEvent(    sendData()    const char sensor_html_template[]   handle_sensor()
              webSocket.broadcastTXT("user:Data transmission stopped due to multiple users.");
              lastUserOnSensorPage = false; // Aktualisieren des letzten Status
          }
      }
    }


      //  webSocketEvent( 

    // Broadcast data every second
    if(isBleOnSensorPage == true){
      // Broadcast-Daten alle Sekunde
      static unsigned long lastBroadcastTime = 0;
      if (millis() - lastBroadcastTime > 1000) {
          DynamicJsonDocument json(1024);
          json["type"] = "status";
          json["bleStatus"]["rssi"] = ble_rssi;  // ble_rssi
          json["bleStatus"]["connectedUsers"] = connected_users;
          json["bleStatus"]["signalPercentage"] = map(ble_rssi, -100, -40, 0, 100);
          json["bleStatus"]["bestRssi"] = bestRssi; 
          json["bleStatus"]["worstRssi"] = worstRssi;
          json["bleStatus"]["receivedTraffic"] = receivedTraffic; 
          json["bleStatus"]["sentTraffic"] = sentTraffic;

          String jsonString;
          serializeJson(json, jsonString);

          webSocket.broadcastTXT(jsonString);
          lastBroadcastTime = millis();
      }
    }



    if(BLE_Beacon_enabled == true && BLE_Server_enabled == true){
      BLE_enabled = true;
    }else{
      BLE_enabled = false;
    }



    if(git_startBeacon2 == true){
         git_startBeacon2 = false;
         printf("[AP] FREE RAM: now: %.3f MB\n", getUsedRAMMB());
         startBeacon2();
         printf("[AP] FREE RAM: now: %.3f MB\n", getUsedRAMMB());
    }
    if(git_stopBeacon2 == true){
         git_stopBeacon2 = false;
         printf("[AP] FREE RAM: now: %.3f MB\n", getUsedRAMMB());
         stopBeacon();
         printf("[AP] FREE RAM: now: %.3f MB\n", getUsedRAMMB());
    }








    //------------------------------------- 
    /*
    if (millis() - u_lastPrintTime >= u_printInterval) {
        u_lastPrintTime = millis();
        bool conditionMet = false;

        if (g_kalibrieren_ist != 0 || g_checken_ist != 0 || g_kal_write_ist != 0 || 
            gFW_Update_start != 0 || g_identify != 0 || displayKNXAddress g_u_view_switch_ist != 0 || 
            g_sensor_online >= 2 || g_LEDT_T_ist != 1 || g_wlan_read == true || g_identify == true) {
            conditionMet = true;
        }

        if (conditionMet) {
            Serial.println(F("Eine der Variablen ist ungleich 0 oder erfüllt die Bedingung."));
            debugVariables();
        } else {
            //Serial.println(F("Alle Variablen sind auf dem erwarteten Wert."));
        }
    }
    */
    //------------------------------------- 




    //------------------------------------- 
    if (g_force_ping == true) {
      if (millis() - lastPingTime >= pingInterval) {  // nur alle 2min möglich
          g_force_ping = false;
          force_ping();
          lastPingTime = millis(); // Aktualisiere die Zeit des letzten Pings
          //Serial.println("g_force_ping wurde auf true gesetzt.");
      } else {
          //Serial.println("Noch nicht genug Zeit seit dem letzten Ping vergangen.");
          g_force_ping = false;
      }
    }
    //------------------------------------- 




    if (g_toggle_knx_prog) {
        // Prüfe, ob die Zeit abgelaufen ist
        if (millis() - startTime_knx > 30000) {
            g_toggle_knx_prog = false;
            Serial.println(F("Maximale Wartezeit abgelaufen."));
        } else {
            // Überprüfe den Pin-Zustand
            int newPinState = digitalRead(20);
            if (newPinState != currentPinState_knx_web) {
                Serial.print(F("Pin-Zustand geändert: ")); Serial.println(newPinState);

                Preferences preferences;
                preferences.begin("eenvs", false); // Ordner eenvs anlegen/verwenden
                if (newPinState == 1) {
                    knx_program_mode = true;
                    g_toggle_knx_prog = false; // Überwachung deaktivieren
                    preferences.putBool("p_KNX_ets", knx_program_mode); // KNX Program Mode aktiviert
                    Serial.print(F("[Web] KNX Program Mode true: ")); Serial.println(knx_program_mode);
                } else {
                    knx_program_mode = false;
                    g_toggle_knx_prog = false; // Überwachung deaktivieren
                    preferences.putBool("p_KNX_ets", knx_program_mode); // KNX Program Mode deaktiviert
                    Serial.print(F("[Web] KNX Program Mode false: ")); Serial.println(knx_program_mode);
                }
                preferences.end();
                g_esp_soft_restart = true;
                g_toggle_knx_prog = false; // Überwachung deaktivieren
            }
        }

        // Watchdog Timer zurücksetzen (falls erforderlich)
        esp_task_wdt_reset();
    }





          //--------------------------------------------------
          if (g_esp_soft_restart == true) {
              g_esp_soft_restart = false;
              restartInitiated = true;
              restartSoftTimer = millis();  // Startet den Timer
          }

          if (restartInitiated){
            if ((millis() - restartSoftTimer >= 2000)) {
             
                //executeRestart();  // Führt die Neustartprozedur aus
                Preferences preferences;
                preferences.begin("eenvs", false);  // Ordner eenvs anlegen/verwenden
                // Weitere Einstellungen speichern, falls notwendig
                preferences.end();
                restartInitiated = false;  // Setzt den Zustand zurück
                delay(2000);
                ESP.restart();
              
            }
          }
          //--------------------------------------------------












}  //void loop()
//--------------------------------------------------------------------------------------------------------


